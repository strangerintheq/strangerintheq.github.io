/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 90);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @version $Id: Logger.js 3418 2015-08-22 00:17:05Z tgaskins $
 */
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    "use strict";
    /**
     * Logs selected message types to the console.
     * @exports Logger
     */

    var Logger = {
        /**
         * Log no messages.
         * @constant
         */
        LEVEL_NONE: 0,
        /**
         * Log messages marked as severe.
         * @constant
         */
        LEVEL_SEVERE: 1,
        /**
         * Log messages marked as warnings and messages marked as severe.
         * @constant
         */
        LEVEL_WARNING: 2,
        /**
         * Log messages marked as information, messages marked as warnings and messages marked as severe.
         * @constant
         */
        LEVEL_INFO: 3,

        /**
         * Set the logging level used by subsequent invocations of the logger.
         * @param {Number} level The logging level, one of Logger.LEVEL_NONE, Logger.LEVEL_SEVERE, Logger.LEVEL_WARNING,
         * or Logger.LEVEL_INFO.
         */
        setLoggingLevel: function (level) {
            loggingLevel = level;
        },

        /**
         * Indicates the current logging level.
         * @returns {Number} The current logging level.
         */
        getLoggingLevel: function () {
            return loggingLevel;
        },

        /**
         * Logs a specified message at a specified level.
         * @param {Number} level The logging level of the message. If the current logging level allows this message to be
         * logged it is written to the console.
         * @param {String} message The message to log. Nothing is logged if the message is null or undefined.
         */
        log: function (level, message) {
            if (message && level > 0 && level <= loggingLevel) {
                if (level === Logger.LEVEL_SEVERE) {
                    console.error(message);
                } else if (level === Logger.LEVEL_WARNING) {
                    console.warn(message);
                } else if (level === Logger.LEVEL_INFO) {
                    console.info(message);
                } else {
                    console.log(message);
                }
            }
        },

        // Intentionally not documented.
        makeMessage: function (className, functionName, message) {
            var msg = this.messageTable[message] ? this.messageTable[message] : message;

            return className + "." + functionName + ": " + msg;
        },

        // Intentionally not documented.
        logMessage: function (level, className, functionName, message) {
            var msg = this.makeMessage(className, functionName, message);
            this.log(level, msg);

            return msg;
        },

        // Intentionally not documented.
        messageTable: { // KEEP THIS TABLE IN ALPHABETICAL ORDER
            abstractInvocation: "The function called is abstract and must be overridden in a subclass.",
            indexOutOfRange: "The specified index is out of range.",
            invalidHeight: "The specified height is zero or negative.",
            invalidWidth: "The specified width is zero or negative.",
            invalidSize: "The specified size is zero or negative.",
            missingAltitudeMode: "The specified altitude mode is null or undefined.",
            missingAttributeName: "The specified DBase attribute file name is null or undefined.",
            missingArray: "The specified array is null, undefined or of insufficient length.",
            missingBoundaries: "The specified boundaries array is null or undefined.",
            missingBuffer: "The specified buffer descriptor is null or undefined.",
            missingColor: "The specified color is null or undefined.",
            missingDc: "The specified draw context is null or undefined.",
            missingDomElement: "The specified DOM element is null or undefined.",
            missingEntry: "The specified entry is null or undefined.",
            missingFont: "The specified font is null or undefined.",
            missingFrustum: "The specified frustum is null or undefined.",
            missingFunction: "The specified function is null or undefined.",
            missingGlContext: "The specified WebGL rendering context is null or undefined.",
            missingGlobe: "The specified globe is null or undefined.",
            missingImage: "The specified image is null or undefined.",
            missingIndices: "The specified indices array is null or undefined.",
            missingKey: "The specified key is null or undefined.",
            missingLevel: "The specified level is null or undefined.",
            missingLine: "The specified line is null or undefined.",
            missingList: "The specified list is null or undefined.",
            missingListener: "The specified listener is null or undefined",
            missingLocation: "The specified location is null or undefined.",
            missingMatrix: "The specified matrix is null or undefined.",
            missingNavigatorState: "The specified navigator state is null or undefined.",
            missingOffset: "The specified offset is null or undefined.",
            missingPath: "The specified path is null or undefined.",
            missingPlacename: "The specified place name is null or undefined.",
            missingPlane: "The specified plane is null or undefined.",
            missingPoint: "The specified point is null or undefined.",
            missingPoints: "The specified points array is null or undefined.",
            missingPosition: "The specified position is null or undefined.",
            missingPositions: "The specified positions array is null or undefined.",
            missingProgram: "The specified program is null or undefined.",
            missingProjection: "The specified projection is null or undefined.",
            missingRectangle: "The specified rectangle is null or undefined.",
            missingRenderable: "The specified renderable is null or undefined.",
            missingResource: "The specified resource is null or undefined.",
            missingResult: "The specified result variable is null or undefined.",
            missingResults: "The specified results array is null or undefined.",
            missingSector: "The specified sector is null or undefined.",
            missingShapeType: "The specified shape type is null or undefined.",
            missingSize: "The specified size is null or undefined.",
            missingText: "The specified text is null or undefined.",
            missingTexture: "The specified texture is null or undefined.",
            missingTile: "The specified tile is null or undefined.",
            missingType: "The specified type is null or undefined.",
            missingUrl: "The specified URL is null or undefined",
            missingVector: "The specified vector is null or undefined.",
            missingVertex: "The specified vertex is null or undefined.",
            missingViewport: "The specified viewport is null or undefined.",
            missingWorldWindow: "The specified World Window is null or undefined.",
            notYetImplemented: "This function is not yet implemented"
        }
    };

    var loggingLevel = 1; // log severe messages by default

    return Logger;
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports ArgumentError
 * @version $Id: ArgumentError.js 2631 2015-01-02 21:32:32Z tgaskins $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(22)], __WEBPACK_AMD_DEFINE_RESULT__ = function (AbstractError) {
        "use strict";

        /**
         * Constructs an argument error with a specified message.
         * @alias ArgumentError
         * @constructor
         * @classdesc Represents an error associated with invalid function arguments.
         * @augments AbstractError
         * @param {String} message The message.
         */
        var ArgumentError = function (message) {
            AbstractError.call(this, "ArgumentError", message);

            var stack;
            try {
                //noinspection ExceptionCaughtLocallyJS
                throw new Error();
            } catch (e) {
                stack = e.stack;
            }
            this.stack = stack;
        };

        ArgumentError.prototype = Object.create(AbstractError.prototype);

        return ArgumentError;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @version $Id: Vec3.js 3001 2015-04-09 20:13:50Z tgaskins $
 */

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(0),
        __webpack_require__(1)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Logger,
              ArgumentError) {
        "use strict";

        /**
         * Constructs a three-component vector.
         * @alias Vec3
         * @classdesc Represents a three-component vector. Access the X component of the vector as v[0], the Y
         * component as v[1] and the Z component as v[2].
         * @augments Float64Array
         * @param {Number} x X component of vector.
         * @param {Number} y Y component of vector.
         * @param {Number} z Z component of vector.
         * @constructor
         */
        var Vec3 = function Vec3(x, y, z) {
            this[0] = x;
            this[1] = y;
            this[2] = z;
        };

        // Vec3 extends Float64Array.
        Vec3.prototype = new Float64Array(3);

        /**
         * A vector corresponding to the origin.
         * @type {Vec3}
         */
        Vec3.ZERO = new Vec3(0, 0, 0);

        /**
         * Computes the average of a specified array of vectors.
         * @param {Vec3[]} vectors The vectors whose average to compute.
         * @param {Vec3} result A pre-allocated Vec3 in which to return the computed average.
         * @returns {Vec3} The result argument set to the average of the specified array of vectors.
         * @throws {ArgumentError} If the specified array of vectors is null, undefined or empty or the specified
         * result argument is null or undefined.
         */
        Vec3.average = function (vectors, result) {
            if (!vectors || vectors.length < 1) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Vec3", "average", "missingArray"));
            }

            if (!result) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Vec3", "average", "missingResult"));
            }

            var count = vectors.length,
                vec;

            result[0] = 0;
            result[1] = 0;
            result[2] = 0;

            for (var i = 0, len = vectors.length; i < len; i++) {
                vec = vectors[i];

                result[0] += vec[0] / count;
                result[1] += vec[1] / count;
                result[2] += vec[2] / count;
            }

            return result;
        };

        /**
         * Computes the average of a specified array of points packed into a single array.
         * @param {Float32Array | Float64Array | Number[]} points The points whose average to compute.
         * @param {Vec3} result A pre-allocated Vec3 in which to return the computed average.
         * @returns {Vec3} The result argument set to the average of the specified array of points.
         * @throws {ArgumentError} If the specified array of points is null, undefined or empty or the result argument
         * is null or undefined.
         */
        Vec3.averageOfBuffer = function (points, result) {
            if (!points || points.length < 1) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Vec3", "averageBuffer", "missingArray"));
            }

            if (!result) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Vec3", "averageBuffer", "missingResult"));
            }

            var count = points.length / 3;

            result[0] = 0;
            result[1] = 0;
            result[2] = 0;

            for (var i = 0; i < count; i++) {
                result[0] += points[i * 3] / count;
                result[1] += points[i * 3 + 1] / count;
                result[2] += points[i * 3 + 2] / count;
            }

            return result;
        };

        /**
         * Indicates whether three vectors are colinear.
         * @param {Vec3} a The first vector.
         * @param {Vec3} b The second vector.
         * @param {Vec3} c The third vector.
         * @returns {Boolean} true if the vectors are colinear, otherwise false.
         * @throws {ArgumentError} If any of the specified vectors are null or undefined.
         */
        Vec3.areColinear = function (a, b, c) {
            if (!a || !b || !c) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Vec3", "areColinear", "missingVector"));
            }

           var ab = new Vec3(a[0]-b[0],a[1]-b[1],a[2]-b[2]).normalize(),
               bc = new Vec3(c[0]-b[0],c[1]-b[1],c[2]-b[2]).normalize();

            // ab and bc are considered colinear if their dot product is near +/-1.
            return Math.abs(ab.dot(bc)) > 0.999;
        };

        /**
         * Computes the normal vector of a specified triangle.
         *
         * @param {Vec3} a The triangle's first vertex.
         * @param {Vec3} b The triangle's second vertex.
         * @param {Vec3} c The triangle's third vertex.
         * @returns {Vec3} The triangle's unit-normal vector.
         * @throws {ArgumentError} If any of the specified vectors are null or undefined.
         */
        Vec3.computeTriangleNormal = function (a, b, c) {
            if (!a || !b || !c) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Vec3", "areColinear", "missingVector"));
            }

            var x = ((b[1] - a[1]) * (c[2] - a[2])) - ((b[2] - a[2]) * (c[1] - a[1])),
                y = ((b[2] - a[2]) * (c[0] - a[0])) - ((b[0] - a[0]) * (c[2] - a[2])),
                z = ((b[0] - a[0]) * (c[1] - a[1])) - ((b[1] - a[1]) * (c[0] - a[0])),
                length = (x * x) + (y * y) + (z * z);

            if (length === 0) {
                return new Vec3(x, y, z);
            }

            length = Math.sqrt(length);

            return new Vec3(x / length, y / length, z / length);
        };

        /**
         * Finds three non-colinear points in an array of coordinates.
         *
         * @param {Number[]} coords The coordinates, in the order x0, y0, z0, x1, y1, z1, ...
         * @param {Number} stride The number of numbers between successive points. 0 indicates that the points
         * are arranged one immediately after the other, as would the value 3.
         * @returns {Vec3[]} Three non-colinear points from the input array of coordinates, or null if three
         * non-colinear points could not be found or the specified coordinates array is null, undefined or
         * contains fewer than three points.
         */
        Vec3.findThreeIndependentVertices = function (coords, stride) {
            var xstride = (stride && stride > 0) ? stride : 3;

            if (!coords || coords.length < 3 * xstride) {
                return null;
            }

            var a = new Vec3(coords[0], coords[1], coords[2]),
                b = null,
                c = null,
                k = xstride;

            for (; k < coords.length; k += xstride) {
                b = new Vec3(coords[k], coords[k + 1], coords[k + 2]);
                if (!(b[0] === a[0] && b[1] === a[1] && b[2] === a[2])) {
                    break;
                }
                b = null;
            }

            if (!b) {
                return null;
            }

            for (k += xstride; k < coords.length; k += xstride) {
                c = new Vec3(coords[k], coords[k + 1], coords[k + 2]);

                // if c is not coincident with a or b, and the vectors ab and bc are not colinear, break and
                // return a, b, c.
                if (!((c[0] === a[0] && c[1] === a[1] && c[2] === a[2])
                    || (c[0] === b[0] && c[1] === b[1] && c[2] === b[2]))) {
                    if (!Vec3.areColinear(a, b, c))
                        break;
                }

                c = null;
            }

            return c ? [a, b, c] : null;
        };

        /**
         * Computes a unit-normal vector for a buffer of coordinate triples. The normal vector is computed from the
         * first three non-colinear points in the buffer.
         *
         * @param {Number[]} coords The coordinates, in the order x0, y0, z0, x1, y1, z1, ...
         * @param {Number} stride The number of numbers between successive points. 0 indicates that the points
         * are arranged one immediately after the other, as would the value 3.
         * @returns {Vec3} The computed unit-length normal vector.
         */
        Vec3.computeBufferNormal = function (coords, stride) {
            var vertices = Vec3.findThreeIndependentVertices(coords, stride);

            return vertices ? Vec3.computeTriangleNormal(vertices[0], vertices[1], vertices[2]) : null;
        };

        /**
         * Assigns the components of this vector.
         * @param {Number} x The X component of the vector.
         * @param {Number} y The Y component of the vector.
         * @param {Number} z The Z component of the vector.
         * @returns {Vec3} This vector with the specified components assigned.
         */
        Vec3.prototype.set = function (x, y, z) {
            this[0] = x;
            this[1] = y;
            this[2] = z;

            return this;
        };

        /**
         * Copies the components of a specified vector to this vector.
         * @param {Vec3} vector The vector to copy.
         * @returns {Vec3} This vector set to the X, Y and Z values of the specified vector.
         * @throws {ArgumentError} If the specified vector is null or undefined.
         */
        Vec3.prototype.copy = function (vector) {
            if (!vector) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Vec3", "copy", "missingVector"));
            }

            this[0] = vector[0];
            this[1] = vector[1];
            this[2] = vector[2];

            return this;
        };

        /**
         * Indicates whether the components of this vector are identical to those of a specified vector.
         * @param {Vec3} vector The vector to test.
         * @returns {Boolean} true if the components of this vector are equal to those of the specified one,
         * otherwise false.
         */
        Vec3.prototype.equals = function (vector) {
            return this[0] === vector[0] && this[1] === vector[1] && this[2] === vector[2];
        };

        /**
         * Adds a specified vector to this vector.
         * @param {Vec3} addend The vector to add.
         * @returns {Vec3} This vector after adding the specified vector to it.
         * @throws {ArgumentError} If the addend is null or undefined.
         */
        Vec3.prototype.add = function (addend) {
            if (!addend) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Vec3", "add", "missingVector"));
            }

            this[0] += addend[0];
            this[1] += addend[1];
            this[2] += addend[2];

            return this;
        };

        /**
         * Subtracts a specified vector from this vector.
         * @param {Vec3} subtrahend The vector to subtract
         * @returns {Vec3} This vector after subtracting the specified vector from it.
         * @throws {ArgumentError} If the subtrahend is null or undefined.
         */
        Vec3.prototype.subtract = function (subtrahend) {
            if (!subtrahend) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Vec3", "subtract", "missingVector"));
            }

            this[0] -= subtrahend[0];
            this[1] -= subtrahend[1];
            this[2] -= subtrahend[2];

            return this;
        };

        /**
         * Multiplies this vector by a scalar.
         * @param {Number} scalar The scalar to multiply this vector by.
         * @returns {Vec3} This vector multiplied by the specified scalar.
         */
        Vec3.prototype.multiply = function (scalar) {
            this[0] *= scalar;
            this[1] *= scalar;
            this[2] *= scalar;

            return this;
        };

        /**
         * Divides this vector by a scalar.
         * @param {Number} divisor The scalar to divide this vector by.
         * @returns {Vec3} This vector divided by the specified scalar.
         */
        Vec3.prototype.divide = function (divisor) {
            this[0] /= divisor;
            this[1] /= divisor;
            this[2] /= divisor;

            return this;
        };

        /**
         * Multiplies this vector by a 4x4 matrix. The multiplication is performed with an implicit W component of 1.
         * The resultant W component of the product is then divided through the X, Y, and Z components.
         *
         * @param {Matrix} matrix The matrix to multiply this vector by.
         * @returns {Vec3} This vector multiplied by the specified matrix.
         * @throws ArgumentError If the specified matrix is null or undefined.
         */
        Vec3.prototype.multiplyByMatrix = function (matrix) {
            if (!matrix) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Vec3", "multiplyByMatrix", "missingMatrix"));
            }

            var x = matrix[0] * this[0] + matrix[1] * this[1] + matrix[2] * this[2] + matrix[3],
                y = matrix[4] * this[0] + matrix[5] * this[1] + matrix[6] * this[2] + matrix[7],
                z = matrix[8] * this[0] + matrix[9] * this[1] + matrix[10] * this[2] + matrix[11],
                w = matrix[12] * this[0] + matrix[13] * this[1] + matrix[14] * this[2] + matrix[15];

            this[0] = x / w;
            this[1] = y / w;
            this[2] = z / w;

            return this;
        };

        /**
         * Mixes (interpolates) a specified vector with this vector, modifying this vector.
         * @param {Vec3} vector The vector to mix with this one.
         * @param {Number} weight The relative weight of this vector.
         * @returns {Vec3} This vector modified to the mix of itself and the specified vector.
         * @throws {ArgumentError} If the specified vector is null or undefined.
         */
        Vec3.prototype.mix = function (vector, weight) {
            if (!vector) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Vec3", "mix", "missingVector"));
            }

            var w0 = 1 - weight,
                w1 = weight;

            this[0] = this[0] * w0 + vector[0] * w1;
            this[1] = this[1] * w0 + vector[1] * w1;
            this[2] = this[2] * w0 + vector[2] * w1;

            return this;
        };

        /**
         * Negates the components of this vector.
         * @returns {Vec3} This vector, negated.
         */
        Vec3.prototype.negate = function () {
            this[0] = -this[0];
            this[1] = -this[1];
            this[2] = -this[2];

            return this;
        };

        /**
         * Computes the scalar dot product of this vector and a specified vector.
         * @param {Vec3} vector The vector to multiply.
         * @returns {Number} The dot product of the two vectors.
         * @throws {ArgumentError} If the specified vector is null or undefined.
         */
        Vec3.prototype.dot = function (vector) {
            if (!vector) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Vec3", "dot", "missingVector"));
            }

            return this[0] * vector[0] +
                this[1] * vector[1] +
                this[2] * vector[2];
        };

        /**
         * Computes the cross product of this vector and a specified vector, modifying this vector.
         * @param {Vec3} vector The vector to cross with this vector.
         * @returns {Vec3} This vector set to the cross product of itself and the specified vector.
         * @throws {ArgumentError} If the specified vector is null or undefined.
         */
        Vec3.prototype.cross = function (vector) {
            if (!vector) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Vec3", "cross", "missingVector"));
            }

            var x = this[1] * vector[2] - this[2] * vector[1],
                y = this[2] * vector[0] - this[0] * vector[2],
                z = this[0] * vector[1] - this[1] * vector[0];

            this[0] = x;
            this[1] = y;
            this[2] = z;

            return this;
        };

        /**
         * Computes the squared magnitude of this vector.
         * @returns {Number} The squared magnitude of this vector.
         */
        Vec3.prototype.magnitudeSquared = function () {
            return this.dot(this);
        };

        /**
         * Computes the magnitude of this vector.
         * @returns {Number} The magnitude of this vector.
         */
        Vec3.prototype.magnitude = function () {
            return Math.sqrt(this.magnitudeSquared());
        };

        /**
         * Normalizes this vector to a unit vector.
         * @returns {Vec3} This vector, normalized.
         */
        Vec3.prototype.normalize = function () {
            var magnitude = this.magnitude(),
                magnitudeInverse = 1 / magnitude;

            this[0] *= magnitudeInverse;
            this[1] *= magnitudeInverse;
            this[2] *= magnitudeInverse;

            return this;
        };

        /**
         * Computes the squared distance from this vector to a specified vector.
         * @param {Vec3} vector The vector to compute the distance to.
         * @returns {Number} The squared distance between the vectors.
         * @throws {ArgumentError} If the specified vector is null or undefined.
         */
        Vec3.prototype.distanceToSquared = function (vector) {
            if (!vector) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Vec3", "distanceToSquared", "missingVector"));
            }

            var dx = this[0] - vector[0],
                dy = this[1] - vector[1],
                dz = this[2] - vector[2];

            return dx * dx + dy * dy + dz * dz;
        };

        /**
         * Computes the distance from this vector to another vector.
         * @param {Vec3} vector The vector to compute the distance to.
         * @returns {number} The distance between the vectors.
         * @throws {ArgumentError} If the specified vector is null or undefined.
         */
        Vec3.prototype.distanceTo = function (vector) {
            if (!vector) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Vec3", "distanceTo", "missingVector"));
            }

            return Math.sqrt(this.distanceToSquared(vector));
        };

        /**
         * Swaps this vector with that vector. This vector's components are set to the values of the specified
         * vector's components, and the specified vector's components are set to the values of this vector's components.
         * @param {Vec3} that The vector to swap.
         * @returns {Vec3} This vector set to the values of the specified vector.
         */
        Vec3.prototype.swap = function (that) {
            var tmp = this[0];
            this[0] = that[0];
            that[0] = tmp;

            tmp = this[1];
            this[1] = that[1];
            that[1] = tmp;

            tmp = this[2];
            this[2] = that[2];
            that[2] = tmp;

            return this;
        };

        /**
         * Returns a string representation of this vector.
         * @returns {String} A string representation of this vector, in the form "(x, y, z)".
         */
        Vec3.prototype.toString = function () {
            return "(" + this[0] + ", " + this[1] + ", " + this[2] + ")";
        };

        return Vec3;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports Sector
 * @version $Id: Sector.js 2933 2015-03-27 01:18:24Z tgaskins $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(6),
        __webpack_require__(1),
        __webpack_require__(7),
        __webpack_require__(0),
        __webpack_require__(2),
        __webpack_require__(4)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Angle,
              ArgumentError,
              Location,
              Logger,
              Vec3,
              WWMath) {
        "use strict";

        /**
         * Constructs a Sector from specified minimum and maximum latitudes and longitudes in degrees.
         * @alias Sector
         * @constructor
         * @classdesc Represents a rectangular region in geographic coordinates in degrees.
         * @param {Number} minLatitude The sector's minimum latitude in degrees.
         * @param {Number} maxLatitude The sector's maximum latitude in degrees.
         * @param {Number} minLongitude The sector's minimum longitude in degrees.
         * @param {Number} maxLongitude The sector's maximum longitude in degrees.
         */
        var Sector = function (minLatitude, maxLatitude, minLongitude, maxLongitude) {
            /**
             * This sector's minimum latitude in degrees.
             * @type {Number}
             */
            this.minLatitude = minLatitude;
            /**
             * This sector's maximum latitude in degrees.
             * @type {Number}
             */
            this.maxLatitude = maxLatitude;
            /**
             * This sector's minimum longitude in degrees.
             * @type {Number}
             */
            this.minLongitude = minLongitude;
            /**
             * This sector's maximum longitude in degrees.
             * @type {Number}
             */
            this.maxLongitude = maxLongitude;
        };

        /**
         * A sector with minimum and maximum latitudes and minimum and maximum longitudes all zero.
         * @constant
         * @type {Sector}
         */
        Sector.ZERO = new Sector(0, 0, 0, 0);

        /**
         * A sector that encompasses the full range of latitude ([-90, 90]) and longitude ([-180, 180]).
         * @constant
         * @type {Sector}
         */
        Sector.FULL_SPHERE = new Sector(-90, 90, -180, 180);

        /**
         * Sets this sector's latitudes and longitudes to those of a specified sector.
         * @param {Sector} sector The sector to copy.
         * @returns {Sector} This sector, set to the values of the specified sector.
         * @throws {ArgumentError} If the specified sector is null or undefined.
         */
        Sector.prototype.copy = function (sector) {
            if (!sector) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "Sector", "copy", "missingSector"));
            }

            this.minLatitude = sector.minLatitude;
            this.maxLatitude = sector.maxLatitude;
            this.minLongitude = sector.minLongitude;
            this.maxLongitude = sector.maxLongitude;

            return this;
        };

        /**
         * Indicates whether this sector has width or height.
         * @returns {Boolean} true if this sector's minimum and maximum latitudes or minimum and maximum
         * longitudes do not differ, otherwise false.
         */
        Sector.prototype.isEmpty = function () {
            return this.minLatitude === this.maxLatitude && this.minLongitude === this.maxLongitude;
        };

        /**
         * Returns the angle between this sector's minimum and maximum latitudes, in degrees.
         * @returns {Number} The difference between this sector's minimum and maximum latitudes, in degrees.
         */
        Sector.prototype.deltaLatitude = function () {
            return this.maxLatitude - this.minLatitude;
        };

        /**
         * Returns the angle between this sector's minimum and maximum longitudes, in degrees.
         * @returns {Number} The difference between this sector's minimum and maximum longitudes, in degrees.
         */
        Sector.prototype.deltaLongitude = function () {
            return this.maxLongitude - this.minLongitude;
        };

        /**
         * Returns the angle midway between this sector's minimum and maximum latitudes.
         * @returns {Number} The mid-angle of this sector's minimum and maximum latitudes, in degrees.
         */
        Sector.prototype.centroidLatitude = function () {
            return 0.5 * (this.minLatitude + this.maxLatitude);
        };

        /**
         * Returns the angle midway between this sector's minimum and maximum longitudes.
         * @returns {Number} The mid-angle of this sector's minimum and maximum longitudes, in degrees.
         */
        Sector.prototype.centroidLongitude = function () {
            return 0.5 * (this.minLongitude + this.maxLongitude);
        };

        /**
         * Computes the location of the angular center of this sector, which is the mid-angle of each of this sector's
         * latitude and longitude dimensions.
         * @param {Location} result A pre-allocated {@link Location} in which to return the computed centroid.
         * @returns {Location} The specified result argument containing the computed centroid.
         * @throws {ArgumentError} If the result argument is null or undefined.
         */
        Sector.prototype.centroid = function (result) {
            if (!result) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Sector", "centroid", "missingResult"));
            }

            result.latitude = this.centroidLatitude();
            result.longitude = this.centroidLongitude();

            return result;
        };

        /**
         * Returns this sector's minimum latitude in radians.
         * @returns {Number} This sector's minimum latitude in radians.
         */
        Sector.prototype.minLatitudeRadians = function () {
            return this.minLatitude * Angle.DEGREES_TO_RADIANS;
        };

        /**
         * Returns this sector's maximum latitude in radians.
         * @returns {Number} This sector's maximum latitude in radians.
         */
        Sector.prototype.maxLatitudeRadians = function () {
            return this.maxLatitude * Angle.DEGREES_TO_RADIANS;
        };

        /**
         * Returns this sector's minimum longitude in radians.
         * @returns {Number} This sector's minimum longitude in radians.
         */
        Sector.prototype.minLongitudeRadians = function () {
            return this.minLongitude * Angle.DEGREES_TO_RADIANS;
        };

        /**
         * Returns this sector's maximum longitude in radians.
         * @returns {Number} This sector's maximum longitude in radians.
         */
        Sector.prototype.maxLongitudeRadians = function () {
            return this.maxLongitude * Angle.DEGREES_TO_RADIANS;
        };

        /**
         * Modifies this sector to encompass an array of specified locations.
         * @param {Location[]} locations An array of locations. The array may be sparse.
         * @returns {Sector} This sector, modified to encompass all locations in the specified array.
         * @throws {ArgumentError} If the specified array is null, undefined or empty or has fewer than two locations.
         */
        Sector.prototype.setToBoundingSector = function (locations) {
            if (!locations || locations.length < 2) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "Sector", "setToBoundingSector",
                    "missingArray"));
            }

            var minLatitude = 90,
                maxLatitude = -90,
                minLongitude = 180,
                maxLongitude = -180;

            for (var idx = 0, len = locations.length; idx < len; idx += 1) {
                var location = locations[idx];

                if (!location) {
                    continue;
                }

                minLatitude = Math.min(minLatitude, location.latitude);
                maxLatitude = Math.max(maxLatitude, location.latitude);
                minLongitude = Math.min(minLongitude, location.longitude);
                maxLongitude = Math.max(maxLongitude, location.longitude);
            }

            this.minLatitude = minLatitude;
            this.maxLatitude = maxLatitude;
            this.minLongitude = minLongitude;
            this.maxLongitude = maxLongitude;

            return this;
        };

        /**
         * Computes bounding sectors from a list of locations that span the dateline.
         * @param {Location[]} locations The locations to bound.
         * @returns {Sector[]} Two sectors, one in the eastern hemisphere and one in the western hemisphere.
         * Returns null if the computed bounding sector has zero width or height.
         * @throws {ArgumentError} If the specified array is null, undefined or empty or the number of locations
         * is less than 2.
         */
        Sector.splitBoundingSectors = function(locations) {
            if (!locations || locations.length < 2) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "Sector", "splitBoundingSectors",
                    "missingArray"));
            }

            var minLat = 90;
            var minLon = 180;
            var maxLat = -90;
            var maxLon = -180;

            var lastLocation = null;

            for (var idx = 0, len = locations.length; idx < len; idx += 1) {
                var location = locations[idx];

                var lat = location.latitude;
                if (lat < minLat) {
                    minLat = lat;
                }
                if (lat > maxLat) {
                    maxLat = lat;
                }

                var lon = location.longitude;
                if (lon >= 0 && lon < minLon) {
                    minLon = lon;
                }
                if (lon <= 0 && lon > maxLon) {
                    maxLon = lon;
                }

                if (lastLocation != null) {
                    var lastLon = lastLocation.longitude;
                    if (WWMath.signum(lon) != WWMath.signum(lastLon)) {
                        if (Math.abs(lon - lastLon) < 180) {
                            // Crossing the zero longitude line too
                            maxLon = 0;
                            minLon = 0;
                        }
                    }
                }
                lastLocation = location;
            }

            if (minLat === maxLat && minLon === maxLon) {
                return null;
            }

            return [
                new Sector(minLat, maxLat, minLon, 180), // Sector on eastern hemisphere.
                new Sector(minLat, maxLat, -180, maxLon) // Sector on western hemisphere.
            ];
        };

        /**
         * Indicates whether this sector intersects a specified sector.
         * This sector intersects the specified sector when each sector's boundaries either overlap with the specified
         * sector or are adjacent to the specified sector.
         * The sectors are assumed to have normalized angles (angles within the range [-90, 90] latitude and
         * [-180, 180] longitude).
         * @param {Sector} sector The sector to test intersection with. May be null or undefined, in which case this
         * function returns false.
         * @returns {Boolean} true if the specifies sector intersections this sector, otherwise false.
         */
        Sector.prototype.intersects = function (sector) {
            // Assumes normalized angles: [-90, 90], [-180, 180].
            return sector
                && this.minLongitude <= sector.maxLongitude
                && this.maxLongitude >= sector.minLongitude
                && this.minLatitude <= sector.maxLatitude
                && this.maxLatitude >= sector.minLatitude;
        };

        /**
         * Indicates whether this sector intersects a specified sector exclusive of the sector boundaries.
         * This sector overlaps the specified sector when the union of the two sectors defines a non-empty sector.
         * The sectors are assumed to have normalized angles (angles within the range [-90, 90] latitude and
         * [-180, 180] longitude).
         * @param {Sector} sector The sector to test overlap with. May be null or undefined, in which case this
         * function returns false.
         * @returns {Boolean} true if the specified sector overlaps this sector, otherwise false.
         */
        Sector.prototype.overlaps = function (sector) {
            // Assumes normalized angles: [-90, 90], [-180, 180].
            return sector
                && this.minLongitude < sector.maxLongitude
                && this.maxLongitude > sector.minLongitude
                && this.minLatitude < sector.maxLatitude
                && this.maxLatitude > sector.minLatitude;
        };

        /**
         * Indicates whether this sector fully contains a specified sector.
         * This sector contains the specified sector when the specified sector's boundaries are completely contained
         * within this sector's boundaries, or are equal to this sector's boundaries.
         * The sectors are assumed to have normalized angles (angles within the range [-90, 90] latitude and
         * [-180, 180] longitude).
         * @param {Sector} sector The sector to test containment with. May be null or undefined, in which case this
         * function returns false.
         * @returns {Boolean} true if the specified sector contains this sector, otherwise false.
         */
        Sector.prototype.contains = function (sector) {
            // Assumes normalized angles: [-90, 90], [-180, 180].
            return sector
                && this.minLatitude <= sector.minLatitude
                && this.maxLatitude >= sector.maxLatitude
                && this.minLongitude <= sector.minLongitude
                && this.maxLongitude >= sector.maxLongitude;
        };

        /**
         * Indicates whether this sector contains a specified geographic location.
         * @param {Number} latitude The location's latitude in degrees.
         * @param {Number} longitude The location's longitude in degrees.
         * @returns {Boolean} true if this sector contains the location, otherwise false.
         */
        Sector.prototype.containsLocation = function (latitude, longitude) {
            // Assumes normalized angles: [-90, 90], [-180, 180].
            return this.minLatitude <= latitude
                && this.maxLatitude >= latitude
                && this.minLongitude <= longitude
                && this.maxLongitude >= longitude;
        };

        /**
         * Sets this sector to the intersection of itself and a specified sector.
         * @param {Sector} sector The sector to intersect with this one.
         * @returns {Sector} This sector, set to its intersection with the specified sector.
         * @throws {ArgumentError} If the specified sector is null or undefined.
         */
        Sector.prototype.intersection = function (sector) {
            if (!sector instanceof Sector) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Sector", "intersection", "missingSector"));
            }

            // Assumes normalized angles: [-180, 180], [-90, 90].
            if (this.minLatitude < sector.minLatitude)
                this.minLatitude = sector.minLatitude;
            if (this.maxLatitude > sector.maxLatitude)
                this.maxLatitude = sector.maxLatitude;
            if (this.minLongitude < sector.minLongitude)
                this.minLongitude = sector.minLongitude;
            if (this.maxLongitude > sector.maxLongitude)
                this.maxLongitude = sector.maxLongitude;

            // If the sectors do not overlap in either latitude or longitude, then the result of the above logic results in
            // the max being greater than the min. In this case, set the max to indicate that the sector is empty in
            // that dimension.
            if (this.maxLatitude < this.minLatitude)
                this.maxLatitude = this.minLatitude;
            if (this.maxLongitude < this.minLongitude)
                this.maxLongitude = this.minLongitude;

            return this;
        };

        /**
         * Sets this sector to the union of itself and a specified sector.
         * @param {Sector} sector The sector to union with this one.
         * @returns {Sector} This sector, set to its union with the specified sector.
         * @throws {ArgumentError} if the specified sector is null or undefined.
         */
        Sector.prototype.union = function (sector) {
            if (!sector instanceof Sector) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Sector", "union", "missingSector"));
            }

            // Assumes normalized angles: [-180, 180], [-90, 90].
            if (this.minLatitude > sector.minLatitude)
                this.minLatitude = sector.minLatitude;
            if (this.maxLatitude < sector.maxLatitude)
                this.maxLatitude = sector.maxLatitude;
            if (this.minLongitude > sector.minLongitude)
                this.minLongitude = sector.minLongitude;
            if (this.maxLongitude < sector.maxLongitude)
                this.maxLongitude = sector.maxLongitude;

            return this;
        };

        return Sector;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @version $Id: WWMath.js 3305 2015-07-07 21:55:51Z dcollins $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(6),
        __webpack_require__(1),
        __webpack_require__(13),
        __webpack_require__(0),
        __webpack_require__(9),
        __webpack_require__(2)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Angle,
              ArgumentError,
              Line,
              Logger,
              Rectangle,
              Vec3) {
        "use strict";
        /**
         * Provides math constants and functions.
         * @exports WWMath
         */
        var WWMath = {

            /**
             * Returns a number within the range of a specified minimum and maximum.
             * @param {Number} value The value to clamp.
             * @param {Number} minimum The minimum value to return.
             * @param {Number} maximum The maximum value to return.
             * @returns {Number} The minimum value if the specified value is less than the minimum, the maximum value if
             * the specified value is greater than the maximum, otherwise the value specified is returned.
             */
            clamp: function (value, minimum, maximum) {
                return value < minimum ? minimum : value > maximum ? maximum : value;
            },

            /**
             * Computes a number between two numbers.
             * @param amount {Number} The relative distance between the numbers at which to compute the new number. This
             * should normally be a number between 0 and 1 but whatever number is specified is applied.
             * @param {Number} value1 The first number.
             * @param {Number} value2 The second number.
             * @returns {Number} the computed value.
             */
            interpolate: function (amount, value1, value2) {
                return (1 - amount) * value1 + amount * value2;
            },

            /**
             * Returns the cube root of a specified value.
             * @param {Number} x The value whose cube root is computed.
             * @returns {Number} The cube root of the specified number.
             */
            cbrt: function (x) {
                // Use the built-in version if it exists. cbrt() is defined in ECMA6.
                if (typeof Math.cbrt == 'function') {
                    return Math.cbrt(x);
                } else {
                    return Math.pow(x, 1 / 3);
                }
            },

            /**
             * Computes the Cartesian intersection point of a specified line with an ellipsoid.
             * @param {Line} line The line for which to compute the intersection.
             * @param {Number} equatorialRadius The ellipsoid's major radius.
             * @param {Number} polarRadius The ellipsoid's minor radius.
             * @param {Vec3} result A pre-allocated Vec3 instance in which to return the computed point.
             * @returns {boolean} true if the line intersects the ellipsoid, otherwise false
             * @throws {ArgumentError} If the specified line or result is null or undefined.
             */
            computeEllipsoidalGlobeIntersection: function (line, equatorialRadius, polarRadius, result) {
                if (!line) {
                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath",
                        "computeEllipsoidalGlobeIntersection", "missingLine"));
                }

                if (!result) {
                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath",
                        "computeEllipsoidalGlobeIntersection", "missingResult"));
                }

                // Taken from "Mathematics for 3D Game Programming and Computer Graphics, Second Edition", Section 5.2.3.
                //
                // Note that the parameter n from in equations 5.70 and 5.71 is omitted here. For an ellipsoidal globe this
                // parameter is always 1, so its square and its product with any other value simplifies to the identity.

                var vx = line.direction[0],
                    vy = line.direction[1],
                    vz = line.direction[2],
                    sx = line.origin[0],
                    sy = line.origin[1],
                    sz = line.origin[2],
                    m = equatorialRadius / polarRadius, // ratio of the x semi-axis length to the y semi-axis length
                    m2 = m * m,
                    r2 = equatorialRadius * equatorialRadius, // nominal radius squared
                    a = vx * vx + m2 * vy * vy + vz * vz,
                    b = 2 * (sx * vx + m2 * sy * vy + sz * vz),
                    c = sx * sx + m2 * sy * sy + sz * sz - r2,
                    d = b * b - 4 * a * c, // discriminant
                    t;

                if (d < 0) {
                    return false;
                }
                else {
                    t = (-b - Math.sqrt(d)) / (2 * a);
                    result[0] = sx + vx * t;
                    result[1] = sy + vy * t;
                    result[2] = sz + vz * t;
                    return true;
                }
            },

            /**
             * Computes the Cartesian intersection point of a specified line with a triangle.
             * @param {Line} line The line for which to compute the intersection.
             * @param {Vec3} vertex0 The triangle's first vertex.
             * @param {Vec3} vertex1 The triangle's second vertex.
             * @param {Vec3} vertex2 The triangle's third vertex.
             * @param {Vec3} result A pre-allocated Vec3 instance in which to return the computed point.
             * @returns {boolean} true if the line intersects the triangle, otherwise false
             * @throws {ArgumentError} If the specified line, vertex or result is null or undefined.
             */
            computeTriangleIntersection: function (line, vertex0, vertex1, vertex2, result) {
                if (!line) {
                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath",
                        "computeTriangleIntersection", "missingLine"));
                }

                if (!vertex0 || !vertex1 || !vertex2) {
                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath",
                        "computeTriangleIntersection", "missingVertex"));
                }

                if (!result) {
                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath",
                        "computeTriangleIntersection", "missingResult"));
                }

                // Taken from Moller and Trumbore
                // https://www.cs.virginia.edu/~gfx/Courses/2003/ImageSynthesis/papers/Acceleration/Fast%20MinimumStorage%20RayTriangle%20Intersection.pdf

                var vx = line.direction[0],
                    vy = line.direction[1],
                    vz = line.direction[2],
                    sx = line.origin[0],
                    sy = line.origin[1],
                    sz = line.origin[2],
                    EPSILON = 0.00001;

                // find vectors for two edges sharing point a: vertex1 - vertex0 and vertex2 - vertex0
                var edge1x = vertex1[0] - vertex0[0],
                    edge1y = vertex1[1] - vertex0[1],
                    edge1z = vertex1[2] - vertex0[2],
                    edge2x = vertex2[0] - vertex0[0],
                    edge2y = vertex2[1] - vertex0[1],
                    edge2z = vertex2[2] - vertex0[2];

                // Compute cross product of line direction and edge2
                var px = (vy * edge2z) - (vz * edge2y),
                    py = (vz * edge2x) - (vx * edge2z),
                    pz = (vx * edge2y) - (vy * edge2x);

                // Get determinant
                var det = edge1x * px + edge1y * py + edge1z * pz; // edge1 dot p
                if (det > -EPSILON && det < EPSILON) { // if det is near zero then ray lies in plane of triangle
                    return false;
                }

                var inv_det = 1.0 / det;

                // Compute distance for vertex A to ray origin: origin - vertex0
                var tx = sx - vertex0[0],
                    ty = sy - vertex0[1],
                    tz = sz - vertex0[2];

                // Calculate u parameter and test bounds: 1/det * t dot p
                var u = inv_det * (tx * px + ty * py + tz * pz);
                if (u < -EPSILON || u > 1 + EPSILON) {
                    return false;
                }

                // Prepare to test v parameter: t cross edge1
                var qx = (ty * edge1z) - (tz * edge1y),
                    qy = (tz * edge1x) - (tx * edge1z),
                    qz = (tx * edge1y) - (ty * edge1x);

                // Calculate v parameter and test bounds: 1/det * dir dot q
                var v = inv_det * (vx * qx + vy * qy + vz * qz);
                if (v < -EPSILON || u + v > 1 + EPSILON) {
                    return false;
                }

                // Calculate the point of intersection on the line: t = 1/det * edge2 dot q
                var t = inv_det * (edge2x * qx + edge2y * qy + edge2z * qz);
                if (t < 0) {
                    return false;
                } else {
                    result[0] = sx + vx * t;
                    result[1] = sy + vy * t;
                    result[2] = sz + vz * t;
                    return true;
                }
            },

            computeIndexedTrianglesIntersection: function (line, points, indices, results) {
                if (!line) {
                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath",
                        "computeIndexedTrianglesIntersection", "missingLine"));
                }

                if (!points) {
                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath",
                        "computeIndexedTrianglesIntersection", "missingPoints"));
                }

                if (!indices) {
                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath",
                        "computeIndexedTrianglesIntersection", "missingIndices"));
                }

                if (!results) {
                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath",
                        "computeIndexedTrianglesIntersection", "missingResults"));
                }

                var v0 = new Vec3(0, 0, 0),
                    v1 = new Vec3(0, 0, 0),
                    v2 = new Vec3(0, 0, 0),
                    iPoint = new Vec3(0, 0, 0);

                for (var i = 0, len = indices.length; i < len; i += 3) {
                    var i0 = 3 * indices[i],
                        i1 = 3 * indices[i + 1],
                        i2 = 3 * indices[i + 2];

                    v0[0] = points[i0];
                    v0[1] = points[i0 + 1];
                    v0[2] = points[i0 + 2];

                    v1[0] = points[i1];
                    v1[1] = points[i1 + 1];
                    v1[2] = points[i1 + 2];

                    v2[0] = points[i2];
                    v2[1] = points[i2 + 1];
                    v2[2] = points[i2 + 2];

                    if (WWMath.computeTriangleIntersection(line, v0, v1, v2, iPoint)) {
                        results.push(iPoint);
                        iPoint = new Vec3(0, 0, 0);
                    }
                }

                return results.length > 0;
            },

            /**
             * Computes the Cartesian intersection points of a specified line with a triangle strip. The triangle strip
             * is specified by a list of vertex points and a list of indices indicating the triangle strip tessellation
             * of those vertices. The triangle strip indices are interpreted in the same manner as WebGL, where each
             * index indicates a vertex position rather than an actual index into the points array (e.g. a triangle
             * strip index of 1 indicates the XYZ tuple starting at array index 3). This is equivalent to calling
             * computeTriangleIntersection for each individual triangle in the triangle strip, but is potentially much
             * more efficient.
             * @param {Line} line The line for which to compute the intersection.
             * @param {Array} points The list of vertex points, organized as a list of tightly-packed XYZ tuples.
             * @param {Array} indices The list of triangle strip indices, organized as a list of vertex positions.
             * @param {Array} results A pre-allocated array instance in which to return the intersection points as
             * {@link Vec3} instances.
             * @throws {ArgumentError} If the specified line, points, indices or results is null or undefined.
             */
            computeTriStripIntersections: function (line, points, indices, results) {
                if (!line) {
                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath",
                        "computeTriStripIntersections", "missingLine"));
                }

                if (!points) {
                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath",
                        "computeTriStripIntersections", "missingPoints"));
                }

                if (!indices) {
                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath",
                        "computeTriStripIntersections", "missingIndices"));
                }

                if (!results) {
                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath",
                        "computeTriStripIntersections", "missingResults"));
                }

                // Taken from Moller and Trumbore
                // https://www.cs.virginia.edu/~gfx/Courses/2003/ImageSynthesis/papers/Acceleration/Fast%20MinimumStorage%20RayTriangle%20Intersection.pdf

                // Adapted from the original ray-triangle intersection algorithm to optimize for ray-triangle strip
                // intersection. We optimize by reusing constant terms, replacing use of Vec3 with inline primitives,
                // and exploiting the triangle strip organization to reuse computations common to adjacent triangles.
                // These optimizations reduce worst-case terrain picking performance by approximately 50% in Chrome on a
                // 2010 iMac and a Nexus 9.

                var vx = line.direction[0],
                    vy = line.direction[1],
                    vz = line.direction[2],
                    sx = line.origin[0],
                    sy = line.origin[1],
                    sz = line.origin[2],
                    vert0x, vert0y, vert0z,
                    vert1x, vert1y, vert1z,
                    vert2x, vert2y, vert2z,
                    edge1x, edge1y, edge1z,
                    edge2x, edge2y, edge2z,
                    px, py, pz,
                    tx, ty, tz,
                    qx, qy, qz,
                    u, v, t,
                    det, inv_det,
                    index,
                    EPSILON = 0.00001;

                // Get the triangle strip's first vertex.
                index = 3 * indices[0];
                vert1x = points[index++];
                vert1y = points[index++];
                vert1z = points[index];

                // Get the triangle strip's second vertex.
                index = 3 * indices[1];
                vert2x = points[index++];
                vert2y = points[index++];
                vert2z = points[index];

                // Compute the intersection of each triangle with the specified ray.
                for (var i = 2, len = indices.length; i < len; i++) {
                    // Move the last two vertices into the first two vertices. This takes advantage of the triangle
                    // strip's structure and avoids redundant reads from points and indices. During the first
                    // iteration this places the triangle strip's first three vertices in vert0, vert1 and vert2,
                    // respectively.
                    vert0x = vert1x;
                    vert0y = vert1y;
                    vert0z = vert1z;
                    vert1x = vert2x;
                    vert1y = vert2y;
                    vert1z = vert2z;

                    // Get the triangle strip's next vertex.
                    index = 3 * indices[i];
                    vert2x = points[index++];
                    vert2y = points[index++];
                    vert2z = points[index];

                    // find vectors for two edges sharing point a: vert1 - vert0 and vert2 - vert0
                    edge1x = vert1x - vert0x;
                    edge1y = vert1y - vert0y;
                    edge1z = vert1z - vert0z;
                    edge2x = vert2x - vert0x;
                    edge2y = vert2y - vert0y;
                    edge2z = vert2z - vert0z;

                    // Compute cross product of line direction and edge2
                    px = (vy * edge2z) - (vz * edge2y);
                    py = (vz * edge2x) - (vx * edge2z);
                    pz = (vx * edge2y) - (vy * edge2x);

                    // Get determinant
                    det = edge1x * px + edge1y * py + edge1z * pz; // edge1 dot p
                    if (det > -EPSILON && det < EPSILON) { // if det is near zero then ray lies in plane of triangle
                        continue;
                    }

                    inv_det = 1.0 / det;

                    // Compute distance for vertex A to ray origin: origin - vert0
                    tx = sx - vert0x;
                    ty = sy - vert0y;
                    tz = sz - vert0z;

                    // Calculate u parameter and test bounds: 1/det * t dot p
                    u = inv_det * (tx * px + ty * py + tz * pz);
                    if (u < -EPSILON || u > 1 + EPSILON) {
                        continue;
                    }

                    // Prepare to test v parameter: tvec cross edge1
                    qx = (ty * edge1z) - (tz * edge1y);
                    qy = (tz * edge1x) - (tx * edge1z);
                    qz = (tx * edge1y) - (ty * edge1x);

                    // Calculate v parameter and test bounds: 1/det * dir dot q
                    v = inv_det * (vx * qx + vy * qy + vz * qz);
                    if (v < -EPSILON || u + v > 1 + EPSILON) {
                        continue;
                    }

                    // Calculate the point of intersection on the line: t = 1/det * edge2 dot q
                    t = inv_det * (edge2x * qx + edge2y * qy + edge2z * qz);
                    if (t >= 0) {
                        results.push(new Vec3(sx + vx * t, sy + vy * t, sz + vz * t));
                    }
                }
            },

            /**
             * Computes the absolute value of a specified value.
             * @param {Number} a The value whose absolute value to compute.
             * @returns {Number} The absolute value of the specified number.
             */
            fabs: function (a) {
                return a >= 0 ? a : -a;
            },

            /**
             * Computes the floating-point modulus of a specified number.
             * @param {Number} number The number whose modulus to compute.
             * @param {Number} modulus The modulus.
             * @returns {Number} The remainder after dividing the number by the modulus: number % modulus.
             */
            fmod: function (number, modulus) {
                return modulus === 0 ? 0 : number - Math.floor(number / modulus) * modulus;
            },

            /**
             * Returns the fractional part of a specified number
             * @param {Number} number The number whose fractional part to compute.
             * @returns {Number} The fractional part of the specified number: number - floor(number).
             */
            fract: function (number) {
                return number - Math.floor(number);
            },

            /**
             * Returns the integer modulus of a specified number. This differs from the % operator in that
             * the result is always positive when the modulus is positive. For example -1 % 10 = -1,
             * whereas mod(-1, 10) = 1.
             * @param {Number} number The number whose modulus to compute.
             * @param {Number} modulus The modulus.
             * @returns {Number} The remainder after dividing the number by the modulus.
             */
            mod: function (number, modulus) {
                return ((number % modulus) + modulus) % modulus;
            },

            /**
             * Returns the maximum of two specified numbers.
             * @param {Number} value1 The first value to compare.
             * @param {Number} value2 The second value to compare.
             * @returns {Number} The maximum of the two specified values.
             */
            max: function (value1, value2) {
                return value1 > value2 ? value1 : value2;
            },

            /**
             * Computes the axes of a local coordinate system on the specified globe, placing the resultant axes in the specified
             * axis arguments.
             *
             * Upon return the specified axis arguments contain three orthogonal axes identifying the X, Y, and Z axes. Each
             * axis has unit length.
             *
             * The local coordinate system is defined such that the Z axis maps to the globe's surface normal at the point, the
             * Y axis maps to the north pointing tangent, and the X axis maps to the east pointing tangent.
             *
             * @param {Vec3} origin The local coordinate system origin, in model coordinates.
             * @param {Globe} globe The globe the coordinate system is relative to.
             * @param {Vec3} xAxisResult A pre-allocated Vec3 in which to return the computed X axis.
             * @param {Vec3} yAxisResult A pre-allocated Vec3 in which to return the computed Y axis.
             * @param {Vec3} zAxisResult A pre-allocated Vec3 in which to return the computed Z axis.
             * @throws {ArgumentError} If any argument is null or undefined.
             */
            localCoordinateAxesAtPoint: function (origin, globe, xAxisResult, yAxisResult, zAxisResult) {
                if (!origin) {
                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath",
                        "localCoordinateAxesAtPoint", "missingVector"));
                }

                if (!globe) {
                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath",
                        "localCoordinateAxesAtPoint", "missingGlobe"));
                }

                if (!xAxisResult || !yAxisResult || !zAxisResult) {
                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath",
                        "localCoordinateAxesAtPoint", "missingResult"));
                }

                var x = origin[0],
                    y = origin[1],
                    z = origin[2];

                // Compute the z axis from the surface normal in model coordinates. This axis is used to determine the other two
                // axes, and is the only constant in the computations below.
                globe.surfaceNormalAtPoint(x, y, z, zAxisResult);

                // Compute the y axis from the north pointing tangent in model coordinates. This axis is known to be orthogonal to
                // the z axis, and is therefore used to compute the x axis.
                globe.northTangentAtPoint(x, y, z, yAxisResult);

                // Compute the x axis as the cross product of the y and z axes. This ensures that the x and z axes are orthogonal.
                xAxisResult.set(yAxisResult[0], yAxisResult[1], yAxisResult[2]);
                xAxisResult.cross(zAxisResult);
                xAxisResult.normalize();

                // Re-compute the y axis as the cross product of the z and x axes. This ensures that all three axes are orthogonal.
                // Though the initial y axis computed above is likely to be very nearly orthogonal, we re-compute it using cross
                // products to reduce the effect of floating point rounding errors caused by working with Earth sized coordinates.
                yAxisResult.set(zAxisResult[0], zAxisResult[1], zAxisResult[2]);
                yAxisResult.cross(xAxisResult);
                yAxisResult.normalize();
            },

            /**
             * Computes the distance to a globe's horizon from a viewer at a given altitude.
             *
             * Only the globe's ellipsoid is considered; terrain height is not incorporated. This returns zero if the radius is zero
             * or if the altitude is less than or equal to zero.
             *
             * @param {Number} radius The globe's radius, in meters.
             * @param {Number} altitude The viewer's altitude above the globe, in meters.
             * @returns {Number} The distance to the horizon, in model coordinates.
             * @throws {ArgumentError} If the specified globe radius is negative.
             */
            horizonDistanceForGlobeRadius: function (radius, altitude) {
                if (radius < 0) {
                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath",
                        "horizontalDistanceForGlobeRadius", "The specified globe radius is negative."));
                }

                return (radius > 0 && altitude > 0) ? Math.sqrt(altitude * (2 * radius + altitude)) : 0;
            },

            /**
             * Computes the near clip distance that corresponds to a specified far clip distance and resolution at the far clip
             * plane.
             *
             * This computes a near clip distance appropriate for use in [perspectiveFrustumRect]{@link WWMath#perspectiveFrustumRectangle}
             * and [setToPerspectiveProjection]{@link Matrix#setToPerspectiveProjection}. This returns zero if either the distance or the
             * resolution are zero.
             *
             * @param {Number} farDistance The far clip distance, in meters.
             * @param {Number} farResolution The depth resolution at the far clip plane, in meters.
             * @param {Number} depthBits The number of bit-planes in the depth buffer.
             * @returns {Number} The near clip distance, in meters.
             * @throws {ArgumentError} If either the distance or resolution is negative, or if the depth bits is less
             * than one.
             */
            perspectiveNearDistanceForFarDistance: function (farDistance, farResolution, depthBits) {
                if (farDistance < 0) {
                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath", "perspectiveNearDistanceForFarDistance",
                        "The specified distance is negative."));
                }

                if (farResolution < 0) {
                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath", "perspectiveNearDistanceForFarDistance",
                        "The specified resolution is negative."));
                }

                if (depthBits < 1) {
                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath", "perspectiveNearDistanceForFarDistance",
                        "The specified depth bits is negative."));
                }

                var maxDepthValue = (1 << depthBits) - 1;

                return farDistance / (maxDepthValue / (1 - farResolution / farDistance) - maxDepthValue + 1);
            },

            /**
             * Computes the maximum near clip distance for a perspective projection that avoids clipping an object at a
             * given distance from the eye point.
             * <p/>
             * This computes a near clip distance appropriate for use in perspectiveFrustumRect and
             * Matrix.setToPerspectiveProjection. The given distance should specify the smallest distance between the
             * eye and the object being viewed, but may be an approximation if an exact distance is not required.
             *
             * @param {Number} viewportWidth The viewport width, in screen coordinates.
             * @param {Number} viewportHeight The viewport height, in screen coordinates.
             * @param {Number} distanceToSurface The distance from the perspective eye point to the nearest object, in
             * meters.
             * @returns {Number} The maximum near clip distance, in meters.
             * @throws {ArgumentError} If the specified width or height is less than or equal to zero, or if the
             * specified distance is negative.
             */
            perspectiveNearDistance: function (viewportWidth, viewportHeight, distanceToSurface) {
                if (viewportWidth <= 0) {
                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath", "perspectiveNearDistance",
                        "invalidWidth"));
                }

                if (viewportHeight <= 0) {
                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath", "perspectiveNearDistance",
                        "invalidHeight"));
                }

                if (distanceToSurface < 0) {
                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath", "perspectiveNearDistance",
                        "The specified distance is negative."));
                }

                // Compute the maximum near clip distance that avoids clipping an object at the specified distance from
                // the eye. Since the furthest points on the near clip rectangle are the four corners, we compute a near
                // distance that puts any one of these corners exactly at the given distance. The distance to one of the
                // four corners can be expressed in terms of the near clip distance, given distance to a corner 'd',
                // near distance 'n', and aspect ratio 'a':
                //
                // d*d = x*x + y*y + z*z
                // d*d = (n*n/4 * a*a) + (n*n/4) + (n*n)
                //
                // Extracting 'n*n/4' from the right hand side gives:
                //
                // d*d = (n*n/4) * (a*a + 1 + 4)
                // d*d = (n*n/4) * (a*a + 5)
                //
                // Finally, solving for 'n' gives:
                //
                // n*n = 4 * d*d / (a*a + 5)
                // n = 2 * d / sqrt(a*a + 5)

                // Assumes a 45 degree horizontal field of view.
                var aspectRatio = viewportHeight / viewportWidth;

                return 2 * distanceToSurface / Math.sqrt(aspectRatio * aspectRatio + 5);
            },

            /**
             * Computes the coordinates of a rectangle carved out of a perspective projection's frustum at a given
             * distance in model coordinates. This returns an empty rectangle if the specified distance is zero.
             *
             * @param {Number} viewportWidth The viewport width, in screen coordinates.
             * @param {Number} viewportHeight The viewport height, in screen coordinates.
             * @param {Number} distance The distance along the negative Z axis, in model coordinates.
             * @returns {Rectangle} The frustum rectangle, in model coordinates.
             * @throws {ArgumentError} If the specified width or height is less than or equal to zero, or if the
             * specified distance is negative.
             */
            perspectiveFrustumRectangle: function (viewportWidth, viewportHeight, distance) {
                if (viewportWidth <= 0) {
                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath", "perspectiveFrustumRectangle",
                        "invalidWidth"));
                }

                if (viewportHeight <= 0) {
                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath", "perspectiveFrustumRectangle",
                        "invalidHeight"));
                }

                if (distance < 0) {
                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath", "perspectiveFrustumRectangle",
                        "The specified distance is negative."));
                }

                // Assumes a 45 degree horizontal field of view.
                var width = distance,
                    height = distance * viewportHeight / viewportWidth;

                return new Rectangle(-width / 2, -height / 2, width, height);
            },

            /**
             * Computes the vertical size of a pixel in model coordinates at a given distance from the eye point in a
             * perspective projection. This returns zero if the specified distance is zero. The returned size is
             * undefined if the distance is less than zero.
             * <p/>
             * This method assumes the model of a screen composed of rectangular pixels, where pixel coordinates denote
             * infinitely thin space between pixels. The units of the returned size are in model coordinates per pixel
             * (usually meters per pixel).
             *
             * @param {Number} viewportWidth The viewport width, in screen coordinates.
             * @param {Number} viewportHeight The viewport height, in screen coordinates.
             * @param {Number} distance The distance from the perspective eye point at which to determine pixel size, in
             * model coordinates.
             * @returns {Number} The pixel size at the specified distance from the eye point, in model coordinates per
             * pixel.
             * @throws {ArgumentError} If the specified width or height is less than or equal to zero, or if the
             * specified distance is negative.
             */
            perspectivePixelSize: function (viewportWidth, viewportHeight, distance) {
                if (viewportWidth <= 0) {
                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath", "perspectivePixelSize",
                        "invalidWidth"));
                }

                if (viewportHeight <= 0) {
                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath", "perspectivePixelSize",
                        "invalidHeight"));
                }

                if (distance < 0) {
                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath", "perspectivePixelSize",
                        "The specified distance is negative."));
                }

                var frustumHeight = WWMath.perspectiveFrustumRectangle(viewportWidth, viewportHeight, distance).height;
                return frustumHeight / viewportHeight;
            },

            /**
             * Computes the bounding rectangle for a unit quadrilateral after applying a transformation matrix to that
             * quadrilateral.
             * @param {Matrix} transformMatrix The matrix to apply to the unit quadrilateral.
             * @returns {Rectangle} The computed bounding rectangle.
             */
            boundingRectForUnitQuad: function (transformMatrix) {
                if (!transformMatrix) {
                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath", "boundingRectForUnitQuad",
                        "missingMatrix"));
                }

                var m = transformMatrix,
                // transform of (0, 0)
                    x1 = m[3],
                    y1 = m[7],
                // transform of (1, 0)
                    x2 = m[0] + m[3],
                    y2 = m[4] + m[7],
                // transform of (0, 1)
                    x3 = m[1] + m[3],
                    y3 = m[5] + m[7],
                // transform of (1, 1)
                    x4 = m[0] + m[1] + m[3],
                    y4 = m[4] + m[5] + m[7],
                    minX = Math.min(Math.min(x1, x2), Math.min(x3, x4)),
                    maxX = Math.max(Math.max(x1, x2), Math.max(x3, x4)),
                    minY = Math.min(Math.min(y1, y2), Math.min(y3, y4)),
                    maxY = Math.max(Math.max(y1, y2), Math.max(y3, y4));

                return new Rectangle(minX, minY, maxX - minX, maxY - minY);
            },

            /**
             * Indicates whether a specified value is a power of two.
             * @param {Number} value The value to test.
             * @returns {boolean} <code>true</code> if the specified value is a power of two,
             * otherwise <code>false</code>.
             */
            isPowerOfTwo: function (value) {
                return value != 0 && (value & (value - 1)) === 0;
            },

            /**
             * Determine the sign of a number.
             * @param {Number} value The value to determine the sign of.
             * @returns {Number} 1, -1, or 0, depending on the sign of the value.
             */
            signum: function (value) {
                return value > 0 ? 1 : value < 0 ? -1 : 0;
            },

            /**
             * Calculates the Gudermannian inverse used to unproject Mercator projections.
             * @param {Number} latitude The latitude in degrees.
             * @returns {Number} The Gudermannian inverse for the specified latitude.
             */
            gudermannianInverse: function (latitude) {
                return Math.log(Math.tan(Math.PI / 4 + (latitude * Angle.DEGREES_TO_RADIANS) / 2)) / Math.PI;
            },

            epsg3857ToEpsg4326: function (easting, northing) {
                var r = 6.3781e6,
                    latRadians = (Math.PI / 2) - 2 * Math.atan(Math.exp(-northing / r)),
                    lonRadians = easting / r;

                return [
                    WWMath.clamp(latRadians * Angle.RADIANS_TO_DEGREES, -90, 90),
                    WWMath.clamp(lonRadians * Angle.RADIANS_TO_DEGREES, -180, 180)
                ];
            },

            /**
             * Returns the value that is the nearest power of 2 less than or equal to the given value.
             * @param {Number} value the reference value. The power of 2 returned is less than or equal to this value.
             * @returns {Number} the value that is the nearest power of 2 less than or equal to the reference value
             */
            powerOfTwoFloor: function (value) {
                var power = Math.floor(Math.log(value) / Math.log(2));
                return Math.pow(2, power);
            }
        };

        return WWMath;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports Matrix
 * @version $Id: Matrix.js 3298 2015-07-06 17:28:33Z dcollins $
 */

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(6),
        __webpack_require__(1),
        __webpack_require__(0),
        __webpack_require__(18),
        __webpack_require__(10),
        __webpack_require__(9),
        __webpack_require__(25),
        __webpack_require__(2),
        __webpack_require__(4)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Angle,
              ArgumentError,
              Logger,
              Plane,
              Position,
              Rectangle,
              Texture,
              Vec3,
              WWMath) {
        "use strict";

        /**
         * Constructs a matrix.
         * @alias Matrix
         * @constructor
         * @classdesc Represents a 4 x 4 double precision matrix stored in a Float64Array in row-major order.
         * @param {Number} m11 matrix element at row 1, column 1.
         * @param {Number} m12 matrix element at row 1, column 2.
         * @param {Number} m13 matrix element at row 1, column 3.
         * @param {Number} m14 matrix element at row 1, column 4.
         * @param {Number} m21 matrix element at row 2, column 1.
         * @param {Number} m22 matrix element at row 2, column 2.
         * @param {Number} m23 matrix element at row 2, column 3.
         * @param {Number} m24 matrix element at row 2, column 4.
         * @param {Number} m31 matrix element at row 3, column 1.
         * @param {Number} m32 matrix element at row 3, column 2.
         * @param {Number} m33 matrix element at row 3, column 3.
         * @param {Number} m34 matrix element at row 3, column 4.
         * @param {Number} m41 matrix element at row 4, column 1.
         * @param {Number} m42 matrix element at row 4, column 2.
         * @param {Number} m43 matrix element at row 4, column 3.
         * @param {Number} m44 matrix element at row 4, column 4.
         */
        var Matrix = function (m11, m12, m13, m14,
                               m21, m22, m23, m24,
                               m31, m32, m33, m34,
                               m41, m42, m43, m44) {
            this[0] = m11;
            this[1] = m12;
            this[2] = m13;
            this[3] = m14;
            this[4] = m21;
            this[5] = m22;
            this[6] = m23;
            this[7] = m24;
            this[8] = m31;
            this[9] = m32;
            this[10] = m33;
            this[11] = m34;
            this[12] = m41;
            this[13] = m42;
            this[14] = m43;
            this[15] = m44;
        };

        // Derives from Float64Array.
        Matrix.prototype = new Float64Array(16);

        /**
         * Creates an identity matrix.
         * @returns {Matrix} A new identity matrix.
         */
        Matrix.fromIdentity = function () {
            return new Matrix(
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            );
        };

        /**
         * Computes the principal axes of a point collection expressed in a typed array.
         * @param {Float32Array} points The points for which to compute the axes,
         * expressed as X0, Y0, Z0, X1, Y1, Z1, ...
         * @param {Vec3} axis1 A vector in which to return the first (longest) principal axis.
         * @param {Vec3} axis2 A vector in which to return the second (mid-length) principal axis.
         * @param {Vec3} axis3 A vector in which to return the third (shortest) principal axis.
         * @throws {ArgumentError} If the specified points array is null, undefined or empty, or one of the
         * specified axes arguments is null or undefined.
         */
        Matrix.principalAxesFromPoints = function (points, axis1, axis2, axis3) {
            if (!points || points.length < 1) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "Matrix", "principalAxesFromPoints",
                    "missingPoints"));
            }

            if (!axis1 || !axis2 || !axis3) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "Matrix", "principalAxesFromPoints",
                    "An axis argument is null or undefined."));
            }

            // Compute the covariance matrix.
            var covariance = Matrix.fromIdentity();
            covariance.setToCovarianceOfPoints(points);

            // Compute the eigenvectors from the covariance matrix. Since the covariance matrix is symmetric by
            // definition, we can safely use the "symmetric" method below.
            covariance.eigensystemFromSymmetricMatrix(axis1, axis2, axis3);

            // Normalize the eigenvectors, which are already sorted in order from most prominent to least prominent.
            axis1.normalize();
            axis2.normalize();
            axis3.normalize();
        };

        /**
         * Sets the components of this matrix to specified values.
         * @param {Number} m11 matrix element at row 1, column 1.
         * @param {Number} m12 matrix element at row 1, column 2.
         * @param {Number} m13 matrix element at row 1, column 3.
         * @param {Number} m14 matrix element at row 1, column 4.
         * @param {Number} m21 matrix element at row 2, column 1.
         * @param {Number} m22 matrix element at row 2, column 2.
         * @param {Number} m23 matrix element at row 2, column 3.
         * @param {Number} m24 matrix element at row 2, column 4.
         * @param {Number} m31 matrix element at row 3, column 1.
         * @param {Number} m32 matrix element at row 3, column 2.
         * @param {Number} m33 matrix element at row 3, column 3.
         * @param {Number} m34 matrix element at row 3, column 4.
         * @param {Number} m41 matrix element at row 4, column 1.
         * @param {Number} m42 matrix element at row 4, column 2.
         * @param {Number} m43 matrix element at row 4, column 3.
         * @param {Number} m44 matrix element at row 4, column 4.
         * @returns {Matrix} This matrix with its components set to the specified values.
         */
        Matrix.prototype.set = function (m11, m12, m13, m14,
                                         m21, m22, m23, m24,
                                         m31, m32, m33, m34,
                                         m41, m42, m43, m44) {
            this[0] = m11;
            this[1] = m12;
            this[2] = m13;
            this[3] = m14;
            this[4] = m21;
            this[5] = m22;
            this[6] = m23;
            this[7] = m24;
            this[8] = m31;
            this[9] = m32;
            this[10] = m33;
            this[11] = m34;
            this[12] = m41;
            this[13] = m42;
            this[14] = m43;
            this[15] = m44;

            return this;
        };

        /**
         * Sets this matrix to the identity matrix.
         * @returns {Matrix} This matrix set to the identity matrix.
         */
        Matrix.prototype.setToIdentity = function () {
            this[0] = 1;
            this[1] = 0;
            this[2] = 0;
            this[3] = 0;
            this[4] = 0;
            this[5] = 1;
            this[6] = 0;
            this[7] = 0;
            this[8] = 0;
            this[9] = 0;
            this[10] = 1;
            this[11] = 0;
            this[12] = 0;
            this[13] = 0;
            this[14] = 0;
            this[15] = 1;
        };

        /**
         * Copies the components of a specified matrix to this matrix.
         * @param {Matrix} matrix The matrix to copy.
         * @returns {Matrix} This matrix set to the values of the specified matrix.
         * @throws {ArgumentError} If the specified matrix is null or undefined.
         */
        Matrix.prototype.copy = function (matrix) {
            if (!matrix) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Matrix", "copy", "missingMatrix"));
            }

            this[0] = matrix[0];
            this[1] = matrix[1];
            this[2] = matrix[2];
            this[3] = matrix[3];
            this[4] = matrix[4];
            this[5] = matrix[5];
            this[6] = matrix[6];
            this[7] = matrix[7];
            this[8] = matrix[8];
            this[9] = matrix[9];
            this[10] = matrix[10];
            this[11] = matrix[11];
            this[12] = matrix[12];
            this[13] = matrix[13];
            this[14] = matrix[14];
            this[15] = matrix[15];
        };

        /**
         * Indicates whether the components of this matrix are equal to those of a specified matrix.
         * @param {Matrix} matrix The matrix to test equality with. May be null or undefined, in which case this
         * function returns false.
         * @returns {boolean} true if all components of this matrix are equal to the corresponding
         * components of the specified matrix, otherwise false.
         */
        Matrix.prototype.equals = function (matrix) {
            return matrix
                && this[0] == matrix[0]
                && this[1] == matrix[1]
                && this[2] == matrix[2]
                && this[3] == matrix[3]
                && this[4] == matrix[4]
                && this[5] == matrix[5]
                && this[6] == matrix[6]
                && this[7] == matrix[7]
                && this[8] == matrix[8]
                && this[9] == matrix[9]
                && this[10] == matrix[10]
                && this[11] == matrix[11]
                && this[12] == matrix[12]
                && this[13] == matrix[13]
                && this[14] == matrix[14]
                && this[15] == matrix[15];
        };

        /**
         * Stores this matrix's components in column-major order in a specified array.
         * <p>
         * The array must have space for at least 16 elements. This matrix's components are stored in the array
         * starting with row 0 column 0 in index 0, row 1 column 0 in index 1, row 2 column 0 in index 2, and so on.
         *
         * @param {Float32Array | Float64Array | Number[]} result An array of at least 16 elements. Upon return,
         * contains this matrix's components in column-major.
         * @returns {Float32Array} The specified result array.
         * @throws {ArgumentError} If the specified result array in null or undefined.
         */
        Matrix.prototype.columnMajorComponents = function (result) {
            if (!result) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Matrix", "columnMajorComponents", "missingResult"));
            }

            // Column 1
            result[0] = this[0];
            result[1] = this[4];
            result[2] = this[8];
            result[3] = this[12];
            // Column 2
            result[4] = this[1];
            result[5] = this[5];
            result[6] = this[9];
            result[7] = this[13];
            // Column 3
            result[8] = this[2];
            result[9] = this[6];
            result[10] = this[10];
            result[11] = this[14];
            // Column 4
            result[12] = this[3];
            result[13] = this[7];
            result[14] = this[11];
            result[15] = this[15];

            return result;
        };

        /**
         * Sets this matrix to a translation matrix with specified translation components.
         * @param {Number} x The X translation component.
         * @param {Number} y The Y translation component.
         * @param {Number} z The Z translation component.
         * @returns {Matrix} This matrix with its translation components set to those specified and all other
         * components set to that of an identity matrix.
         */
        Matrix.prototype.setToTranslation = function (x, y, z) {
            this[0] = 1;
            this[1] = 0;
            this[2] = 0;
            this[3] = x;
            this[4] = 0;
            this[5] = 1;
            this[6] = 0;
            this[7] = y;
            this[8] = 0;
            this[9] = 0;
            this[10] = 1;
            this[11] = z;
            this[12] = 0;
            this[13] = 0;
            this[14] = 0;
            this[15] = 1;

            return this;
        };

        /**
         * Sets the translation components of this matrix to specified values.
         * @param {Number} x The X translation component.
         * @param {Number} y The Y translation component.
         * @param {Number} z The Z translation component.
         * @returns {Matrix} This matrix with its translation components set to the specified values and all other
         * components unmodified.
         */
        Matrix.prototype.setTranslation = function (x, y, z) {
            this[3] = x;
            this[7] = y;
            this[11] = z;

            return this;
        };

        /**
         * Sets this matrix to a scale matrix with specified scale components.
         * @param {Number} xScale The X scale component.
         * @param {Number} yScale The Y scale component.
         * @param {Number} zScale The Z scale component.
         * @returns {Matrix} This matrix with its scale components set to those specified and all other
         * components set to that of an identity matrix.
         */
        Matrix.prototype.setToScale = function (xScale, yScale, zScale) {
            this[0] = xScale;
            this[1] = 0;
            this[2] = 0;
            this[3] = 0;
            this[4] = 0;
            this[5] = yScale;
            this[6] = 0;
            this[7] = 0;
            this[8] = 0;
            this[9] = 0;
            this[10] = zScale;
            this[11] = 0;
            this[12] = 0;
            this[13] = 0;
            this[14] = 0;
            this[15] = 1;

            return this;
        };

        /**
         * Sets the scale components of this matrix to specified values.
         * @param {Number} xScale The X scale component.
         * @param {Number} yScale The Y scale component.
         * @param {Number} zScale The Z scale component.
         * @returns {Matrix} This matrix with its scale components set to the specified values and all other
         * components unmodified.
         */
        Matrix.prototype.setScale = function (xScale, yScale, zScale) {
            this[0] = xScale;
            this[5] = yScale;
            this[10] = zScale;

            return this;
        };

        /**
         * Sets this matrix to the transpose of a specified matrix.
         * @param {Matrix} matrix The matrix whose transpose is to be copied.
         * @returns {Matrix} This matrix, with its values set to the transpose of the specified matrix.
         * @throws {ArgumentError} If the specified matrix in null or undefined.
         */
        Matrix.prototype.setToTransposeOfMatrix = function (matrix) {
            if (!matrix) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Matrix", "setToTransposeOfMatrix", "missingMatrix"));
            }

            this[0] = matrix[0];
            this[1] = matrix[4];
            this[2] = matrix[8];
            this[3] = matrix[12];
            this[4] = matrix[1];
            this[5] = matrix[5];
            this[6] = matrix[9];
            this[7] = matrix[13];
            this[8] = matrix[2];
            this[9] = matrix[6];
            this[10] = matrix[10];
            this[11] = matrix[14];
            this[12] = matrix[3];
            this[13] = matrix[7];
            this[14] = matrix[11];
            this[15] = matrix[15];

            return this;
        };

        /**
         * Sets this matrix to the matrix product of two specified matrices.
         * @param {Matrix} matrixA The first matrix multiplicand.
         * @param {Matrix} matrixB The second matrix multiplicand.
         * @returns {Matrix} This matrix set to the product of matrixA x matrixB.
         * @throws {ArgumentError} If either specified matrix is null or undefined.
         */
        Matrix.prototype.setToMultiply = function (matrixA, matrixB) {
            if (!matrixA || !matrixB) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Matrix", "setToMultiply", "missingMatrix"));
            }

            var ma = matrixA,
                mb = matrixB;

            this[0] = ma[0] * mb[0] + ma[1] * mb[4] + ma[2] * mb[8] + ma[3] * mb[12];
            this[1] = ma[0] * mb[1] + ma[1] * mb[5] + ma[2] * mb[9] + ma[3] * mb[13];
            this[2] = ma[0] * mb[2] + ma[1] * mb[6] + ma[2] * mb[10] + ma[3] * mb[14];
            this[3] = ma[0] * mb[3] + ma[1] * mb[7] + ma[2] * mb[11] + ma[3] * mb[15];

            this[4] = ma[4] * mb[0] + ma[5] * mb[4] + ma[6] * mb[8] + ma[7] * mb[12];
            this[5] = ma[4] * mb[1] + ma[5] * mb[5] + ma[6] * mb[9] + ma[7] * mb[13];
            this[6] = ma[4] * mb[2] + ma[5] * mb[6] + ma[6] * mb[10] + ma[7] * mb[14];
            this[7] = ma[4] * mb[3] + ma[5] * mb[7] + ma[6] * mb[11] + ma[7] * mb[15];

            this[8] = ma[8] * mb[0] + ma[9] * mb[4] + ma[10] * mb[8] + ma[11] * mb[12];
            this[9] = ma[8] * mb[1] + ma[9] * mb[5] + ma[10] * mb[9] + ma[11] * mb[13];
            this[10] = ma[8] * mb[2] + ma[9] * mb[6] + ma[10] * mb[10] + ma[11] * mb[14];
            this[11] = ma[8] * mb[3] + ma[9] * mb[7] + ma[10] * mb[11] + ma[11] * mb[15];

            this[12] = ma[12] * mb[0] + ma[13] * mb[4] + ma[14] * mb[8] + ma[15] * mb[12];
            this[13] = ma[12] * mb[1] + ma[13] * mb[5] + ma[14] * mb[9] + ma[15] * mb[13];
            this[14] = ma[12] * mb[2] + ma[13] * mb[6] + ma[14] * mb[10] + ma[15] * mb[14];
            this[15] = ma[12] * mb[3] + ma[13] * mb[7] + ma[14] * mb[11] + ma[15] * mb[15];

            return this;
        };

        /**
         * Sets this matrix to the symmetric covariance Matrix computed from the x, y, z coordinates of a specified
         * points array.
         * <p/>
         * The computed covariance matrix represents the correlation between each pair of x-, y-, and z-coordinates as
         * they're distributed about the point array's arithmetic mean. Its layout is as follows:
         * <p/>
         * <code> C(x, x)  C(x, y)  C(x, z) <br/> C(x, y)  C(y, y)  C(y, z) <br/> C(x, z)  C(y, z)  C(z, z) </code>
         * <p/>
         * C(i, j) is the covariance of coordinates i and j, where i or j are a coordinate's dispersion about its mean
         * value. If any entry is zero, then there's no correlation between the two coordinates defining that entry. If the
         * returned matrix is diagonal, then all three coordinates are uncorrelated, and the specified point is
         * distributed evenly about its mean point.
         * @param {Float32Array | Float64Array | Number[]} points The points to consider.
         * @returns {Matrix} This matrix set to the covariance matrix for the specified list of points.
         * @throws {ArgumentError} If the specified array of points is null, undefined or empty.
         */
        Matrix.prototype.setToCovarianceOfPoints = function (points) {
            if (!points || points.length < 1) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Matrix", "setToCovarianceOfPoints", "missingArray"));
            }

            var mean,
                dx,
                dy,
                dz,
                count = 0,
                c11 = 0,
                c22 = 0,
                c33 = 0,
                c12 = 0,
                c13 = 0,
                c23 = 0,
                vec = new Vec3(0, 0, 0);

            mean = Vec3.averageOfBuffer(points, new Vec3(0, 0, 0));

            for (var i = 0, len = points.length / 3; i < len; i++) {
                vec[0] = points[i * 3];
                vec[1] = points[i * 3 + 1];
                vec[2] = points[i * 3 + 2];

                dx = vec[0] - mean[0];
                dy = vec[1] - mean[1];
                dz = vec[2] - mean[2];

                ++count;
                c11 += dx * dx;
                c22 += dy * dy;
                c33 += dz * dz;
                c12 += dx * dy; // c12 = c21
                c13 += dx * dz; // c13 = c31
                c23 += dy * dz; // c23 = c32
            }

            // Row 1
            this[0] = c11 / count;
            this[1] = c12 / count;
            this[2] = c13 / count;
            this[3] = 0;

            // Row 2
            this[4] = c12 / count;
            this[5] = c22 / count;
            this[6] = c23 / count;
            this[7] = 0;

            // Row 3
            this[8] = c13 / count;
            this[9] = c23 / count;
            this[10] = c33 / count;
            this[11] = 0;

            // Row 4
            this[12] = 0;
            this[13] = 0;
            this[14] = 0;
            this[15] = 0;

            return this;
        };

        /**
         * Multiplies this matrix by a translation matrix with specified translation values.
         * @param {Number} x The X translation component.
         * @param {Number} y The Y translation component.
         * @param {Number} z The Z translation component.
         * @returns {Matrix} This matrix multiplied by the translation matrix implied by the specified values.
         */
        Matrix.prototype.multiplyByTranslation = function (x, y, z) {

            this.multiply(
                1, 0, 0, x,
                0, 1, 0, y,
                0, 0, 1, z,
                0, 0, 0, 1);

            return this;
        };

        /**
         * Multiplies this matrix by a rotation matrix about a specified axis and angle.
         * @param {Number} x The X component of the rotation axis.
         * @param {Number} y The Y component of the rotation axis.
         * @param {Number} z The Z component of the rotation axis.
         * @param {Number} angleDegrees The angle to rotate, in degrees.
         * @returns {Matrix} This matrix multiplied by the rotation matrix implied by the specified values.
         */
        Matrix.prototype.multiplyByRotation = function (x, y, z, angleDegrees) {

            var c = Math.cos(angleDegrees * Angle.DEGREES_TO_RADIANS),
                s = Math.sin(angleDegrees * Angle.DEGREES_TO_RADIANS);

            this.multiply(
                c + (1 - c) * x * x, (1 - c) * x * y - s * z, (1 - c) * x * z + s * y, 0,
                (1 - c) * x * y + s * z, c + (1 - c) * y * y, (1 - c) * y * z - s * x, 0,
                (1 - c) * x * z - s * y, (1 - c) * y * z + s * x, c + (1 - c) * z * z, 0,
                0, 0, 0, 1);

            return this;
        };

        /**
         * Multiplies this matrix by a scale matrix with specified values.
         * @param {Number} xScale The X scale component.
         * @param {Number} yScale The Y scale component.
         * @param {Number} zScale The Z scale component.
         * @returns {Matrix} This matrix multiplied by the scale matrix implied by the specified values.
         */
        Matrix.prototype.multiplyByScale = function (xScale, yScale, zScale) {

            this.multiply(
                xScale, 0, 0, 0,
                0, yScale, 0, 0,
                0, 0, zScale, 0,
                0, 0, 0, 1);

            return this;
        };

        /**
         * Sets this matrix to one that flips and shifts the y-axis.
         * <p>
         * The resultant matrix maps Y=0 to Y=1 and Y=1 to Y=0. All existing values are overwritten. This matrix is
         * usually used to change the coordinate origin from an upper left coordinate origin to a lower left coordinate
         * origin. This is typically necessary to align the coordinate system of images (top-left origin) with that of
         * OpenGL (bottom-left origin).
         * @returns {Matrix} This matrix set to values described above.
         */
        Matrix.prototype.setToUnitYFlip = function () {

            this[0] = 1;
            this[1] = 0;
            this[2] = 0;
            this[3] = 0;
            this[4] = 0;
            this[5] = -1;
            this[6] = 0;
            this[7] = 1;
            this[8] = 0;
            this[9] = 0;
            this[10] = 1;
            this[11] = 0;
            this[12] = 0;
            this[13] = 0;
            this[14] = 0;
            this[15] = 1;

            return this;
        };

        /**
         * Multiplies this matrix by a local coordinate system transform for the specified globe.
         * <p>
         * The local coordinate system is defined such that the local origin (0, 0, 0) maps to the specified origin
         * point, the z axis maps to the globe's surface normal at the point, the y-axis maps to the north pointing
         * tangent, and the x-axis maps to the east pointing tangent.
         *
         * @param {Vec3} origin The local coordinate system origin, in model coordinates.
         * @param {Globe} globe The globe the coordinate system is relative to.
         *
         * @throws {ArgumentError} If either argument is null or undefined.
         */
        Matrix.prototype.multiplyByLocalCoordinateTransform = function (origin, globe) {
            if (!origin) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Matrix", "multiplyByLocalCoordinateTransform",
                        "Origin vector is null or undefined"));
            }

            if (!globe) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Matrix", "multiplyByLocalCoordinateTransform",
                        "missingGlobe"));
            }

            var xAxis = new Vec3(0, 0, 0),
                yAxis = new Vec3(0, 0, 0),
                zAxis = new Vec3(0, 0, 0);

            WWMath.localCoordinateAxesAtPoint(origin, globe, xAxis, yAxis, zAxis);

            this.multiply(
                xAxis[0], yAxis[0], zAxis[0], origin[0],
                xAxis[1], yAxis[1], zAxis[1], origin[1],
                xAxis[2], yAxis[2], zAxis[2], origin[2],
                0, 0, 0, 1);

            return this;
        };

        /**
         * Multiplies this matrix by a texture transform for the specified texture.
         * <p>
         * A texture image transform maps the bottom-left corner of the texture's image data to coordinate [0,0] and maps the
         * top-right of the texture's image data to coordinate [1,1]. This correctly handles textures whose image data has
         * non-power-of-two dimensions, and correctly orients textures whose image data has its origin in the upper-left corner.
         *
         * @param {Texture} texture The texture to multiply a transform for.
         *
         * @throws {ArgumentError} If the texture is null or undefined.
         */
        Matrix.prototype.multiplyByTextureTransform = function (texture) {
            if (!texture) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Matrix", "multiplyByTextureTransform",
                        "missingTexture"));
            }

            // Compute the scale necessary to map the edge of the image data to the range [0,1]. When the texture contains
            // power-of-two image data the scale is 1 and has no effect. Otherwise, the scale is computed such that the portion
            // of the texture containing image data maps to the range [0,1].
            var sx = texture.originalImageWidth / texture.imageWidth,
                sy = texture.originalImageHeight / texture.imageHeight;

            // Multiply this by a scaling matrix that maps the texture's image data to the range [0,1] and inverts the y axis.
            // We have precomputed the result here in order to avoid an unnecessary matrix multiplication.
            this.multiply(
                sx, 0, 0, 0,
                0, -sy, 0, sy,
                0, 0, 1, 0,
                0, 0, 0, 1);

            return this;
        };

        /**
         * Returns the translation components of this matrix.
         * @param {Vec3} result A pre-allocated {@link Vec3} in which to return the translation components.
         * @returns {Vec3} The specified result argument set to the translation components of this matrix.
         * @throws {ArgumentError} If the specified result argument is null or undefined.
         */
        Matrix.prototype.extractTranslation = function (result) {
            if (!result) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Matrix", "extractTranslation", "missingResult"));
            }

            result[0] = this[3];
            result[1] = this[7];
            result[2] = this[11];

            return result;
        };

        /**
         * Returns the rotation angles of this matrix.
         * @param {Vec3} result A pre-allocated {@link Vec3} in which to return the rotation angles.
         * @returns {Vec3} The specified result argument set to the rotation angles of this matrix. The angles are in
         * degrees.
         * @throws {ArgumentError} If the specified result argument is null or undefined.
         */
        Matrix.prototype.extractRotationAngles = function (result) {
            if (!result) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Matrix", "extractRotationAngles", "missingResult"));
            }

            // Taken from Extracting Euler Angles from a Rotation Matrix by Mike Day, Insomniac Games.
            // http://www.insomniacgames.com/mike-day-extracting-euler-angles-from-a-rotation-matrix/

            var x = Math.atan2(this[6], this[10]),
                y = Math.atan2(-this[2], Math.sqrt(this[0] * this[0] + this[1] * this[1])),
                cx = Math.cos(x),
                sx = Math.sin(x),
                z = Math.atan2(sx * this[8] - cx * this[4], cx * this[5] - sx * this[9]);

            result[0] = x * Angle.RADIANS_TO_DEGREES;
            result[1] = y * Angle.RADIANS_TO_DEGREES;
            result[2] = z * Angle.RADIANS_TO_DEGREES;

            return result;
        };

        /**
         * Multiplies this matrix by a first person viewing matrix for the specified globe.
         * <p>
         * A first person viewing matrix places the viewer's eye at the specified eyePosition. By default the viewer is looking
         * straight down at the globe's surface from the eye position, with the globe's normal vector coming out of the screen
         * and north pointing toward the top of the screen.
         * <p>
         * Heading specifies the viewer's azimuth, or its angle relative to North. Heading values range from -180 degrees to 180
         * degrees. A heading of 0 degrees looks North, 90 degrees looks East, +-180 degrees looks South, and -90 degrees looks
         * West.
         * <p>
         * Tilt specifies the viewer's angle relative to the surface. Tilt values range from -180 degrees to 180 degrees. A tilt
         * of 0 degrees looks straight down at the globe's surface, 90 degrees looks at the horizon, and 180 degrees looks
         * straight up. Tilt values greater than 180 degrees cause the viewer to turn upside down, and are therefore rarely used.
         * <p>
         * Roll specifies the viewer's angle relative to the horizon. Roll values range from -180 degrees to 180 degrees. A roll
         * of 0 degrees orients the viewer so that up is pointing to the top of the screen, at 90 degrees up is pointing to the
         * right, at +-180 degrees up is pointing to the bottom, and at -90 up is pointing to the left.
         *
         * @param {Position} eyePosition The viewer's geographic eye position relative to the specified globe.
         * @param {Number} heading The viewer's angle relative to north, in degrees.
         * @param {Number} tilt The viewer's angle relative to the surface, in degrees.
         * @param {Number} roll The viewer's angle relative to the horizon, in degrees.
         * @param {Globe} globe The globe the viewer is looking at.
         *
         * @throws {ArgumentError} If the specified position or globe is null or undefined.
         */
        Matrix.prototype.multiplyByFirstPersonModelview = function (eyePosition, heading, tilt, roll, globe) {
            if (!eyePosition) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Matrix", "multiplyByFirstPersonModelview", "missingPosition"));
            }

            if (!globe) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Matrix", "multiplyByFirstPersonModelview", "missingGlobe"));
            }

            var c,
                s,
                ex, ey, ez,
                xx, xy, xz,
                yx, yy, yz,
                zx, zy, zz,
                eyePoint = new Vec3(0, 0, 0),
                xAxis = new Vec3(0, 0, 0),
                yAxis = new Vec3(0, 0, 0),
                zAxis = new Vec3(0, 0, 0);

            // Roll. Rotate the eye point in a counter-clockwise direction about the z axis. Note that we invert the sines used
            // in the rotation matrix in order to produce the counter-clockwise rotation. We invert only the cosines since
            // sin(-a) = -sin(a) and cos(-a) = cos(a).
            c = Math.cos(roll * Angle.DEGREES_TO_RADIANS);
            s = Math.sin(roll * Angle.DEGREES_TO_RADIANS);
            this.multiply(
                c, s, 0, 0,
                -s, c, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1);

            // Tilt. Rotate the eye point in a counter-clockwise direction about the x axis. Note that we invert the sines used
            // in the rotation matrix in order to produce the counter-clockwise rotation. We invert only the cosines since
            // sin(-a) = -sin(a) and cos(-a) = cos(a).
            c = Math.cos(tilt * Angle.DEGREES_TO_RADIANS);
            s = Math.sin(tilt * Angle.DEGREES_TO_RADIANS);
            this.multiply(1, 0, 0, 0,
                0, c, s, 0,
                0, -s, c, 0,
                0, 0, 0, 1);

            // Heading. Rotate the eye point in a clockwise direction about the z axis again. This has a different effect than
            // roll when tilt is non-zero because the viewer is no longer looking down the z axis.
            c = Math.cos(heading * Angle.DEGREES_TO_RADIANS);
            s = Math.sin(heading * Angle.DEGREES_TO_RADIANS);
            this.multiply(c, -s, 0, 0,
                s, c, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1);

            // Compute the eye point in model coordinates. This point is mapped to the origin in the look at transform below.
            globe.computePointFromPosition(eyePosition.latitude, eyePosition.longitude, eyePosition.altitude, eyePoint);
            ex = eyePoint[0];
            ey = eyePoint[1];
            ez = eyePoint[2];

            // Transform the origin to the local coordinate system at the eye point.
            WWMath.localCoordinateAxesAtPoint(eyePoint, globe, xAxis, yAxis, zAxis);
            xx = xAxis[0];
            xy = xAxis[1];
            xz = xAxis[2];
            yx = yAxis[0];
            yy = yAxis[1];
            yz = yAxis[2];
            zx = zAxis[0];
            zy = zAxis[1];
            zz = zAxis[2];

            this.multiply(xx, xy, xz, -xx * ex - xy * ey - xz * ez,
                yx, yy, yz, -yx * ex - yy * ey - yz * ez,
                zx, zy, zz, -zx * ex - zy * ey - zz * ez,
                0, 0, 0, 1);

            return this;
        };

        /**
         * Multiplies this matrix by a look at viewing matrix for the specified globe.
         * <p>
         * A look at viewing matrix places the center of the screen at the specified lookAtPosition. By default the viewer is
         * looking straight down at the look at position from the specified range, with the globe's normal vector coming out of
         * the screen and north pointing toward the top of the screen.
         * <p>
         * Range specifies the distance between the look at position and the viewer's eye point. Range values may be any positive
         * real number. A range of 0 places the eye point at the look at point, while a positive range moves the eye point away
         * from but still looking at the look at point.
         * <p>
         * Heading specifies the viewer's azimuth, or its angle relative to North. Heading values range from -180 degrees to 180
         * degrees. A heading of 0 degrees looks North, 90 degrees looks East, +-180 degrees looks South, and -90 degrees looks
         * West.
         * <p>
         * Tilt specifies the viewer's angle relative to the surface. Tilt values range from -180 degrees to 180 degrees. A tilt
         * of 0 degrees looks straight down at the globe's surface, 90 degrees looks at the horizon, and 180 degrees looks
         * straight up. Tilt values greater than 180 degrees cause the viewer to turn upside down, and are therefore rarely used.
         * <p>
         * Roll specifies the viewer's angle relative to the horizon. Roll values range from -180 degrees to 180 degrees. A roll
         * of 0 degrees orients the viewer so that up is pointing to the top of the screen, at 90 degrees up is pointing to the
         * right, at +-180 degrees up is pointing to the bottom, and at -90 up is pointing to the left.
         *
         * @param {Position} lookAtPosition The viewer's geographic look at position relative to the specified globe.
         * @param {Number} range The distance between the eye point and the look at point, in model coordinates.
         * @param {Number} heading The viewer's angle relative to north, in degrees.
         * @param {Number} tilt The viewer's angle relative to the surface, in degrees.
         * @param {Number} roll The viewer's angle relative to the horizon, in degrees.
         * @param {Globe} globe The globe the viewer is looking at.
         *
         * @throws {ArgumentError} If either the specified look-at position or globe is null or undefined, or the
         * specified range is less than zero.
         */
        Matrix.prototype.multiplyByLookAtModelview = function (lookAtPosition, range, heading, tilt, roll, globe) {
            if (!lookAtPosition) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Matrix", "multiplyByLookAtModelview", "missingPosition"));
            }

            if (range < 0) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Matrix", "multiplyByLookAtModelview",
                        "Range is less than zero"));
            }

            if (!globe) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Matrix", "multiplyByLookAtModelview", "missingGlobe"));
            }

            // Translate the eye point along the positive z axis while keeping the look at point in the center of the viewport.
            this.multiplyByTranslation(0, 0, -range);

            // Transform the origin to the local coordinate system at the look at position, and rotate the viewer by the
            // specified heading, tilt and roll.
            this.multiplyByFirstPersonModelview(lookAtPosition, heading, tilt, roll, globe);

            return this;
        };

        /**
         * Sets this matrix to a perspective projection matrix for the specified viewport dimensions and clip distances.
         * <p>
         * A perspective projection matrix maps points in eye coordinates into clip coordinates in a way that causes
         * distant objects to appear smaller, and preserves the appropriate depth information for each point. In model
         * coordinates, a perspective projection is defined by frustum originating at the eye position and extending
         * outward in the viewer's direction. The near distance and the far distance identify the minimum and maximum
         * distance, respectively, at which an object in the scene is visible. Near and far distances must be positive
         * and may not be equal.
         *
         * @param {Number} viewportWidth The viewport width, in screen coordinates.
         * @param {Number} viewportHeight The viewport height, in screen coordinates.
         * @param {Number} nearDistance The near clip plane distance, in model coordinates.
         * @param {Number} farDistance The far clip plane distance, in model coordinates.
         * @throws {ArgumentError} If the specified width or height is less than or equal to zero, if the near and far
         * distances are equal, or if either the near or far distance are less than or equal to zero.
         */
        Matrix.prototype.setToPerspectiveProjection = function (viewportWidth, viewportHeight, nearDistance, farDistance) {
            if (viewportWidth <= 0) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "Matrix", "setToPerspectiveProjection",
                    "invalidWidth"));
            }

            if (viewportHeight <= 0) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "Matrix", "setToPerspectiveProjection",
                    "invalidHeight"));
            }

            if (nearDistance === farDistance) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "Matrix", "setToPerspectiveProjection",
                        "Near and far distance are the same."));
            }

            if (nearDistance <= 0 || farDistance <= 0) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "Matrix", "setToPerspectiveProjection",
                        "Near or far distance is less than or equal to zero."));
            }

            // Compute the dimensions of the viewport rectangle at the near distance.
            var nearRect = WWMath.perspectiveFrustumRectangle(viewportWidth, viewportHeight, nearDistance),
                left = nearRect.getMinX(),
                right = nearRect.getMaxX(),
                bottom = nearRect.getMinY(),
                top = nearRect.getMaxY();

            // Taken from Mathematics for 3D Game Programming and Computer Graphics, Second Edition, equation 4.52.

            // Row 1
            this[0] = 2 * nearDistance / (right - left);
            this[1] = 0;
            this[2] = (right + left) / (right - left);
            this[3] = 0;
            // Row 2
            this[4] = 0;
            this[5] = 2 * nearDistance / (top - bottom);
            this[6] = (top + bottom) / (top - bottom);
            this[7] = 0;
            // Row 3
            this[8] = 0;
            this[9] = 0;
            this[10] = -(farDistance + nearDistance) / (farDistance - nearDistance);
            this[11] = -2 * nearDistance * farDistance / (farDistance - nearDistance);
            // Row 4
            this[12] = 0;
            this[13] = 0;
            this[14] = -1;
            this[15] = 0;

            return this;
        };

        /**
         * Sets this matrix to a screen projection matrix for the specified viewport dimensions.
         * <p>
         * A screen projection matrix is an orthographic projection that assumes that points in model coordinates
         * represent a screen point and a depth. Screen projection matrices therefore map model coordinates directly
         * into screen coordinates without modification. A point's xy coordinates are interpreted as literal screen
         * coordinates and must be in the viewport to be visible. A point's z coordinate is interpreted as a depth value
         * that ranges from 0 to 1. Additionally, the screen projection matrix preserves the depth value returned by
         * [NavigatorState.project]{@link NavigatorState#project}.
         *
         * @param {Number} viewportWidth The viewport width, in screen coordinates.
         * @param {Number} viewportHeight The viewport height, in screen coordinates.
         * @throws {ArgumentError} If the specified width or height is less than or equal to zero.
         */
        Matrix.prototype.setToScreenProjection = function (viewportWidth, viewportHeight) {
            if (viewportWidth <= 0) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "Matrix", "setToScreenProjection",
                    "invalidWidth"));
            }

            if (viewportHeight <= 0) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "Matrix", "setToScreenProjection",
                    "invalidHeight"));
            }

            // Taken from Mathematics for 3D Game Programming and Computer Graphics, Second Edition, equation 4.57.
            // Simplified to assume that the viewport origin is (0, 0).
            //
            // The third row of this projection matrix is configured so that points with z coordinates representing
            // depth values ranging from 0 to 1 are not modified after transformation into window coordinates. This
            // projection matrix maps z values in the range [0, 1] to the range [-1, 1] by applying the following
            // function to incoming z coordinates:
            //
            // zp = z0 * 2 - 1
            //
            // Where 'z0' is the point's z coordinate and 'zp' is the projected z coordinate. The GPU then maps the
            // projected z coordinate into window coordinates in the range [0, 1] by applying the following function:
            //
            // zw = zp * 0.5 + 0.5
            //
            // The result is that a point's z coordinate is effectively passed to the GPU without modification.

            // Row 1
            this[0] = 2 / viewportWidth;
            this[1] = 0;
            this[2] = 0;
            this[3] = -1;
            // Row 2
            this[4] = 0;
            this[5] = 2 / viewportHeight;
            this[6] = 0;
            this[7] = -1;
            // Row 3
            this[8] = 0;
            this[9] = 0;
            this[10] = 2;
            this[11] = -1;
            // Row 4
            this[12] = 0;
            this[13] = 0;
            this[14] = 0;
            this[15] = 1;

            return this;
        };

        /**
         * Returns this viewing matrix's eye point.
         * <p>
         * This method assumes that this matrix represents a viewing matrix. If this does not represent a viewing matrix the
         * results are undefined.
         * <p>
         * In model coordinates, a viewing matrix's eye point is the point the viewer is looking from and maps to the center of
         * the screen.
         *
         * @param {Vec3} result A pre-allocated {@link Vec3} in which to return the extracted values.
         * @return {Vec3} The specified result argument containing the viewing matrix's eye point, in model coordinates.
         * @throws {ArgumentError} If the specified result argument is null or undefined.
         */
        Matrix.prototype.extractEyePoint = function (result) {
            if (!result) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Matrix", "extractEyePoint", "missingResult"));
            }

            // The eye point of a modelview matrix is computed by transforming the origin (0, 0, 0, 1) by the matrix's inverse.
            // This is equivalent to transforming the inverse of this matrix's translation components in the rightmost column by
            // the transpose of its upper 3x3 components.
            result[0] = -(this[0] * this[3]) - (this[4] * this[7]) - (this[8] * this[11]);
            result[1] = -(this[1] * this[3]) - (this[5] * this[7]) - (this[9] * this[11]);
            result[2] = -(this[2] * this[3]) - (this[6] * this[7]) - (this[10] * this[11]);

            return result;
        };

        /**
         * Returns this viewing matrix's forward vector.
         * <p>
         * This method assumes that this matrix represents a viewing matrix. If this does not represent a viewing matrix the
         * results are undefined.
         *
         * @param {Vec3} result A pre-allocated {@link Vec3} in which to return the extracted values.
         * @return {Vec3} The specified result argument containing the viewing matrix's forward vector, in model coordinates.
         * @throws {ArgumentError} If the specified result argument is null or undefined.
         */
        Matrix.prototype.extractForwardVector = function (result) {
            if (!result) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Matrix", "extractForwardVector", "missingResult"));
            }

            // The forward vector of a modelview matrix is computed by transforming the negative Z axis (0, 0, -1, 0) by the
            // matrix's inverse. We have pre-computed the result inline here to simplify this computation.
            result[0] = -this[8];
            result[1] = -this[9];
            result[2] = -this[10];

            return result;
        };

        /**
         * Extracts this viewing matrix's parameters given a viewing origin and a globe.
         * <p>
         * This method assumes that this matrix represents a viewing matrix. If this does not represent a viewing matrix the
         * results are undefined.
         * <p>
         * This returns a parameterization of this viewing matrix based on the specified origin and globe. The origin indicates
         * the model coordinate point that the view's orientation is relative to, while the globe provides the necessary model
         * coordinate context for the origin and the orientation. The origin should be either the view's eye point or a point on
         * the view's forward vector. The view's roll must be specified in order to disambiguate heading and roll when the view's
         * tilt is zero.
         * <p>
         * The following list outlines the returned key-value pairs and their meanings:
         * <ul>
         * <li> 'origin' - The geographic position corresponding to the origin point.</li>
         * <li> 'range' - The distance between the specified origin point and the view's eye point, in model coordinates.</li>
         * <li> 'heading' - The view's heading angle relative to the globe's north pointing tangent at the origin point, in degrees.</li>
         * <li> 'tilt' - The view's tilt angle relative to the globe's normal vector at the origin point, in degrees.</li>
         * <li> 'roll' - The view's roll relative to the globe's normal vector at the origin point, in degrees.</li>
         * </ul>
         * @param {Vec3} origin The origin of the viewing parameters, in model coordinates.
         * @param {Number} roll The view's roll, in degrees.
         * @param {Globe} globe The globe the viewer is looking at.
         * @param {Object} result A pre-allocated object in which to return the viewing parameters.
         *
         * @return {Object} The specified result argument containing a parameterization of this viewing matrix.
         *
         * @throws {ArgumentError} If either the specified origin or globe are null or undefined or the specified
         * result argument is null or undefined.
         */
        Matrix.prototype.extractViewingParameters = function (origin, roll, globe, result) {
            if (!origin) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Matrix", "extractViewingParameters",
                        "The specified origin is null or undefined."));
            }

            if (!globe) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Matrix", "extractViewingParameters", "missingGlobe"));
            }

            if (!result) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Matrix", "extractViewingParameters", "missingResult"));
            }

            var originPos = new Position(0, 0, 0),
                modelviewLocal = Matrix.fromIdentity(),
                range,
                ct,
                st,
                tilt,
                cr, sr,
                ch, sh,
                heading;

            globe.computePositionFromPoint(origin[0], origin[1], origin[2], originPos);

            // Transform the modelview matrix to a local coordinate system at the origin. This eliminates the geographic
            // transform contained in the modelview matrix while maintaining rotation and translation relative to the origin.
            modelviewLocal.copy(this);
            modelviewLocal.multiplyByLocalCoordinateTransform(origin, globe);

            range = -modelviewLocal[11];
            ct = modelviewLocal[10];
            st = Math.sqrt(modelviewLocal[2] * modelviewLocal[2] + modelviewLocal[6] * modelviewLocal[6]);
            tilt = Math.atan2(st, ct) * Angle.RADIANS_TO_DEGREES;

            cr = Math.cos(roll * Angle.DEGREES_TO_RADIANS);
            sr = Math.sin(roll * Angle.DEGREES_TO_RADIANS);
            ch = cr * modelviewLocal[0] - sr * modelviewLocal[4];
            sh = sr * modelviewLocal[5] - cr * modelviewLocal[1];
            heading = Math.atan2(sh, ch) * Angle.RADIANS_TO_DEGREES;

            result['origin'] = originPos;
            result['range'] = range;
            result['heading'] = heading;
            result['tilt'] = tilt;
            result['roll'] = roll;

            return result;
        };

        /**
         * Applies a specified depth offset to this projection matrix.
         * <p>
         * This method assumes that this matrix represents a projection matrix. If this does not represent a projection
         * matrix the results are undefined. Projection matrices can be created by calling
         * [setToPerspectiveProjection]{@link Matrix#setToPerspectiveProjection} or [setToScreenProjection]{@link Matrix#setToScreenProjection}.
         * <p>
         * The depth offset may be any real number and is typically used to draw geometry slightly closer to the user's
         * eye in order to give those shapes visual priority over nearby or geometry. An offset of zero has no effect.
         * An offset less than zero brings depth values closer to the eye, while an offset greater than zero pushes
         * depth values away from the eye.
         * <p>
         * Depth offset may be applied to both perspective and orthographic projection matrices. The effect on each
         * projection type is outlined here:
         * <p>
         * <strong>Perspective Projection</strong>
         * <p>
         * The effect of depth offset on a perspective projection increases exponentially with distance from the eye.
         * This has the effect of adjusting the offset for the loss in depth precision with geometry drawn further from
         * the eye. Distant geometry requires a greater offset to differentiate itself from nearby geometry, while close
         * geometry does not.
         * <p>
         * <strong>Orthographic Projection</strong>
         * <p>
         * The effect of depth offset on an orthographic projection increases linearly with distance from the eye. While
         * it is reasonable to apply a depth offset to an orthographic projection, the effect is most appropriate when
         * applied to the projection used to draw the scene. For example, when an object's coordinates are projected by
         * a perspective projection into screen coordinates then drawn using an orthographic projection, it is best to
         * apply the offset to the original perspective projection. The method [NavigatorState.project]{@link NavigatorState#project} performs the
         * correct behavior for the projection type used to draw the scene.
         *
         * @param {Number} depthOffset The amount of offset to apply.
         * @returns {Matrix} This matrix with it's depth offset set to the specified offset.
         */
        Matrix.prototype.offsetProjectionDepth = function (depthOffset) {

            this[10] *= 1 + depthOffset;

            return this;
        };

        /**
         * Multiplies this matrix by a specified matrix.
         *
         * @param {Matrix} matrix The matrix to multiply with this matrix.
         * @returns {Matrix} This matrix after multiplying it by the specified matrix.
         * @throws {ArgumentError} if the specified matrix is null or undefined.
         */
        Matrix.prototype.multiplyMatrix = function (matrix) {
            if (!matrix) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Matrix", "multiplyMatrix", "missingMatrix"));
            }

            var ma = this,
                mb = matrix,
                ma0, ma1, ma2, ma3;

            // Row 1
            ma0 = ma[0];
            ma1 = ma[1];
            ma2 = ma[2];
            ma3 = ma[3];
            ma[0] = (ma0 * mb[0]) + (ma1 * mb[4]) + (ma2 * mb[8]) + (ma3 * mb[12]);
            ma[1] = (ma0 * mb[1]) + (ma1 * mb[5]) + (ma2 * mb[9]) + (ma3 * mb[13]);
            ma[2] = (ma0 * mb[2]) + (ma1 * mb[6]) + (ma2 * mb[10]) + (ma3 * mb[14]);
            ma[3] = (ma0 * mb[3]) + (ma1 * mb[7]) + (ma2 * mb[11]) + (ma3 * mb[15]);

            // Row 2
            ma0 = ma[4];
            ma1 = ma[5];
            ma2 = ma[6];
            ma3 = ma[7];
            ma[4] = (ma0 * mb[0]) + (ma1 * mb[4]) + (ma2 * mb[8]) + (ma3 * mb[12]);
            ma[5] = (ma0 * mb[1]) + (ma1 * mb[5]) + (ma2 * mb[9]) + (ma3 * mb[13]);
            ma[6] = (ma0 * mb[2]) + (ma1 * mb[6]) + (ma2 * mb[10]) + (ma3 * mb[14]);
            ma[7] = (ma0 * mb[3]) + (ma1 * mb[7]) + (ma2 * mb[11]) + (ma3 * mb[15]);

            // Row 3
            ma0 = ma[8];
            ma1 = ma[9];
            ma2 = ma[10];
            ma3 = ma[11];
            ma[8] = (ma0 * mb[0]) + (ma1 * mb[4]) + (ma2 * mb[8]) + (ma3 * mb[12]);
            ma[9] = (ma0 * mb[1]) + (ma1 * mb[5]) + (ma2 * mb[9]) + (ma3 * mb[13]);
            ma[10] = (ma0 * mb[2]) + (ma1 * mb[6]) + (ma2 * mb[10]) + (ma3 * mb[14]);
            ma[11] = (ma0 * mb[3]) + (ma1 * mb[7]) + (ma2 * mb[11]) + (ma3 * mb[15]);

            // Row 4
            ma0 = ma[12];
            ma1 = ma[13];
            ma2 = ma[14];
            ma3 = ma[15];
            ma[12] = (ma0 * mb[0]) + (ma1 * mb[4]) + (ma2 * mb[8]) + (ma3 * mb[12]);
            ma[13] = (ma0 * mb[1]) + (ma1 * mb[5]) + (ma2 * mb[9]) + (ma3 * mb[13]);
            ma[14] = (ma0 * mb[2]) + (ma1 * mb[6]) + (ma2 * mb[10]) + (ma3 * mb[14]);
            ma[15] = (ma0 * mb[3]) + (ma1 * mb[7]) + (ma2 * mb[11]) + (ma3 * mb[15]);

            return this;
        };

        /**
         * Multiplies this matrix by a matrix specified by individual components.
         *
         * @param {Number} m00 matrix element at row 1, column 1.
         * @param {Number} m01 matrix element at row 1, column 2.
         * @param {Number} m02 matrix element at row 1, column 3.
         * @param {Number} m03 matrix element at row 1, column 4.
         * @param {Number} m10 matrix element at row 2, column 1.
         * @param {Number} m11 matrix element at row 2, column 2.
         * @param {Number} m12 matrix element at row 2, column 3.
         * @param {Number} m13 matrix element at row 2, column 4.
         * @param {Number} m20 matrix element at row 3, column 1.
         * @param {Number} m21 matrix element at row 3, column 2.
         * @param {Number} m22 matrix element at row 3, column 3.
         * @param {Number} m23 matrix element at row 3, column 4.
         * @param {Number} m30 matrix element at row 4, column 1.
         * @param {Number} m31 matrix element at row 4, column 2.
         * @param {Number} m32 matrix element at row 4, column 3.
         * @param {Number} m33 matrix element at row 4, column 4.
         * @returns {Matrix} This matrix with its components multiplied by the specified values.
         */
        Matrix.prototype.multiply = function (m00, m01, m02, m03,
                                              m10, m11, m12, m13,
                                              m20, m21, m22, m23,
                                              m30, m31, m32, m33) {

            var ma = this,
                ma0, ma1, ma2, ma3;

            // Row 1
            ma0 = ma[0];
            ma1 = ma[1];
            ma2 = ma[2];
            ma3 = ma[3];
            ma[0] = (ma0 * m00) + (ma1 * m10) + (ma2 * m20) + (ma3 * m30);
            ma[1] = (ma0 * m01) + (ma1 * m11) + (ma2 * m21) + (ma3 * m31);
            ma[2] = (ma0 * m02) + (ma1 * m12) + (ma2 * m22) + (ma3 * m32);
            ma[3] = (ma0 * m03) + (ma1 * m13) + (ma2 * m23) + (ma3 * m33);

            // Row 2
            ma0 = ma[4];
            ma1 = ma[5];
            ma2 = ma[6];
            ma3 = ma[7];
            ma[4] = (ma0 * m00) + (ma1 * m10) + (ma2 * m20) + (ma3 * m30);
            ma[5] = (ma0 * m01) + (ma1 * m11) + (ma2 * m21) + (ma3 * m31);
            ma[6] = (ma0 * m02) + (ma1 * m12) + (ma2 * m22) + (ma3 * m32);
            ma[7] = (ma0 * m03) + (ma1 * m13) + (ma2 * m23) + (ma3 * m33);

            // Row 3
            ma0 = ma[8];
            ma1 = ma[9];
            ma2 = ma[10];
            ma3 = ma[11];
            ma[8] = (ma0 * m00) + (ma1 * m10) + (ma2 * m20) + (ma3 * m30);
            ma[9] = (ma0 * m01) + (ma1 * m11) + (ma2 * m21) + (ma3 * m31);
            ma[10] = (ma0 * m02) + (ma1 * m12) + (ma2 * m22) + (ma3 * m32);
            ma[11] = (ma0 * m03) + (ma1 * m13) + (ma2 * m23) + (ma3 * m33);

            // Row 4
            ma0 = ma[12];
            ma1 = ma[13];
            ma2 = ma[14];
            ma3 = ma[15];
            ma[12] = (ma0 * m00) + (ma1 * m10) + (ma2 * m20) + (ma3 * m30);
            ma[13] = (ma0 * m01) + (ma1 * m11) + (ma2 * m21) + (ma3 * m31);
            ma[14] = (ma0 * m02) + (ma1 * m12) + (ma2 * m22) + (ma3 * m32);
            ma[15] = (ma0 * m03) + (ma1 * m13) + (ma2 * m23) + (ma3 * m33);

            return this;
        };

        /**
         * Inverts the specified matrix and stores the result in this matrix.
         * <p>
         * This throws an exception if the specified matrix is singular.
         * <p>
         * The result of this method is undefined if this matrix is passed in as the matrix to invert.
         *
         * @param {Matrix} matrix The matrix whose inverse is computed.
         * @returns {Matrix} This matrix set to the inverse of the specified matrix.
         *
         * @throws {ArgumentError} If the specified matrix is null, undefined or cannot be inverted.
         */
        Matrix.prototype.invertMatrix = function (matrix) {
            if (!matrix) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Matrix", "invertMatrix", "missingMatrix"));
            }

            // Copy the specified matrix into a mutable two-dimensional array.
            var A = [[], [], [], []];
            A[0][0] = matrix[0];
            A[0][1] = matrix[1];
            A[0][2] = matrix[2];
            A[0][3] = matrix[3];
            A[1][0] = matrix[4];
            A[1][1] = matrix[5];
            A[1][2] = matrix[6];
            A[1][3] = matrix[7];
            A[2][0] = matrix[8];
            A[2][1] = matrix[9];
            A[2][2] = matrix[10];
            A[2][3] = matrix[11];
            A[3][0] = matrix[12];
            A[3][1] = matrix[13];
            A[3][2] = matrix[14];
            A[3][3] = matrix[15];

            var index = [],
                d = Matrix.ludcmp(A, index),
                i,
                j;

            // Compute the matrix's determinant.
            for (i = 0; i < 4; i += 1) {
                d *= A[i][i];
            }

            // The matrix is singular if its determinant is zero or very close to zero.
            if (Math.abs(d) < 1.0e-8)
                return null;

            var Y = [[], [], [], []],
                col = [];
            for (j = 0; j < 4; j += 1) {
                for (i = 0; i < 4; i += 1) {
                    col[i] = 0.0;
                }

                col[j] = 1.0;
                Matrix.lubksb(A, index, col);

                for (i = 0; i < 4; i += 1) {
                    Y[i][j] = col[i];
                }
            }

            this[0] = Y[0][0];
            this[1] = Y[0][1];
            this[2] = Y[0][2];
            this[3] = Y[0][3];
            this[4] = Y[1][0];
            this[5] = Y[1][1];
            this[6] = Y[1][2];
            this[7] = Y[1][3];
            this[8] = Y[2][0];
            this[9] = Y[2][1];
            this[10] = Y[2][2];
            this[11] = Y[2][3];
            this[12] = Y[3][0];
            this[13] = Y[3][1];
            this[14] = Y[3][2];
            this[15] = Y[3][3];

            return this;
        };

        /* Internal. Intentionally not documented.
         * Utility method to solve a linear system with an LU factorization of a matrix.
         * Solves Ax=b, where A is in LU factorized form.
         * Algorithm derived from "Numerical Recipes in C", Press et al., 1988.
         *
         * @param {Number[]} A An LU factorization of a matrix.
         * @param {Number[]} index Permutation vector of that LU factorization.
         * @param {Number[]} b Vector to be solved.
         */
            // Method "lubksb" derived from "Numerical Recipes in C", Press et al., 1988
        Matrix.lubksb = function (A, index, b) {
            var ii = -1,
                i,
                j,
                sum;
            for (i = 0; i < 4; i += 1) {
                var ip = index[i];
                sum = b[ip];
                b[ip] = b[i];

                if (ii != -1) {
                    for (j = ii; j <= i - 1; j += 1) {
                        sum -= A[i][j] * b[j];
                    }
                }
                else if (sum != 0.0) {
                    ii = i;
                }

                b[i] = sum;
            }

            for (i = 3; i >= 0; i -= 1) {
                sum = b[i];
                for (j = i + 1; j < 4; j += 1) {
                    sum -= A[i][j] * b[j];
                }

                b[i] = sum / A[i][i];
            }
        };

        /* Internal. Intentionally not documented.
         * Utility method to perform an LU factorization of a matrix.
         * "ludcmp" is derived from "Numerical Recipes in C", Press et al., 1988.
         *
         * @param {Number[]} A matrix to be factored
         * @param {Number[]} index permutation vector
         * @returns {Number} Condition number of matrix.
         */
        Matrix.ludcmp = function (A, index) {
            var TINY = 1.0e-20,
                vv = [], /* new double[4]; */
                d = 1.0,
                temp,
                i,
                j,
                k,
                big,
                sum,
                imax,
                dum;
            for (i = 0; i < 4; i += 1) {
                big = 0.0;
                for (j = 0; j < 4; j += 1) {
                    if ((temp = Math.abs(A[i][j])) > big) {
                        big = temp;
                    }
                }

                if (big == 0.0) {
                    return 0.0; // Matrix is singular if the entire row contains zero.
                }
                else {
                    vv[i] = 1.0 / big;
                }
            }

            for (j = 0; j < 4; j += 1) {
                for (i = 0; i < j; i += 1) {
                    sum = A[i][j];
                    for (k = 0; k < i; k += 1) {
                        sum -= A[i][k] * A[k][j];
                    }

                    A[i][j] = sum;
                }

                big = 0.0;
                imax = -1;
                for (i = j; i < 4; i += 1) {
                    sum = A[i][j];
                    for (k = 0; k < j; k++) {
                        sum -= A[i][k] * A[k][j];
                    }

                    A[i][j] = sum;

                    if ((dum = vv[i] * Math.abs(sum)) >= big) {
                        big = dum;
                        imax = i;
                    }
                }

                if (j != imax) {
                    for (k = 0; k < 4; k += 1) {
                        dum = A[imax][k];
                        A[imax][k] = A[j][k];
                        A[j][k] = dum;
                    }

                    d = -d;
                    vv[imax] = vv[j];
                }

                index[j] = imax;
                if (A[j][j] == 0.0)
                    A[j][j] = TINY;

                if (j != 3) {
                    dum = 1.0 / A[j][j];
                    for (i = j + 1; i < 4; i += 1) {
                        A[i][j] *= dum;
                    }
                }
            }

            return d;
        };

        /**
         * Inverts the specified matrix and stores the result in this matrix.
         * <p>
         * The specified matrix is assumed to represent an orthonormal transform matrix. This matrix's upper 3x3 is
         * transposed, then its fourth column is transformed by the transposed upper 3x3 and negated.
         * <p>
         * The result of this method is undefined if this matrix is passed in as the matrix to invert.
         *
         * @param {Matrix} matrix The matrix whose inverse is computed. This matrix is assumed to represent an
         * orthonormal transform matrix.
         * @returns {Matrix} This matrix set to the inverse of the specified matrix.
         *
         * @throws {ArgumentError} If the specified matrix is null or undefined.
         */
        Matrix.prototype.invertOrthonormalMatrix = function (matrix) {
            if (!matrix) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Matrix", "invertOrthonormalMatrix", "missingMatrix"));
            }

            // 'a' is assumed to contain a 3D transformation matrix.
            // Upper-3x3 is inverted, translation is transformed by inverted-upper-3x3 and negated.

            var a = matrix;

            this[0] = a[0];
            this[1] = a[4];
            this[2] = a[8];
            this[3] = 0.0 - (a[0] * a[3]) - (a[4] * a[7]) - (a[8] * a[11]);

            this[4] = a[1];
            this[5] = a[5];
            this[6] = a[9];
            this[7] = 0.0 - (a[1] * a[3]) - (a[5] * a[7]) - (a[9] * a[11]);

            this[8] = a[2];
            this[9] = a[6];
            this[10] = a[10];
            this[11] = 0.0 - (a[2] * a[3]) - (a[6] * a[7]) - (a[10] * a[11]);

            this[12] = 0;
            this[13] = 0;
            this[14] = 0;
            this[15] = 1;

            return this;
        };

        /**
         * Computes the eigenvectors of this matrix.
         * <p>
         * The eigenvectors are returned sorted from the most prominent vector to the least prominent vector.
         * Each eigenvector has length equal to its corresponding eigenvalue.
         *
         * @param {Vec3} result1 A pre-allocated vector in which to return the most prominent eigenvector.
         * @param {Vec3} result2 A pre-allocated vector in which to return the second most prominent eigenvector.
         * @param {Vec3} result3 A pre-allocated vector in which to return the least prominent eigenvector.
         *
         * @throws {ArgumentError} if any argument is null or undefined or if this matrix is not symmetric.
         */
        Matrix.prototype.eigensystemFromSymmetricMatrix = function (result1, result2, result3) {
            if (!result1 || !result2 || !result3) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Matrix", "eigensystemFromSymmetricMatrix", "missingResult"));
            }

            if (this[1] != this[4] || this[2] != this[8] || this[6] != this[9]) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Matrix", "eigensystemFromSymmetricMatrix",
                        "Matrix is not symmetric"));
            }

            // Taken from Mathematics for 3D Game Programming and Computer Graphics, Second Edition, listing 14.6.

            var epsilon = 1.0e-10,
            // Since the matrix is symmetric m12=m21, m13=m31 and m23=m32, therefore we can ignore the values m21,
            // m32 and m32.
                m11 = this[0],
                m12 = this[1],
                m13 = this[2],
                m22 = this[5],
                m23 = this[6],
                m33 = this[10],
                r = [
                    [1, 0, 0],
                    [0, 1, 0],
                    [0, 0, 1]
                ],
                maxSweeps = 32,
                u, u2, u2p1, t, c, s, temp, i, i1, i2, i3;

            for (var a = 0; a < maxSweeps; a++) {
                // Exit if off-diagonal entries small enough
                if (WWMath.fabs(m12) < epsilon && WWMath.fabs(m13) < epsilon && WWMath.fabs(m23) < epsilon)
                    break;

                // Annihilate (1,2) entry.
                if (m12 != 0) {
                    u = (m22 - m11) * 0.5 / m12;
                    u2 = u * u;
                    u2p1 = u2 + 1;
                    t = (u2p1 != u2) ? ((u < 0) ? -1 : 1) * (Math.sqrt(u2p1) - WWMath.fabs(u)) : 0.5 / u;
                    c = 1 / Math.sqrt(t * t + 1);
                    s = c * t;

                    m11 -= t * m12;
                    m22 += t * m12;
                    m12 = 0;

                    temp = c * m13 - s * m23;
                    m23 = s * m13 + c * m23;
                    m13 = temp;

                    for (i = 0; i < 3; i++) {
                        temp = c * r[i][0] - s * r[i][1];
                        r[i][1] = s * r[i][0] + c * r[i][1];
                        r[i][0] = temp;
                    }
                }

                // Annihilate (1,3) entry.
                if (m13 != 0) {
                    u = (m33 - m11) * 0.5 / m13;
                    u2 = u * u;
                    u2p1 = u2 + 1;
                    t = (u2p1 != u2) ? ((u < 0) ? -1 : 1) * (Math.sqrt(u2p1) - WWMath.fabs(u)) : 0.5 / u;
                    c = 1 / Math.sqrt(t * t + 1);
                    s = c * t;

                    m11 -= t * m13;
                    m33 += t * m13;
                    m13 = 0;

                    temp = c * m12 - s * m23;
                    m23 = s * m12 + c * m23;
                    m12 = temp;

                    for (i = 0; i < 3; i++) {
                        temp = c * r[i][0] - s * r[i][2];
                        r[i][2] = s * r[i][0] + c * r[i][2];
                        r[i][0] = temp;
                    }
                }

                // Annihilate (2,3) entry.
                if (m23 != 0) {
                    u = (m33 - m22) * 0.5 / m23;
                    u2 = u * u;
                    u2p1 = u2 + 1;
                    t = (u2p1 != u2) ? ((u < 0) ? -1 : 1) * (Math.sqrt(u2p1) - WWMath.fabs(u)) : 0.5 / u;
                    c = 1 / Math.sqrt(t * t + 1);
                    s = c * t;

                    m22 -= t * m23;
                    m33 += t * m23;
                    m23 = 0;

                    temp = c * m12 - s * m13;
                    m13 = s * m12 + c * m13;
                    m12 = temp;

                    for (i = 0; i < 3; i++) {
                        temp = c * r[i][1] - s * r[i][2];
                        r[i][2] = s * r[i][1] + c * r[i][2];
                        r[i][1] = temp;
                    }
                }
            }

            i1 = 0;
            i2 = 1;
            i3 = 2;

            if (m11 < m22) {
                temp = m11;
                m11 = m22;
                m22 = temp;

                temp = i1;
                i1 = i2;
                i2 = temp;
            }

            if (m22 < m33) {
                temp = m22;
                m22 = m33;
                m33 = temp;

                temp = i2;
                i2 = i3;
                i3 = temp;
            }

            if (m11 < m22) {
                temp = m11;
                m11 = m22;
                m22 = temp;

                temp = i1;
                i1 = i2;
                i2 = temp;
            }

            result1[0] = r[0][i1];
            result1[1] = r[1][i1];
            result1[2] = r[2][i1];

            result2[0] = r[0][i2];
            result2[1] = r[1][i2];
            result2[2] = r[2][i2];

            result3[0] = r[0][i3];
            result3[1] = r[1][i3];
            result3[2] = r[2][i3];

            result1.normalize();
            result2.normalize();
            result3.normalize();

            result1.multiply(m11);
            result2.multiply(m22);
            result3.multiply(m33);
        };

        /**
         * Extracts and returns a new matrix whose upper 3x3 entries are identical to those of this matrix,
         * and whose fourth row and column are 0 except for a 1 in the diagonal position.
         * @returns {Matrix} The upper 3x3 matrix of this matrix.
         */
        Matrix.prototype.upper3By3 = function () {
            var result = Matrix.fromIdentity();

            result[0] = this[0];
            result[1] = this[1];
            result[2] = this[2];

            result[4] = this[4];
            result[5] = this[5];
            result[6] = this[6];

            result[8] = this[8];
            result[9] = this[9];
            result[10] = this[10];

            return result;
        };

        return Matrix;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));



/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @version $Id: Angle.js 2914 2015-03-19 19:10:19Z tgaskins $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
    "use strict";
    /**
     * Provides constants and functions for working with angles.
     * @exports Angle
     */

    var Angle = {
        /**
         * Conversion factor for degrees to radians.
         * @constant
         */
        DEGREES_TO_RADIANS: Math.PI / 180.0,
        /**
         * Conversion factor for radians to degrees.
         * @constant
         */
        RADIANS_TO_DEGREES: 180.0 / Math.PI,
        /**
         * 2 pi.
         * @constant
         */
        TWO_PI: 2 * Math.PI,
        /**
         * pi / 2
         * @constant
         */
        HALF_PI: Math.PI / 2,

        /**
         * Normalizes a specified value to be within the range of [-180, 180] degrees.
         * @param {Number} degrees The value to normalize, in degrees.
         * @returns {Number} The specified value normalized to [-180, 180] degrees.
         */
        normalizedDegrees: function (degrees) {
            var angle = degrees % 360;

            return angle > 180 ? angle - 360 : angle < -180 ? 360 + angle : angle;
        },

        /**
         * Normalizes a specified value to be within the range of [-90, 90] degrees.
         * @param {Number} degrees The value to normalize, in degrees.
         * @returns {Number} The specified value normalized to the normal range of latitude.
         */
        normalizedDegreesLatitude: function (degrees) {
            var lat = degrees % 180;

            return lat > 90 ? 180 - lat : lat < -90 ? -180 - lat : lat;
        },

        /**
         * Normalizes a specified value to be within the range of [-180, 180] degrees.
         * @param {Number} degrees The value to normalize, in degrees.
         * @returns {Number} The specified value normalized to the normal range of longitude.
         */
        normalizedDegreesLongitude: function (degrees) {
            var lon = degrees % 360;

            return lon > 180 ? lon - 360 : lon < -180 ? 360 + lon : lon;
        },

        /**
         * Normalizes a specified value to be within the range of [-Pi, Pi] radians.
         * @param {Number} radians The value to normalize, in radians.
         * @returns {Number} The specified value normalized to [-Pi, Pi] radians.
         */
        normalizedRadians: function (radians) {
            var angle = radians % this.TWO_PI;

            return angle > Math.PI ? angle - this.TWO_PI : angle < -Math.PI ? this.TWO_PI + angle : angle;
        },

        /**
         * Normalizes a specified value to be within the range of [-Pi/2, Pi/2] radians.
         * @param {Number} radians The value to normalize, in radians.
         * @returns {Number} The specified value normalized to the normal range of latitude.
         */
        normalizedRadiansLatitude: function (radians) {
            var lat = radians % Math.PI;

            return lat > this.HALF_PI ? Math.PI - lat : lat < -this.HALF_PI ? -Math.PI - lat : lat;
        },

        /**
         * Normalizes a specified value to be within the range of [-Pi, Pi] radians.
         * @param {Number} radians The value to normalize, in radians.
         * @returns {Number} The specified value normalized to the normal range of longitude.
         */
        normalizedRadiansLongitude: function (radians) {
            var lon = radians % this.TWO_PI;

            return lon > Math.PI ? lon - this.TWO_PI : lon < -Math.PI ? this.TWO_PI + lon : lon;
        },

        /**
         * Indicates whether a specified value is within the normal range of latitude, [-90, 90].
         * @param {Number} degrees The value to test, in degrees.
         * @returns {Boolean} true if the value is within the normal range of latitude, otherwise false.
         */
        isValidLatitude: function (degrees) {
            return degrees >= -90 && degrees <= 90;
        },

        /**
         * Indicates whether a specified value is within the normal range of longitude, [-180, 180].
         * @param {Number} degrees The value to test, in degrees.
         * @returns {boolean} true if the value is within the normal range of longitude, otherwise false.
         */
        isValidLongitude: function (degrees) {
            return degrees >= -180 && degrees <= 180;
        },

        /**
         * Returns a string representation of a specified value in degrees.
         * @param {Number} degrees The value for which to compute the string.
         * @returns {String} The computed string, which is a decimal degrees value followed by the degree symbol.
         */
        toString: function (degrees) {
            return degrees.toString() + '\u00B0';
        },

        /**
         * Returns a decimal degrees string representation of a specified value in degrees.
         * @param {Number} degrees The value for which to compute the string.
         * @returns {String} The computed string, which is a decimal degrees value followed by the degree symbol.
         */
        toDecimalDegreesString: function (degrees) {
            return degrees.toString() + '\u00B0';
        },

        /**
         * Returns a degrees-minutes-seconds string representation of a specified value in degrees.
         * @param {Number} degrees The value for which to compute the string.
         * @returns {String} The computed string in degrees, minutes and decimal seconds.
         */
        toDMSString: function (degrees) {
            var sign,
                temp,
                d,
                m,
                s;

            sign = degrees < 0 ? -1 : 1;
            temp = sign * degrees;
            d = Math.floor(temp);
            temp = (temp - d) * 60;
            m = Math.floor(temp);
            temp = (temp - m) * 60;
            s = Math.round(temp);

            if (s == 60) {
                m++;
                s = 0;
            }
            if (m == 60) {
                d++;
                m = 0;
            }

            return (sign == -1 ? "-" : "") + d + "\u00B0" + " " + m + "\u2019" + " " + s + "\u201D";
        },

        /**
         * Returns a degrees-minutes string representation of a specified value in degrees.
         * @param {Number} degrees The value for which to compute the string.
         * @returns {String} The computed string in degrees and decimal minutes.
         */
        toDMString: function (degrees) {
            var sign,
                temp,
                d,
                m,
                s,
                mf;

            sign = degrees < 0 ? -1 : 1;
            temp = sign * degrees;
            d = Math.floor(temp);
            temp = (temp - d) * 60;
            m = Math.floor(temp);
            temp = (temp - m) * 60;
            s = Math.round(temp);

            if (s == 60) {
                m++;
                s = 0;
            }
            if (m == 60) {
                d++;
                m = 0;
            }

            mf = s == 0 ? m : m + s / 60;

            return (sign == -1 ? "-" : "") + d + "\u00B0" + " " + mf + "\u2019";
        }
    };

    return Angle;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports Location
 * @version $Id: Location.js 3116 2015-05-27 01:30:07Z tgaskins $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(6),
        __webpack_require__(1),
        __webpack_require__(0),
        __webpack_require__(18),
        __webpack_require__(2),
        __webpack_require__(4)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Angle,
              ArgumentError,
              Logger,
              Plane,
              Vec3,
              WWMath) {
        "use strict";

        /**
         * Constructs a location from a specified latitude and longitude in degrees.
         * @alias Location
         * @constructor
         * @classdesc Represents a latitude, longitude pair in degrees.
         * @param {Number} latitude The latitude in degrees.
         * @param {Number} longitude The longitude in degrees.
         */
        var Location = function (latitude, longitude) {
            /**
             * The latitude in degrees.
             * @type {Number}
             */
            this.latitude = latitude;
            /**
             * The longitude in degrees.
             * @type {Number}
             */
            this.longitude = longitude;
        };

        /**
         * A Location with latitude and longitude both 0.
         * @constant
         * @type {Location}
         */
        Location.ZERO = new Location(0, 0);

        /**
         * Creates a location from angles specified in radians.
         * @param {Number} latitudeRadians The latitude in radians.
         * @param {Number} longitudeRadians The longitude in radians
         * @returns {Location} The new location with latitude and longitude in degrees.
         */
        Location.fromRadians = function (latitudeRadians, longitudeRadians) {
            return new Location(latitudeRadians * Angle.RADIANS_TO_DEGREES, longitudeRadians * Angle.RADIANS_TO_DEGREES);
        };

        /**
         * Copies this location to the latitude and longitude of a specified location.
         * @param {Location} location The location to copy.
         * @returns {Location} This location, set to the values of the specified location.
         * @throws {ArgumentError} If the specified location is null or undefined.
         */
        Location.prototype.copy = function (location) {
            if (!location) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Location", "copy", "missingLocation"));
            }

            this.latitude = location.latitude;
            this.longitude = location.longitude;

            return this;
        };

        /**
         * Sets this location to the latitude and longitude.
         * @param {number} latitude The latitude to set.
         * @param {number} longitude The longitude to set.
         * @returns {Location} This location, set to the values of the specified location.
         * @throws {ArgumentError} If the specified location is null or undefined.
         */
        Location.prototype.set = function (latitude, longitude) {
            this.latitude = latitude;
            this.longitude = longitude;

            return this;
        };

        /**
         * Indicates whether this location is equal to a specified location.
         * @param {Location} location The location to compare this one to.
         * @returns {boolean} <code>true</code> if this location is equal to the specified location, otherwise
         * <code>false</code>.
         */
        Location.prototype.equals = function (location) {
            return location
                && location.latitude === this.latitude && location.longitude === this.longitude;
        };

        /**
         * Compute a location along a path at a specified distance between two specified locations.
         * @param {String} pathType The type of path to assume. Recognized values are
         * [WorldWind.GREAT_CIRCLE]{@link WorldWind#GREAT_CIRCLE},
         * [WorldWind.RHUMB_LINE]{@link WorldWind#RHUMB_LINE} and
         * [WorldWind.LINEAR]{@link WorldWind#LINEAR}.
         * If the path type is not recognized then WorldWind.LINEAR is used.
         * @param {Number} amount The fraction of the path between the two locations at which to compute the new
         * location. This number should be between 0 and 1. If not, it is clamped to the nearest of those values.
         * @param {Location} location1 The starting location.
         * @param {Location} location2 The ending location.
         * @param {Location} result A Location in which to return the result.
         * @returns {Location} The specified result location.
         * @throws {ArgumentError} If either specified location or the result argument is null or undefined.
         */
        Location.interpolateAlongPath = function (pathType, amount, location1, location2, result) {
            if (!location1 || !location2) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Location", "interpolateAlongPath", "missingLocation"));
            }

            if (!result) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Location", "interpolateAlongPath", "missingResult"));
            }

            if (pathType === WorldWind.GREAT_CIRCLE) {
                return this.interpolateGreatCircle(amount, location1, location2, result);
            } else if (pathType && pathType === WorldWind.RHUMB_LINE) {
                return this.interpolateRhumb(amount, location1, location2, result);
            } else {
                return this.interpolateLinear(amount, location1, location2, result);
            }
        };

        /**
         * Compute a location along a great circle path at a specified distance between two specified locations.
         * @param {Number} amount The fraction of the path between the two locations at which to compute the new
         * location. This number should be between 0 and 1. If not, it is clamped to the nearest of those values.
         * This function uses a spherical model, not elliptical.
         * @param {Location} location1 The starting location.
         * @param {Location} location2 The ending location.
         * @param {Location} result A Location in which to return the result.
         * @returns {Location} The specified result location.
         * @throws {ArgumentError} If either specified location or the result argument is null or undefined.
         */
        Location.interpolateGreatCircle = function (amount, location1, location2, result) {
            if (!location1 || !location2) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Location", "interpolateGreatCircle", "missingLocation"));
            }
            if (!result) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Location", "interpolateGreatCircle", "missingResult"));
            }

            if (location1.equals(location2)) {
                result.latitude = location1.latitude;
                result.longitude = location1.longitude;
                return result;
            }

            var t = WWMath.clamp(amount, 0, 1),
                azimuthDegrees = this.greatCircleAzimuth(location1, location2),
                distanceRadians = this.greatCircleDistance(location1, location2);

            return this.greatCircleLocation(location1, azimuthDegrees, t * distanceRadians, result);
        };

        /**
         * Computes the azimuth angle (clockwise from North) that points from the first location to the second location.
         * This angle can be used as the starting azimuth for a great circle arc that begins at the first location, and
         * passes through the second location.
         * This function uses a spherical model, not elliptical.
         * @param {Location} location1 The starting location.
         * @param {Location} location2 The ending location.
         * @returns {Number} The computed azimuth, in degrees.
         * @throws {ArgumentError} If either specified location is null or undefined.
         */
        Location.greatCircleAzimuth = function (location1, location2) {
            if (!location1 || !location2) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Location", "greatCircleAzimuth", "missingLocation"));
            }

            var lat1 = location1.latitude * Angle.DEGREES_TO_RADIANS,
                lat2 = location2.latitude * Angle.DEGREES_TO_RADIANS,
                lon1 = location1.longitude * Angle.DEGREES_TO_RADIANS,
                lon2 = location2.longitude * Angle.DEGREES_TO_RADIANS,
                x,
                y,
                azimuthRadians;

            if (lat1 == lat2 && lon1 == lon2) {
                return 0;
            }

            if (lon1 == lon2) {
                return lat1 > lat2 ? 180 : 0;
            }

            // Taken from "Map Projections - A Working Manual", page 30, equation 5-4b.
            // The atan2() function is used in place of the traditional atan(y/x) to simplify the case when x == 0.
            y = Math.cos(lat2) * Math.sin(lon2 - lon1);
            x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);
            azimuthRadians = Math.atan2(y, x);

            return isNaN(azimuthRadians) ? 0 : azimuthRadians * Angle.RADIANS_TO_DEGREES;
        };

        /**
         * Computes the great circle angular distance between two locations. The return value gives the distance as the
         * angle between the two positions. In radians, this angle is the arc length of the segment between the two
         * positions. To compute a distance in meters from this value, multiply the return value by the radius of the
         * globe.
         * This function uses a spherical model, not elliptical.
         *
         * @param {Location} location1 The starting location.
         * @param {Location} location2 The ending location.
         * @returns {Number} The computed distance, in radians.
         * @throws {ArgumentError} If either specified location is null or undefined.
         */
        Location.greatCircleDistance = function (location1, location2) {
            if (!location1 || !location2) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Location", "greatCircleDistance", "missingLocation"));
            }

            var lat1Radians = location1.latitude * Angle.DEGREES_TO_RADIANS,
                lat2Radians = location2.latitude * Angle.DEGREES_TO_RADIANS,
                lon1Radians = location1.longitude * Angle.DEGREES_TO_RADIANS,
                lon2Radians = location2.longitude * Angle.DEGREES_TO_RADIANS,
                a,
                b,
                c,
                distanceRadians;

            if (lat1Radians == lat2Radians && lon1Radians == lon2Radians) {
                return 0;
            }

            // "Haversine formula," taken from https://en.wikipedia.org/wiki/Great-circle_distance#Formul.C3.A6
            a = Math.sin((lat2Radians - lat1Radians) / 2.0);
            b = Math.sin((lon2Radians - lon1Radians) / 2.0);
            c = a * a + Math.cos(lat1Radians) * Math.cos(lat2Radians) * b * b;
            distanceRadians = 2.0 * Math.asin(Math.sqrt(c));

            return isNaN(distanceRadians) ? 0 : distanceRadians;
        };

        /**
         * Computes the location on a great circle path corresponding to a given starting location, azimuth, and
         * arc distance.
         * This function uses a spherical model, not elliptical.
         *
         * @param {Location} location The starting location.
         * @param {Number} greatCircleAzimuthDegrees The azimuth in degrees.
         * @param {Number} pathLengthRadians The radian distance along the path at which to compute the end location.
         * @param {Location} result A Location in which to return the result.
         * @returns {Location} The specified result location.
         * @throws {ArgumentError} If the specified location or the result argument is null or undefined.
         */
        Location.greatCircleLocation = function (location, greatCircleAzimuthDegrees, pathLengthRadians, result) {
            if (!location) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Location", "greatCircleLocation", "missingLocation"));
            }
            if (!result) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Location", "greatCircleLocation", "missingResult"));
            }

            if (pathLengthRadians == 0) {
                result.latitude = location.latitude;
                result.longitude = location.longitude;
                return result;
            }

            var latRadians = location.latitude * Angle.DEGREES_TO_RADIANS,
                lonRadians = location.longitude * Angle.DEGREES_TO_RADIANS,
                azimuthRadians = greatCircleAzimuthDegrees * Angle.DEGREES_TO_RADIANS,
                endLatRadians,
                endLonRadians;

            // Taken from "Map Projections - A Working Manual", page 31, equation 5-5 and 5-6.
            endLatRadians = Math.asin(Math.sin(latRadians) * Math.cos(pathLengthRadians) +
                Math.cos(latRadians) * Math.sin(pathLengthRadians) * Math.cos(azimuthRadians));
            endLonRadians = lonRadians + Math.atan2(
                Math.sin(pathLengthRadians) * Math.sin(azimuthRadians),
                Math.cos(latRadians) * Math.cos(pathLengthRadians) -
                Math.sin(latRadians) * Math.sin(pathLengthRadians) * Math.cos(azimuthRadians));

            if (isNaN(endLatRadians) || isNaN(endLonRadians)) {
                result.latitude = location.latitude;
                result.longitude = location.longitude;
            } else {
                result.latitude = Angle.normalizedDegreesLatitude(endLatRadians * Angle.RADIANS_TO_DEGREES);
                result.longitude = Angle.normalizedDegreesLongitude(endLonRadians * Angle.RADIANS_TO_DEGREES);
            }

            return result;
        };

        /**
         * Compute a location along a rhumb path at a specified distance between two specified locations.
         * This function uses a spherical model, not elliptical.
         * @param {Number} amount The fraction of the path between the two locations at which to compute the new
         * location. This number should be between 0 and 1. If not, it is clamped to the nearest of those values.
         * @param {Location} location1 The starting location.
         * @param {Location} location2 The ending location.
         * @param {Location} result A Location in which to return the result.
         * @returns {Location} The specified result location.
         * @throws {ArgumentError} If either specified location or the result argument is null or undefined.
         */
        Location.interpolateRhumb = function (amount, location1, location2, result) {
            if (!location1 || !location2) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Location", "interpolateRhumb", "missingLocation"));
            }
            if (!result) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Location", "interpolateRhumb", "missingResult"));
            }

            if (location1.equals(location2)) {
                result.latitude = location1.latitude;
                result.longitude = location1.longitude;
                return result;
            }

            var t = WWMath.clamp(amount, 0, 1),
                azimuthDegrees = this.rhumbAzimuth(location1, location2),
                distanceRadians = this.rhumbDistance(location1, location2);

            return this.rhumbLocation(location1, azimuthDegrees, t * distanceRadians, result);
        };

        /**
         * Computes the azimuth angle (clockwise from North) that points from the first location to the second location.
         * This angle can be used as the azimuth for a rhumb arc that begins at the first location, and
         * passes through the second location.
         * This function uses a spherical model, not elliptical.
         * @param {Location} location1 The starting location.
         * @param {Location} location2 The ending location.
         * @returns {Number} The computed azimuth, in degrees.
         * @throws {ArgumentError} If either specified location is null or undefined.
         */
        Location.rhumbAzimuth = function (location1, location2) {
            if (!location1 || !location2) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Location", "rhumbAzimuth", "missingLocation"));
            }

            var lat1 = location1.latitude * Angle.DEGREES_TO_RADIANS,
                lat2 = location2.latitude * Angle.DEGREES_TO_RADIANS,
                lon1 = location1.longitude * Angle.DEGREES_TO_RADIANS,
                lon2 = location2.longitude * Angle.DEGREES_TO_RADIANS,
                dLon,
                dPhi,
                azimuthRadians;

            if (lat1 == lat2 && lon1 == lon2) {
                return 0;
            }

            dLon = lon2 - lon1;
            dPhi = Math.log(Math.tan(lat2 / 2.0 + Math.PI / 4) / Math.tan(lat1 / 2.0 + Math.PI / 4));

            // If lonChange over 180 take shorter rhumb across 180 meridian.
            if (WWMath.fabs(dLon) > Math.PI) {
                dLon = dLon > 0 ? -(2 * Math.PI - dLon) : (2 * Math.PI + dLon);
            }

            azimuthRadians = Math.atan2(dLon, dPhi);

            return isNaN(azimuthRadians) ? 0 : azimuthRadians * Angle.RADIANS_TO_DEGREES;
        };

        /**
         * Computes the rhumb angular distance between two locations. The return value gives the distance as the
         * angle between the two positions in radians. This angle is the arc length of the segment between the two
         * positions. To compute a distance in meters from this value, multiply the return value by the radius of the
         * globe.
         * This function uses a spherical model, not elliptical.
         *
         * @param {Location} location1 The starting location.
         * @param {Location} location2 The ending location.
         * @returns {Number} The computed distance, in radians.
         * @throws {ArgumentError} If either specified location is null or undefined.
         */
        Location.rhumbDistance = function (location1, location2) {
            if (!location1 || !location2) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Location", "rhumbDistance", "missingLocation"));
            }

            var lat1 = location1.latitude * Angle.DEGREES_TO_RADIANS,
                lat2 = location2.latitude * Angle.DEGREES_TO_RADIANS,
                lon1 = location1.longitude * Angle.DEGREES_TO_RADIANS,
                lon2 = location2.longitude * Angle.DEGREES_TO_RADIANS,
                dLat,
                dLon,
                dPhi,
                q,
                distanceRadians;

            if (lat1 == lat2 && lon1 == lon2) {
                return 0;
            }

            dLat = lat2 - lat1;
            dLon = lon2 - lon1;
            dPhi = Math.log(Math.tan(lat2 / 2.0 + Math.PI / 4) / Math.tan(lat1 / 2.0 + Math.PI / 4));
            q = dLat / dPhi;

            if (isNaN(dPhi) || isNaN(q)) {
                q = Math.cos(lat1);
            }

            // If lonChange over 180 take shorter rhumb across 180 meridian.
            if (WWMath.fabs(dLon) > Math.PI) {
                dLon = dLon > 0 ? -(2 * Math.PI - dLon) : (2 * Math.PI + dLon);
            }

            distanceRadians = Math.sqrt(dLat * dLat + q * q * dLon * dLon);

            return isNaN(distanceRadians) ? 0 : distanceRadians;
        };

        /**
         * Computes the location on a rhumb arc with the given starting location, azimuth, and arc distance.
         * This function uses a spherical model, not elliptical.
         *
         * @param {Location} location The starting location.
         * @param {Number} azimuthDegrees The azimuth in degrees.
         * @param {Number} pathLengthRadians The radian distance along the path at which to compute the location.
         * @param {Location} result A Location in which to return the result.
         * @returns {Location} The specified result location.
         * @throws {ArgumentError} If the specified location or the result argument is null or undefined.
         */
        Location.rhumbLocation = function (location, azimuthDegrees, pathLengthRadians, result) {
            if (!location) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Location", "rhumbLocation", "missingLocation"));
            }
            if (!result) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Location", "rhumbLocation", "missingResult"));
            }

            if (pathLengthRadians == 0) {
                result.latitude = location.latitude;
                result.longitude = location.longitude;
                return result;
            }

            var latRadians = location.latitude * Angle.DEGREES_TO_RADIANS,
                lonRadians = location.longitude * Angle.DEGREES_TO_RADIANS,
                azimuthRadians = azimuthDegrees * Angle.DEGREES_TO_RADIANS,
                endLatRadians = latRadians + pathLengthRadians * Math.cos(azimuthRadians),
                dPhi = Math.log(Math.tan(endLatRadians / 2 + Math.PI / 4) / Math.tan(latRadians / 2 + Math.PI / 4)),
                q = (endLatRadians - latRadians) / dPhi,
                dLon,
                endLonRadians;

            if (isNaN(dPhi) || isNaN(q) || !isFinite(q)) {
                q = Math.cos(latRadians);
            }

            dLon = pathLengthRadians * Math.sin(azimuthRadians) / q;

            // Handle latitude passing over either pole.
            if (WWMath.fabs(endLatRadians) > Math.PI / 2)
            {
                endLatRadians = endLatRadians > 0 ? Math.PI - endLatRadians : -Math.PI - endLatRadians;
            }

            endLonRadians = WWMath.fmod(lonRadians + dLon + Math.PI, 2 * Math.PI) - Math.PI;

            if (isNaN(endLatRadians) || isNaN(endLonRadians)) {
                result.latitude = location.latitude;
                result.longitude = location.longitude;
            } else {
                result.latitude = Angle.normalizedDegreesLatitude(endLatRadians * Angle.RADIANS_TO_DEGREES);
                result.longitude = Angle.normalizedDegreesLongitude(endLonRadians * Angle.RADIANS_TO_DEGREES);
            }

            return result;
        };

        /**
         * Compute a location along a linear path at a specified distance between two specified locations.
         * @param {Number} amount The fraction of the path between the two locations at which to compute the new
         * location. This number should be between 0 and 1. If not, it is clamped to the nearest of those values.
         * @param {Location} location1 The starting location.
         * @param {Location} location2 The ending location.
         * @param {Location} result A Location in which to return the result.
         * @returns {Location} The specified result location.
         * @throws {ArgumentError} If either specified location or the result argument is null or undefined.
         */
        Location.interpolateLinear = function (amount, location1, location2, result) {
            if (!location1 || !location2) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Location", "interpolateLinear", "missingLocation"));
            }
            if (!result) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Location", "interpolateLinear", "missingResult"));
            }

            if (location1.equals(location2)) {
                result.latitude = location1.latitude;
                result.longitude = location1.longitude;
                return result;
            }

            var t = WWMath.clamp(amount, 0, 1),
                azimuthDegrees = this.linearAzimuth(location1, location2),
                distanceRadians = this.linearDistance(location1, location2);

            return this.linearLocation(location1, azimuthDegrees, t * distanceRadians, result);
        };

        /**
         * Computes the azimuth angle (clockwise from North) that points from the first location to the second location.
         * This angle can be used as the azimuth for a linear arc that begins at the first location, and
         * passes through the second location.
         * @param {Location} location1 The starting location.
         * @param {Location} location2 The ending location.
         * @returns {Number} The computed azimuth, in degrees.
         * @throws {ArgumentError} If either specified location is null or undefined.
         */
        Location.linearAzimuth = function (location1, location2) {
            if (!location1 || !location2) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Location", "linearAzimuth", "missingLocation"));
            }

            var lat1 = location1.latitude * Angle.DEGREES_TO_RADIANS,
                lat2 = location2.latitude * Angle.DEGREES_TO_RADIANS,
                lon1 = location1.longitude * Angle.DEGREES_TO_RADIANS,
                lon2 = location2.longitude * Angle.DEGREES_TO_RADIANS,
                dLon,
                dPhi,
                azimuthRadians;

            if (lat1 == lat2 && lon1 == lon2) {
                return 0;
            }

            dLon = lon2 - lon1;
            dPhi = lat2 - lat1;

            // If longitude change is over 180 take shorter path across 180 meridian.
            if (WWMath.fabs(dLon) > Math.PI) {
                dLon = dLon > 0 ? -(2 * Math.PI - dLon) : (2 * Math.PI + dLon);
            }

            azimuthRadians = Math.atan2(dLon, dPhi);

            return isNaN(azimuthRadians) ? 0 : azimuthRadians * Angle.RADIANS_TO_DEGREES;
        };

        /**
         * Computes the linear angular distance between two locations. The return value gives the distance as the
         * angle between the two positions in radians. This angle is the arc length of the segment between the two
         * positions. To compute a distance in meters from this value, multiply the return value by the radius of the
         * globe.
         *
         * @param {Location} location1 The starting location.
         * @param {Location} location2 The ending location.
         * @returns {Number} The computed distance, in radians.
         * @throws {ArgumentError} If either specified location is null or undefined.
         */
        Location.linearDistance = function (location1, location2) {
            if (!location1 || !location2) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Location", "linearDistance", "missingLocation"));
            }

            var lat1 = location1.latitude * Angle.DEGREES_TO_RADIANS,
                lat2 = location2.latitude * Angle.DEGREES_TO_RADIANS,
                lon1 = location1.longitude * Angle.DEGREES_TO_RADIANS,
                lon2 = location2.longitude * Angle.DEGREES_TO_RADIANS,
                dLat,
                dLon,
                distanceRadians;

            if (lat1 == lat2 && lon1 == lon2) {
                return 0;
            }

            dLat = lat2 - lat1;
            dLon = lon2 - lon1;

            // If lonChange over 180 take shorter path across 180 meridian.
            if (WWMath.fabs(dLon) > Math.PI) {
                dLon = dLon > 0 ? -(2 * Math.PI - dLon) : (2 * Math.PI + dLon);
            }

            distanceRadians = Math.sqrt(dLat * dLat + dLon * dLon);

            return isNaN(distanceRadians) ? 0 : distanceRadians;
        };

        /**
         * Computes the location on a linear path with the given starting location, azimuth, and arc distance.
         *
         * @param {Location} location The starting location.
         * @param {Number} azimuthDegrees The azimuth in degrees.
         * @param {Number} pathLengthRadians The radian distance along the path at which to compute the location.
         * @param {Location} result A Location in which to return the result.
         * @returns {Location} The specified result location.
         * @throws {ArgumentError} If the specified location or the result argument is null or undefined.
         */
        Location.linearLocation = function (location, azimuthDegrees, pathLengthRadians, result) {
            if (!location) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Location", "linearLocation", "missingLocation"));
            }
            if (!result) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Location", "linearLocation", "missingResult"));
            }

            if (pathLengthRadians == 0) {
                result.latitude = location.latitude;
                result.longitude = location.longitude;
                return result;
            }

            var latRadians = location.latitude * Angle.DEGREES_TO_RADIANS,
                lonRadians = location.longitude * Angle.DEGREES_TO_RADIANS,
                azimuthRadians = azimuthDegrees * Angle.DEGREES_TO_RADIANS,
                endLatRadians = latRadians + pathLengthRadians * Math.cos(azimuthRadians),
                endLonRadians;

            // Handle latitude passing over either pole.
            if (WWMath.fabs(endLatRadians) > Math.PI / 2)
            {
                endLatRadians = endLatRadians > 0 ? Math.PI - endLatRadians : -Math.PI - endLatRadians;
            }

            endLonRadians =
                WWMath.fmod(lonRadians + pathLengthRadians * Math.sin(azimuthRadians) + Math.PI, 2 * Math.PI) - Math.PI;

            if (isNaN(endLatRadians) || isNaN(endLonRadians)) {
                result.latitude = location.latitude;
                result.longitude = location.longitude;
            } else {
                result.latitude = Angle.normalizedDegreesLatitude(endLatRadians * Angle.RADIANS_TO_DEGREES);
                result.longitude = Angle.normalizedDegreesLongitude(endLonRadians * Angle.RADIANS_TO_DEGREES);
            }

            return result;
        };

        /**
         * Determine whether a list of locations crosses the dateline.
         * @param {Location[]} locations The locations to test.
         * @returns {boolean} True if the dateline is crossed, else false.
         * @throws {ArgumentError} If the locations list is null.
         */
        Location.locationsCrossDateLine = function(locations) {
            if (!locations) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Location", "locationsCrossDateline", "missingLocation"));
            }

            var pos = null;
            for (var idx = 0, len = locations.length; idx < len; idx += 1) {
                var posNext = locations[idx];

                if (pos != null) {
                    // A segment cross the line if end pos have different longitude signs
                    // and are more than 180 degrees longitude apart
                    if (WWMath.signum(pos.longitude) != WWMath.signum(posNext.longitude)) {
                        var delta = Math.abs(pos.longitude - posNext.longitude);
                        if (delta > 180 && delta < 360)
                            return true;
                    }
                }
                pos = posNext;
            }

            return false;
        };

        /**
         * Returns two locations with the most extreme latitudes on the sequence of great circle arcs defined by each pair
         * of locations in the specified iterable.
         *
         * @param {Location[]} locations The pairs of locations defining a sequence of great circle arcs.
         *
         * @return {Location[]} Two locations with the most extreme latitudes on the great circle arcs.
         *
         * @throws IllegalArgumentException if locations is null.
         */
        Location.greatCircleArcExtremeLocations = function(locations) {
            if (!locations) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Location", "greatCircleArcExtremeLocations", "missingLocation"));
            }

            var minLatLocation = null;
            var maxLatLocation = null;

            var lastLocation = null;

            for (var idx = 0, len = locations.length; idx < len; idx += 1) {
                var location = locations[idx];

                if (lastLocation != null) {
                    var extremes = Location.greatCircleArcExtremeForTwoLocations(lastLocation, location);
                    if (extremes == null) {
                        continue;
                    }

                    if (minLatLocation == null || minLatLocation.latitude > extremes[0].latitude) {
                        minLatLocation = extremes[0];
                    }
                    if (maxLatLocation == null || maxLatLocation.latitude < extremes[1].latitude) {
                        maxLatLocation = extremes[1];
                    }
                }

                lastLocation = location;
            }

            return [minLatLocation, maxLatLocation];
        };

        /**
         * Returns two locations with the most extreme latitudes on the great circle arc defined by, and limited to, the two
         * locations.
         *
         * @param {Location} begin Beginning location on the great circle arc.
         * @param {Location} end   Ending location on the great circle arc.
         *
         * @return {Location[]} Two locations with the most extreme latitudes on the great circle arc.
         *
         * @throws {ArgumentError} If either begin or end are null.
         */
        Location.greatCircleArcExtremeForTwoLocations = function(begin, end) {
            if (!begin || !end) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Location", "greatCircleArcExtremeForTwoLocations", "missingLocation"));
            }

            var idx, len, location; // Iteration variables.
            var minLatLocation = null;
            var maxLatLocation = null;
            var minLat = 90;
            var maxLat = -90;

            // Compute the min and max latitude and associated locations from the arc endpoints.
            var locations = [begin, end];
            for (idx = 0, len = locations.length; idx < len; idx += 1) {
                location = locations[idx];

                if (minLat >= location.latitude) {
                    minLat = location.latitude;
                    minLatLocation = location;
                }
                if (maxLat <= location.latitude) {
                    maxLat = location.latitude;
                    maxLatLocation = location;
                }
            }
            // The above could be written for greater clarity, simplicity, and speed:
            // minLat = Math.min(begin.latitude, end.latitude);
            // maxLat = Math.max(begin.latitude, end.latitude);
            // minLatLocation = minLat == begin.latitude ? begin : end;
            // maxLatLocation = maxLat == begin.latitude ? begin : end;

            // Compute parameters for the great circle arc defined by begin and end. Then compute the locations of extreme
            // latitude on entire the great circle which that arc is part of.
            var greatArcAzimuth = Location.greatCircleAzimuth(begin, end);
            var greatArcDistance = Location.greatCircleDistance(begin, end);
            var greatCircleExtremes = Location.greatCircleExtremeLocationsUsingAzimuth(begin, greatArcAzimuth);

            // Determine whether either of the extreme locations are inside the arc defined by begin and end. If so,
            // adjust the min and max latitude accordingly.
            for (idx = 0, len = greatCircleExtremes.length; idx < len; idx += 1) {
                location = greatCircleExtremes[idx];

                var az = Location.greatCircleAzimuth(begin, location);
                var d = Location.greatCircleDistance(begin, location);

                // The extreme location must be between the begin and end locations. Therefore its azimuth relative to
                // the begin location should have the same signum, and its distance relative to the begin location should
                // be between 0 and greatArcDistance, inclusive.
                if (WWMath.signum(az) == WWMath.signum(greatArcAzimuth)) {
                    if (d >= 0 && d <= greatArcDistance) {
                        if (minLat >= location.latitude) {
                            minLat = location.latitude;
                            minLatLocation = location;
                        }
                        if (maxLat <= location.latitude) {
                            maxLat = location.latitude;
                            maxLatLocation = location;
                        }
                    }
                }
            }

            return [minLatLocation, maxLatLocation];
        };

        /**
         * Returns two locations with the most extreme latitudes on the great circle with the given starting location and
         * azimuth.
         *
         * @param {Location} location Location on the great circle.
         * @param {number} azimuth  Great circle azimuth angle (clockwise from North).
         *
         * @return {Location[]} Two locations where the great circle has its extreme latitudes.
         *
         * @throws {ArgumentError} If location is null.
         */
        Location.greatCircleExtremeLocationsUsingAzimuth = function(location, azimuth) {
            if (!location) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Location", "greatCircleArcExtremeLocationsUsingAzimuth", "missingLocation"));
            }

            var lat0 = location.latitude;
            var az = azimuth * Angle.DEGREES_TO_RADIANS;

            // Derived by solving the function for longitude on a great circle against the desired longitude. We start
            // with the equation in "Map Projections - A Working Manual", page 31, equation 5-5:
            //
            //     lat = asin( sin(lat0) * cos(C) + cos(lat0) * sin(C) * cos(Az) )
            //
            // Where (lat0, lon) are the starting coordinates, c is the angular distance along the great circle from the
            // starting coordinate, and Az is the azimuth. All values are in radians. Solving for angular distance gives
            // distance to the equator:
            //
            //     tan(C) = -tan(lat0) / cos(Az)
            //
            // The great circle is by definition centered about the Globe's origin. Therefore intersections with the
            // equator will be antipodal (exactly 180 degrees opposite each other), as will be the extreme latitudes.
            // By observing the symmetry of a great circle, it is also apparent that the extreme latitudes will be 90
            // degrees from either intersection with the equator.
            //
            // d1 = c + 90
            // d2 = c - 90

            var tanDistance = -Math.tan(lat0) / Math.cos(az);
            var distance = Math.atan(tanDistance);

            var extremeDistance1 = distance + (Math.PI / 2.0);
            var extremeDistance2 = distance - (Math.PI / 2.0);

            return [
                Location.greatCircleLocation(location, azimuth, extremeDistance1, new Location(0, 0)),
                Location.greatCircleLocation(location, azimuth, extremeDistance2, new Location(0,0))
            ];
        };

        /**
         * Determine where a line between two positions crosses a given meridian. The intersection test is performed by
         * intersecting a line in Cartesian space between the two positions with a plane through the meridian. Thus, it is
         * most suitable for working with positions that are fairly close together as the calculation does not take into
         * account great circle or rhumb paths.
         *
         * @param {Location} p1         First position.
         * @param {Location} p2         Second position.
         * @param {number} meridian     Longitude line to intersect with.
         * @param {Globe} globe         Globe used to compute intersection.
         *
         * @return {number} latitude The intersection latitude along the meridian
         *
         * TODO: this code allocates 4 new Vec3 and 1 new Position; use scratch variables???
         * TODO: Why not? Every location created would then allocated those variables as well, even if they aren't needed :(.
         */
        Location.intersectionWithMeridian = function(p1, p2, meridian, globe) {
            // TODO: add support for 2D
            //if (globe instanceof Globe2D)
            //{
            //    // y = mx + b case after normalizing negative angles.
            //    double lon1 = p1.getLongitude().degrees < 0 ? p1.getLongitude().degrees + 360 : p1.getLongitude().degrees;
            //    double lon2 = p2.getLongitude().degrees < 0 ? p2.getLongitude().degrees + 360 : p2.getLongitude().degrees;
            //    if (lon1 == lon2)
            //        return null;
            //
            //    double med = meridian.degrees < 0 ? meridian.degrees + 360 : meridian.degrees;
            //    double slope = (p2.latitude.degrees - p1.latitude.degrees) / (lon2 - lon1);
            //    double lat = p1.latitude.degrees + slope * (med - lon1);
            //
            //    return LatLon.fromDegrees(lat, meridian.degrees);
            //}

            var pt1 = globe.computePointFromLocation(p1.latitude, p1.longitude, new Vec3(0, 0, 0));
            var pt2 = globe.computePointFromLocation(p2.latitude, p2.longitude, new Vec3(0, 0, 0));

            // Compute a plane through the origin, North Pole, and the desired meridian.
            var northPole = globe.computePointFromLocation(90, meridian, new Vec3(0, 0, 0));
            var pointOnEquator = globe.computePointFromLocation(0, meridian, new Vec3(0, 0, 0));

            var plane = Plane.fromPoints(northPole, pointOnEquator, Vec3.ZERO);

            var intersectionPoint = new Vec3(0, 0, 0);
            if (!plane.intersectsSegmentAt(pt1, pt2, intersectionPoint)) {
                return null;
            }

            // TODO: unable to simply create a new Position(0, 0, 0)
            var pos = new WorldWind.Position(0, 0, 0);
            globe.computePositionFromPoint(intersectionPoint[0], intersectionPoint[1], intersectionPoint[2], pos);

            return pos.latitude;
        };

        /**
         * A bit mask indicating which if any pole is being referenced.
         * This corresponds to Java WW's AVKey.NORTH and AVKey.SOUTH,
         * although this encoding can capture both poles simultaneously, which was
         * a 'to do' item in the Java implementation.
         * @type {{NONE: number, NORTH: number, SOUTH: number}}
         */
        Location.poles = {
            'NONE': 0,
            'NORTH': 1,
            'SOUTH': 2
        };

        return Location;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports Color
 * @version $Id: Color.js 3017 2015-04-14 17:10:31Z dcollins $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(0)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Logger) {
        "use strict";

        /**
         * Constructs a color from red, green, blue and alpha values.
         * @alias Color
         * @constructor
         * @classdesc Represents a red, green, blue, alpha, color.
         * @param {Number} red The red component, a number between 0 and 1.
         * @param {Number} green The green component, a number between 0 and 1.
         * @param {Number} blue The blue component, a number between 0 and 1.
         * @param {Number} alpha The alpha component, a number between 0 and 1.
         */
        var Color = function (red, green, blue, alpha) {

            /**
             * This color's red component, a number between 0 and 1.
             * @type {Number}
             */
            this.red = red;

            /**
             * This color's green component, a number between 0 and 1.
             * @type {Number}
             */
            this.green = green;

            /**
             * This color's blue component, a number between 0 and 1.
             * @type {Number}
             */
            this.blue = blue;

            /**
             * This color's alpha component, a number between 0 and 1.
             * @type {Number}
             */
            this.alpha = alpha;
        };

        /**
         * The color white.
         * @type {Color}
         * @constant
         */
        Color.WHITE = new Color(1, 1, 1, 1);

        /**
         * The color black.
         * @type {Color}
         * @constant
         */
        Color.BLACK = new Color(0, 0, 0, 1);

        /**
         * The color red.
         * @type {Color}
         * @constant
         */
        Color.RED = new Color(1, 0, 0, 1);

        /**
         * The color green.
         * @type {Color}
         * @constant
         */
        Color.GREEN = new Color(0, 1, 0, 1);

        /**
         * The color blue.
         * @type {Color}
         * @constant
         */
        Color.BLUE = new Color(0, 0, 1, 1);

        /**
         * The color cyan.
         * @type {Color}
         * @constant
         */
        Color.CYAN = new Color(0, 1, 1, 1);

        /**
         * The color yellow.
         * @type {Color}
         * @constant
         */
        Color.YELLOW = new Color(1, 1, 0, 1);

        /**
         * The color magenta.
         * @type {Color}
         * @constant
         */
        Color.MAGENTA = new Color(1, 0, 1, 1);

        /**
         * A light gray (75% white).
         * @type {Color}
         */
        Color.LIGHT_GRAY = new Color(0.75, 0.75, 0.75, 1);

        /**
         * A medium gray (50% white).
         * @type {Color}
         */
        Color.MEDIUM_GRAY = new Color(0.5, 0.5, 0.5, 1);

        /**
         * A dark gray (25% white).
         * @type {Color}
         */
        Color.DARK_GRAY = new Color(0.25, 0.25, 0.25, 1);

        /**
         * A transparent color.
         * @type {Color}
         */
        Color.TRANSPARENT = new Color(0, 0, 0, 0);

        /**
         * Assigns the components of this color.
         * @param {Number} red The red component, a number between 0 and 1.
         * @param {Number} green The green component, a number between 0 and 1.
         * @param {Number} blue The blue component, a number between 0 and 1.
         * @param {Number} alpha The alpha component, a number between 0 and 1.
         * @returns {Color} This color with the specified components assigned.
         */
        Color.prototype.set = function (red, green, blue, alpha) {
            this.red = red;
            this.green = green;
            this.blue = blue;
            this.alpha = alpha;

            return this;
        };

        /**
         * Copies the components of a specified color to this color.
         * @param {Color} color The color to copy.
         * @returns {Color} This color set to the red, green, blue and alpha values of the specified color.
         * @throws {ArgumentError} If the specified color is null or undefined.
         */
        Color.prototype.copy = function (color) {
            if (!color) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Color", "copy", "missingColor"));
            }

            this.red = color.red;
            this.green = color.green;
            this.blue = color.blue;
            this.alpha = color.alpha;

            return this;
        };

        /**
         * Create a copy of this color.
         * @returns {Color} A new instance containing the color components of this color.
         */
        Color.prototype.clone = function () {
            return new Color(this.red, this.green, this.blue, this.alpha);
        };

        /**
         * Returns this color's components premultiplied by this color's alpha component.
         * @param {Float32Array} array A pre-allocated array in which to return the color components.
         * @returns {Float32Array} This colors premultiplied components as an array, in the order RGBA.
         */
        Color.prototype.premultipliedComponents = function (array) {
            var a = this.alpha;

            array[0] = this.red * a;
            array[1] = this.green * a;
            array[2] = this.blue * a;
            array[3] = a;

            return array;
        };

        /**
         * Construct a color from an array of color components expressed as byte values.
         * @param {Uint8Array} bytes A four-element array containing the red, green, blue and alpha color
         * components each in the range [0, 255];
         * @returns {Color} The constructed color.
         */
        Color.colorFromByteArray = function (bytes) {
            return new Color(bytes[0] / 255, bytes[1] / 255, bytes[2] / 255, bytes[3] / 255);
        };

        /**
         * Construct a color from specified color components expressed as byte values.
         * @param {number} redByte The red component in the range [0, 255].
         * @param {number} greenByte The green component in the range [0, 255].
         * @param {number} blueByte The blue component in the range [0, 255].
         * @param {number} alphaByte The alpha component in the range [0, 255].
         * @returns {Color} The constructed color.
         */
        Color.colorFromBytes = function (redByte, greenByte, blueByte, alphaByte) {
            return new Color(redByte / 255, greenByte / 255, blueByte / 255, alphaByte / 255);
        };

        Color.colorFromHex = function(color) {
            var red = parseInt(color.substring(0, 2), 16);
            var green = parseInt(color.substring(2,4), 16);
            var blue = parseInt(color.substring(4,6), 16);
            var alpha = parseInt(color.substring(6,8), 16);
            return Color.colorFromBytes(red, green, blue, alpha);
        };

        Color.colorFromKmlHex = function(color) {
            color = color.split("").reverse().join("");
            return Color.colorFromHex(color);
        };

        /**
         * Computes and sets this color to the next higher RBG color. If the color overflows, this color is set to
         * (1 / 255, 0, 0, *), where * indicates the current alpha value.
         * @returns {Color} This color, set to the next possible color.
         */
        Color.prototype.nextColor = function () {
            var rb = Math.round(this.red * 255),
                gb = Math.round(this.green * 255),
                bb = Math.round(this.blue * 255);

            if (rb < 255) {
                this.red = (rb + 1) / 255;
            } else if (gb < 255) {
                this.red = 0;
                this.green = (gb + 1) / 255;
            } else if (bb < 255) {
                this.red = 0;
                this.green = 0;
                this.blue = (bb + 1) / 255;
            } else {
                this.red = 1 / 255;
                this.green = 0;
                this.blue = 0;
            }

            return this;
        };

        /**
         * Indicates whether this color is equal to a specified color after converting the floating-point component
         * values of each color to byte values.
         * @param {Color} color The color to test,
         * @returns {Boolean} true if the colors are equal, otherwise false.
         */
        Color.prototype.equals = function (color) {
            var rbA = Math.round(this.red * 255),
                gbA = Math.round(this.green * 255),
                bbA = Math.round(this.blue * 255),
                abA = Math.round(this.alpha * 255),
                rbB = Math.round(color.red * 255),
                gbB = Math.round(color.green * 255),
                bbB = Math.round(color.blue * 255),
                abB = Math.round(color.alpha * 255);

            return rbA === rbB && gbA === gbB && bbA === bbB && abA === abB;
        };

        /**
         * Indicates whether this color is equal to another color expressed as an array of bytes.
         * @param {Uint8Array} bytes The red, green, blue and alpha color components.
         * @returns {Boolean} true if the colors are equal, otherwise false.
         */
        Color.prototype.equalsBytes = function (bytes) {
            var rb = Math.round(this.red * 255),
                gb = Math.round(this.green * 255),
                bb = Math.round(this.blue * 255),
                ab = Math.round(this.alpha * 255);

            return rb === bytes[0] && gb === bytes[1] && bb === bytes[2] && ab === bytes[3];
        };

        /**
         * Returns a string representation of this color, indicating the byte values corresponding to this color's
         * floating-point component values.
         * @returns {String}
         */
        Color.prototype.toByteString = function () {
            var rb = Math.round(this.red * 255),
                gb = Math.round(this.green * 255),
                bb = Math.round(this.blue * 255),
                ab = Math.round(this.alpha * 255);

            return "(" + rb + "," + gb + "," + bb + "," + ab + ")";
        };

        /**
         * Create a hex color string that CSS can use. Optionally, inhibit capturing alpha,
         * because some uses reject a four-component color specification.
         * @param {Boolean} isUsingAlpha Enable the use of an alpha component.
         * @returns {string} A color string suitable for CSS.
         */
        Color.prototype.toHexString = function(isUsingAlpha) {
            // Use Math.ceil() to get 0.75 to map to 0xc0. This is important if the display is dithering.
            var redHex = Math.ceil(this.red * 255).toString(16),
                greenHex = Math.ceil(this.green * 255).toString(16),
                blueHex = Math.ceil(this.blue * 255).toString(16),
                alphaHex = Math.ceil(this.alpha * 255).toString(16);

            var result = "#";
            result += (redHex.length < 2) ? ('0' + redHex) : redHex;
            result += (greenHex.length < 2) ? ('0' + greenHex) : greenHex;
            result += (blueHex.length < 2) ? ('0' + blueHex) : blueHex;
            if (isUsingAlpha) {
                result += (alphaHex.length < 2) ? ('0' + alphaHex) : alphaHex;
            }

            return result;
        };

        /**
         * Create a rgba color string that CSS can use.
         * @returns {string} A color string suitable for CSS.
         */
        Color.prototype.toRGBAString = function () {
            var red = Math.floor(this.red * 255),
                green = Math.floor(this.green * 255),
                blue = Math.floor(this.blue * 255);

            return 'rgba(' + red + ' ,' + green + ' ,' + blue + ' ,' + this.alpha + ')';
        };

        return Color;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports Rectangle
 * @version $Id: Rectangle.js 3174 2015-06-10 19:36:49Z tgaskins $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(0)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Logger) {
        "use strict";

        /**
         * Constructs a rectangle with a specified origin and size.
         * @alias Rectangle
         * @constructor
         * @classdesc Represents a rectangle in 2D Cartesian coordinates.
         * @param {Number} x The X coordinate of the rectangle's origin.
         * @param {Number} y The Y coordinate of the rectangle's origin.
         * @param {Number} width The rectangle's width.
         * @param {Number} height The rectangle's height.
         */
        var Rectangle = function (x, y, width, height) {

            /**
             * The X coordinate of this rectangle's origin.
             * @type {Number}
             */
            this.x = x;

            /**
             * The Y coordinate of this rectangle's origin.
             * @type {Number}
             */
            this.y = y;

            /**
             * This rectangle's width.
             * @type {Number}
             */
            this.width = width;

            /**
             * This rectangle's height.
             * @type {Number}
             */
            this.height = height;
        };

        /**
         * Sets all this rectangle's properties.
         * @param {Number} x The X coordinate of the rectangle's origin.
         * @param {Number} y The Y coordinate of the rectangle's origin.
         * @param {Number} width The rectangle's width.
         * @param {Number} height The rectangle's height.
         */
        Rectangle.prototype.set = function(x, y, width, height) {
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
        };

        /**
         * Returns the minimum X value of this rectangle.
         * @returns {Number} The rectangle's minimum X value.
         */
        Rectangle.prototype.getMinX = function () {
            return this.x;
        };

        /**
         * Returns the minimum Y value of this rectangle.
         * @returns {Number} The rectangle's minimum Y value.
         */
        Rectangle.prototype.getMinY = function () {
            return this.y;
        };

        /**
         * Returns the maximum X value of this rectangle.
         * @returns {Number} The rectangle's maximum X value.
         */
        Rectangle.prototype.getMaxX = function () {
            return this.x + this.width;
        };

        /**
         * Returns the maximum Y value of this rectangle.
         * @returns {Number} The rectangle's maximum Y value.
         */
        Rectangle.prototype.getMaxY = function () {
            return this.y + this.height;
        };

        /**
         * Indicates whether this rectangle contains a specified point.
         * @param {Vec2} point The point to test.
         * @returns {Boolean} true if this rectangle contains the specified point, otherwise false.
         */
        Rectangle.prototype.containsPoint = function (point) {
            return point[0] >= this.x && point[0] <= (this.x + this.width)
                && point[1] >= this.y && point[1] <= (this.y + this.height);
        };
        /**
         *
         * Indicates whether this rectangle intersects a specified one.
         * @param {Rectangle} that The rectangle to test.
         * @returns {Boolean} true if this triangle and the specified one intersect, otherwise false.
         */
        Rectangle.prototype.intersects = function (that) {
            if ((that.x + that.width) < this.x)
                return false;

            if (that.x > (this.x + this.width))
                return false;

            if ((that.y + that.height) < this.y)
                return false;

            //noinspection RedundantIfStatementJS
            if (that.y > (this.y + this.height))
                return false;

            return true;
        };

        /**
         * Indicates whether this rectangle intersects any rectangle in a specified array of rectangles.
         * @param {Rectangle[]} rectangles The rectangles to test intersection with.
         * @returns {Boolean} true if this rectangle intersects any rectangle in the array, otherwise false.
         */
        Rectangle.prototype.intersectsRectangles = function (rectangles) {
            if (rectangles) {
                for (var i = 0; i < rectangles.length; i++){
                    if (this.intersects(rectangles[i])) {
                        return true;
                    }
                }
            }

            return false;
        };

        /**
         * Returns a string representation of this object.
         * @returns {String} A string representation of this object.
         */
        Rectangle.prototype.toString = function () {
            return this.x + ", " + this.y + ", " + this.width + ", " + this.height;
        };

        return Rectangle;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports Position
 * @version $Id: Position.js 2933 2015-03-27 01:18:24Z tgaskins $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(6),
        __webpack_require__(1),
        __webpack_require__(7),
        __webpack_require__(0),
        __webpack_require__(4)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Angle,
              ArgumentError,
              Location,
              Logger,
              WWMath) {
        "use strict";

        /**
         * Constructs a position from a specified latitude and longitude in degrees and altitude in meters.
         * @alias Position
         * @constructor
         * @classdesc Represents a latitude, longitude, altitude triple, with latitude and longitude in degrees and
         * altitude in meters.
         * @param {Number} latitude The latitude in degrees.
         * @param {Number} longitude The longitude in degrees.
         * @param {Number} altitude The altitude in meters.
         */
        var Position = function (latitude, longitude, altitude) {
            /**
             * The latitude in degrees.
             * @type {Number}
             */
            this.latitude = latitude;
            /**
             * The longitude in degrees.
             * @type {Number}
             */
            this.longitude = longitude;
            /**
             * The altitude in meters.
             * @type {Number}
             */
            this.altitude = altitude;
        };

        /**
         * A Position with latitude, longitude and altitude all 0.
         * @constant
         * @type {Position}
         */
        Position.ZERO = new Position(0, 0, 0);

        /**
         * Creates a position from angles specified in radians.
         * @param {Number} latitudeRadians The latitude in radians.
         * @param {Number} longitudeRadians The longitude in radians.
         * @param {Number} altitude The altitude in meters.
         * @returns {Position} The new position with latitude and longitude in degrees.
         */
        Position.fromRadians = function (latitudeRadians, longitudeRadians, altitude) {
            return new Position(
                latitudeRadians * Angle.RADIANS_TO_DEGREES,
                longitudeRadians * Angle.RADIANS_TO_DEGREES,
                altitude);
        };

        /**
         * Sets this position to the latitude, longitude and altitude of a specified position.
         * @param {Position} position The position to copy.
         * @returns {Position} This position, set to the values of the specified position.
         * @throws {ArgumentError} If the specified position is null or undefined.
         */
        Position.prototype.copy = function (position) {
            if (!position) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Position", "copy", "missingPosition"));
            }

            this.latitude = position.latitude;
            this.longitude = position.longitude;
            this.altitude = position.altitude;

            return this;
        };

        /**
         * Indicates whether this position has the same latitude, longitude and altitude as a specified position.
         * @param {Position} position The position to compare with this one.
         * @returns {Boolean} true if this position is equal to the specified one, otherwise false.
         */
        Position.prototype.equals = function (position) {
            return position
                && position.latitude === this.latitude
                && position.longitude === this.longitude
                && position.altitude === this.altitude;
        };

        /**
         * Computes a position along a great circle path at a specified distance between two specified positions.
         * @param {Number} amount The fraction of the path between the two positions at which to compute the new
         * position. This number should be between 0 and 1. If not, it is clamped to the nearest of those values.
         * @param {Position} position1 The starting position.
         * @param {Position} position2 The ending position.
         * @param {Position} result A Position in which to return the result.
         * @returns {Position} The specified result position.
         * @throws {ArgumentError} If either specified position or the result argument is null or undefined.
         */
        Position.interpolateGreatCircle = function (amount, position1, position2, result) {
            if (!position1 || !position2) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Position", "interpolateGreatCircle", "missingPosition"));
            }

            if (!result) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Position", "interpolateGreatCircle", "missingResult"));
            }

            var t = WWMath.clamp(amount, 0, 1);
            result.altitude = WWMath.interpolate(t, position1.altitude, position2.altitude);

            //noinspection JSCheckFunctionSignatures
            Location.interpolateGreatCircle(t, position1, position2, result);

            return result;
        };

        /**
         * Computes a position along a rhumb path at a specified distance between two specified positions.
         * @param {Number} amount The fraction of the path between the two positions at which to compute the new
         * position. This number should be between 0 and 1. If not, it is clamped to the nearest of those values.
         * @param {Position} position1 The starting position.
         * @param {Position} position2 The ending position.
         * @param {Position} result A Position in which to return the result.
         * @returns {Position} The specified result position.
         * @throws {ArgumentError} If either specified position or the result argument is null or undefined.
         */
        Position.interpolateRhumb = function (amount, position1, position2, result) {
            if (!position1 || !position2) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Position", "interpolateRhumb", "missingPosition"));
            }

            if (!result) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Position", "interpolateRhumb", "missingResult"));
            }

            var t = WWMath.clamp(amount, 0, 1);
            result.altitude = WWMath.interpolate(t, position1.altitude, position2.altitude);

            //noinspection JSCheckFunctionSignatures
            Location.interpolateRhumb(t, position1, position2, result);

            return result;
        };

        /**
         * Computes a position along a linear path at a specified distance between two specified positions.
         * @param {Number} amount The fraction of the path between the two positions at which to compute the new
         * position. This number should be between 0 and 1. If not, it is clamped to the nearest of those values.
         * @param {Position} position1 The starting position.
         * @param {Position} position2 The ending position.
         * @param {Position} result A Position in which to return the result.
         * @returns {Position} The specified result position.
         * @throws {ArgumentError} If either specified position or the result argument is null or undefined.
         */
        Position.interpolateLinear = function (amount, position1, position2, result) {
            if (!position1 || !position2) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Position", "interpolateLinear", "missingPosition"));
            }

            if (!result) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Position", "interpolateLinear", "missingResult"));
            }

            var t = WWMath.clamp(amount, 0, 1);
            result.altitude = WWMath.interpolate(t, position1.altitude, position2.altitude);

            //noinspection JSCheckFunctionSignatures
            Location.interpolateLinear(t, position1, position2, result);

            return result;
        };

        /**
         * Returns a string representation of this position.
         * @returns {String}
         */
        Position.prototype.toString = function () {
            return "(" + this.latitude.toString() + "\u00b0, " + this.longitude.toString() + "\u00b0, "
                + this.altitude.toString() + ")";
        };

        return Position;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports GpuProgram
 * @version $Id: GpuProgram.js 3345 2015-07-28 20:28:35Z dcollins $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(1),
        __webpack_require__(8),
        __webpack_require__(80),
        __webpack_require__(0)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
              Color,
              GpuShader,
              Logger) {
        "use strict";

        /**
         * Constructs a GPU program with specified source code for vertex and fragment shaders.
         * This constructor is intended to be called only by subclasses.
         * <p>
         * This constructor creates WebGL shaders for the specified shader sources and attaches them to a new GLSL
         * program. The method compiles the shaders and then links the program if compilation is successful. Use the
         * [DrawContext.bindProgram]{@link DrawContext#bindProgram} function to make the program current during rendering.
         *
         * @alias GpuProgram
         * @constructor
         * @classdesc
         * Represents an OpenGL shading language (GLSL) shader program and provides methods for identifying and
         * accessing shader variables. Shader programs are created by instances of this class and made current when the
         * DrawContext.bindProgram function is invoked.
         * <p>
         * This is an abstract class and not intended to be created directly.
         *
         * @param {WebGLRenderingContext} gl The current WebGL context.
         * @param {String} vertexShaderSource The source code for the vertex shader.
         * @param {String} fragmentShaderSource The source code for the fragment shader.
         * @param {String[]} attributeBindings An array of attribute variable names whose bindings are to be explicitly
         * specified. Each name is bound to its corresponding index in the array. May be null, in which case the
         * linker determines all the bindings.
         * @throws {ArgumentError} If either source is null or undefined, the shaders cannot be compiled, or linking of
         * the compiled shaders into a program fails.
         */
        var GpuProgram = function (gl, vertexShaderSource, fragmentShaderSource, attributeBindings) {
            if (!vertexShaderSource || !fragmentShaderSource) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "GpuProgram", "constructor",
                    "The specified shader source is null or undefined."));
            }

            var program, vShader, fShader;

            try {
                vShader = new GpuShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
                fShader = new GpuShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
            } catch (e) {
                if (vShader)
                    vShader.dispose(gl);
                if (fShader)
                    fShader.dispose(gl);

                throw e;
            }

            program = gl.createProgram();
            if (!program) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "GpuProgram", "constructor",
                    "Unable to create shader program."));
            }

            gl.attachShader(program, vShader.shaderId);
            gl.attachShader(program, fShader.shaderId);

            if (attributeBindings) {
                for (var i = 0, len = attributeBindings.length; i < len; i++) {
                    gl.bindAttribLocation(program, i, attributeBindings[i]);
                }
            }

            if (!this.link(gl, program)) {
                // Get the info log before deleting the program.
                var infoLog = gl.getProgramInfoLog(program);

                gl.detachShader(program, vShader.shaderId);
                gl.detachShader(program, fShader.shaderId);
                gl.deleteProgram(program);
                vShader.dispose(gl);
                fShader.dispose(gl);

                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "GpuProgram", "constructor",
                    "Unable to link shader program: " + infoLog));
            }

            /**
             * Indicates the WebGL program object associated with this GPU program.
             * @type {WebGLProgram}
             * @readonly
             */
            this.programId = program;

            // Internal. Intentionally not documented. These will be filled in as attribute locations are requested.
            this.attributeLocations = {};
            this.uniformLocations = {};

            // Internal. Intentionally not documented.
            this.vertexShader = vShader;

            // Internal. Intentionally not documented.
            this.fragmentShader = fShader;

            // Internal. Intentionally not documented.
            this.size = vertexShaderSource.length + fragmentShaderSource.length;

            // Internal. Intentionally not documented.
            this.scratchArray = new Float32Array(16);
        };

        /**
         * Releases this GPU program's WebGL program and associated shaders. Upon return this GPU program's WebGL
         * program ID is 0 as is that of the associated shaders.
         *
         * @param {WebGLRenderingContext} gl The current WebGL context.
         */
        GpuProgram.prototype.dispose = function (gl) {
            if (this.programId) {
                if (this.vertexShader) {
                    gl.detachShader(this.programId, this.vertexShader.shaderId);
                }
                if (this.fragmentShader) {
                    gl.detachShader(this.programId, this.fragmentShader.shaderId);
                }

                gl.deleteProgram(this.programId);
                delete this.programId;
            }

            if (this.vertexShader) {
                this.vertexShader.dispose(gl);
                delete this.vertexShader;
            }

            if (this.fragmentShader) {
                this.fragmentShader.dispose(gl);
                delete this.fragmentShader;
            }

            this.attributeLocations = {};
            this.uniformLocations = {};
        };

        /**
         * Returns the GLSL attribute location of a specified attribute name.
         *
         * @param {WebGLRenderingContext} gl The current WebGL context.
         * @param {String} attributeName The name of the attribute whose location is determined.
         * @returns {Number} The WebGL attribute location of the specified attribute, or -1 if the attribute is not
         * found.
         * @throws {ArgumentError} If the specified attribute name is null, empty or undefined.
         */
        GpuProgram.prototype.attributeLocation = function (gl, attributeName) {
            if (!attributeName || attributeName.length == 0) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "GpuProgram", "attributeLocation",
                    "The specified attribute name is null, undefined or empty."));
            }

            var location = this.attributeLocations[attributeName];
            if (!location) {
                location = gl.getAttribLocation(this.programId, attributeName);
                this.attributeLocations[attributeName] = location;
            }

            return location;
        };

        /**
         * Returns the GLSL uniform location of a specified uniform name.
         *
         * @param {WebGLRenderingContext} gl The current WebGL context.
         * @param {String} uniformName The name of the uniform variable whose location is determined.
         * @returns {WebGLUniformLocation} The WebGL uniform location of the specified uniform variable,
         * or -1 if the uniform is not found.
         * @throws {ArgumentError} If the specified uniform name is null, empty or undefined.
         */
        GpuProgram.prototype.uniformLocation = function (gl, uniformName) {
            if (!uniformName || uniformName.length == 0) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "GpuProgram", "uniformLocation",
                    "The specified uniform name is null, undefined or empty."));
            }

            var location = this.uniformLocations[uniformName];
            if (!location) {
                location = gl.getUniformLocation(this.programId, uniformName);
                this.uniformLocations[uniformName] = location;
            }

            return location;
        };

        /**
         * Links a specified GLSL program. This method is not meant to be called by applications. It is called
         * internally as needed.
         *
         * @param {WebGLRenderingContext} gl The current WebGL context.
         * @param {WebGLProgram} program The WebGL program.
         * @returns {Boolean} true if linking was successful, otherwise false.
         * @protected
         */
        GpuProgram.prototype.link = function (gl, program) {
            gl.linkProgram(program);

            return gl.getProgramParameter(program, gl.LINK_STATUS);
        };

        /**
         * Loads a specified matrix as the value of a GLSL 4x4 matrix uniform variable with the specified location.
         * <p>
         * This functions converts the matrix into column-major order prior to loading its components into the GLSL
         * uniform variable, but does not modify the specified matrix.
         *
         * @param {WebGLRenderingContext} gl The current WebGL context.
         * @param {Matrix} matrix The matrix to load.
         * @param {WebGLUniformLocation} location The location of the uniform variable in the currently bound GLSL program.
         * @throws {ArgumentError} If the specified matrix is null or undefined.
         */
        GpuProgram.prototype.loadUniformMatrix = function (gl, matrix, location) {
            if (!matrix) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "GpuProgram", "loadUniformMatrix",
                    "missingMatrix"));
            }

            var columnMajorArray = matrix.columnMajorComponents(this.scratchArray);
            gl.uniformMatrix4fv(location, false, columnMajorArray);
        };

        /**
         * Loads a specified color as the value of a GLSL vec4 uniform variable with the specified location.
         * <p>
         * This function multiplies the red, green and blue components by the alpha component prior to loading the color
         * in the GLSL uniform variable, but does not modify the specified color.
         *
         * @param {WebGLRenderingContext} gl The current WebGL context.
         * @param {Color} color The color to load.
         * @param {WebGLUniformLocation} location The location of the uniform variable in the currently bound GLSL program.
         * @throws {ArgumentError} If the specified color is null or undefined.
         */
        GpuProgram.prototype.loadUniformColor = function (gl, color, location) {
            if (!color) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "GpuProgram", "loadUniformColor",
                    "missingColor"));
            }

            var premul = color.premultipliedComponents(this.scratchArray);
            gl.uniform4f(location, premul[0], premul[1], premul[2], premul[3]);
        };

        /**
         * Loads the specified RGBA color components as the value of a GLSL vec4 uniform variable with the specified
         * location.
         * <p>
         * This function multiplies the red, green and blue components by the alpha component prior to loading the color
         * in the GLSL uniform variable.
         *
         * @param {WebGLRenderingContext} gl The current WebGL context.
         * @param {Number} red The red component, a number between 0 and 1.
         * @param {Number} green The green component, a number between 0 and 1.
         * @param {Number} blue The blue component, a number between 0 and 1.
         * @param {Number} alpha The alpha component, a number between 0 and 1.
         * @param {WebGLUniformLocation} location The location of the uniform variable in the currently bound GLSL program.
         */
        GpuProgram.prototype.loadUniformColorComponents = function (gl, red, green, blue, alpha, location) {
            gl.uniform4f(location, red * alpha, green * alpha, blue * alpha, alpha);
        };

        return GpuProgram;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports Tile
 * @version $Id: Tile.js 3125 2015-05-29 14:43:25Z tgaskins $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(1),
        __webpack_require__(36),
        __webpack_require__(0),
        __webpack_require__(3),
        __webpack_require__(2),
        __webpack_require__(28)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
              BoundingBox,
              Logger,
              Sector,
              Vec3,
              WWUtil) {
        "use strict";

        /**
         * Constructs a tile for a specified sector, level, row and column.
         * @alias Tile
         * @constructor
         * @classdesc Represents a tile of terrain or imagery.
         * Provides a base class for texture tiles used by tiled image layers and elevation tiles used by elevation models.
         * Applications typically do not interact with this class.
         * @param {Sector} sector The sector represented by this tile.
         * @param {Level} level This tile's level in a tile pyramid.
         * @param {Number} row This tile's row in the specified level in a tile pyramid.
         * @param {Number} column This tile's column in the specified level in a tile pyramid.
         * @throws {ArgumentError} If the specified sector or level is null or undefined or the row or column arguments
         * are less than zero.
         */
        var Tile = function (sector, level, row, column) {
            if (!sector) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Tile", "constructor", "missingSector"));
            }

            if (!level) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Tile", "constructor",
                        "The specified level is null or undefined."));
            }

            if (row < 0 || column < 0) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Tile", "constructor",
                        "The specified row or column is less than zero."));
            }

            /**
             * The sector represented by this tile.
             * @type {Sector}
             * @readonly
             */
            this.sector = sector;

            /**
             * The level at which this tile lies in a tile pyramid.
             * @type {Number}
             * @readonly
             */
            this.level = level;

            /**
             * The row in this tile's level in which this tile lies in a tile pyramid.
             * @type {Number}
             * @readonly
             */
            this.row = row;

            /**
             * The column in this tile's level in which this tile lies in a tile pyramid.
             * @type {Number}
             * @readonly
             */
            this.column = column;

            /**
             * The width in pixels or cells of this tile's associated resource.
             * @type {Number}
             */
            this.tileWidth = level.tileWidth;

            /**
             * The height in pixels or cells of this tile's associated resource.
             * @type {Number}
             */
            this.tileHeight = level.tileHeight;

            /**
             * The size in radians of pixels or cells of this tile's associated resource.
             * @type {Number}
             */
            this.texelSize = level.texelSize;

            /**
             * A key that uniquely identifies this tile within a level set.
             * @type {String}
             * @readonly
             */
            this.tileKey = level.levelNumber.toString() + "." + row.toString() + "." + column.toString();

            /**
             * The Cartesian bounding box of this tile.
             * @type {BoundingBox}
             */
            this.extent = null;

            /**
             * The tile's local origin in model coordinates. Any model coordinate points associates with the tile
             * should be relative to this point.
             * @type {Vec3}
             */
            this.referencePoint = null;

            /**
             * This tile's opacity.
             * @type {Number}
             * @default 1
             */
            this.opacity = 1;

            // Internal use only. Intentionally not documented.
            this.samplePoints = null;

            // Internal use only. Intentionally not documented.
            this.sampleElevations = null;

            // Internal use only. Intentionally not documented.
            this.updateTimestamp = null;

            // Internal use only. Intentionally not documented.
            this.updateVerticalExaggeration = null;

            // Internal use only. Intentionally not documented.
            this.updateGlobeStateKey = null;
        };

        /**
         * Indicates whether this tile is equivalent to a specified tile.
         * @param {Tile} that The tile to check equivalence with.
         * @returns {boolean} true if this tile is equivalent to the specified one, false if
         * they are not equivalent or the specified tile is null or undefined.
         */
        Tile.prototype.isEqual = function (that) {
            if (!that)
                return false;

            if (!that.tileKey)
                return false;

            return this.tileKey == that.tileKey;
        };

        /**
         * Returns the size of this tile in bytes.
         * @returns {Number} The size of this tile in bytes.
         */
        Tile.prototype.size = function () {
            return 4 // child pointer
                + (4 + 32) // sector
                + 4 //level pointer (the level is common to the layer or tessellator so is not included here)
                + 8 // row and column
                + 8 // texel size
                + (4 + 32) // reference point
                + (4 + 676) // bounding box
                + 8 // min and max height
                + (4 + 32) // nearest point
                + 8; // extent timestamp and vertical exaggeration
        };

        /**
         * Computes an approximate distance from this tile to a specified vector.
         * @param {Vec3} vector The vector to compute the distance to.
         * @returns {number} The distance between this tile and the vector.
         * @throws {ArgumentError} If the specified vector is null or undefined.
         */
        Tile.prototype.distanceTo = function (vector) {
            if (!vector) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Tile", "distanceTo", "missingVector"));
            }

            var px = vector[0], py = vector[1], pz = vector[2],
                dx, dy, dz,
                points = this.samplePoints,
                distance = Number.POSITIVE_INFINITY;

            for (var i = 0, len = points.length; i < len; i += 3) {
                dx = px - points[i];
                dy = py - points[i + 1];
                dz = pz - points[i + 2];
                distance = Math.min(distance, dx * dx + dy * dy + dz * dz); // minimum squared distance
            }

            return Math.sqrt(distance);
        };

        /**
         * Returns the four children formed by subdividing this tile.
         * @param {Level} level The level of the children.
         * @param {TileFactory} tileFactory The tile factory to use to create the children.
         * @returns {Tile[]} An array containing the four child tiles.
         * @throws {ArgumentError} If the specified tile factory or level is null or undefined.
         */
        Tile.prototype.subdivide = function (level, tileFactory) {
            if (!level) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Tile", "subdivide",
                        "The specified level is null or undefined."));
            }

            if (!tileFactory) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Tile", "subdivide",
                        "The specified tile factory is null or undefined."));
            }

            var latMin = this.sector.minLatitude,
                latMax = this.sector.maxLatitude,
                latMid = this.sector.centroidLatitude(),

                lonMin = this.sector.minLongitude,
                lonMax = this.sector.maxLongitude,
                lonMid = this.sector.centroidLongitude(),

                subRow,
                subCol,
                childSector,
                children = [];

            subRow = 2 * this.row;
            subCol = 2 * this.column;
            childSector = new Sector(latMin, latMid, lonMin, lonMid);
            children.push(tileFactory.createTile(childSector, level, subRow, subCol));

            subRow = 2 * this.row;
            subCol = 2 * this.column + 1;
            childSector = new Sector(latMin, latMid, lonMid, lonMax);
            children.push(tileFactory.createTile(childSector, level, subRow, subCol));

            subRow = 2 * this.row + 1;
            subCol = 2 * this.column;
            childSector = new Sector(latMid, latMax, lonMin, lonMid);
            children.push(tileFactory.createTile(childSector, level, subRow, subCol));

            subRow = 2 * this.row + 1;
            subCol = 2 * this.column + 1;
            childSector = new Sector(latMid, latMax, lonMid, lonMax);
            children.push(tileFactory.createTile(childSector, level, subRow, subCol));

            return children;
        };

        /**
         * Returns the four children formed by subdividing this tile, drawing those children from a specified cache
         * if they exist there.
         * @param {Level} level The level of the children.
         * @param {TileFactory} tileFactory The tile factory to use to create the children.
         * @param {MemoryCache} cache A memory cache that may contain pre-existing child tiles. If non-null, the
         * cache is checked for a child collection prior to creating that tile. If one exists
         * in the cache it is returned rather than creating a new collection of children. If a new collection is
         * created, it is added to the cache.
         * @returns {Tile[]} An array containing the four tiles.
         * @throws {ArgumentError} If the specified tile factory or level is null or undefined.
         */
        Tile.prototype.subdivideToCache = function (level, tileFactory, cache) {
            if (!level) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Tile", "subdivideToCache",
                        "The specified level is null or undefined."));
            }

            if (!tileFactory) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Tile", "subdivideToCache",
                        "The specified tile factory is null or undefined."));
            }

            var childList = cache ? cache.entryForKey(this.tileKey) : null;
            if (!childList) {
                childList = this.subdivide(level, tileFactory);
                if (childList && cache) {
                    cache.putEntry(this.tileKey, childList, 4 * childList[0].size());
                }
            }

            return childList;
        };

        /**
         * Indicates whether this tile should be subdivided based on the current navigation state and a specified
         * detail factor.
         * @param {DrawContext} dc The current draw context.
         * @param {Number} detailFactor The detail factor to consider.
         * @returns {boolean} true If the tile should be subdivided, otherwise false.
         */
        Tile.prototype.mustSubdivide = function (dc, detailFactor) {
            // Split when the cell height (length of a texel) becomes greater than the specified fraction of the eye
            // distance. The fraction is specified as a power of 10. For example, a detail factor of 3 means split when
            // the cell height becomes more than one thousandth of the eye distance. Another way to say it is, use the
            // current tile if the cell height is less than the specified fraction of the eye distance.
            //
            // Note: It's tempting to instead compare a screen pixel size to the texel size, but that calculation is
            // window-size dependent and results in selecting an excessive number of tiles when the window is large.

            var cellSize = dc.globe.equatorialRadius * this.texelSize,
                distance = this.distanceTo(dc.navigatorState.eyePoint),
                pixelSize = dc.navigatorState.pixelSizeAtDistance(distance);

            return cellSize > Math.max(detailFactor * pixelSize, 0.5);
        };

        /**
         * Updates this tile's frame-dependent properties as necessary, according to the specified draw context.
         * <p>
         * The tile's frame-dependent properties, include the extent (bounding volume). These properties are dependent
         * on the tile's sector and the elevation values currently in memory, and change when those dependencies change.
         * Therefore <code>update</code> must be called once per frame before the extent and any other frame-dependent
         * properties are used. <code>update</code> intelligently determines when it is necessary to recompute these
         * properties, and does nothing if the state of all dependencies has not changed since the last call.
         * @param {DrawContext} dc The current draw context.
         */
        Tile.prototype.update = function (dc) {
            var elevationTimestamp = dc.globe.elevationTimestamp(),
                verticalExaggeration = dc.verticalExaggeration,
                globeStateKey = dc.globeStateKey;

            if (this.updateTimestamp != elevationTimestamp
                || this.updateVerticalExaggeration != verticalExaggeration
                || this.updateGlobeStateKey != globeStateKey) {

                this.doUpdate(dc);
                dc.frameStatistics.incrementTileUpdateCount(1);

                // Set the geometry extent to the globe's elevation timestamp on which the geometry is based. This
                // ensures that the geometry timestamp can be reliably compared to the elevation timestamp in subsequent
                // frames.
                this.updateTimestamp = elevationTimestamp;
                this.updateVerticalExaggeration = verticalExaggeration;
                this.updateGlobeStateKey = globeStateKey;
            }
        };

        /**
         * Updates this tile's frame-dependent properties according to the specified draw context.
         * @param {DrawContext} dc The current draw context.
         * @protected
         */
        Tile.prototype.doUpdate = function (dc) {
            // Compute the minimum and maximum world coordinate height for this tile's sector by multiplying the minimum
            // and maximum elevations by the scene's vertical exaggeration. This ensures that the elevations to used
            // build the terrain are contained by this tile's extent. Use zero if the globe as no elevations in this
            // tile's sector.
            var globe = dc.globe,
                verticalExaggeration = dc.verticalExaggeration,
                extremes = globe.minAndMaxElevationsForSector(this.sector),
                minHeight = extremes ? (extremes[0] * verticalExaggeration) : 0,
                maxHeight = extremes ? (extremes[1] * verticalExaggeration) : 0;
            if (minHeight == maxHeight) {
                minHeight = maxHeight + 10; // TODO: Determine if this is necessary.
            }

            // Compute a bounding box for this tile that contains the terrain surface in the tile's coverage area.
            if (!this.extent) {
                this.extent = new BoundingBox();
            }
            this.extent.setToSector(this.sector, globe, minHeight, maxHeight);

            // Compute the cartesian points for a 3x3 geographic grid. This grid captures sufficiently close sample
            // points in order to estimate the distance from the viewer to this tile.
            if (!this.samplePoints) {
                this.sampleElevations = new Float64Array(9);
                this.samplePoints = new Float64Array(3 * this.sampleElevations.length);
            }
            WWUtil.fillArray(this.sampleElevations, 0.5 * (minHeight + maxHeight));
            globe.computePointsForGrid(this.sector, 3, 3, this.sampleElevations, Vec3.ZERO, this.samplePoints);

            // Compute the reference point used as a local coordinate origin for the tile.
            if (!this.referencePoint) {
                this.referencePoint = new Vec3(0, 0, 0);
            }

            globe.computePointFromPosition(this.sector.centroidLatitude(), this.sector.centroidLongitude(), 0,
                this.referencePoint);
        };

        /**
         * Computes a row number for a tile within a level given the tile's latitude.
         * @param {Number} delta The level's latitudinal tile delta in degrees.
         * @param {Number} latitude The tile's minimum latitude.
         * @returns {Number} The computed row number.
         */
        Tile.computeRow = function (delta, latitude) {
            var row = Math.floor((latitude + 90) / delta);

            // If latitude is at the end of the grid, subtract 1 from the computed row to return the last row.
            if (latitude == 90) {
                row -= 1;
            }

            return row;
        };

        /**
         * Computes a column number for a tile within a level given the tile's longitude.
         * @param {Number} delta The level's longitudinal tile delta in degrees.
         * @param {Number} longitude The tile's minimum longitude.
         * @returns {Number} The computed column number.
         */
        Tile.computeColumn = function (delta, longitude) {
            var col = Math.floor((longitude + 180) / delta);

            // If longitude is at the end of the grid, subtract 1 from the computed column to return the last column.
            if (longitude == 180) {
                col -= 1;
            }

            return col;
        };

        /**
         * Computes the last row number for a tile within a level given the tile's maximum latitude.
         * @param {Number} delta The level's latitudinal tile delta in degrees.
         * @param {Number} maxLatitude The tile's maximum latitude in degrees.
         * @returns {Number} The computed row number.
         */
        Tile.computeLastRow = function (delta, maxLatitude) {
            var row = Math.ceil((maxLatitude + 90) / delta - 1);

            // If max latitude is in the first row, set the max row to 0.
            if (maxLatitude + 90 < delta) {
                row = 0;
            }

            return row;
        };

        /**
         * Computes the last column number for a tile within a level given the tile's maximum longitude.
         * @param {Number} delta The level's longitudinal tile delta in degrees.
         * @param {Number} maxLongitude The tile's maximum longitude in degrees.
         * @returns {Number} The computed column number.
         */
        Tile.computeLastColumn = function (delta, maxLongitude) {
            var col = Math.ceil((maxLongitude + 180) / delta - 1);

            // If max longitude is in the first column, set the max column to 0.
            if (maxLongitude + 180 < delta) {
                col = 0;
            }

            return col;
        };

        /**
         * Computes a sector spanned by a tile with the specified level number, row and column.
         * @param {Level} level The tile's level number.
         * @param {Number} row The tile's row number.
         * @param {Number} column The tile's column number.
         * @returns {Sector} The sector spanned by the tile.
         * @throws {ArgumentError} If the specified level is null or undefined or the row or column are less than zero.
         */
        Tile.computeSector = function (level, row, column) {
            if (!level) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Tile", "computeSector", "missingLevel"));
            }

            if (row < 0 || column < 0) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Tile", "computeSector",
                        "The specified row or column is less than zero."));
            }

            var deltaLat = level.tileDelta.latitude,
                deltaLon = level.tileDelta.longitude,

                minLat = -90 + row * deltaLat,
                minLon = -180 + column * deltaLon,
                maxLat = minLat + deltaLat,
                maxLon = minLon + deltaLon;

            return new Sector(minLat, maxLat, minLon, maxLon);
        };

        /**
         * Creates all tiles for a specified level number.
         * @param {Level} level The level to create the tiles for.
         * @param {TileFactory} tileFactory The tile factory to use for creating tiles.
         * @param {Tile[]} result An array in which to return the results.
         * @throws {ArgumentError} If any argument is null or undefined.
         */
        Tile.createTilesForLevel = function (level, tileFactory, result) {
            if (!level) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Tile", "createTilesForLevel", "missingLevel"));
            }

            if (!tileFactory) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Tile", "createTilesForLevel",
                        "The specified tile factory is null or undefined"));
            }

            if (!result) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Tile", "createTilesForLevel", "missingResult"));
            }

            var deltaLat = level.tileDelta.latitude,
                deltaLon = level.tileDelta.longitude,

                sector = level.sector,
                firstRow = Tile.computeRow(deltaLat, sector.minLatitude),
                lastRow = Tile.computeRow(deltaLat, sector.maxLatitude),

                firstCol = Tile.computeColumn(deltaLon, sector.minLongitude),
                lastCol = Tile.computeColumn(deltaLon, sector.maxLongitude),

                firstRowLat = -90 + firstRow * deltaLat,
                firstRowLon = -180 + firstCol * deltaLon,

                minLat = firstRowLat,
                minLon,
                maxLat,
                maxLon;

            for (var row = firstRow; row <= lastRow; row += 1) {
                maxLat = minLat + deltaLat;
                minLon = firstRowLon;

                for (var col = firstCol; col <= lastCol; col += 1) {
                    maxLon = minLon + deltaLon;
                    var tileSector = new Sector(minLat, maxLat, minLon, maxLon),
                        tile = tileFactory.createTile(tileSector, level, row, col);
                    result.push(tile);

                    minLon = maxLon;
                }

                minLat = maxLat;
            }
        };

        return Tile;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports Line
 * @version $Id: Line.js 2935 2015-03-27 17:59:48Z tgaskins $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(1),
        __webpack_require__(0),
        __webpack_require__(2)], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
              Logger,
              Vec3) {
        "use strict";

        /**
         * Constructs a line from a specified origin and direction.
         * @alias Line
         * @constructor
         * @classdesc Represents a line in Cartesian coordinates.
         * @param {Vec3} origin The line's origin.
         * @param {Vec3} direction The line's direction.
         * @throws {ArgumentError} If either the origin or the direction are null or undefined.
         */
        var Line = function (origin, direction) {
            if (!origin) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "Line", "constructor",
                    "Origin is null or undefined."));
            }

            if (!direction) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "Line", "constructor",
                    "Direction is null or undefined."));
            }

            /**
             * This line's origin.
             * @type {Vec3}
             */
            this.origin = origin;

            /**
             * This line's direction.
             * @type {Vec3}
             */
            this.direction = direction;
        };

        /**
         * Creates a line given two specified endpoints.
         * @param {Vec3} pointA The first endpoint.
         * @param {Vec3} pointB The second endpoint.
         * @return {Line} The new line.
         * @throws {ArgumentError} If either endpoint is null or undefined.
         */
        Line.fromSegment = function (pointA, pointB) {
            if (!pointA || !pointB) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Line", "fromSegment", "missingPoint"));
            }

            var origin = new Vec3(pointA[0], pointA[1], pointA[2]),
                direction = new Vec3(pointB[0] - pointA[0], pointB[1] - pointA[1], pointB[2] - pointA[2]);

            return new Line(origin, direction);
        };

        /**
         * Computes a Cartesian point a specified distance along this line.
         * @param {Number} distance The distance from this line's origin at which to compute the point.
         * @param {Vec3} result A pre-allocated {@Link Vec3} instance in which to return the computed point.
         * @return {Vec3} The specified result argument containing the computed point.
         * @throws {ArgumentError} If the specified result argument is null or undefined.
         */
        Line.prototype.pointAt = function (distance, result) {
            if (!result) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "Line", "pointAt", "missingResult."));
            }

            result[0] = this.origin[0] + this.direction[0] * distance;
            result[1] = this.origin[1] + this.direction[1] * distance;
            result[2] = this.origin[2] + this.direction[2] * distance;

            return result;
        };

        return Line;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @version $Id: Vec2.js 2946 2015-03-31 20:37:33Z dcollins $
 */

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(0),
        __webpack_require__(1),
        __webpack_require__(2)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Logger,
              ArgumentError,
              Vec3) {
        "use strict";

        /**
         * Constructs a two-component vector.
         * @alias Vec2
         * @classdesc Represents a two-component vector. Access the X component of the vector as v[0] and the Y
         * component as v[1].
         * @augments Float64Array
         * @param {Number} x X component of vector.
         * @param {Number} y Y component of vector.
         * @constructor
         */
        var Vec2 = function Vec2(x, y) {
            this[0] = x;
            this[1] = y;
        };

        // Vec2 inherits from Float64Array.
        Vec2.prototype = new Float64Array(2);

        /**
         * Assigns the components of this vector.
         * @param {Number} x The X component of the vector.
         * @param {Number} y The Y component of the vector.
         * @returns {Vec2} This vector with the specified components assigned.
         */
        Vec2.prototype.set = function (x, y) {
            this[0] = x;
            this[1] = y;

            return this;
        };

        /**
         * Copies the components of a specified vector to this vector.
         * @param {Vec2} vector The vector to copy.
         * @returns {Vec2} This vector set to the values of the specified vector.
         * @throws {ArgumentError} If the specified vector is null or undefined.
         */
        Vec2.prototype.copy = function (vector) {
            if (!vector) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Vec2", "copy", "missingVector"));
            }

            this[0] = vector[0];
            this[1] = vector[1];

            return this;
        };

        /**
         * Indicates whether the X and Y components of this vector are identical to those of a specified vector.
         * @param {Vec2} vector The vector to test.
         * @returns {Boolean} true if this vector's components are equal to those of the specified vector,
         * otherwise false.
         */
        Vec2.prototype.equals = function (vector) {
            return this[0] === vector[0] && this[1] === vector[1];
        };

        /**
         * Computes the average of a specified array of vectors.
         * @param {Vec2[]} vectors The vectors whose average to compute.
         * @param {Vec2} result A pre-allocated Vec2 in which to return the computed average.
         * @returns {Vec2} The result argument set to the average of the specified lists of vectors.
         * @throws {ArgumentError} If the specified array of vectors is null, undefined or empty, or the specified
         * result argument is null or undefined.
         */
        Vec2.average = function (vectors, result) {
            if (!vectors || vectors.length < 1) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Vec2", "average", "missingArray"));
            }

            if (!result) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Vec2", "average", "missingResult"));
            }

            var count = vectors.length,
                vec;

            result[0] = 0;
            result[1] = 0;

            for (var i = 0, len = vectors.length; i < len; i++) {
                vec = vectors[i];

                result[0] += vec[0] / count;
                result[1] += vec[1] / count;
            }

            return result;
        };

        /**
         * Adds a vector to this vector.
         * @param {Vec2} addend The vector to add to this one.
         * @returns {Vec2} This vector after adding the specified vector to it.
         * @throws {ArgumentError} If the specified addend is null or undefined.
         */
        Vec2.prototype.add = function (addend) {
            if (!addend) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Vec2", "add", "missingVector"));
            }

            this[0] += addend[0];
            this[1] += addend[1];

            return this;
        };

        /**
         * Subtracts a vector from this vector.
         * @param {Vec2} subtrahend The vector to subtract from this one.
         * @returns {Vec2} This vector after subtracting the specified vector from it.
         * @throws {ArgumentError} If the subtrahend is null or undefined.
         */
        Vec2.prototype.subtract = function (subtrahend) {
            if (!subtrahend) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Vec2", "subtract", "missingVector"));
            }

            this[0] -= subtrahend[0];
            this[1] -= subtrahend[1];

            return this;
        };

        /**
         * Multiplies this vector by a scalar.
         * @param {Number} scalar The scalar to multiply this vector by.
         * @returns {Vec2} This vector multiplied by the specified scalar.
         */
        Vec2.prototype.multiply = function (scalar) {
            this[0] *= scalar;
            this[1] *= scalar;

            return this;
        };

        /**
         * Divide this vector by a scalar.
         * @param {Number} divisor The scalar to divide this vector by.
         * @returns {Vec2} This vector divided by the specified scalar.
         */
        Vec2.prototype.divide = function (divisor) {
            this[0] /= divisor;
            this[1] /= divisor;

            return this;
        };

        /**
         * Mixes (interpolates) a specified vector with this vector, modifying this vector.
         * @param {Vec2} vector The vector to mix.
         * @param {Number} weight The relative weight of this vector.
         * @returns {Vec2} This vector modified to the mix of itself and the specified vector.
         * @throws {ArgumentError} If the specified vector is null or undefined.
         */
        Vec2.prototype.mix = function (vector, weight) {
            if (!vector) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Vec2", "mix", "missingVector"));
            }

            var w0 = 1 - weight,
                w1 = weight;

            this[0] = this[0] * w0 + vector[0] * w1;
            this[1] = this[1] * w0 + vector[1] * w1;

            return this;
        };

        /**
         * Negates this vector.
         * @returns {Vec2} This vector, negated.
         */
        Vec2.prototype.negate = function () {
            this[0] = -this[0];
            this[1] = -this[1];

            return this;
        };

        /**
         * Computes the scalar dot product of this vector and a specified vector.
         * @param {Vec2} vector The vector to multiply.
         * @returns {Number} The scalar dot product of the vectors.
         * @throws {ArgumentError} If the specified vector is null or undefined.
         */
        Vec2.prototype.dot = function (vector) {
            if (!vector) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Vec2", "dot", "missingVector"));
            }

            return this[0] * vector[0] + this[1] * vector[1];
        };

        /**
         * Computes the squared magnitude of this vector.
         * @returns {Number} The squared magnitude of this vector.
         */
        Vec2.prototype.magnitudeSquared = function () {
            return this.dot(this);
        };

        /**
         * Computes the magnitude of this vector.
         * @returns {Number} The magnitude of this vector.
         */
        Vec2.prototype.magnitude = function () {
            return Math.sqrt(this.magnitudeSquared());
        };

        /**
         * Normalizes this vector to a unit vector.
         * @returns {Vec2} This vector, normalized.
         */
        Vec2.prototype.normalize = function () {
            var magnitude = this.magnitude(),
                magnitudeInverse = 1 / magnitude;

            this[0] *= magnitudeInverse;
            this[1] *= magnitudeInverse;

            return this;
        };

        /**
         * Computes the squared distance from this vector to a specified vector.
         * @param {Vec2} vector The vector to compute the distance to.
         * @returns {Number} The squared distance between the vectors.
         * @throws {ArgumentError} If the specified vector is null or undefined.
         */
        Vec2.prototype.distanceToSquared = function (vector) {
            if (!vector) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Vec2", "distanceToSquared", "missingVector"));
            }

            var dx = this[0] - vector[0],
                dy = this[1] - vector[1];

            return dx * dx + dy * dy;
        };

        /**
         * Computes the distance from this vector to a specified vector.
         * @param {Vec2} vector The vector to compute the distance to.
         * @returns {Number} The distance between the vectors.
         * @throws {ArgumentError} If the specified vector is null or undefined.
         */
        Vec2.prototype.distanceTo = function (vector) {
            if (!vector) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Vec2", "distanceTo", "missingVector"));
            }

            return Math.sqrt(this.distanceToSquared(vector));
        };

        /**
         * Creates a {@link Vec3} using this vector's X and Y components and a Z component of 0.
         * @returns {Vec3} A new vector whose X and Y components are those of this vector and whose Z component is 0.
         */
        Vec2.prototype.toVec3 = function () {
            return new Vec3(this[0], this[1], 0);
        };

        /**
         * Swaps the components of this vector with those of another vector. This vector is set to the values of the
         * specified vector, and the specified vector's components are set to the values of this vector.
         * @param {Vec2} that The vector to swap.
         * @returns {Vec2} This vector set to the values of the specified vector.
         */
        Vec2.prototype.swap = function (that) {
            var tmp = this[0];
            this[0] = that[0];
            that[0] = tmp;

            tmp = this[1];
            this[1] = that[1];
            that[1] = tmp;

            return this;
        };

        /**
         * Returns a string representation of this vector.
         * @returns {String} A string representation of this vector, in the form "(x, y)".
         */
        Vec2.prototype.toString = function () {
            return "(" + this[0] + ", " + this[1] + ")";
        };

        return Vec2;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports Globe
 * @version $Id: Globe.js 2940 2015-03-30 17:58:36Z tgaskins $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(6),
        __webpack_require__(1),
        __webpack_require__(36),
        __webpack_require__(29),
        __webpack_require__(13),
        __webpack_require__(7),
        __webpack_require__(0),
        __webpack_require__(10),
        __webpack_require__(73),
        __webpack_require__(3),
        __webpack_require__(67),
        __webpack_require__(2),
        __webpack_require__(4)], __WEBPACK_AMD_DEFINE_RESULT__ = function (Angle,
              ArgumentError,
              BoundingBox,
              ElevationModel,
              Line,
              Location,
              Logger,
              Position,
              ProjectionWgs84,
              Sector,
              Tessellator,
              Vec3,
              WWMath) {
        "use strict";

        /**
         * Constructs an ellipsoidal Globe with default radii for Earth (WGS84).
         * @alias Globe
         * @constructor
         * @classdesc Represents an ellipsoidal globe. The default configuration represents Earth but may be changed.
         * To configure for another planet, set the globe's equatorial and polar radii properties and its
         * eccentricity-squared property.
         * <p>
         * A globe uses a Cartesian coordinate system whose origin is at the globe's center. It's Y axis points to the
         * north pole, the Z axis points to the intersection of the prime meridian and the equator,
         * and the X axis completes a right-handed coordinate system, is in the equatorial plane and 90 degrees east
         * of the Z axis.
         * <p>
         *     All Cartesian coordinates and elevations are in meters.

         * @param {ElevationModel} elevationModel The elevation model to use for this globe.
         * @param {GeographicProjection} projection The projection to apply to the globe. May be null or undefined,
         * in which case no projection is applied and the globe is a WGS84 ellipsoid.
         * @throws {ArgumentError} If the specified elevation model is null or undefined.
         */
        var Globe = function (elevationModel, projection) {
            if (!elevationModel) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "Globe",
                    "constructor", "Elevation model is null or undefined."));
            }
            /**
             * This globe's elevation model.
             * @type {ElevationModel}
             */
            this.elevationModel = elevationModel;

            /**
             * This globe's equatorial radius.
             * @type {Number}
             * @default 6378137.0 meters
             */
            this.equatorialRadius = 6378137.0;

            /**
             * This globe's polar radius.
             * @type {Number}
             * @default 6356752.3 meters
             */
            this.polarRadius = 6356752.3;

            /**
             * This globe's eccentricity squared.
             * @type {Number}
             * @default 0.00669437999013
             */
            this.eccentricitySquared = 0.00669437999013;

            /**
             * The tessellator used to create this globe's terrain.
             * @type {Tessellator}
             */
            this.tessellator = new Tessellator();

            // Internal. Intentionally not documented.
            this._projection = projection || new ProjectionWgs84();

            // Internal. Intentionally not documented.
            this._offset = 0;

            // Internal. Intentionally not documented.
            this.offsetVector = new Vec3(0, 0, 0);

            // A unique ID for this globe. Intentionally not documented.
            this.id = ++Globe.idPool;

            this._stateKey = "globe " + this.id.toString() + " ";
        };

        Globe.idPool = 0; // Used to assign unique IDs to globes for use in their state keys.

        Object.defineProperties(Globe.prototype, {
            /**
             * A string identifying this globe's current state. Used to compare states during rendering to
             * determine whether globe-state dependent cached values must be updated. Applications typically do not
             * interact with this property.
             * @memberof Globe.prototype
             * @readonly
             * @type {String}
             */
            stateKey: {
                get: function () {
                    return this._stateKey + this.elevationModel.stateKey + "offset " + this.offset.toString() + " "
                        + this.projection.stateKey;
                }
            },

            /**
             * Indicates whether this globe is 2D and continuous with itself -- that it should scroll continuously
             * horizontally.
             * @memberof Globe.prototype
             * @readonly
             * @type {Boolean}
             */
            continuous: {
                get: function () {
                    return this.projection.continuous;
                }
            },

            /**
             * The projection used by this globe.
             * @memberof Globe.prototype
             * @default {@link ProjectionWgs84}
             * @type {GeographicProjection}
             */
            projection: {
                get: function () {
                    return this._projection;
                },
                set: function (projection) {
                    if (!projection) {
                        throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "Globe",
                            "projection", "missingProjection"));
                    }

                    if (this.projection != projection) {
                        this.tessellator = new Tessellator();
                    }
                    this._projection = projection;
                }
            },

            /**
             * The projection limits of the associated projection.
             * @memberof Globe.prototype
             * @type {Sector}
             */
            projectionLimits: {
                get: function () {
                    return this._projection.projectionLimits;
                }
            },

            /**
             * An offset to apply to this globe when translating between Geographic positions and Cartesian points.
             * Used during scrolling to position points appropriately.
             * Applications typically do not access this property. It is used by the associated globe.
             * @memberof Globe.prototype
             * @type {Number}
             */
            offset: {
                get: function () {
                    return this._offset;
                },
                set: function (offset) {
                    this._offset = offset;
                    this.offsetVector[0] = offset * 2 * Math.PI * this.equatorialRadius;
                }
            }
        });

        /**
         * Indicates whether this is a 2D globe.
         * @returns {Boolean} true if this is a 2D globe, otherwise false.
         */
        Globe.prototype.is2D = function () {
            return this.projection.is2D;
        };

        /**
         * Computes a Cartesian point from a specified position.
         * See this class' Overview section for a description of the Cartesian coordinate system used.
         * @param {Number} latitude The position's latitude.
         * @param {Number} longitude The position's longitude.
         * @param {Number} altitude The position's altitude.
         * @param {Vec3} result A reference to a pre-allocated {@link Vec3} in which to return the computed X,
         * Y and Z Cartesian coordinates.
         * @returns {Vec3} The result argument.
         * @throws {ArgumentError} If the specified result argument is null or undefined.
         */
        Globe.prototype.computePointFromPosition = function (latitude, longitude, altitude, result) {
            if (!result) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "Globe", "computePointFromPosition",
                    "missingResult"));
            }

            return this.projection.geographicToCartesian(this, latitude, longitude, altitude, this.offsetVector, result);
        };

        /**
         * Computes a Cartesian point from a specified location.
         * See this class' Overview section for a description of the Cartesian coordinate system used.
         * @param {Number} latitude The position's latitude.
         * @param {Number} longitude The position's longitude.
         * @param {Vec3} result A reference to a pre-allocated {@link Vec3} in which to return the computed X,
         * Y and Z Cartesian coordinates.
         * @returns {Vec3} The result argument.
         * @throws {ArgumentError} If the specified result argument is null or undefined.
         */
        Globe.prototype.computePointFromLocation = function (latitude, longitude, result) {
            if (!result) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "Globe", "computePointFromLocation",
                    "missingResult"));
            }

            return this.computePointFromPosition(latitude, longitude, 0, result);
        };

        /**
         * Computes a grid of Cartesian points within a specified sector and relative to a specified Cartesian
         * reference point.
         * <p>
         * This method is used to compute a collection of points within a sector. It is used by tessellators to
         * efficiently generate a tile's interior points. The number of points to generate is indicated by the numLon
         * and numLat parameters.
         * <p>
         * For each implied position within the sector, an elevation value is specified via an array of elevations. The
         * calculation at each position incorporates the associated elevation. There must be numLat x numLon elevations
         * in the array.
         *
         * @param {Sector} sector The sector for which to compute the points.
         * @param {Number} numLat The number of latitudinal points in the grid.
         * @param {Number} numLon The number of longitudinal points in the grid.
         * @param {Number[]} elevations An array of elevations to incorporate in the point calculations. There must be
         * one elevation value in the array for each generated point. Elevations are in meters. There must be
         * numLat x numLon elevations in the array.
         * @param {Vec3} referencePoint The X, Y and Z Cartesian coordinates to subtract from the computed coordinates.
         * This makes the computed coordinates relative to the specified point.
         * @param {Float32Array} result A typed array to hold the computed coordinates. It must be at least of
         * size numLat x numLon. The points are returned in row major order, beginning with the row of minimum latitude.
         * @returns {Float32Array} The specified result argument.
         * @throws {ArgumentError} if the specified sector, elevations array or results arrays are null or undefined, or
         * if the lengths of any of the arrays are insufficient.
         */
        Globe.prototype.computePointsForGrid = function (sector, numLat, numLon, elevations, referencePoint, result) {
            if (!sector) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "Globe",
                    "computePointsFromPositions", "missingSector"));
            }

            if (numLat < 1 || numLon < 1) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "Globe", "computePointsFromPositions",
                    "Number of latitude or longitude locations is less than one."));
            }

            var numPoints = numLat * numLon;
            if (!elevations || elevations.length < numPoints) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "Globe", "computePointsFromPositions",
                    "Elevations array is null, undefined or insufficient length."));
            }

            if (!result || result.length < numPoints) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "Globe", "computePointsFromPositions",
                    "Result array is null, undefined or insufficient length."));
            }

            return this.projection.geographicToCartesianGrid(this, sector, numLat, numLon, elevations, referencePoint,
                this.offsetVector, result);
        };

        /**
         * Computes a geographic position from a specified Cartesian point.
         *
         * See this class' Overview section for a description of the Cartesian coordinate system used.
         *
         * @param {Number} x The X coordinate.
         * @param {Number} y The Y coordinate.
         * @param {Number} z The Z coordinate.
         * @param {Position} result A pre-allocated {@link Position} instance in which to return the computed position.
         * @returns {Position} The specified result position.
         * @throws {ArgumentError} If the specified result argument is null or undefined.
         */
        Globe.prototype.computePositionFromPoint = function (x, y, z, result) {
            if (!result) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "Globe", "computePositionFromPoint",
                    "missingResult"));
            }

            this.projection.cartesianToGeographic(this, x, y, z, this.offsetVector, result);

            // Wrap if the globe is continuous.
            if (this.continuous) {
                if (result.longitude < -180) {
                    result.longitude += 360;
                } else if (result.longitude > 180) {
                    result.longitude -= 360;
                }
            }

            return result;
        };

        /**
         * Computes the radius of this globe at a specified location.
         * @param {Number} latitude The locations' latitude.
         * @param {Number} longitude The locations' longitude.
         * @returns {Number} The radius at the specified location.
         */
        Globe.prototype.radiusAt = function (latitude, longitude) {
            var sinLat = Math.sin(latitude * Angle.DEGREES_TO_RADIANS),
                rpm = this.equatorialRadius / Math.sqrt(1.0 - this.eccentricitySquared * sinLat * sinLat);

            return rpm * Math.sqrt(1.0 + (this.eccentricitySquared * this.eccentricitySquared - 2.0 * this.eccentricitySquared) * sinLat * sinLat);
        };

        /**
         * Computes the normal vector to this globe's surface at a specified location.
         * @param {Number} latitude The location's latitude.
         * @param {Number} longitude The location's longitude.
         * @param {Vec3} result A pre-allocated {@Link Vec3} instance in which to return the computed vector. The returned
         * normal vector is unit length.
         * @returns {Vec3} The specified result vector.  The returned normal vector is unit length.
         * @throws {ArgumentError} If the specified result argument is null or undefined.
         */
        Globe.prototype.surfaceNormalAtLocation = function (latitude, longitude, result) {
            if (!result) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "Globe", "surfaceNormalAtLocation",
                    "missingResult"));
            }

            if (this.is2D()) {
                result[0] = 0;
                result[1] = 0;
                result[2] = 1;

                return result;
            }

            var cosLat = Math.cos(latitude * Angle.DEGREES_TO_RADIANS),
                cosLon = Math.cos(longitude * Angle.DEGREES_TO_RADIANS),
                sinLat = Math.sin(latitude * Angle.DEGREES_TO_RADIANS),
                sinLon = Math.sin(longitude * Angle.DEGREES_TO_RADIANS),
                eqSquared = this.equatorialRadius * this.equatorialRadius,
                polSquared = this.polarRadius * this.polarRadius;

            result[0] = cosLat * sinLon / eqSquared;
            result[1] = (1 - this.eccentricitySquared) * sinLat / polSquared;
            result[2] = cosLat * cosLon / eqSquared;

            return result.normalize();
        };

        /**
         * Computes the normal vector to this globe's surface at a specified Cartesian point.
         * @param {Number} x The point's X coordinate.
         * @param {Number} y The point's Y coordinate.
         * @param {Number} z The point's Z coordinate.
         * @param {Vec3} result A pre-allocated {@Link Vec3} instance in which to return the computed vector. The returned
         * normal vector is unit length.
         * @returns {Vec3} The specified result vector.
         * @throws {ArgumentError} If the specified result argument is null or undefined.
         */
        Globe.prototype.surfaceNormalAtPoint = function (x, y, z, result) {
            if (!result) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "Globe", "surfaceNormalAtPoint",
                    "missingResult"));
            }

            // For backwards compatibility, check whether the projection defines a surfaceNormalAtPoint function
            // before calling it. If it's not available, use the old code to compute the normal.
            if (this.projection.surfaceNormalAtPoint) {
                return this.projection.surfaceNormalAtPoint(this, x, y, z, result);
            }

            if (this.is2D()) {
                result[0] = 0;
                result[1] = 0;
                result[2] = 1;

                return result;
            }

            var eSquared = this.equatorialRadius * this.equatorialRadius,
                polSquared = this.polarRadius * this.polarRadius;

            result[0] = x / eSquared;
            result[1] = y / polSquared;
            result[2] = z / eSquared;

            return result.normalize();
        };

        /**
         * Computes the north-pointing tangent vector to this globe's surface at a specified location.
         * @param {Number} latitude The location's latitude.
         * @param {Number} longitude The location's longitude.
         * @param {Vec3} result A pre-allocated {@Link Vec3} instance in which to return the computed vector. The returned
         * tangent vector is unit length.
         * @returns {Vec3} The specified result vector.
         * @throws {ArgumentError} If the specified result argument is null or undefined.
         */
        Globe.prototype.northTangentAtLocation = function (latitude, longitude, result) {
            if (!result) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "Globe", "northTangentAtLocation",
                    "missingResult"));
            }

            return this.projection.northTangentAtLocation(this, latitude, longitude, result);
        };

        /**
         * Computes the north-pointing tangent vector to this globe's surface at a specified Cartesian point.
         * @param {Number} x The point's X coordinate.
         * @param {Number} y The point's Y coordinate.
         * @param {Number} z The point's Z coordinate.
         * @param {Vec3} result A pre-allocated {@Link Vec3} instance in which to return the computed vector. The returned
         * tangent vector is unit length.
         * @returns {Vec3} The specified result vector.
         * @throws {ArgumentError} If the specified result argument is null or undefined.
         */
        Globe.prototype.northTangentAtPoint = function (x, y, z, result) {
            if (!result) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "Globe", "northTangentAtPoint",
                    "missingResult"));
            }

            return this.projection.northTangentAtPoint(this, x, y, z, this.offsetVector, result);
        };

        /**
         * Indicates whether this globe intersects a specified frustum.
         * @param {Frustum} frustum The frustum to test.
         * @returns {Boolean} true if this globe intersects the frustum, otherwise false.
         * @throws {ArgumentError} If the specified frustum is null or undefined.
         */
        Globe.prototype.intersectsFrustum = function (frustum) {
            if (!frustum) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Globe", "intersectsFrustum", "missingFrustum"));
            }

            if (this.is2D()) {
                var bbox = new BoundingBox();
                bbox.setToSector(Sector.FULL_SPHERE, this, this.elevationModel.minElevation,
                    this.elevationModel.maxElevation);

                return bbox.intersectsFrustum(frustum);
            }

            if (frustum.far.distance <= this.equatorialRadius)
                return false;
            if (frustum.left.distance <= this.equatorialRadius)
                return false;
            if (frustum.right.distance <= this.equatorialRadius)
                return false;
            if (frustum.top.distance <= this.equatorialRadius)
                return false;
            if (frustum.bottom.distance <= this.equatorialRadius)
                return false;
            if (frustum.near.distance <= this.equatorialRadius)
                return false;

            return true;
        };

        /**
         * Computes the first intersection of this globe with a specified line. The line is interpreted as a ray;
         * intersection points behind the line's origin are ignored.
         * @param {Line} line The line to intersect with this globe.
         * @param {Vec3} result A pre-allocated Vec3 in which to return the computed point.
         * @returns {boolean} true If the ray intersects the globe, otherwise false.
         * @throws {ArgumentError} If the specified line or result argument is null or undefined.
         */
        Globe.prototype.intersectsLine = function (line, result) {
            if (!line) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Globe", "intersectWithRay", "missingLine"));
            }

            if (!result) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "Globe", "intersectsLine", "missingResult"));
            }

            if (this.is2D()) {
                var vx = line.direction[0],
                    vy = line.direction[1],
                    vz = line.direction[2],
                    sx = line.origin[0],
                    sy = line.origin[1],
                    sz = line.origin[2],
                    t;

                if (vz == 0 && sz != 0) { // ray is parallel to and not coincident with the XY plane
                    return false;
                }

                t = -sz / vz; // intersection distance, simplified for the XY plane
                if (t < 0) { // intersection is behind the ray's origin
                    return false;
                }

                result[0] = sx + vx * t;
                result[1] = sy + vy * t;
                result[2] = sz + vz * t;

                return true;
            }

            return WWMath.computeEllipsoidalGlobeIntersection(line, this.equatorialRadius, this.polarRadius, result);
        };

        /**
         * Returns the time at which any elevations associated with this globe last changed.
         * @returns {Number} The time in milliseconds relative to the Epoch of the most recent elevation change.
         */
        Globe.prototype.elevationTimestamp = function () {
            return this.elevationModel.timestamp;
        };

        /**
         * Returns this globe's minimum elevation.
         * @returns {Number} This globe's minimum elevation.
         */
        Globe.prototype.minElevation = function () {
            return this.elevationModel.minElevation
        };

        /**
         * Returns this globe's maximum elevation.
         * @returns {Number} This globe's maximum elevation.
         */
        Globe.prototype.maxElevation = function () {
            return this.elevationModel.maxElevation
        };

        /**
         * Returns the minimum and maximum elevations within a specified sector of this globe.
         * @param {Sector} sector The sector for which to determine extreme elevations.
         * @returns {Number[]} The An array containing the minimum and maximum elevations.
         * @throws {ArgumentError} If the specified sector is null or undefined.
         */
        Globe.prototype.minAndMaxElevationsForSector = function (sector) {
            if (!sector) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Globe", "minAndMaxElevationsForSector",
                        "missingSector"));
            }

            return this.elevationModel.minAndMaxElevationsForSector(sector);
        };

        /**
         * Returns the elevation at a specified location.
         * @param {Number} latitude The location's latitude in degrees.
         * @param {Number} longitude The location's longitude in degrees.
         * @returns {Number} The elevation at the specified location, in meters. Returns zero if the location is
         * outside the coverage area of this elevation model.
         */
        Globe.prototype.elevationAtLocation = function (latitude, longitude) {
            return this.elevationModel.elevationAtLocation(latitude, longitude);
        };

        /**
         * Returns the elevations at locations within a specified sector.
         * @param {Sector} sector The sector for which to determine the elevations.
         * @param {Number} numLat The number of latitudinal sample locations within the sector.
         * @param {Number} numLon The number of longitudinal sample locations within the sector.
         * @param {Number} targetResolution The desired elevation resolution, in radians. (To compute radians from
         * meters, divide the number of meters by the globe's radius.)
         * @param {Number[]} result An array in which to return the requested elevations.
         * @returns {Number} The resolution actually achieved, which may be greater than that requested if the
         * elevation data for the requested resolution is not currently available.
         * @throws {ArgumentError} If the specified sector or result array is null or undefined, or if either of the
         * specified numLat or numLon values is less than one.
         */
        Globe.prototype.elevationsForGrid = function (sector, numLat, numLon, targetResolution, result) {
            if (!sector) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Globe", "elevationsForSector", "missingSector"));
            }

            if (numLat <= 0 || numLon <= 0) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "Globe",
                    "elevationsForSector", "numLat or numLon is less than 1"));
            }

            if (!result || result.length < numLat * numLon) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "Globe",
                    "elevationsForSector", "missingArray"));
            }

            return this.elevationModel.elevationsForGrid(sector, numLat, numLon, targetResolution, result);
        };

        return Globe;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports MemoryCache
 * @version $Id: MemoryCache.js 2911 2015-03-19 18:36:01Z tgaskins $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(1),
        __webpack_require__(0)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
              Logger) {
        "use strict";

        /**
         * Constructs a memory cache of a specified size.
         * @alias MemoryCache
         * @constructor
         * @classdesc Provides a limited-size memory cache of key-value pairs. The meaning of size depends on usage.
         * Some instances of this class work in bytes while others work in counts. See the documentation for the
         * specific use to determine the size units.
         * @param {Number} capacity The cache's capacity.
         * @param {Number} lowWater The size to clear the cache to when its capacity is exceeded.
         * @throws {ArgumentError} If either the capacity is 0 or negative or the low-water value is greater than
         * or equal to the capacity or less than 1.
         */
        var MemoryCache = function (capacity, lowWater) {
            if (!capacity || capacity < 1) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "MemoryCache", "constructor",
                    "The specified capacity is undefined, zero or negative"));
            }

            if (!lowWater || lowWater >= capacity || lowWater < 0) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "MemoryCache", "constructor",
                    "The specified low-water value is undefined, greater than or equal to the capacity, or less than 1"));
            }

            // Documented with its property accessor below.
            this._capacity = capacity;

            // Documented with its property accessor below.
            this._lowWater = lowWater;

            /**
             * The size currently used by this cache.
             * @type {Number}
             * @readonly
             */
            this.usedCapacity = 0;

            /**
             * The size currently unused by this cache.
             * @type {Number}
             * @readonly
             */
            this.freeCapacity = capacity;

            // Private. The cache entries.
            this.entries = {};

            // Private. The cache listeners.
            this.listeners = [];
        };

        Object.defineProperties(MemoryCache.prototype, {
            /**
             * The maximum this cache may hold. When the capacity is explicitly set via this property, and the current
             * low-water value is greater than the specified capacity, the low-water value is adjusted to be 85% of
             * the specified capacity. The specified capacity may not be less than or equal to 0.
             * @type {Number}
             * @memberof MemoryCache.prototype
             */
            capacity: {
                get: function() {
                    return this._capacity;
                },
                set: function (value) {
                    if (!value || value < 1) {
                        throw new ArgumentError(
                            Logger.logMessage(Logger.LEVEL_SEVERE, "MemoryCache", "capacity",
                                "Specified cache capacity is undefined, 0 or negative."));
                    }

                    var oldCapacity = this._capacity;

                    this._capacity = value;

                    if (this._capacity <= this.lowWater) {
                        this._lowWater = 0.85 * this._capacity;
                    }

                    // Trim the cache to the low-water mark if it's less than the old capacity
                    if (this._capacity < oldCapacity) {
                        this.makeSpace(0);
                    }
                }
            },

            /**
             * The size to clear this cache to when its capacity is exceeded. It must be less than the current
             * capacity and not negative.
             * @type {Number}
             * @memberof MemoryCache.prototype
             */
            lowWater: {
                get: function () {
                    return this._lowWater;
                },
                set: function (value) {
                    if (!value || value >= this._capacity || value < 0) {
                        throw new ArgumentError(
                            Logger.logMessage(Logger.LEVEL_SEVERE, "MemoryCache", "lowWater",
                                "Specified cache low-water value is undefined, negative or not less than the current capacity."));
                    }

                    this._lowWater = value;
                }
            }
        });

        /**
         * Returns the entry for a specified key.
         * @param {String} key The key of the entry to return.
         * @returns {Object} The entry associated with the specified key, or null if the key is not in the cache or
         * is null or undefined.
         */
        MemoryCache.prototype.entryForKey = function (key) {
            if (!key)
                return null;

            var cacheEntry = this.entries[key];
            if (!cacheEntry)
                return null;

            cacheEntry.lastUsed = Date.now();

            return cacheEntry.entry;
        };

        /**
         * Adds a specified entry to this cache.
         * @param {String} key The entry's key.
         * @param {Object} entry The entry.
         * @param {Number} size The entry's size.
         * @throws {ArgumentError} If the specified key or entry is null or undefined or the specified size is less
         * than 1.
         */
        MemoryCache.prototype.putEntry = function (key, entry, size) {
            if (!key) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "MemoryCache", "putEntry", "missingKey."));
            }

            if (!entry) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "MemoryCache", "putEntry", "missingEntry."));
            }

            if (size < 1) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "MemoryCache", "putEntry",
                        "The specified entry size is less than 1."));
            }

            var existing = this.entries[key],
                cacheEntry;

            if (existing) {
                this.removeEntry(key);
            }

            if (this.usedCapacity + size > this._capacity) {
                this.makeSpace(size);
            }

            this.usedCapacity += size;
            this.freeCapacity = this._capacity - this.usedCapacity;

            cacheEntry = {
                key: key,
                entry: entry,
                size: size,
                lastUsed: Date.now()
            };

            this.entries[key] = cacheEntry;
        };

        /**
         * Removes all resources from this cache.
         * @param {Boolean} callListeners If true, the current cache listeners are called for each entry removed.
         * If false, the cache listeners are not called.
         */
        MemoryCache.prototype.clear = function (callListeners) {
            if (callListeners) {
                // Remove each entry individually so that the listeners can be called for each entry.
                for (var key in this.entries) {
                    if (this.entries.hasOwnProperty(key)) {
                        this.removeCacheEntry(key);
                    }
                }
            }

            this.entries = {};
            this.freeCapacity = this._capacity;
            this.usedCapacity = 0;
        };

        /**
         * Remove an entry from this cache.
         * @param {String} key The key of the entry to remove. If null or undefined, this cache is not modified.
         */
        MemoryCache.prototype.removeEntry = function (key) {
            if (!key)
                return;

            var cacheEntry = this.entries[key];
            if (cacheEntry) {
                this.removeCacheEntry(cacheEntry);
            }
        };

        // Private. Removes a specified entry from this cache.
        MemoryCache.prototype.removeCacheEntry = function (cacheEntry) {
            // All removal passes through this function.

            delete this.entries[cacheEntry.key];

            this.usedCapacity -= cacheEntry.size;
            this.freeCapacity = this._capacity - this.usedCapacity;

            for (var i = 0, len = this.listeners.length; i < len; i++) {
                try {
                    this.listeners[i].entryRemoved(cacheEntry.key, cacheEntry.entry);
                } catch (e) {
                    this.listeners[i].removalError(e, cacheEntry.key, cacheEntry.entry);
                }
            }
        };

        /**
         * Indicates whether a specified entry is in this cache.
         * @param {String} key The key of the entry to search for.
         * @returns {Boolean} true if the entry exists, otherwise false.
         */
        MemoryCache.prototype.containsKey = function (key) {
            return key && this.entries[key];
        };

        /**
         * Adds a cache listener to this cache.
         * @param {MemoryCacheListener} listener The listener to add.
         * @throws {ArgumentError} If the specified listener is null or undefined or does not implement both the
         * entryRemoved and removalError functions.
         */
        MemoryCache.prototype.addCacheListener = function (listener) {
            if (!listener) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "MemoryCache", "addCacheListener", "missingListener"));
            }

            if (typeof listener.entryRemoved != "function" || typeof listener.removalError != "function") {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "MemoryCache", "addCacheListener",
                        "The specified listener does not implement the required functions."));
            }

            this.listeners.push(listener);
        };

        /**
         * Removes a cache listener from this cache.
         * @param {MemoryCacheListener} listener The listener to remove.
         * @throws {ArgumentError} If the specified listener is null or undefined.
         */
        MemoryCache.prototype.removeCacheListener = function (listener) {
            if (!listener) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "MemoryCache", "removeCacheListener", "missingListener"));
            }

            var index = this.listeners.indexOf(listener);
            if (index > -1) {
                this.listeners.splice(index, 1);
            }
        };

        // Private. Clears this cache to that necessary to contain a specified amount of free space.
        MemoryCache.prototype.makeSpace = function (spaceRequired) {
            var sortedEntries = [];

            // Sort the entries from least recently used to most recently used, then remove the least recently used entries
            // until the cache capacity reaches the low water and the cache has enough free capacity for the required
            // space.

            var sizeAtStart = this.usedCapacity;
            for (var key in this.entries) {
                if (this.entries.hasOwnProperty(key)) {
                    sortedEntries.push(this.entries[key]);
                }
            }

            sortedEntries.sort(function (a, b) {
                return a.lastUsed - b.lastUsed;
            });

            for (var i = 0, len = sortedEntries.length; i < len; i++) {
                if (this.usedCapacity > this._lowWater || this.freeCapacity < spaceRequired) {
                    this.removeCacheEntry(sortedEntries[i]);
                } else {
                    break;
                }
            }
        };

        return MemoryCache;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports UnsupportedOperationError
 * @version $Id: UnsupportedOperationError.js 2631 2015-01-02 21:32:32Z tgaskins $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(22)], __WEBPACK_AMD_DEFINE_RESULT__ = function (AbstractError) {
        "use strict";

        /**
         * Constructs an unsupported-operation error with a specified message.
         * @alias UnsupportedOperationError
         * @constructor
         * @classdesc Represents an error associated with an operation that is not available or should not be invoked.
         * Typically raised when an abstract function of an abstract base class is called because a subclass has not
         * implemented the function.
         * @augments AbstractError
         * @param {String} message The message.
         */
        var UnsupportedOperationError = function (message) {
            AbstractError.call(this, "UnsupportedOperationError", message);

            var stack;
            try {
                //noinspection ExceptionCaughtLocallyJS
                throw new Error();
            } catch (e) {
                stack = e.stack;
            }
            this.stack = stack;
        };

        UnsupportedOperationError.prototype = Object.create(AbstractError.prototype);

        return UnsupportedOperationError;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports Plane
 * @version $Id: Plane.js 2935 2015-03-27 17:59:48Z tgaskins $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(1),
        __webpack_require__(13),
        __webpack_require__(0),
        __webpack_require__(2)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
              Line,
              Logger,
              Vec3) {
        "use strict";

        /**
         * Constructs a plane.
         * This constructor does not normalize the components. It assumes that a unit normal vector is provided.
         * @alias Plane
         * @constructor
         * @classdesc Represents a plane in Cartesian coordinates.
         * The plane's X, Y and Z components indicate the plane's normal vector. The distance component
         * indicates the plane's distance from the origin relative to its unit normal.
         * The components are expected to be normalized.
         * @param {Number} x The X coordinate of the plane's unit normal vector.
         * @param {Number} y The Y coordinate of the plane's unit normal vector.
         * @param {Number} z The Z coordinate of the plane's unit normal vector.
         * @param {Number} distance The plane's distance from the origin.
         */
        var Plane = function (x, y, z, distance) {
            /**
             * The normal vector to the plane.
             * @type {Vec3}
             */
            this.normal = new Vec3(x, y, z);

            /**
             * The plane's distance from the origin.
             * @type {Number}
             */
            this.distance = distance;
        };

        /**
         * Computes a plane that passes through the specified three points.
         * The plane's normal is the cross product of the
         * two vectors from pb to pa and pc to pa, respectively. The
         * returned plane is undefined if any of the specified points are colinear.
         *
         * @param {Vec3} pa The first point.
         * @param {Vec3} pb The second point.
         * @param {Vec3} pc The third point.
         *
         * @return {Plane} A plane passing through the specified points.
         *
         * @throws {ArgumentError} if pa, pb, or pc is null or undefined.
         */
        Plane.fromPoints = function(pa, pb, pc) {
            if (!pa || !pb || !pc) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Plane", "fromPoints", "missingVector"));
            }

            var vab = new Vec3(pb[0], pb[1], pb[2]);
            vab.subtract(pa);
            var vac = new Vec3(pc[0], pc[1], pc[2]);
            vac.subtract(pa);
            vab.cross(vac);
            vab.normalize();
            var d = -vab.dot(pa);

            return new Plane(vab[0], vab[1], vab[2], d);
        };

        /**
         * Computes the dot product of this plane's normal vector with a specified vector.
         * Since the plane was defined with a unit normal vector, this function returns the distance of the vector from
         * the plane.
         * @param {Vec3} vector The vector to dot with this plane's normal vector.
         * @returns {Number} The computed dot product.
         * @throws {ArgumentError} If the specified vector is null or undefined.
         */
        Plane.prototype.dot = function (vector) {
            if (!vector) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Plane", "dot", "missingVector"));
            }

            return this.normal.dot(vector) + this.distance;
        };

        /**
         * Computes the distance between this plane and a point.
         * @param {Vec3} point The point whose distance to compute.
         * @returns {Number} The computed distance.
         * @throws {ArgumentError} If the specified point is null or undefined.
         */
        Plane.prototype.distanceToPoint = function (point) {
            return this.dot(point);
        };

        /**
         * Transforms this plane by a specified matrix.
         * @param {Matrix} matrix The matrix to apply to this plane.
         * @returns {Plane} This plane transformed by the specified matrix.
         * @throws {ArgumentError} If the specified matrix is null or undefined.
         */
        Plane.prototype.transformByMatrix = function (matrix){
            if (!matrix) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Plane", "transformByMatrix", "missingMatrix"));
            }

            var x = matrix[0] * this.normal[0] + matrix[1] * this.normal[1] + matrix[2] * this.normal[2] + matrix[3] * this.distance,
                y = matrix[4] * this.normal[0] + matrix[5] * this.normal[1] + matrix[6] * this.normal[2] + matrix[7] * this.distance,
                z = matrix[8] * this.normal[0] + matrix[9] * this.normal[1] + matrix[10] * this.normal[2] + matrix[11] * this.distance,
                distance = matrix[12] * this.normal[0] + matrix[13] * this.normal[1] + matrix[14] * this.normal[2] + matrix[15] * this.distance;

            this.normal[0] = x;
            this.normal[1] = y;
            this.normal[2] = z;
            this.distance = distance;
            
            return this;
        };

        /**
         * Normalizes the components of this plane.
         * @returns {Plane} This plane with its components normalized.
         */
        Plane.prototype.normalize = function () {
            var magnitude = this.normal.magnitude();

            if (magnitude === 0)
                return this;

            this.normal.divide(magnitude);
            this.distance /= magnitude;

            return this;
        };

        /**
         * Determines whether a specified line segment intersects this plane.
         *
         * @param {Vec3} endPoint1 The first end point of the line segment.
         * @param {Vec3} endPoint2 The second end point of the line segment.
         * @returns {Boolean} true if the line segment intersects this plane, otherwise false.
         */
        Plane.prototype.intersectsSegment = function(endPoint1, endPoint2) {
            var distance1 = this.dot(endPoint1),
                distance2 = this.dot(endPoint2);

            return distance1 * distance2 <= 0;
        };

        /**
         * Computes the intersection point of this plane with a specified line segment.
         *
         * @param {Vec3} endPoint1 The first end point of the line segment.
         * @param {Vec3} endPoint2 The second end point of the line segment.
         * @param {Vec3} result A variable in which to return the intersection point of the line segment with this plane.
         * @returns {Boolean} true If the line segment intersects this plane, otherwise false.
         */
        Plane.prototype.intersectsSegmentAt = function (endPoint1, endPoint2, result) {
            // Compute the distance from the end-points.
            var distance1 = this.dot(endPoint1),
                distance2 = this.dot(endPoint2);

            // If both points points lie on the plane, ...
            if (distance1 === 0 && distance2 === 0) {
                // Choose an arbitrary endpoint as the intersection.
                result[0] = endPoint1[0];
                result[1] = endPoint1[1];
                result[2] = endPoint1[2];

                return true;
            }
            else if (distance1 === distance2) {
                // The intersection is undefined.
                return false;
            }

            var weight1 = -distance1 / (distance2 - distance1),
                weight2 = 1 - weight1;

            result[0] = weight1 * endPoint1[0] + weight2 * endPoint2[0];
            result[1] = weight1 * endPoint1[1] + weight2 * endPoint2[1];
            result[2] = weight1 * endPoint1[2] + weight2 * endPoint2[2];

            return distance1 * distance2 <= 0;
        };

        /**
         * Determines whether two points are on the same side of this plane.
         *
         * @param {Vec3} pointA the first point.
         * @param {Vec3} pointB the second point.
         *
         * @return {Number} -1 If both points are on the negative side of this plane, +1 if both points are on the
         * positive side of this plane, 0 if the points are on opposite sides of this plane.
         *
         * @throws {ArgumentError} If either point is null or undefined.
         */
        Plane.prototype.onSameSide = function (pointA, pointB) {
            if (!pointA || !pointB) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Plane", "onSameSide", "missingPoint"));
            }

            var da = this.distanceToPoint(pointA),
                db = this.distanceToPoint(pointB);

            if (da < 0 && db < 0)
                return -1;

            if (da > 0 && db > 0)
                return 1;

            return 0;
        };

        /**
         * Clips a line segment to this plane.
         * @param {Vec3} pointA The first line segment endpoint.
         * @param {Vec3} pointB The second line segment endpoint.
         *
         * @returns {Vec3[]}  An array of two points both on the positive side of the plane. If the direction of the line formed by the
         *         two points is positive with respect to this plane's normal vector, the first point in the array will be
         *         the intersection point on the plane, and the second point will be the original segment end point. If the
         *         direction of the line is negative with respect to this plane's normal vector, the first point in the
         *         array will be the original segment's begin point, and the second point will be the intersection point on
         *         the plane. If the segment does not intersect the plane, null is returned. If the segment is coincident
         *         with the plane, the input points are returned, in their input order.
         *
         * @throws {ArgumentError} If either point is null or undefined.
         */
        Plane.prototype.clip = function (pointA, pointB) {
            if (!pointA || !pointB) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Plane", "clip", "missingPoint"));
            }

            if (pointA.equals(pointB)) {
                return null;
            }

            // Get the projection of the segment onto the plane.
            var line = Line.fromSegment(pointA, pointB),
                lDotV = this.normal.dot(line.direction),
                lDotS, t, p;

            // Are the line and plane parallel?
            if (lDotV === 0) { // line and plane are parallel and may be coincident.
                lDotS = this.dot(line.origin);
                if (lDotS === 0) {
                    return [pointA, pointB]; // line is coincident with the plane
                } else {
                    return null; // line is not coincident with the plane.
                }
            }

            // Not parallel so the line intersects. But does the segment intersect?
            t = -this.dot(line.origin) / lDotV; // lDotS / lDotV
            if (t < 0 || t > 1) { // segment does not intersect
                return null;
            }

            p = line.pointAt(t, new Vec3(0, 0, 0));
            if (lDotV > 0) {
                return [p, pointB];
            } else {
                return [pointA, p];
            }
        };

        return Plane;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports GestureRecognizer
 * @version $Id: GestureRecognizer.js 3241 2015-06-22 23:52:49Z dcollins $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(1),
        __webpack_require__(0),
        __webpack_require__(63)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
              Logger,
              Touch) {
        "use strict";

        /**
         * Constructs a base gesture recognizer. This is an abstract base class and not intended to be instantiated
         * directly.
         * @alias GestureRecognizer
         * @constructor
         * @classdesc Gesture recognizers translate user input event streams into higher level actions. A gesture
         * recognizer is associated with an event target, which dispatches mouse and keyboard events to the gesture
         * recognizer. When a gesture recognizer has received enough information from the event stream to interpret the
         * action, it calls its callback functions. Callback functions may be specified at construction or added to the
         * [gestureCallbacks]{@link GestureRecognizer#gestureCallbacks} list after construction.
         * @param {EventTarget} target The document element this gesture recognizer observes for mouse and touch events.
         * @param {Function} callback An optional function to call when this gesture is recognized. If non-null, the
         * function is called when this gesture is recognized, and is passed a single argument: this gesture recognizer,
         * e.g., <code>gestureCallback(recognizer)</code>.
         * @throws {ArgumentError} If the specified target is null or undefined.
         */
        var GestureRecognizer = function (target, callback) {
            if (!target) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "GestureRecognizer", "constructor", "missingTarget"));
            }

            /**
             * Indicates the document element this gesture recognizer observes for UI events.
             * @type {EventTarget}
             * @readonly
             */
            this.target = target;

            /**
             * Indicates whether or not this gesture recognizer is enabled. When false, this gesture recognizer will
             * ignore any events dispatched by its target.
             * @type {Boolean}
             * @default true
             */
            this.enabled = true;

            // Documented with its property accessor below.
            this._state = WorldWind.POSSIBLE;

            // Intentionally not documented.
            this._nextState = null;

            // Documented with its property accessor below.
            this._clientX = 0;

            // Documented with its property accessor below.
            this._clientY = 0;

            // Intentionally not documented.
            this._clientStartX = 0;

            // Intentionally not documented.
            this._clientStartY = 0;

            // Documented with its property accessor below.
            this._translationX = 0;

            // Documented with its property accessor below.
            this._translationY = 0;

            // Intentionally not documented.
            this._translationWeight = 0.4;

            // Documented with its property accessor below.
            this._mouseButtonMask = 0;

            // Intentionally not documented.
            this._touches = [];

            // Intentionally not documented.
            this._touchCentroidShiftX = 0;

            // Intentionally not documented.
            this._touchCentroidShiftY = 0;

            // Documented with its property accessor below.
            this._gestureCallbacks = [];

            // Intentionally not documented.
            this._canRecognizeWith = [];

            // Intentionally not documented.
            this._requiresFailureOf = [];

            // Intentionally not documented.
            this._requiredToFailBy = [];

            // Add the optional gesture callback.
            if (callback) {
                this._gestureCallbacks.push(callback);
            }

            // Add this recognizer to the list of all recognizers.
            GestureRecognizer.allRecognizers.push(this);

            // Register listeners on the event target.
            var thisRecognizer = this;

            function eventListener(event) {
                thisRecognizer.handleEvent(event);
            }

            if (window.PointerEvent) {
                target.addEventListener("pointerdown", eventListener, false);
                window.addEventListener("pointermove", eventListener, false); // get pointermove events outside event target
                window.addEventListener("pointercancel", eventListener, false); // get pointercancel events outside event target
                window.addEventListener("pointerup", eventListener, false); // get pointerup events outside event target
            } else {
                target.addEventListener("mousedown", eventListener, false);
                window.addEventListener("mousemove", eventListener, false); // get mousemove events outside event target
                window.addEventListener("mouseup", eventListener, false); // get mouseup events outside event target
                target.addEventListener("touchstart", eventListener, false);
                target.addEventListener("touchmove", eventListener, false);
                target.addEventListener("touchend", eventListener, false);
                target.addEventListener("touchcancel", eventListener, false);
            }
        };

        // Intentionally not documented.
        GestureRecognizer.allRecognizers = [];

        Object.defineProperties(GestureRecognizer.prototype, {
            /**
             * Indicates this gesture's current state. Possible values are WorldWind.POSSIBLE, WorldWind.FAILED,
             * WorldWind.RECOGNIZED, WorldWind.BEGAN, WorldWind.CHANGED, WorldWind.CANCELLED and WorldWind.ENDED.
             * @type {String}
             * @default WorldWind.POSSIBLE
             * @memberof GestureRecognizer.prototype
             */
            state: {
                get: function () {
                    return this._state;
                },
                set: function (value) {
                    this.transitionToState(value);
                }
            },

            /**
             * Indicates the X coordinate of this gesture.
             * @type {Number}
             * @memberof GestureRecognizer.prototype
             */
            clientX: {
                get: function () {
                    return this._clientX;
                },
                set: function (value) {
                    this._clientX = value;
                }
            },

            /**
             * Returns the Y coordinate of this gesture.
             * @type {Number}
             * @memberof GestureRecognizer.prototype
             */
            clientY: {
                get: function () {
                    return this._clientY;
                },
                set: function (value) {
                    this._clientY = value;
                }
            },

            /**
             * Indicates this gesture's translation along the X axis since the gesture started.
             * @type {Number}
             * @memberof GestureRecognizer.prototype
             */
            translationX: {
                get: function () {
                    return this._translationX;
                },
                set: function (value) {
                    this._translationX = value;
                    this._clientStartX = this._clientX;
                    this._touchCentroidShiftX = 0;
                }
            },

            /**
             * Indicates this gesture's translation along the Y axis since the gesture started.
             * @type {Number}
             * @memberof GestureRecognizer.prototype
             */
            translationY: {
                get: function () {
                    return this._translationY;
                },
                set: function (value) {
                    this._translationY = value;
                    this._clientStartY = this._clientY;
                    this._touchCentroidShiftY = 0;
                }
            },

            /**
             * Indicates the currently pressed mouse buttons as a bitmask. A value of 0 indicates that no buttons are
             * pressed. A nonzero value indicates that one or more buttons are pressed as follows: bit 1 indicates the
             * primary button, bit 2 indicates the the auxiliary button, bit 3 indicates the secondary button.
             * @type {Number}
             * @readonly
             * @memberof GestureRecognizer.prototype
             */
            mouseButtonMask: {
                get: function () {
                    return this._mouseButtonMask;
                }
            },

            /**
             * Indicates the number of active touches.
             * @type {Number}
             * @readonly
             * @memberof GestureRecognizer.prototype
             */
            touchCount: {
                get: function () {
                    return this._touches.length;
                }
            },

            /**
             * The list of functions to call when this gesture is recognized. The functions have a single argument:
             * this gesture recognizer, e.g., <code>gestureCallback(recognizer)</code>. Applications may
             * add functions to this array or remove them.
             * @type {Function[]}
             * @readonly
             * @memberof GestureRecognizer.prototype
             */
            gestureCallbacks: {
                get: function () {
                    return this._gestureCallbacks;
                }
            }
        });

        /**
         *
         * @param index
         * @returns {Touch}
         * @throws {ArgumentError} If the index is out of range.
         */
        GestureRecognizer.prototype.touch = function (index) {
            if (index < 0 || index >= this._touches.length) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "GestureRecognizer", "touch", "indexOutOfRange"));
            }

            return this._touches[index];
        };

        /**
         *
         * @param recognizer
         */
        GestureRecognizer.prototype.recognizeSimultaneouslyWith = function (recognizer) {
            if (!recognizer) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "GestureRecognizer", "recognizeSimultaneouslyWith",
                        "The specified gesture recognizer is null or undefined."));
            }

            var index = this._canRecognizeWith.indexOf(recognizer);
            if (index == -1) {
                this._canRecognizeWith.push(recognizer);
                recognizer._canRecognizeWith.push(this);
            }
        };

        /**
         *
         * @param recognizer
         * @returns {Boolean}
         */
        GestureRecognizer.prototype.canRecognizeSimultaneouslyWith = function (recognizer) {
            var index = this._canRecognizeWith.indexOf(recognizer);
            return index != -1;
        };

        /**
         *
         * @param recognizer
         */
        GestureRecognizer.prototype.requireRecognizerToFail = function (recognizer) {
            if (!recognizer) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "GestureRecognizer", "requireRecognizerToFail",
                        "The specified gesture recognizer is null or undefined"));
            }

            var index = this._requiresFailureOf.indexOf(recognizer);
            if (index == -1) {
                this._requiresFailureOf.push(recognizer);
                recognizer._requiredToFailBy.push(this);
            }
        };

        /**
         *
         * @param recognizer
         * @returns {Boolean}
         */
        GestureRecognizer.prototype.requiresRecognizerToFail = function (recognizer) {
            var index = this._requiresFailureOf.indexOf(recognizer);
            return index != -1;
        };

        /**
         *
         * @param recognizer
         * @returns {Boolean}
         */
        GestureRecognizer.prototype.requiredToFailByRecognizer = function (recognizer) {
            var index = this._requiredToFailBy.indexOf(recognizer);
            return index != -1;
        };

        /**
         * @protected
         */
        GestureRecognizer.prototype.reset = function () {
            this._state = WorldWind.POSSIBLE;
            this._nextState = null;
            this._clientX = 0;
            this._clientY = 0;
            this._clientStartX = 0;
            this._clientStartY = 0;
            this._translationX = 0;
            this._translationY = 0;
            this._mouseButtonMask = 0;
            this._touches = [];
            this._touchCentroidShiftX = 0;
            this._touchCentroidShiftY = 0;
        };

        /**
         * @protected
         */
        GestureRecognizer.prototype.prepareToRecognize = function () {
        };

        /**
         *
         * @param event
         * @protected
         */
        GestureRecognizer.prototype.mouseDown = function (event) {
        };

        /**
         *
         * @param event
         * @protected
         */
        GestureRecognizer.prototype.mouseMove = function (event) {
        };

        /**
         *
         * @param event
         * @protected
         */
        GestureRecognizer.prototype.mouseUp = function (event) {
        };

        /**
         *
         * @param touch
         * @protected
         */
        GestureRecognizer.prototype.touchStart = function (touch) {
        };

        /**
         *
         * @param touch
         * @protected
         */
        GestureRecognizer.prototype.touchMove = function (touch) {
        };

        /**
         *
         * @param touch
         * @protected
         */
        GestureRecognizer.prototype.touchCancel = function (touch) {
        };

        /**
         *
         * @param touch
         * @protected
         */
        GestureRecognizer.prototype.touchEnd = function (touch) {
        };

        // Intentionally not documented.
        GestureRecognizer.prototype.transitionToState = function (newState) {
            this._nextState = null; // clear any pending state transition

            if (newState == WorldWind.FAILED) {
                this._state = newState;
                this.updateRecognizersWaitingForFailure();
                this.resetIfEventsEnded();
            } else if (newState == WorldWind.RECOGNIZED) {
                this.tryToRecognize(newState); // may prevent the transition to Recognized
                if (this._state == newState) {
                    this.prepareToRecognize();
                    this.callGestureCallbacks();
                    this.resetIfEventsEnded();
                }
            } else if (newState == WorldWind.BEGAN) {
                this.tryToRecognize(newState); // may prevent the transition to Began
                if (this._state == newState) {
                    this.prepareToRecognize();
                    this.callGestureCallbacks();
                }
            } else if (newState == WorldWind.CHANGED) {
                this._state = newState;
                this.callGestureCallbacks();
            } else if (newState == WorldWind.CANCELLED) {
                this._state = newState;
                this.callGestureCallbacks();
                this.resetIfEventsEnded();
            } else if (newState == WorldWind.ENDED) {
                this._state = newState;
                this.callGestureCallbacks();
                this.resetIfEventsEnded();
            }
        };

        // Intentionally not documented.
        GestureRecognizer.prototype.updateRecognizersWaitingForFailure = function () {
            // Transition gestures that are waiting for this gesture to transition to Failed.
            for (var i = 0, len = this._requiredToFailBy.length; i < len; i++) {
                var recognizer = this._requiredToFailBy[i];
                if (recognizer._nextState != null) {
                    recognizer.transitionToState(recognizer._nextState);
                }
            }
        };

        // Intentionally not documented.
        GestureRecognizer.prototype.tryToRecognize = function (newState) {
            // Transition to Failed if another gesture can prevent this gesture from recognizing.
            if (GestureRecognizer.allRecognizers.some(this.canBePreventedByRecognizer, this)) {
                this.transitionToState(WorldWind.FAILED);
                return;
            }

            // Delay the transition to Recognized/Began if this gesture is waiting for a gesture in the Possible state.
            if (GestureRecognizer.allRecognizers.some(this.isWaitingForRecognizerToFail, this)) {
                this._nextState = newState;
                return;
            }

            // Transition to Failed all other gestures that can be prevented from recognizing by this gesture.
            var prevented = GestureRecognizer.allRecognizers.filter(this.canPreventRecognizer, this);
            for (var i = 0, len = prevented.length; i < len; i++) {
                prevented[i].transitionToState(WorldWind.FAILED);
            }

            this._state = newState;
        };

        // Intentionally not documented.
        GestureRecognizer.prototype.canPreventRecognizer = function (that) {
            return this != that && this.target == that.target && that.state == WorldWind.POSSIBLE &&
                (this.requiredToFailByRecognizer(that) || !this.canRecognizeSimultaneouslyWith(that));
        };

        // Intentionally not documented.
        GestureRecognizer.prototype.canBePreventedByRecognizer = function (that) {
            return this != that && this.target == that.target && that.state == WorldWind.RECOGNIZED &&
                (this.requiresRecognizerToFail(that) || !this.canRecognizeSimultaneouslyWith(that));
        };

        // Intentionally not documented.
        GestureRecognizer.prototype.isWaitingForRecognizerToFail = function (that) {
            return this != that && this.target == that.target && that.state == WorldWind.POSSIBLE &&
                this.requiresRecognizerToFail(that);
        };

        // Intentionally not documented.
        GestureRecognizer.prototype.callGestureCallbacks = function () {
            for (var i = 0, len = this._gestureCallbacks.length; i < len; i++) {
                this._gestureCallbacks[i](this);
            }
        };

        // Intentionally not documented.
        GestureRecognizer.prototype.handleEvent = function (event) {
            if (!this.enabled) {
                return;
            }

            if (event.defaultPrevented && this.state == WorldWind.POSSIBLE) {
                return; // ignore cancelled events while in the Possible state
            }

            var i, len;

            try {
                if (event.type == "mousedown") {
                    this.handleMouseDown(event);
                } else if (event.type == "mousemove") {
                    this.handleMouseMove(event);
                } else if (event.type == "mouseup") {
                    this.handleMouseUp(event);
                } else if (event.type == "touchstart") {
                    for (i = 0, len = event.changedTouches.length; i < len; i++) {
                        this.handleTouchStart(event.changedTouches.item(i));
                    }
                } else if (event.type == "touchmove") {
                    for (i = 0, len = event.changedTouches.length; i < len; i++) {
                        this.handleTouchMove(event.changedTouches.item(i));
                    }
                } else if (event.type == "touchcancel") {
                    for (i = 0, len = event.changedTouches.length; i < len; i++) {
                        this.handleTouchCancel(event.changedTouches.item(i));
                    }
                } else if (event.type == "touchend") {
                    for (i = 0, len = event.changedTouches.length; i < len; i++) {
                        this.handleTouchEnd(event.changedTouches.item(i));
                    }
                } else if (event.type == "pointerdown" && event.pointerType == "mouse") {
                    this.handleMouseDown(event);
                } else if (event.type == "pointermove" && event.pointerType == "mouse") {
                    this.handleMouseMove(event);
                } else if (event.type == "pointercancel" && event.pointerType == "mouse") {
                    // Intentionally left blank. The W3C Pointer Events specification is ambiguous on what cancel means
                    // for mouse input, and there is no evidence that this event is actually generated (6/19/2015).
                } else if (event.type == "pointerup" && event.pointerType == "mouse") {
                    this.handleMouseUp(event);
                } else if (event.type == "pointerdown" && event.pointerType == "touch") {
                    this.handleTouchStart(event);
                } else if (event.type == "pointermove" && event.pointerType == "touch") {
                    this.handleTouchMove(event);
                } else if (event.type == "pointercancel" && event.pointerType == "touch") {
                    this.handleTouchCancel(event);
                } else if (event.type == "pointerup" && event.pointerType == "touch") {
                    this.handleTouchEnd(event);
                } else {
                    Logger.logMessage(Logger.LEVEL_INFO, "GestureRecognizer", "handleEvent",
                        "Unrecognized event type: " + event.type);
                }
            } catch (e) {
                Logger.logMessage(Logger.LEVEL_SEVERE, "GestureRecognizer", "handleEvent",
                    "Error handling event.\n" + e.toString());
            }
        };

        // Intentionally not documented.
        GestureRecognizer.prototype.handleMouseDown = function (event) {
            if (event.type == "mousedown" && this._touches.length > 0) {
                return; // ignore synthesized mouse down events on Android Chrome
            }

            var buttonBit = (1 << event.button);
            if (buttonBit & this._mouseButtonMask != 0) {
                return; // ignore redundant mouse down events
            }

            if (this._mouseButtonMask == 0) { // first button down
                this._clientX = event.clientX;
                this._clientY = event.clientY;
                this._clientStartX = event.clientX;
                this._clientStartY = event.clientY;
                this._translationX = 0;
                this._translationY = 0;
            }

            this._mouseButtonMask |= buttonBit;
            this.mouseDown(event);
        };

        // Intentionally not documented.
        GestureRecognizer.prototype.handleMouseMove = function (event) {
            if (this._mouseButtonMask == 0) {
                return; // ignore mouse move events when this recognizer does not consider any button to be down
            }

            if (this._clientX == event.clientX && this._clientY == event._clientY) {
                return; // ignore redundant mouse move events
            }

            var dx = event.clientX - this._clientStartX,
                dy = event.clientY - this._clientStartY,
                w = this._translationWeight;
            this._clientX = event.clientX;
            this._clientY = event.clientY;
            this._translationX = this._translationX * (1 - w) + dx * w;
            this._translationY = this._translationY * (1 - w) + dy * w;
            this.mouseMove(event);
        };

        // Intentionally not documented.
        GestureRecognizer.prototype.handleMouseUp = function (event) {
            var buttonBit = (1 << event.button);
            if (buttonBit & this._mouseButtonMask == 0) {
                return; // ignore mouse up events for buttons this recognizer does not consider to be down
            }

            this._mouseButtonMask &= ~buttonBit;
            this.mouseUp(event);

            if (this._mouseButtonMask == 0) {
                this.resetIfEventsEnded(); // last button up
            }
        };

        // Intentionally not documented.
        GestureRecognizer.prototype.handleTouchStart = function (event) {
            var touch = new Touch(event.identifier || event.pointerId, event.clientX, event.clientY); // touch events or pointer events
            this._touches.push(touch);

            if (this._touches.length == 1) { // first touch
                this._clientX = event.clientX;
                this._clientY = event.clientY;
                this._clientStartX = event.clientX;
                this._clientStartY = event.clientY;
                this._translationX = 0;
                this._translationY = 0;
                this._touchCentroidShiftX = 0;
                this._touchCentroidShiftY = 0;
            } else {
                this.touchesAddedOrRemoved();
            }

            this.touchStart(touch);
        };

        // Intentionally not documented.
        GestureRecognizer.prototype.handleTouchMove = function (event) {
            var index = this.indexOfTouchWithId(event.identifier || event.pointerId); // touch events or pointer events
            if (index == -1) {
                return; // ignore events for touches that did not start in this recognizer's target
            }

            var touch = this._touches[index];
            if (touch.clientX == event.clientX && touch.clientY == event.clientY) {
                return; // ignore redundant touch move events, which we've encountered on Android Chrome
            }

            touch.clientX = event.clientX;
            touch.clientY = event.clientY;

            var centroid = this.touchCentroid(),
                dx = centroid.clientX - this._clientStartX + this._touchCentroidShiftX,
                dy = centroid.clientY - this._clientStartY + this._touchCentroidShiftY,
                w = this._translationWeight;
            this._clientX = centroid.clientX;
            this._clientY = centroid.clientY;
            this._translationX = this._translationX * (1 - w) + dx * w;
            this._translationY = this._translationY * (1 - w) + dy * w;

            this.touchMove(touch);
        };

        // Intentionally not documented.
        GestureRecognizer.prototype.handleTouchCancel = function (event) {
            var index = this.indexOfTouchWithId(event.identifier || event.pointerId); // touch events or pointer events
            if (index == -1) {
                return; // ignore events for touches that did not start in this recognizer's target
            }

            var touch = this._touches[index];
            this._touches.splice(index, 1);
            this.touchesAddedOrRemoved();
            this.touchCancel(touch);
            this.resetIfEventsEnded();
        };

        // Intentionally not documented.
        GestureRecognizer.prototype.handleTouchEnd = function (event) {
            var index = this.indexOfTouchWithId(event.identifier || event.pointerId); // touch events or pointer events
            if (index == -1) {
                return; // ignore events for touches that did not start in this recognizer's target
            }

            var touch = this._touches[index];
            this._touches.splice(index, 1);
            this.touchesAddedOrRemoved();
            this.touchEnd(touch);
            this.resetIfEventsEnded();
        };

        // Intentionally not documented.
        GestureRecognizer.prototype.resetIfEventsEnded = function () {
            if (this._state != WorldWind.POSSIBLE && this._mouseButtonMask == 0 && this._touches.length == 0) {
                this.reset();
            }
        };

        // Intentionally not documented.
        GestureRecognizer.prototype.touchesAddedOrRemoved = function () {
            this._touchCentroidShiftX += this._clientX;
            this._touchCentroidShiftY += this._clientY;
            var centroid = this.touchCentroid();
            this._clientX = centroid.clientX;
            this._clientY = centroid.clientY;
            this._touchCentroidShiftX -= this._clientX;
            this._touchCentroidShiftY -= this._clientY;
        };

        // Intentionally not documented.
        GestureRecognizer.prototype.touchCentroid = function () {
            var x = 0,
                y = 0;

            for (var i = 0, len = this._touches.length; i < len; i++) {
                var touch = this._touches[i];
                x += touch.clientX / len;
                y += touch.clientY / len;
            }

            return {clientX: x, clientY: y};
        };

        // Intentionally not documented.
        GestureRecognizer.prototype.indexOfTouchWithId = function (identifier) {
            for (var i = 0, len = this._touches.length; i < len; i++) {
                if (this._touches[i].identifier == identifier) {
                    return i;
                }
            }

            return -1;
        };

        return GestureRecognizer;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports NavigatorState
 * @version $Id: NavigatorState.js 3279 2015-06-26 22:42:56Z tgaskins $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(1),
        __webpack_require__(24),
        __webpack_require__(13),
        __webpack_require__(0),
        __webpack_require__(5),
        __webpack_require__(9),
        __webpack_require__(14),
        __webpack_require__(2),
        __webpack_require__(4)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
              Frustum,
              Line,
              Logger,
              Matrix,
              Rectangle,
              Vec2,
              Vec3,
              WWMath) {
        "use strict";

        /**
         * Constructs a navigator state. This constructor is meant to be called by navigators when their current state
         * is requested.
         * @alias NavigatorState
         * @constructor
         * @classdesc Represents the state of a navigator.
         * <p>
         * Properties of NavigatorState objects are
         * read-only because they are values captured from a {@link Navigator}. Setting the properties on
         * a NavigatorState instance has no effect on the Navigator from which they came.
         * @param {Matrix} modelViewMatrix The navigator's model-view matrix.
         * @param {Matrix} projectionMatrix The navigator's projection matrix.
         * @param {Rectangle} viewport The navigator's viewport.
         * @param {Number} heading The navigator's heading.
         * @param {Number} tilt The navigator's tilt.
         */
        var NavigatorState = function (modelViewMatrix, projectionMatrix, viewport, heading, tilt) {

            /**
             * The navigator's model-view matrix. The model-view matrix transforms points from model coordinates to eye
             * coordinates.
             * @type {Matrix}
             * @readonly
             */
            this.modelview = modelViewMatrix;

            /**
             * The navigator's projection matrix. The projection matrix transforms points from eye coordinates to clip
             * coordinates.
             * @type {Matrix}
             * @readonly
             */
            this.projection = projectionMatrix;

            /**
             * The concatenation of the navigator's model-view and projection matrices. This matrix transforms points
             * from model coordinates to clip coordinates.
             * @type {Matrix}
             * @readonly
             */
            this.modelviewProjection = Matrix.fromIdentity();
            this.modelviewProjection.setToMultiply(projectionMatrix, modelViewMatrix);

            /**
             * The navigator's viewport, in WebGL screen coordinates. The viewport places the origin in the bottom-left
             * corner and has axes that extend up and to the right from the origin.
             * @type {Rectangle}
             * @readonly
             */
            this.viewport = viewport;

            /**
             * Indicates the number of degrees clockwise from north to which the view is directed.
             * @type {Number}
             * @readonly
             */
            this.heading = heading;

            /**
             * The number of degrees the globe is tilted relative to its surface being parallel to the screen. Values are
             * typically in the range 0 to 90 but may vary from that depending on the navigator in use.
             * @type {Number}
             * @readonly
             */
            this.tilt = tilt;

            /**
             * The navigator's eye point in model coordinates, relative to the globe's center.
             * @type {Vec3}
             * @readonly
             */
            this.eyePoint = this.modelview.extractEyePoint(new Vec3(0, 0, 0));

            /**
             * The navigator's viewing frustum in model coordinates. The frustum originates at the eyePoint and extends
             * outward along the forward vector. The navigator's near distance and far distance identify the minimum and
             * maximum distance, respectively, at which an object in the scene is visible.
             * @type {Frustum}
             * @readonly
             */
            this.frustumInModelCoordinates = null;
            // Compute the frustum in model coordinates. Start by computing the frustum in eye coordinates from the
            // projection matrix, then transform this frustum to model coordinates by multiplying its planes by the
            // transpose of the modelview matrix. We use the transpose of the modelview matrix because planes are
            // transformed by the inverse transpose of a matrix, and we want to transform from eye coordinates to model
            // coordinates.
            var modelviewTranspose = Matrix.fromIdentity();
            modelviewTranspose.setToTransposeOfMatrix(this.modelview);
            this.frustumInModelCoordinates = Frustum.fromProjectionMatrix(this.projection);
            this.frustumInModelCoordinates.transformByMatrix(modelviewTranspose);
            this.frustumInModelCoordinates.normalize();

            // Compute the inverse of the modelview, projection, and modelview-projection matrices. The inverse matrices
            // are used to support operations on navigator state, such as project, unProject, and pixelSizeAtDistance.
            this.modelviewInv = Matrix.fromIdentity();
            this.modelviewInv.invertOrthonormalMatrix(this.modelview);
            this.projectionInv = Matrix.fromIdentity();
            this.projectionInv.invertMatrix(this.projection);
            this.modelviewProjectionInv = Matrix.fromIdentity();
            this.modelviewProjectionInv.invertMatrix(this.modelviewProjection);

            /**
             * The matrix that transforms normal vectors in model coordinates to normal vectors in eye coordinates.
             * Typically used to transform a shape's normal vectors during lighting calculations.
             * @type {Matrix}
             * @readonly
             */
            this.modelviewNormalTransform = Matrix.fromIdentity().setToTransposeOfMatrix(this.modelviewInv.upper3By3());

            // Compute the eye coordinate rectangles carved out of the frustum by the near and far clipping planes, and
            // the distance between those planes and the eye point along the -Z axis. The rectangles are determined by
            // transforming the bottom-left and top-right points of the frustum from clip coordinates to eye
            // coordinates.
            var nbl = new Vec3(-1, -1, -1),
                ntr = new Vec3(+1, +1, -1),
                fbl = new Vec3(-1, -1, +1),
                ftr = new Vec3(+1, +1, +1);
            // Convert each frustum corner from clip coordinates to eye coordinates by multiplying by the inverse
            // projection matrix.
            nbl.multiplyByMatrix(this.projectionInv);
            ntr.multiplyByMatrix(this.projectionInv);
            fbl.multiplyByMatrix(this.projectionInv);
            ftr.multiplyByMatrix(this.projectionInv);

            var nrRectWidth = WWMath.fabs(ntr[0] - nbl[0]),
                frRectWidth = WWMath.fabs(ftr[0] - fbl[0]),
                nrDistance = -nbl[2],
                frDistance = -fbl[2];

            // Compute the scale and offset used to determine the width of a pixel on a rectangle carved out of the
            // frustum at a distance along the -Z axis in eye coordinates. These values are found by computing the scale
            // and offset of a frustum rectangle at a given distance, then dividing each by the viewport width.
            var frustumWidthScale = (frRectWidth - nrRectWidth) / (frDistance - nrDistance),
                frustumWidthOffset = nrRectWidth - frustumWidthScale * nrDistance;
            this.pixelSizeScale = frustumWidthScale / viewport.width;
            this.pixelSizeOffset = frustumWidthOffset / viewport.height;
        };

        /**
         * Transforms the specified model point from model coordinates to WebGL screen coordinates.
         * <p>
         * The resultant screen point is in WebGL screen coordinates, with the origin in the bottom-left corner and
         * axes that extend up and to the right from the origin.
         * <p>
         * This function stores the transformed point in the result argument, and returns true or false to indicate
         * whether or not the transformation is successful. It returns false if this navigator state's modelview or
         * projection matrices are malformed, or if the specified model point is clipped by the near clipping plane or
         * the far clipping plane.
         *
         * @param {Vec3} modelPoint The model coordinate point to project.
         * @param {Vec3} result A pre-allocated vector in which to return the projected point.
         * @returns {boolean} true if the transformation is successful, otherwise false.
         * @throws {ArgumentError} If either the specified point or result argument is null or undefined.
         */
        NavigatorState.prototype.project = function (modelPoint, result) {
            if (!modelPoint) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "NavigatorState", "project",
                    "missingPoint"));
            }

            if (!result) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "NavigatorState", "project",
                    "missingResult"));
            }

            // Transform the model point from model coordinates to eye coordinates then to clip coordinates. This
            // inverts the Z axis and stores the negative of the eye coordinate Z value in the W coordinate.
            var mx = modelPoint[0],
                my = modelPoint[1],
                mz = modelPoint[2],
                m = this.modelviewProjection,
                x = m[0] * mx + m[1] * my + m[2] * mz + m[3],
                y = m[4] * mx + m[5] * my + m[6] * mz + m[7],
                z = m[8] * mx + m[9] * my + m[10] * mz + m[11],
                w = m[12] * mx + m[13] * my + m[14] * mz + m[15],
                viewport = this.viewport;

            if (w == 0) {
                return false;
            }

            // Complete the conversion from model coordinates to clip coordinates by dividing by W. The resultant X, Y
            // and Z coordinates are in the range [-1,1].
            x /= w;
            y /= w;
            z /= w;

            // Clip the point against the near and far clip planes.
            if (z < -1 || z > 1) {
                return false;
            }

            // Convert the point from clip coordinate to the range [0,1]. This enables the X and Y coordinates to be
            // converted to screen coordinates, and the Z coordinate to represent a depth value in the range[0,1].
            x = x * 0.5 + 0.5;
            y = y * 0.5 + 0.5;
            z = z * 0.5 + 0.5;

            // Convert the X and Y coordinates from the range [0,1] to screen coordinates.
            x = x * viewport.width + viewport.x;
            y = y * viewport.height + viewport.y;

            result[0] = x;
            result[1] = y;
            result[2] = z;

            return true;
        };
        /**
         * Transforms the specified model point from model coordinates to WebGL screen coordinates, applying an offset
         * to the modelPoint's projected depth value.
         * <p>
         * The resultant screen point is in WebGL screen coordinates, with the origin in the bottom-left corner and axes
         * that extend up and to the right from the origin.
         * <p>
         * This function stores the transformed point in the result argument, and returns true or false to indicate whether or
         * not the transformation is successful. It returns false if this navigator state's modelview or projection
         * matrices are malformed, or if the modelPoint is clipped by the near clipping plane or the far clipping plane,
         * ignoring the depth offset.
         * <p>
         * The depth offset may be any real number and is typically used to move the screenPoint slightly closer to the
         * user's eye in order to give it visual priority over nearby objects or terrain. An offset of zero has no effect.
         * An offset less than zero brings the screenPoint closer to the eye, while an offset greater than zero pushes the
         * projected screen point away from the eye.
         * <p>
         * Applying a non-zero depth offset has no effect on whether the model point is clipped by this method or by
         * WebGL. Clipping is performed on the original model point, ignoring the depth offset. The final depth value
         * after applying the offset is clamped to the range [0,1].
         *
         * @param {Vec3} modelPoint The model coordinate point to project.
         * @param {Number} depthOffset The amount of offset to apply.
         * @param {Vec3} result A pre-allocated vector in which to return the projected point.
         * @returns {boolean} true if the transformation is successful, otherwise false.
         * @throws {ArgumentError} If either the specified point or result argument is null or undefined.
         */
        NavigatorState.prototype.projectWithDepth = function (modelPoint, depthOffset, result) {
            if (!modelPoint) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "NavigatorState", "projectWithDepth",
                    "missingPoint"));
            }

            if (!result) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "NavigatorState", "projectWithDepth",
                    "missingResult"));
            }

            // Transform the model point from model coordinates to eye coordinates. The eye coordinate and the clip
            // coordinate are transformed separately in order to reuse the eye coordinate below.
            var mx = modelPoint[0],
                my = modelPoint[1],
                mz = modelPoint[2],
                m = this.modelview,
                ex = m[0] * mx + m[1] * my + m[2] * mz + m[3],
                ey = m[4] * mx + m[5] * my + m[6] * mz + m[7],
                ez = m[8] * mx + m[9] * my + m[10] * mz + m[11],
                ew = m[12] * mx + m[13] * my + m[14] * mz + m[15];

            // Transform the point from eye coordinates to clip coordinates.
            var p = this.projection,
                x = p[0] * ex + p[1] * ey + p[2] * ez + p[3] * ew,
                y = p[4] * ex + p[5] * ey + p[6] * ez + p[7] * ew,
                z = p[8] * ex + p[9] * ey + p[10] * ez + p[11] * ew,
                w = p[12] * ex + p[13] * ey + p[14] * ez + p[15] * ew,
                viewport = this.viewport;

            if (w === 0) {
                return false;
            }

            // Complete the conversion from model coordinates to clip coordinates by dividing by W. The resultant X, Y
            // and Z coordinates are in the range [-1,1].
            x /= w;
            y /= w;
            z /= w;

            // Clip the point against the near and far clip planes.
            if (z < -1 || z > 1) {
                return false;
            }

            // Transform the Z eye coordinate to clip coordinates again, this time applying a depth offset. The depth
            // offset is applied only to the matrix element affecting the projected Z coordinate, so we inline the
            // computation here instead of re-computing X, Y, Z and W in order to improve performance. See
            // Matrix.offsetProjectionDepth for more information on the effect of this offset.
            z = p[8] * ex + p[9] * ey + p[10] * ez * (1 + depthOffset) + p[11] * ew;
            z /= w;

            // Clamp the point to the near and far clip planes. We know the point's original Z value is contained within
            // the clip planes, so we limit its offset z value to the range [-1, 1] in order to ensure it is not clipped
            // by WebGL. In clip coordinates the near and far clip planes are perpendicular to the Z axis and are
            // located at -1 and 1, respectively.
            z = WWMath.clamp(z, -1, 1);

            // Convert the point from clip coordinates to the range [0, 1]. This enables the XY coordinates to be
            // converted to screen coordinates, and the Z coordinate to represent a depth value in the range [0, 1].
            x = x * 0.5 + 0.5;
            y = y * 0.5 + 0.5;
            z = z * 0.5 + 0.5;

            // Convert the X and Y coordinates from the range [0,1] to screen coordinates.
            x = x * viewport.width + viewport.x;
            y = y * viewport.height + viewport.y;

            result[0] = x;
            result[1] = y;
            result[2] = z;

            return true;
        };

        /**
         * Transforms the specified screen point from WebGL screen coordinates to model coordinates.
         * <p>
         * The screen point is understood to be in WebGL screen coordinates, with the origin in the bottom-left corner
         * and axes that extend up and to the right from the origin.
         * <p>
         * This function stores the transformed point in the result argument, and returns true or false to indicate whether the
         * transformation is successful. It returns false if this navigator state's modelview or projection matrices
         * are malformed, or if the screenPoint is clipped by the near clipping plane or the far clipping plane.
         *
         * @param {Vec3} screenPoint The screen coordinate point to un-project.
         * @param {Vec3} result A pre-allocated vector in which to return the unprojected point.
         * @returns {boolean} true if the transformation is successful, otherwise false.
         * @throws {ArgumentError} If either the specified point or result argument is null or undefined.
         */
        NavigatorState.prototype.unProject = function (screenPoint, result) {
            if (!screenPoint) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "NavigatorState", "unProject",
                    "missingPoint"));
            }

            if (!result) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "NavigatorState", "unProject",
                    "missingResult"));
            }

            var sx = screenPoint[0],
                sy = screenPoint[1],
                sz = screenPoint[2],
                viewport = this.viewport;

            // Convert the XY screen coordinates to coordinates in the range [0, 1]. This enables the XY coordinates to
            // be converted to clip coordinates.
            sx = (sx - viewport.x) / viewport.width;
            sy = (sy - viewport.y) / viewport.height;

            // Convert from coordinates in the range [0, 1] to clip coordinates in the range [-1, 1].
            sx = sx * 2 - 1;
            sy = sy * 2 - 1;
            sz = sz * 2 - 1;

            // Clip the point against the near and far clip planes. In clip coordinates the near and far clip planes are
            // perpendicular to the Z axis and are located at -1 and 1, respectively.
            if (sz < -1 || sz > 1) {
                return false;
            }

            // Transform the screen point from clip coordinates to model coordinates. This inverts the Z axis and stores
            // the negative of the eye coordinate Z value in the W coordinate.
            var m = this.modelviewProjectionInv,
                x = m[0] * sx + m[1] * sy + m[2] * sz + m[3],
                y = m[4] * sx + m[5] * sy + m[6] * sz + m[7],
                z = m[8] * sx + m[9] * sy + m[10] * sz + m[11],
                w = m[12] * sx + m[13] * sy + m[14] * sz + m[15];

            if (w === 0) {
                return false;
            }

            // Complete the conversion from model coordinates to clip coordinates by dividing by W.
            result[0] = x / w;
            result[1] = y / w;
            result[2] = z / w;

            return true;
        };

        /**
         * Converts a WebGL screen point to window coordinates.
         * <p>
         * The specified point is understood to be in WebGL screen coordinates, with the origin in the bottom-left
         * corner and axes that extend up and to the right from the origin point.
         * <p>
         * The returned point is in the window coordinate system of the WorldWindow, with the origin in the top-left
         * corner and axes that extend down and to the right from the origin point.
         *
         * @param {Vec2} screenPoint The screen point to convert.
         * @param {Vec2} result A pre-allocated {@link Vec2} in which to return the computed point.
         * @returns {Vec2} The specified result argument set to the computed point.
         * @throws {ArgumentError} If either argument is null or undefined.
         */
        NavigatorState.prototype.convertPointToWindow = function (screenPoint, result) {
            if (!screenPoint) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "NavigatorState", "convertPointToWindow",
                    "missingPoint"));
            }

            if (!result) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "NavigatorState", "convertPointToWindow",
                    "missingResult"));
            }

            result[0] = screenPoint[0];
            result[1] = this.viewport.height - screenPoint[1];

            return result;
        };

        /**
         * Converts a window-coordinate point to WebGL screen coordinates.
         * <p>
         * The specified point is understood to be in the window coordinate system of the WorldWindow, with the origin
         * in the top-left corner and axes that extend down and to the right from the origin point.
         * <p>
         * The returned point is in WebGL screen coordinates, with the origin in the bottom-left corner and axes that
         * extend up and to the right from the origin point.
         *
         * @param {Vec2} point The window-coordinate point to convert.
         * @param {Vec2} result A pre-allocated {@link Vec2} in which to return the computed point.
         * @returns {Vec2} The specified result argument set to the computed point.
         * @throws {ArgumentError} If either argument is null or undefined.
         */
        NavigatorState.prototype.convertPointToViewport = function (point, result) {
            if (!point) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "NavigatorState", "convertPointToViewport",
                    "missingPoint"));
            }

            if (!result) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "NavigatorState", "convertPointToViewport",
                    "missingResult"));
            }

            result[0] = point[0];
            result[1] = this.viewport.height - point[1];

            return result;
        };

        /**
         * Computes a ray originating at the navigator's eyePoint and extending through the specified point in window
         * coordinates.
         * <p>
         * The specified point is understood to be in the window coordinate system of the WorldWindow, with the origin
         * in the top-left corner and axes that extend down and to the right from the origin point.
         * <p>
         * The results of this method are undefined if the specified point is outside of the WorldWindow's
         * bounds.
         *
         * @param {Vec2} point The window coordinates point to compute a ray for.
         * @returns {Line} A new Line initialized to the origin and direction of the computed ray, or null if the
         * ray could not be computed.
         */
        NavigatorState.prototype.rayFromScreenPoint = function (point) {
            if (!point) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "NavigatorState", "rayFromScreenPoint",
                    "missingPoint"));
            }

            // Convert the point's xy coordinates from window coordinates to WebGL screen coordinates.
            var screenPoint = this.convertPointToViewport(point, new Vec3(0, 0, 0)),
                nearPoint = new Vec3(0, 0, 0),
                farPoint = new Vec3(0, 0, 0);

            // Compute the model coordinate point on the near clip plane with the xy coordinates and depth 0.
            if (!this.unProject(screenPoint, nearPoint)) {
                return null;
            }

            // Compute the model coordinate point on the far clip plane with the xy coordinates and depth 1.
            screenPoint[2] = 1;
            if (!this.unProject(screenPoint, farPoint)) {
                return null;
            }

            // Compute a ray originating at the eye point and with direction pointing from the xy coordinate on the near
            // plane to the same xy coordinate on the far plane.
            var origin = new Vec3(this.eyePoint[0], this.eyePoint[1], this.eyePoint[2]),
                direction = new Vec3(farPoint[0], farPoint[1], farPoint[2]);

            direction.subtract(nearPoint);
            direction.normalize();

            return new Line(origin, direction);
        };

        /**
         * Computes the approximate size of a pixel at a specified distance from the navigator's eye point.
         * <p>
         * This method assumes rectangular pixels, where pixel coordinates denote
         * infinitely thin spaces between pixels. The units of the returned size are in model coordinates per pixel
         * (usually meters per pixel). This returns 0 if the specified distance is zero. The returned size is undefined
         * if the distance is less than zero.
         *
         * @param {Number} distance The distance from the eye point at which to determine pixel size, in model
         * coordinates.
         * @returns {Number} The approximate pixel size at the specified distance from the eye point, in model
         * coordinates per pixel.
         */
        NavigatorState.prototype.pixelSizeAtDistance = function (distance) {
            // Compute the pixel size from the width of a rectangle carved out of the frustum in model coordinates at
            // the specified distance along the -Z axis and the viewport width in screen coordinates. The pixel size is
            // expressed in model coordinates per screen coordinate (e.g. meters per pixel).
            //
            // The frustum width is determined by noticing that the frustum size is a linear function of distance from
            // the eye point. The linear equation constants are determined during initialization, then solved for
            // distance here.
            //
            // This considers only the frustum width by assuming that the frustum and viewport share the same aspect
            // ratio, so that using either the frustum width or height results in the same pixel size.

            return this.pixelSizeScale * distance + this.pixelSizeOffset;
        };

        return NavigatorState;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports PickedObject
 * @version $Id: PickedObject.js 2940 2015-03-30 17:58:36Z tgaskins $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
        "use strict";

        /**
         * Constructs a picked object.
         * @alias PickedObject
         * @constructor
         * @classdesc Represents a picked object.
         * @param {Color} color The pick color identifying the object.
         * @param {Object} userObject An object to associate with this picked object, usually the picked shape.
         * @param {Position} position The picked object's geographic position. May be null if unknown.
         * @param {Layer} parentLayer The layer containing the picked object.
         * @param {Boolean} isTerrain true if the picked object is terrain, otherwise false.
         */
        var PickedObject = function (color, userObject, position, parentLayer, isTerrain) {

            /**
             * This picked object's pick color.
             * @type {Color}
             * @readonly
             */
            this.color = color;

            /**
             * The picked shape.
             * @type {Object}
             * @readonly
             */
            this.userObject = userObject;

            /**
             * This picked object's geographic position.
             * @type {Position}
             * @readonly
             */
            this.position = position;

            /**
             * The layer containing this picked object.
             * @type {Layer}
             * @readonly
             */
            this.parentLayer = parentLayer;

            /**
             * Indicates whether this picked object is terrain.
             * @type {Boolean}
             * @readonly
             */
            this.isTerrain = isTerrain;

            /**
             * Indicates whether this picked object is the top object.
             * @type {boolean}
             */
            this.isOnTop = false;
        };

        return PickedObject;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports AbstractError
 * @version $Id: AbstractError.js 2913 2015-03-19 19:01:18Z tgaskins $
 */
!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    "use strict";

    /**
     * Constructs an error with a specified name and message.
     * @alias AbstractError
     * @constructor
     * @abstract
     * @classdesc Provides an abstract base class for error classes. This class is not meant to be instantiated
     * directly but used only by subclasses.
     * @param {String} name The error's name.
     * @param {String} message The message.
     */
    var AbstractError = function (name, message) {
        this.name = name;
        this.message = message;
    };

    /**
     * Returns the message and stack trace associated with this error.
     * @returns {String} The message and stack trace associated with this error.
     */
    AbstractError.prototype.toString = function () {
        var str = this.name + ': ' + this.message;

        if (this.stack) {
            str += '\n' + this.stack.toString();
        }

        return str;
    };

    return AbstractError;

}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports NotYetImplementedError
 * @version $Id: NotYetImplementedError.js 2631 2015-01-02 21:32:32Z tgaskins $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(22)], __WEBPACK_AMD_DEFINE_RESULT__ = function (AbstractError) {
        "use strict";

        /**
         * Constructs a not-yet-implemented error with a specified message.
         * @alias NotYetImplementedError
         * @constructor
         * @classdesc Represents an error associated with an operation that is not yet implemented.
         * @augments AbstractError
         * @param {String} message The message.
         */
        var NotYetImplementedError = function (message) {
            AbstractError.call(this, "NotYetImplementedError", message);

            var stack;
            try {
                //noinspection ExceptionCaughtLocallyJS
                throw new Error();
            } catch (e) {
                stack = e.stack;
            }
            this.stack = stack;
        };

        NotYetImplementedError.prototype = Object.create(AbstractError.prototype);

        return NotYetImplementedError;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports Frustum
 * @version $Id: Frustum.js 2919 2015-03-22 20:46:59Z tgaskins $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(1),
        __webpack_require__(5),
        __webpack_require__(18),
        __webpack_require__(0)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
              Matrix,
              Plane,
              Logger) {
        "use strict";

        /**
         * Constructs a frustum.
         * @alias Frustum
         * @constructor
         * @classdesc Represents a six-sided view frustum in Cartesian coordinates.
         * @param {Plane} left The frustum's left plane.
         * @param {Plane} right The frustum's right plane.
         * @param {Plane} bottom The frustum's bottom plane.
         * @param {Plane} top The frustum's top plane.
         * @param {Plane} near The frustum's near plane.
         * @param {Plane} far The frustum's far plane.
         * @throws {ArgumentError} If any specified plane is null or undefined.
         */
        var Frustum = function (left, right, bottom, top, near, far) {
            if (!left || !right || !bottom || !top || !near || !far) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Frustum", "constructor", "missingPlane"));
            }

            // Internal. Intentionally not documented. See property accessors below for public interface.
            this._left = left;
            this._right = right;
            this._bottom = bottom;
            this._top = top;
            this._near = near;
            this._far = far;

            // Internal. Intentionally not documented.
            this._planes = [this._left, this._right, this._top, this._bottom, this._near, this._far];
        };

        // These accessors are defined in order to prevent changes that would make the properties inconsistent with the
        // planes array.
        Object.defineProperties(Frustum.prototype, {
            /**
             * This frustum's left plane.
             * @memberof Frustum.prototype
             * @type {Plane}
             * @readonly
             */
            left: {
                get: function() {
                    return this._left;
                }
            },
            /**
             * This frustum's right plane.
             * @memberof Frustum.prototype
             * @type {Plane}
             * @readonly
             */
            right: {
                get: function() {
                    return this._right;
                }
            },
            /**
             * This frustum's bottom plane.
             * @memberof Frustum.prototype
             * @type {Plane}
             * @readonly
             */
            bottom: {
                get: function() {
                    return this._bottom;
                }
            },
            /**
             * This frustum's top plane.
             * @memberof Frustum.prototype
             * @type {Plane}
             * @readonly
             */
            top: {
                get: function() {
                    return this._top;
                }
            },
            /**
             * This frustum's near plane.
             * @memberof Frustum.prototype
             * @type {Plane}
             * @readonly
             */
            near: {
                get: function() {
                    return this._near;
                }
            },
            /**
             * This frustum's far plane.
             * @memberof Frustum.prototype
             * @type {Plane}
             * @readonly
             */
            far: {
                get: function() {
                    return this._far;
                }
            }
        });

        /**
         * Transforms this frustum by a specified matrix.
         * @param {Matrix} matrix The matrix to apply to this frustum.
         * @returns {Frustum} This frustum set to its original value multiplied by the specified matrix.
         * @throws {ArgumentError} If the specified matrix is null or undefined.
         */
        Frustum.prototype.transformByMatrix = function (matrix) {
            if (!matrix) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Frustum", "transformByMatrix", "missingMatrix"));
            }

            this._left.transformByMatrix(matrix);
            this._right.transformByMatrix(matrix);
            this._bottom.transformByMatrix(matrix);
            this._top.transformByMatrix(matrix);
            this._near.transformByMatrix(matrix);
            this._far.transformByMatrix(matrix);

            return this;
        };

        /**
         * Normalizes the plane vectors of the planes composing this frustum.
         * @returns {Frustum} This frustum with its planes normalized.
         */
        Frustum.prototype.normalize = function () {
            this._left.normalize();
            this._right.normalize();
            this._bottom.normalize();
            this._top.normalize();
            this._near.normalize();
            this._far.normalize();

            return this;
        };

        /**
         * Returns a new frustum with each of its planes 1 meter from the center.
         * @returns {Frustum} The new frustum.
         */
        Frustum.unitFrustum = function () {
            return new Frustum(
                new Plane(1, 0, 0, 1), // left
                new Plane(-1, 0, 0, 1), // right
                new Plane(0, 1, 1, 1), // bottom
                new Plane(0, -1, 0, 1), // top
                new Plane(0, 0, -1, 1), // near
                new Plane(0, 0, 1, 1) // far
            );
        };

        /**
         * Extracts a frustum from a projection matrix.
         * <p>
         * This method assumes that the specified matrix represents a projection matrix. If it does not represent a projection matrix
         * the results are undefined.
         * <p>
         * A projection matrix's view frustum is a Cartesian volume that contains everything visible in a scene displayed
         * using that projection matrix.
         *
         * @param {Matrix} matrix The projection matrix to extract the frustum from.
         * @return {Frustum} A new frustum containing the projection matrix's view frustum, in eye coordinates.
         * @throws {ArgumentError} If the specified matrix is null or undefined.
         */
        Frustum.fromProjectionMatrix = function (matrix) {
            if (!matrix) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Frustum", "fromProjectionMatrix", "missingMatrix"));
            }

            var x, y, z, w, d, left, right, top, bottom, near, far;

            // Left Plane = row 4 + row 1:
            x = matrix[12] + matrix[0];
            y = matrix[13] + matrix[1];
            z = matrix[14] + matrix[2];
            w = matrix[15] + matrix[3];
            d = Math.sqrt(x * x + y * y + z * z); // for normalizing the coordinates
            left = new Plane(x / d, y / d, z / d, w / d);

            // Right Plane = row 4 - row 1:
            x = matrix[12] - matrix[0];
            y = matrix[13] - matrix[1];
            z = matrix[14] - matrix[2];
            w = matrix[15] - matrix[3];
            d = Math.sqrt(x * x + y * y + z * z); // for normalizing the coordinates
            right = new Plane(x / d, y / d, z / d, w / d);

            // Bottom Plane = row 4 + row 2:
            x = matrix[12] + matrix[4];
            y = matrix[13] + matrix[5];
            z = matrix[14] + matrix[6];
            w = matrix[15] + matrix[7];
            d = Math.sqrt(x * x + y * y + z * z); // for normalizing the coordinates
            bottom = new Plane(x / d, y / d, z / d, w / d);

            // Top Plane = row 4 - row 2:
            x = matrix[12] - matrix[4];
            y = matrix[13] - matrix[5];
            z = matrix[14] - matrix[6];
            w = matrix[15] - matrix[7];
            d = Math.sqrt(x * x + y * y + z * z); // for normalizing the coordinates
            top = new Plane(x / d, y / d, z / d, w / d);

            // Near Plane = row 4 + row 3:
            x = matrix[12] + matrix[8];
            y = matrix[13] + matrix[9];
            z = matrix[14] + matrix[10];
            w = matrix[15] + matrix[11];
            d = Math.sqrt(x * x + y * y + z * z); // for normalizing the coordinates
            near = new Plane(x / d, y / d, z / d, w / d);

            // Far Plane = row 4 - row 3:
            x = matrix[12] - matrix[8];
            y = matrix[13] - matrix[9];
            z = matrix[14] - matrix[10];
            w = matrix[15] - matrix[11];
            d = Math.sqrt(x * x + y * y + z * z); // for normalizing the coordinates
            far = new Plane(x / d, y / d, z / d, w / d);

            return new Frustum(left, right, bottom, top, near, far);
        };

        Frustum.prototype.containsPoint = function (point) {
            if (!point) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Frustum", "containsPoint", "missingPoint"));
            }

            // See if the point is entirely within the frustum. The dot product of the point with each plane's vector
            // provides a distance to each plane. If this distance is less than 0, the point is clipped by that plane and
            // neither intersects nor is contained by the space enclosed by this Frustum.

            if (this._far.dot(point) <= 0)
                return false;
            if (this._left.dot(point) <= 0)
                return false;
            if (this._right.dot(point) <= 0)
                return false;
            if (this._top.dot(point) <= 0)
                return false;
            if (this._bottom.dot(point) <= 0)
                return false;
            if (this._near.dot(point) <= 0)
                return false;

            return true;
        };

        /**
         * Determines whether a line segment intersects this frustum.
         *
         * @param {Vec3} pointA One end of the segment.
         * @param {Vec3} pointB The other end of the segment.
         *
         * @return {boolean} <code>true</code> if the segment intersects or is contained in this frustum,
         * otherwise <code>false</code>.
         *
         * @throws {ArgumentError} If either point is null or undefined.
         */
        Frustum.prototype.intersectsSegment = function (pointA, pointB) {
            if (!pointA || !pointB) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Frustum", "containsPoint", "missingPoint"));
            }

            // First do a trivial accept test.
            if (this.containsPoint(pointA) || this.containsPoint(pointB))
                return true;

            if (pointA.equals(pointB))
                return false;

            for (var i = 0, len = this._planes.length; i < len; i++) {

                // See if both points are behind the plane and therefore not in the frustum.
                if (this._planes[i].onSameSide(pointA, pointB) < 0)
                    return false;

                // See if the segment intersects the plane.
                if (this._planes[i].clip(pointA, pointB) != null)
                    return true;
            }

            return false; // segment does not intersect frustum
        };

        return Frustum;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports Texture
 * @version $Id: Texture.js 3414 2015-08-20 19:09:19Z tgaskins $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(1),
        __webpack_require__(0),
        __webpack_require__(4)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
              Logger,
              WWMath) {
        "use strict";

        /**
         * Constructs a texture for a specified image.
         * @alias Texture
         * @constructor
         * @classdesc Represents a WebGL texture. Applications typically do not interact with this class.
         * @param {WebGLRenderingContext} gl The current WebGL rendering context.
         * @param {Image} image The texture's image.
         * @param {GL.enum} wrapMode Optional. Specifies the wrap mode of the texture. Defaults to gl.CLAMP_TO_EDGE
         * @throws {ArgumentError} If the specified WebGL context or image is null or undefined.
         */
        var Texture = function (gl, image, wrapMode) {

            if (!gl) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "Texture", "constructor",
                    "missingGlContext"));
            }

            if (!image) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "Texture", "constructor",
                    "missingImage"));
            }

            if (!wrapMode) {
                wrapMode = gl.CLAMP_TO_EDGE;
            }

            var textureId = gl.createTexture(),
                isPowerOfTwo = (WWMath.isPowerOfTwo(image.width) && WWMath.isPowerOfTwo(image.height));

            this.originalImageWidth = image.width;
            this.originalImageHeight = image.height;

            if (wrapMode === gl.REPEAT && !isPowerOfTwo) {
                image = this.resizeImage(image);
                isPowerOfTwo = true;
            }

            this.imageWidth = image.width;
            this.imageHeight = image.height;
            this.size = image.width * image.height * 4;

            gl.bindTexture(gl.TEXTURE_2D, textureId);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER,
                isPowerOfTwo ? gl.LINEAR_MIPMAP_LINEAR : gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER,
                gl.LINEAR);

            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrapMode);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapMode);

            // Setup 4x anisotropic texture filtering when this feature is available.
            // https://www.khronos.org/registry/webgl/extensions/EXT_texture_filter_anisotropic
            var ext = (
            gl.getExtension("EXT_texture_filter_anisotropic") ||
            gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic"));
            if (ext) {
                gl.texParameteri(gl.TEXTURE_2D, ext.TEXTURE_MAX_ANISOTROPY_EXT, 4);
            }

            gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 1);
            gl.texImage2D(gl.TEXTURE_2D, 0,
                gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
            gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);

            if (isPowerOfTwo) {
                gl.generateMipmap(gl.TEXTURE_2D);
            }

            this.textureId = textureId;

            /**
             * The time at which this texture was created.
             * @type {Date}
             */
            this.creationTime = new Date();
        };

        /**
         * Disposes of the WebGL texture object associated with this texture.
         * @param gl
         */
        Texture.prototype.dispose = function (gl) {
            gl.deleteTexture(this.textureId);
            delete this.textureId;
        };

        /**
         * Binds this texture in the current WebGL graphics context.
         * @param {DrawContext} dc The current draw context.
         */
        Texture.prototype.bind = function (dc) {
            dc.currentGlContext.bindTexture(dc.currentGlContext.TEXTURE_2D, this.textureId);
            dc.frameStatistics.incrementTextureLoadCount(1);
            return true;
        };

        /**
         * Resizes an image to a power of two.
         * @param {Image} image The image to resize.
         */
        Texture.prototype.resizeImage = function (image) {
            var canvas = document.createElement("canvas");
            canvas.width = WWMath.powerOfTwoFloor(image.width);
            canvas.height = WWMath.powerOfTwoFloor(image.height);
            var ctx = canvas.getContext("2d");
            ctx.drawImage(image, 0, 0, canvas.width, canvas.height);
            return canvas;
        };


        return Texture;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports Level
 * @version $Id: Level.js 2952 2015-04-01 00:33:54Z tgaskins $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(6),
        __webpack_require__(1),
        __webpack_require__(7),
        __webpack_require__(0)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Angle,
              ArgumentError,
              Location,
              Logger) {
        "use strict";

        /**
         * Constructs a Level within a [LevelSet]{@link LevelSet}. Applications typically do not interact with this
         * class.
         * @alias Level
         * @constructor
         * @classdesc Represents a level in a tile pyramid.
         * @throws {ArgumentError} If either the specified tile delta or parent level set is null or undefined.
         */
        var Level = function (levelNumber, tileDelta, parent) {
            if (!tileDelta) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Level", "constructor",
                        "The specified tile delta is null or undefined"));
            }

            if (!parent) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Level", "constructor",
                        "The specified parent level set is null or undefined"));
            }

            /**
             * The level's ordinal in its parent level set.
             * @type {Number}
             */
            this.levelNumber = levelNumber;

            /**
             * The geographic size of tiles within this level.
             * @type {Location}
             */
            this.tileDelta = tileDelta;

            /**
             * The level set that this level is a member of.
             * @type {LevelSet}
             */
            this.parent = parent;

            /**
             * The size of pixels or elevation cells within this level, in radians per pixel or per cell.
             * @type {Number}
             */
            this.texelSize = (tileDelta.latitude * Angle.DEGREES_TO_RADIANS) / parent.tileHeight;

            /**
             * The width in pixels or cells of the resource associated with tiles within this level.
             * @type {Number}
             */
            this.tileWidth = parent.tileWidth;

            /**
             * The height in pixels or cells of the resource associated with tiles within this level.
             * @type {Number}
             */
            this.tileHeight = parent.tileHeight;

            /**
             * The sector spanned by this level.
             * @type {Sector}
             */
            this.sector = parent.sector;
        };

        /**
         * Indicates whether this level is the lowest resolution level (level 0) within its parent's level set.
         * @returns {Boolean} true If this tile is the lowest resolution in the parent level set,
         * otherwise false.
         */
        Level.prototype.isFirstLevel = function () {
            return this.parent.firstLevel() == this;
        };

        /**
         * Indicates whether this level is the highest resolution level within its parent's level set.
         * @returns {Boolean} true If this tile is the highest resolution in the parent level set,
         * otherwise false.
         */
        Level.prototype.isLastLevel = function () {
            return this.parent.lastLevel() == this;
        };

        /**
         * Returns the level whose ordinal occurs immediately before this level's ordinal in the parent level set, or
         * null if this is the fist level.
         * @returns {Level} The previous level, or null if this is the first level.
         */
        Level.prototype.previousLevel = function () {
            return this.parent.level(this.levelNumber - 1);
        };

        /**
         * Returns the level whose ordinal occurs immediately after this level's ordinal in the parent level set, or
         * null if this is the last level.
         * @returns {Level} The next level, or null if this is the last level.
         */
        Level.prototype.nextLevel = function () {
            return this.parent.level(this.levelNumber + 1);
        };

        /**
         * Compare this level's ordinal to that of a specified level.
         * @param {Level} that The level to compare this one to.
         * @returns {Number} 0 if the two ordinals are equivalent. -1 if this level's ordinal is less than the specified
         * level's ordinal. 1 if this level's ordinal is greater than the specified level's ordinal.
         * @throws {ArgumentError} If the specified level is null or undefined.
         */
        Level.prototype.compare = function (that) {
            if (!that) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Level", "compare",
                        "The specified level is null or undefined"));
            }

            if (this.levelNumber < that.levelNumber)
                return -1;

            if (this.levelNumber > that.levelNumber)
                return 1;

            return 0;
        };

        return Level;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports LevelSet
 * @version $Id: LevelSet.js 2952 2015-04-01 00:33:54Z tgaskins $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(1),
        __webpack_require__(26),
        __webpack_require__(7),
        __webpack_require__(0)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
              Level,
              Location,
              Logger) {
        "use strict";

        /**
         * Constructs a level set.
         * @alias Level
         * @constructor
         * @classdesc Represents a multi-resolution, hierarchical collection of tiles. Applications typically do not
         * interact with this class.
         * @param {Sector} sector The sector spanned by this level set.
         * @param {Location} levelZeroDelta The geographic size of tiles in the lowest resolution level of this level set.
         * @param {Number} numLevels The number of levels in the level set.
         * @param {Number} tileWidth The height in pixels of images associated with tiles in this level set, or the number of sample
         * points in the longitudinal direction of elevation tiles associate with this level set.
         * @param {Number} tileHeight The height in pixels of images associated with tiles in this level set, or the number of sample
         * points in the latitudinal direction of elevation tiles associate with this level set.
         * @throws {ArgumentError} If the specified sector or level-zero-delta is null or undefined, the level zero
         * delta values are less than or equal to zero, or any of the number-of-levels, tile-width or tile-height
         * arguments are less than 1.
         */
        var LevelSet = function (sector, levelZeroDelta, numLevels, tileWidth, tileHeight) {
            if (!sector) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "LevelSet", "constructor", "missingSector"));
            }

            if (!levelZeroDelta) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "LevelSet", "constructor",
                        "The specified level zero delta is null or undefined"));
            }

            if (levelZeroDelta.latitude <= 0 || levelZeroDelta.longitude <= 0) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "LevelSet", "constructor",
                        "The specified level zero delta is less than or equal to zero."));
            }

            if (numLevels < 1) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "LevelSet", "constructor",
                        "The specified number of levels is less than one."));
            }

            if (tileWidth < 1 || tileHeight < 1) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "LevelSet", "constructor",
                        "The specified tile width or tile height is less than one."));
            }

            /**
             * The sector spanned by this level set.
             * @type {Sector}
             * @readonly
             */
            this.sector = sector;

            /**
             * The geographic size of the lowest resolution (level 0) tiles in this level set.
             * @type {Location}
             * @readonly
             */
            this.levelZeroDelta = levelZeroDelta;

            /**
             * The number of levels in this level set.
             * @type {Number}
             * @readonly
             */
            this.numLevels = numLevels;

            /**
             *  The width in pixels of images associated with tiles in this level set, or the number of sample points
             *  in the longitudinal direction of elevation tiles associated with this level set.
             * @type {Number}
             * @readonly
             */
            this.tileWidth = tileWidth;

            /**
             *  The height in pixels of images associated with tiles in this level set, or the number of sample points
             *  in the latitudinal direction of elevation tiles associated with this level set.
             * @type {Number}
             * @readonly
             */
            this.tileHeight = tileHeight;

            this.levels = [];

            for (var i = 0; i < numLevels; i += 1) {
                var n = Math.pow(2, i),
                    latDelta = levelZeroDelta.latitude / n,
                    lonDelta = levelZeroDelta.longitude / n,
                    tileDelta = new Location(latDelta, lonDelta),
                    level = new Level(i, tileDelta, this);

                this.levels[i] = level;
            }
        };

        /**
         * Returns the {@link Level} for a specified level number.
         * @param {Number} levelNumber The number of the desired level.
         * @returns {Level} The requested level, or null if the level does not exist.
         */
        LevelSet.prototype.level = function(levelNumber) {
            if (levelNumber < 0 || levelNumber >= this.levels.length) {
                return null;
            } else {
                return this.levels[levelNumber];
            }
        };

        /**
         * Returns the level with a specified texel size.
         * This function returns the first level if the specified texel size is greater than the first level's texel
         * size, and returns the last level if the delta is less than the last level's texel size.
         * @param {Number} texelSize The size of pixels or elevation cells in the level, in radians per pixel or cell.
         */
        LevelSet.prototype.levelForTexelSize = function(texelSize) {
            // TODO: Replace this loop with a computation.
            var lastLevel = this.lastLevel();

            if (lastLevel.texelSize >= texelSize) {
                return lastLevel; // Can't do any better than the last level.
            }

            for (var index = 0, length = this.levels.length; index < length; index += 1) {
                var level = this.levels[index];
                if (level.texelSize <= texelSize) {
                    return level;
                }
            }

            return lastLevel;
        };

        /**
         * Returns the first (lowest resolution) level of this level set.
         * @returns {Level} The first level of this level set.
         */
        LevelSet.prototype.firstLevel = function() {
            return this.levels[0];
        };

        /**
         * Returns the last (highest resolution) level of this level set.
         * @returns {Level} The last level of this level set.
         */
        LevelSet.prototype.lastLevel = function() {
            return this.levels[this.levels.length - 1];
        };

        return LevelSet;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @version $Id: WWUtil.js 3402 2015-08-14 17:28:09Z tgaskins $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(1),
        __webpack_require__(13),
        __webpack_require__(0),
        __webpack_require__(9),
        __webpack_require__(2)], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
              Line,
              Logger,
              Rectangle,
              Vec3) {
        "use strict";
        /**
         * Provides math constants and functions.
         * @exports WWUtil
         */
        var WWUtil = {
            // A regular expression that matches latitude followed by a comma and possible white space followed by
            // longitude. Latitude and longitude ranges are not considered.
            latLonRegex: /^(\-?\d+(\.\d+)?),\s*(\-?\d+(\.\d+)?)$/,

            /**
             * Returns the suffix for a specified mime type.
             * @param {String} mimeType The mime type to determine a suffix for.
             * @returns {String} The suffix for the specified mime type, or null if the mime type is not recognized.
             */
            suffixForMimeType: function (mimeType) {
                if (mimeType === "image/png")
                    return "png";

                if (mimeType === "image/jpeg")
                    return "jpg";

                if (mimeType === "application/bil16")
                    return "bil";

                if (mimeType === "application/bil32")
                    return "bil";

                return null;
            },

            /**
             * Returns the current location URL as obtained from window.location with the last path component
             * removed.
             * @returns {String} The current location URL with the last path component removed.
             */
            currentUrlSansFilePart: function () {
                var protocol = window.location.protocol,
                    host = window.location.host,
                    path = window.location.pathname,
                    pathParts = path.split("/"),
                    newPath = "";

                for (var i = 0, len = pathParts.length; i < len - 1; i++) {
                    if (pathParts[i].length > 0) {
                        newPath = newPath + "/" + pathParts[i];
                    }
                }

                return protocol + "//" + host + newPath;
            },

            /**
             * Returns the URL of the directory containing the World Wind library.
             * @returns {String} The URL of the directory containing the World Wind library, or null if that directory
             * cannot be determined.
             */
            worldwindlibLocation: function () {
                var scripts = document.getElementsByTagName("script"),
                    libraryName = "/worldwind.";

                for (var i = 0; i < scripts.length; i++) {
                    var index = scripts[i].src.indexOf(libraryName);
                    if (index >= 0) {
                        return scripts[i].src.substring(0, index) + "/";
                    }
                }

                return null;
            },

            /**
             * Returns the path component of a specified URL.
             * @param {String} url The URL from which to determine the path component.
             * @returns {String} The path component, or the empty string if the specified URL is null, undefined
             * or empty.
             */
            urlPath: function (url) {
                if (!url)
                    return "";

                var urlParts = url.split("/"),
                    newPath = "";

                for (var i = 0, len = urlParts.length; i < len; i++) {
                    var part = urlParts[i];

                    if (!part || part.length === 0
                        || part.indexOf(":") != -1
                        || part === "."
                        || part === ".."
                        || part === "null"
                        || part === "undefined") {
                        continue;
                    }

                    if (newPath.length !== 0) {
                        newPath = newPath + "/";
                    }

                    newPath = newPath + part;
                }

                return newPath;
            },

            /**
             * Sets each element of an array to a specified value. This function is intentionally generic, and works
             * with any data structure with a length property whose elements may be referenced using array index syntax.
             * @param array The array to fill.
             * @param {*} value The value to assign to each array element.
             */
            fillArray: function (array, value) {
                if (!array) {
                    return;
                }

                for (var i = 0, len = array.length; i < len; i++) {
                    array[i] = value;
                }
            },

            /**
             * Multiplies each element of an array by a specified value and assigns each element to the result. This
             * function is intentionally generic, and works with any data structure with a length property whose
             * elements may be referenced using array index syntax.
             * @param array The array to fill.
             * @param {*} value The value to multiply by each array element.
             */
            multiplyArray: function (array, value) {
                if (!array) {
                    return;
                }

                for (var i = 0, len = array.length; i < len; i++) {
                    array[i] *= value;
                }
            },

            // Used to form unique function names for JSONP callback functions.
            jsonpCounter: 0,

            /**
             * Request a resource using JSONP.
             * @param {String} url The url to receive the request.
             * @param {String} parameterName The JSONP callback function key required by the server. Typically
             * "jsonp" or "callback".
             * @param {Function} callback The function to invoke when the request succeeds. The function receives
             * one argument, the JSON payload of the JSONP request.
             */
            jsonp: function (url, parameterName, callback) {

                // Generate a unique function name for the JSONP callback.
                var functionName = "gov_nasa_worldwind_jsonp_" + WWUtil.jsonpCounter++;

                // Define a JSONP callback function. Assign it to global scope the browser can find it.
                window[functionName] = function (jsonData) {
                    // Remove the JSONP callback from global scope.
                    delete window[functionName];

                    // Call the client's callback function.
                    callback(jsonData);
                };

                // Append the callback query parameter to the URL.
                var jsonpUrl = url + (url.indexOf('?') === -1 ? '?' : '&');
                jsonpUrl += parameterName + "=" + functionName;

                // Create a script element for the browser to invoke.
                var script = document.createElement('script');
                script.async = true;
                script.src = jsonpUrl;

                // Prepare to add the script to the document's head.
                var head = document.getElementsByTagName('head')[0];

                // Set up to remove the script element once it's invoked.
                var cleanup = function () {
                    script.onload = undefined;
                    script.onerror = undefined;
                    head.removeChild(script);
                };

                script.onload = cleanup;
                script.onerror = cleanup;

                // Add the script element to the document, causing the browser to invoke it.
                head.appendChild(script);
            },

            arrayEquals: function (array1, array2) {
                return (array1.length == array2.length) && array1.every(function (element, index) {
                        return element === array2[index] || element.equals && element.equals(array2[index]);
                    });
            },

            /**
             * It transforms given item to the boolean. It respects that 0, "0" and "false" are percieved as false
             * on top of the standard Boolean function.
             * @param item {String} Item to transform
             * @returns {boolean} Value transformed to the boolean.
             */
            transformToBoolean: function (item) {
                if (item == 0 || item == "0" || item == "false") {
                    return false;
                } else {
                    return Boolean(item);
                }
            },

            /**
             * It clones original object into the new one. It is necessary to retain the options information valid
             * for all nodes.
             * @param original Object to clone
             * @returns {Object} Cloned object
             */
            clone: function (original) {
                var clone = {};
                var i, keys = Object.keys(original);

                for (i = 0; i < keys.length; i++) {
                    // copy each property into the clone
                    clone[keys[i]] = original[keys[i]];
                }

                return clone;
            },

            /**
             * It returns unique GUID.
             * @returns {string} String representing unique identifier in the application.
             */
            guid: function () {
                function s4() {
                    return Math.floor((1 + Math.random()) * 0x10000)
                        .toString(16)
                        .substring(1);
                }

                return s4() + s4() + '-' + s4() + '-' + s4() + '-' +
                    s4() + '-' + s4() + s4() + s4();
            },

            /**
             * Transforms item to date. It accepts ISO-8601 format.
             * @param item {String} To transform.
             * @returns {Date} Date extracted from the current information.
             */
            date: function(item) {
                return new Date(item);
            }
        };

        return WWUtil;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports ElevationModel
 * @version $Id: ElevationModel.js 3415 2015-08-20 19:15:57Z tgaskins $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(52),
        __webpack_require__(6),
        __webpack_require__(1),
        __webpack_require__(65),
        __webpack_require__(66),
        __webpack_require__(27),
        __webpack_require__(0),
        __webpack_require__(16),
        __webpack_require__(3),
        __webpack_require__(12),
        __webpack_require__(4)], __WEBPACK_AMD_DEFINE_RESULT__ = function (AbsentResourceList,
              Angle,
              ArgumentError,
              ElevationImage,
              ElevationTile,
              LevelSet,
              Logger,
              MemoryCache,
              Sector,
              Tile,
              WWMath) {
        "use strict";

        /**
         * Constructs an elevation model.
         * @alias ElevationModel
         * @constructor
         * @classdesc Represents the elevations for an area, often but not necessarily the whole globe.
         * <p>
         *     While this class can be used as-is, it is intended to be a base class for more concrete elevation
         *     models, such as {@link EarthElevationModel}.
         * @param {Sector} coverageSector The sector this elevation model spans.
         * @param {Location} levelZeroDelta The size of top-level tiles, in degrees.
         * @param {Number} numLevels The number of levels used to represent this elevation model's resolution pyramid.
         * @param {String} retrievalImageFormat The mime type of the elevation data retrieved by this elevation model.
         * @param {String} cachePath A string unique to this elevation model relative to other elevation models used by
         * the application.
         * @param {Number} tileWidth The number of intervals (cells) in the longitudinal direction of this elevation
         * model's elevation tiles.
         * @param {Number} tileHeight The number of intervals (cells) in the latitudinal direction of this elevation
         * model's elevation tiles.
         * @throws {ArgumentError} If any argument is null or undefined, if the number of levels specified is less
         * than one, or if either the tile width or tile height are less than one.
         */
        var ElevationModel = function (coverageSector, levelZeroDelta, numLevels, retrievalImageFormat, cachePath,
                                       tileWidth, tileHeight) {
            if (!coverageSector) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "ElevationModel", "constructor", "missingSector"));
            }

            if (!levelZeroDelta) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "ElevationModel", "constructor",
                        "The specified level-zero delta is null or undefined."));
            }

            if (!retrievalImageFormat) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "ElevationModel", "constructor",
                        "The specified image format is null or undefined."));
            }

            if (!cachePath) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "ElevationModel", "constructor",
                        "The specified cache path is null or undefined."));
            }

            if (!numLevels || numLevels < 1) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "ElevationModel", "constructor",
                        "The specified number of levels is not greater than zero."));
            }

            if (!tileWidth || !tileHeight || tileWidth < 1 || tileHeight < 1) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "ElevationModel", "constructor",
                        "The specified tile width or height is not greater than zero."));
            }

            /**
             * The sector this elevation model spans.
             * @type {Sector}
             * @readonly
             */
            this.coverageSector = coverageSector;

            /**
             * The mime type to use when retrieving elevations.
             * @type {String}
             * @readonly
             */
            this.retrievalImageFormat = retrievalImageFormat;

            /** A unique string identifying this elevation model relative to other elevation models in use.
             * @type {String}
             * @readonly
             */
            this.cachePath = cachePath;

            /**
             * Indicates this elevation model's display name.
             * @type {String}
             * @default "Elevations"
             */
            this.displayName = "Elevations";

            /**
             * Indicates the last time this elevation model changed, in milliseconds since midnight Jan 1, 1970.
             * @type {Number}
             * @readonly
             * @default Date.now() at construction
             */
            this.timestamp = Date.now();

            /**
             * This elevation model's minimum elevation in meters.
             * @type {Number}
             * @default 0
             */
            this.minElevation = 0;

            /**
             * This elevation model's maximum elevation in meters.
             * @type {Number}
             */
            this.maxElevation = 0;

            /**
             * Indicates whether the data associated with this elevation model is point data. A value of false
             * indicates that the data is area data (pixel is area).
             * @type {Boolean}
             * @default true
             */
            this.pixelIsPoint = true;

            /**
             * The {@link LevelSet} created during construction of this elevation model.
             * @type {LevelSet}
             * @readonly
             */
            this.levels = new LevelSet(this.coverageSector, levelZeroDelta, numLevels, tileWidth, tileHeight);

            // These are internal and intentionally not documented.
            this.currentTiles = []; // holds assembled tiles
            this.currentSector = new Sector(0, 0, 0, 0); // a scratch variable
            this.tileCache = new MemoryCache(1000000, 800000); // for elevation tiles
            this.imageCache = new MemoryCache(10000000, 8000000); // for the elevations, themselves
            this.currentRetrievals = []; // Identifies elevation retrievals in progress
            this.absentResourceList = new AbsentResourceList(3, 5e3);
            this.id = ++ElevationModel.idPool;

            /**
             * A string identifying this elevation model's current state. Used to compare states during rendering to
             * determine whether globe-state dependent cached values must be updated. Applications typically do not
             * interact with this property. It is primarily used by shapes and terrain generators.
             * @memberof ElevationModel.prototype
             * @readonly
             * @type {String}
             */
            this.stateKey = "elevationModel " + this.id.toString() + " ";
        };

        ElevationModel.idPool = 0; // Used to assign unique IDs to elevation models for use in their state key.

        /**
         * Returns the minimum and maximum elevations within a specified sector.
         * @param {Sector} sector The sector for which to determine extreme elevations.
         * @returns {Number[]} An array containing the minimum and maximum elevations within the specified sector,
         * or null if the specified sector is outside this elevation model's coverage area.
         * @throws {ArgumentError} If the specified sector is null or undefined.
         */
        ElevationModel.prototype.minAndMaxElevationsForSector = function (sector) {
            if (!sector) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "ElevationModel", "minAndMaxElevationsForSector", "missingSector"));
            }

            var level = this.levels.levelForTexelSize(sector.deltaLatitude() * Angle.DEGREES_TO_RADIANS / 64);
            this.assembleTiles(level, sector, false);

            if (this.currentTiles.length == 0) {
                return null; // Sector is outside the elevation model's coverage area. Do not modify the result array.
            }

            // Assign the output extreme elevations to the largest and smallest double values, respectively. This has the effect
            // of expanding the extremes with each subsequent tile as needed. If we initialized this array with zeros then the
            // output extreme elevations would always contain zero, even when the range of the image's extreme elevations in the
            // sector does not contain zero.
            var min = Number.MAX_VALUE,
                max = -min,
                image,
                imageMin,
                imageMax,
                result = [];

            for (var i = 0, len = this.currentTiles.length; i < len; i++) {
                image = this.currentTiles[i].image();
                if (image) {
                    imageMin = image.minElevation;
                    if (min > imageMin) {
                        min = imageMin;
                    }

                    imageMax = image.maxElevation;
                    if (max < imageMax) {
                        max = imageMax;
                    }
                } else {
                    result[0] = this.minElevation;
                    result[1] = this.maxElevation;
                    return result; // At least one tile image is not in memory; return the model's extreme elevations.
                }
            }

            result[0] = min;
            result[1] = max;

            return result;
        };

        /**
         * Returns the elevation at a specified location.
         * @param {Number} latitude The location's latitude in degrees.
         * @param {Number} longitude The location's longitude in degrees.
         * @returns {Number} The elevation at the specified location, in meters. Returns zero if the location is
         * outside the coverage area of this elevation model.
         */
        ElevationModel.prototype.elevationAtLocation = function (latitude, longitude) {
            if (!this.coverageSector.containsLocation(latitude, longitude)) {
                return 0; // location is outside the elevation model's coverage
            }

            return this.pointElevationForLocation(latitude, longitude);
        };

        /**
         * Returns the elevations at locations within a specified sector.
         * @param {Sector} sector The sector for which to determine the elevations.
         * @param {Number} numLat The number of latitudinal sample locations within the sector.
         * @param {Number} numLon The number of longitudinal sample locations within the sector.
         * @param {Number} targetResolution The desired elevation resolution, in radians. (To compute radians from
         * meters, divide the number of meters by the globe's radius.)
         * @param {Number[]} result An array in which to return the requested elevations.
         * @returns {Number} The resolution actually achieved, which may be greater than that requested if the
         * elevation data for the requested resolution is not currently available.
         * @throws {ArgumentError} If the specified sector or result array is null or undefined, or if either of the
         * specified numLat or numLon values is less than one.
         */
        ElevationModel.prototype.elevationsForGrid = function (sector, numLat, numLon, targetResolution, result) {
            if (!sector) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "ElevationModel", "elevationsForSector", "missingSector"));
            }

            if (!result) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "ElevationModel", "elevationsForSector", "missingResult"));
            }

            if (!numLat || !numLon || numLat < 1 || numLon < 1) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "ElevationModel", "constructor",
                        "The specified number of latitudinal or longitudinal positions is less than one."));
            }

            var level = this.levels.levelForTexelSize(targetResolution);
            if (this.pixelIsPoint) {
                return this.pointElevationsForGrid(sector, numLat, numLon, level, result);
            } else {
                return this.areaElevationsForGrid(sector, numLat, numLon, level, result);
            }
        };

        // Intentionally not documented.
        ElevationModel.prototype.pointElevationForLocation = function (latitude, longitude) {
            var level = this.levels.lastLevel(),
                deltaLat = level.tileDelta.latitude,
                deltaLon = level.tileDelta.longitude,
                r = Tile.computeRow(deltaLat, latitude),
                c = Tile.computeColumn(deltaLon, longitude),
                tile,
                image = null;

            for (var i = level.levelNumber; i >= 0; i--) {
                tile = this.tileCache.entryForKey(i + "." + r + "." + c);
                if (tile) {
                    image = tile.image();
                    if (image) {
                        return image.elevationAtLocation(latitude, longitude);
                    }
                }

                r = Math.floor(r / 2);
                c = Math.floor(c / 2);
            }

            return 0; // did not find a tile with an image
        };

        // Intentionally not documented.
        ElevationModel.prototype.pointElevationsForGrid = function (sector, numLat, numLon, level, result) {
            var maxResolution = 0,
                resolution;

            this.assembleTiles(level, sector, true);
            if (this.currentTiles.length === 0) {
                return 0; // Sector is outside the elevation model's coverage area. Do not modify the results array.
            }

            // Sort from lowest resolution to highest so that higher resolutions override lower resolutions in the
            // loop below.
            this.currentTiles.sort(function (tileA, tileB) {
                return tileA.level.levelNumber - tileB.level.levelNumber;
            });

            for (var i = 0, len = this.currentTiles.length; i < len; i++) {
                var tile = this.currentTiles[i],
                    image = tile.image();

                if (image) {
                    image.elevationsForGrid(sector, numLat, numLon, result);
                    resolution = tile.level.texelSize;

                    if (maxResolution < resolution) {
                        maxResolution = resolution;
                    }
                } else {
                    maxResolution = Number.MAX_VALUE;
                }
            }

            return maxResolution;
        };

        // Internal. Returns elevations for a grid assuming pixel-is-area.
        ElevationModel.prototype.areaElevationsForGrid = function (sector, numLat, numLon, level, result) {
            var minLat = sector.minLatitude,
                maxLat = sector.maxLatitude,
                minLon = sector.minLongitude,
                maxLon = sector.maxLongitude,
                deltaLat = sector.deltaLatitude() / (numLat > 1 ? numLat - 1 : 1),
                deltaLon = sector.deltaLongitude() / (numLon > 1 ? numLon - 1 : 1),
                lat, lon, s, t,
                latIndex, lonIndex, resultIndex = 0;

            for (latIndex = 0, lat = minLat; latIndex < numLat; latIndex += 1, lat += deltaLat) {
                if (latIndex === numLat - 1) {
                    lat = maxLat; // explicitly set the last lat to the max latitude ensure alignment
                }

                for (lonIndex = 0, lon = minLon; lonIndex < numLon; lonIndex += 1, lon += deltaLon) {
                    if (lonIndex === numLon - 1) {
                        lon = maxLon; // explicitly set the last lon to the max longitude ensure alignment
                    }

                    if (this.coverageSector.containsLocation(lat, lon)) { // ignore locations outside of the model
                        s = (lon + 180) / 360;
                        t = (lat + 90) / 180;
                        this.areaElevationForCoord(s, t, level.levelNumber, result, resultIndex);
                    }

                    resultIndex++;
                }
            }

            return level.texelSize; // TODO: return the actual achieved
        };

        // Internal. Returns an elevation for a location assuming pixel-is-area.
        ElevationModel.prototype.areaElevationForCoord = function (s, t, levelNumber, result, resultIndex) {
            var level, levelWidth, levelHeight,
                tMin, tMax,
                vMin, vMax,
                u, v,
                x0, x1, y0, y1,
                xf, yf,
                retrieveTiles,
                pixels = new Float64Array(4);

            for (var i = levelNumber; i >= 0; i--) {
                level = this.levels.level(i);
                levelWidth = Math.round(level.tileWidth * 360 / level.tileDelta.longitude);
                levelHeight = Math.round(level.tileHeight * 180 / level.tileDelta.latitude);
                tMin = 1 / (2 * levelHeight);
                tMax = 1 - tMin;
                vMin = 0;
                vMax = levelHeight - 1;
                u = levelWidth * WWMath.fract(s); // wrap the horizontal coordinate
                v = levelHeight * WWMath.clamp(t, tMin, tMax); // clamp the vertical coordinate to the level edge
                x0 = WWMath.mod(Math.floor(u - 0.5), levelWidth);
                x1 = WWMath.mod((x0 + 1), levelWidth);
                y0 = WWMath.clamp(Math.floor(v - 0.5), vMin, vMax);
                y1 = WWMath.clamp(y0 + 1, vMin, vMax);
                xf = WWMath.fract(u - 0.5);
                yf = WWMath.fract(v - 0.5);
                retrieveTiles = (i == levelNumber) || (i == 0);

                if (this.lookupPixels(x0, x1, y0, y1, level, retrieveTiles, pixels)) {
                    result[resultIndex] = (1 - xf) * (1 - yf) * pixels[0] +
                        xf * (1 - yf) * pixels[1] +
                        (1 - xf) * yf * pixels[2] +
                        xf * yf * pixels[3];
                    return;
                }
            }
        };

        // Internal. Bilinearly interpolates tile-image elevations.
        ElevationModel.prototype.lookupPixels = function (x0, x1, y0, y1, level, retrieveTiles, result) {
            var levelNumber = level.levelNumber,
                tileWidth = level.tileWidth,
                tileHeight = level.tileHeight,
                row0 = Math.floor(y0 / tileHeight),
                row1 = Math.floor(y1 / tileHeight),
                col0 = Math.floor(x0 / tileWidth),
                col1 = Math.floor(x1 / tileWidth),
                r0c0, r0c1, r1c0, r1c1;

            if (row0 == row1 && row0 == this.cachedRow && col0 == col1 && col0 == this.cachedCol) {
                r0c0 = r0c1 = r1c0 = r1c1 = this.cachedImage; // use results from previous lookup
            } else if (row0 == row1 && col0 == col1) {
                r0c0 = this.lookupImage(levelNumber, row0, col0, retrieveTiles); // only need to lookup one image
                r0c1 = r1c0 = r1c1 = r0c0; // re-use the single image
                this.cachedRow = row0;
                this.cachedCol = col0;
                this.cachedImage = r0c0; // note the results for subsequent lookups
            } else {
                r0c0 = this.lookupImage(levelNumber, row0, col0, retrieveTiles);
                r0c1 = this.lookupImage(levelNumber, row0, col1, retrieveTiles);
                r1c0 = this.lookupImage(levelNumber, row1, col0, retrieveTiles);
                r1c1 = this.lookupImage(levelNumber, row1, col1, retrieveTiles);
            }

            if (r0c0 && r0c1 && r1c0 && r1c1) {
                result[0] = r0c0.pixel(x0 % tileWidth, y0 % tileHeight);
                result[1] = r0c1.pixel(x1 % tileWidth, y0 % tileHeight);
                result[2] = r1c0.pixel(x0 % tileWidth, y1 % tileHeight);
                result[3] = r1c1.pixel(x1 % tileWidth, y1 % tileHeight);
                return true;
            }

            return false;
        };

        // Internal. Intentionally not documented.
        ElevationModel.prototype.lookupImage = function (levelNumber, row, column, retrieveTiles) {
            var tile = this.tileForLevel(levelNumber, row, column),
                image = tile.image();

            // If the tile's elevations have expired, cause it to be re-retrieved. Note that the current,
            // expired elevations are still used until the updated ones arrive.
            if (image == null && retrieveTiles) {
                this.retrieveTileImage(tile);
            }

            return image;
        };

        // Intentionally not documented.
        ElevationModel.prototype.createTile = function (sector, level, row, column) {
            var imagePath = this.cachePath + "/" + level.levelNumber + "/" + row + "/" + row + "_" + column + ".bil";

            return new ElevationTile(sector, level, row, column, imagePath, this.imageCache);
        };

        // Intentionally not documented.
        ElevationModel.prototype.assembleTiles = function (level, sector, retrieveTiles) {
            this.currentTiles = [];

            // Intersect the requested sector with the elevation model's coverage area. This avoids attempting to assemble tiles
            // that are outside the coverage area.
            this.currentSector.copy(sector);
            this.currentSector.intersection(this.coverageSector);

            if (this.currentSector.isEmpty())
                return; // sector is outside the elevation model's coverage area

            var deltaLat = level.tileDelta.latitude,
                deltaLon = level.tileDelta.longitude,
                firstRow = Tile.computeRow(deltaLat, this.currentSector.minLatitude),
                lastRow = Tile.computeLastRow(deltaLat, this.currentSector.maxLatitude),
                firstCol = Tile.computeColumn(deltaLon, this.currentSector.minLongitude),
                lastCol = Tile.computeLastColumn(deltaLon, this.currentSector.maxLongitude);

            for (var row = firstRow; row <= lastRow; row++) {
                for (var col = firstCol; col <= lastCol; col++) {
                    this.addTileOrAncestor(level, row, col, retrieveTiles);
                }
            }
        };

        // Intentionally not documented.
        ElevationModel.prototype.addTileOrAncestor = function (level, row, column, retrieveTiles) {
            var tile = this.tileForLevel(level.levelNumber, row, column);

            if (this.isTileImageInMemory(tile)) {
                this.addToCurrentTiles(tile);
            } else {
                if (retrieveTiles) {
                    this.retrieveTileImage(tile);
                }

                if (level.isFirstLevel()) {
                    this.currentTiles.push(tile); // no ancestor tile to add
                } else {
                    this.addAncestor(level, row, column, retrieveTiles);
                }
            }
        };

        // Intentionally not documented.
        ElevationModel.prototype.addAncestor = function (level, row, column, retrieveTiles) {
            var tile = null,
                r = Math.floor(row / 2),
                c = Math.floor(column / 2);

            for (var i = level.levelNumber - 1; i >= 0; i--) {
                tile = this.tileForLevel(i, r, c);
                if (this.isTileImageInMemory(tile)) {
                    this.addToCurrentTiles(tile);
                    return;
                }

                r = Math.floor(r / 2);
                c = Math.floor(c / 2);
            }

            // No ancestor tiles have an in-memory image. Retrieve the ancestor tile corresponding for the first level, and
            // add it. We add the necessary tiles to provide coverage over the requested sector in order to accurately return
            // whether or not this elevation model has data for the entire sector.
            this.addToCurrentTiles(tile);

            if (retrieveTiles) {
                this.retrieveTileImage(tile);
            }
        };

        // Intentionally not documented.
        ElevationModel.prototype.addToCurrentTiles = function (tile) {
            this.currentTiles.push(tile);
        };

        // Intentionally not documented.
        ElevationModel.prototype.tileForLevel = function (levelNumber, row, column) {
            var tileKey = levelNumber + "." + row + "." + column,
                tile = this.tileCache.entryForKey(tileKey);

            if (tile) {
                return tile;
            }

            var level = this.levels.level(levelNumber),
                sector = Tile.computeSector(level, row, column);

            tile = this.createTile(sector, level, row, column);
            this.tileCache.putEntry(tileKey, tile, tile.size());

            return tile;
        };

        // Intentionally not documented.
        ElevationModel.prototype.isTileImageInMemory = function (tile) {
            return this.imageCache.containsKey(tile.imagePath);
        };

        // Intentionally not documented.
        ElevationModel.prototype.resourceUrlForTile = function (tile) {
            return this.urlBuilder.urlForTile(tile, this.retrievalImageFormat);
        };

        // Intentionally not documented.
        ElevationModel.prototype.retrieveTileImage = function (tile) {
            if (this.currentRetrievals.indexOf(tile.imagePath) < 0) {
                var url = this.resourceUrlForTile(tile, this.retrievalImageFormat),
                    xhr = new XMLHttpRequest(),
                    elevationModel = this;

                if (!url)
                    return;

                xhr.open("GET", url, true);
                xhr.responseType = 'arraybuffer';
                xhr.onreadystatechange = function () {
                    if (xhr.readyState === 4) {
                        elevationModel.removeFromCurrentRetrievals(tile.imagePath);

                        var contentType = xhr.getResponseHeader("content-type");

                        if (xhr.status === 200) {
                            if (contentType === elevationModel.retrievalImageFormat
                                || contentType === "text/plain"
                                || contentType === "application/octet-stream") {
                                Logger.log(Logger.LEVEL_INFO, "Elevations retrieval succeeded: " + url);
                                elevationModel.loadElevationImage(tile, xhr);
                                elevationModel.absentResourceList.unmarkResourceAbsent(tile.imagePath);

                                // Send an event to request a redraw.
                                var e = document.createEvent('Event');
                                e.initEvent(WorldWind.REDRAW_EVENT_TYPE, true, true);
                                window.dispatchEvent(e);
                            } else if (contentType === "text/xml") {
                                elevationModel.absentResourceList.markResourceAbsent(tile.imagePath);
                                Logger.log(Logger.LEVEL_WARNING,
                                    "Elevations retrieval failed (" + xhr.statusText + "): " + url + ".\n "
                                    + String.fromCharCode.apply(null, new Uint8Array(xhr.response)));
                            } else {
                                elevationModel.absentResourceList.markResourceAbsent(tile.imagePath);
                                Logger.log(Logger.LEVEL_WARNING,
                                    "Elevations retrieval failed: " + url + ". " + "Unexpected content type "
                                    + contentType);
                            }
                        } else {
                            elevationModel.absentResourceList.markResourceAbsent(tile.imagePath);
                            Logger.log(Logger.LEVEL_WARNING,
                                "Elevations retrieval failed (" + xhr.statusText + "): " + url);
                        }
                    }
                };

                xhr.onerror = function () {
                    elevationModel.removeFromCurrentRetrievals(tile.imagePath);
                    elevationModel.absentResourceList.markResourceAbsent(tile.imagePath);
                    Logger.log(Logger.LEVEL_WARNING, "Elevations retrieval failed: " + url);
                };

                xhr.ontimeout = function () {
                    elevationModel.removeFromCurrentRetrievals(tile.imagePath);
                    elevationModel.absentResourceList.markResourceAbsent(tile.imagePath);
                    Logger.log(Logger.LEVEL_WARNING, "Elevations retrieval timed out: " + url);
                };

                xhr.send(null);

                this.currentRetrievals.push(tile.imagePath);
            }
        };

        // Intentionally not documented.
        ElevationModel.prototype.removeFromCurrentRetrievals = function (imagePath) {
            var index = this.currentRetrievals.indexOf(imagePath);
            if (index > -1) {
                this.currentRetrievals.splice(index, 1);
            }
        };

        // Intentionally not documented.
        ElevationModel.prototype.loadElevationImage = function (tile, xhr) {
            var elevationImage = new ElevationImage(tile.imagePath, tile.sector, tile.tileWidth, tile.tileHeight);

            if (this.retrievalImageFormat == "application/bil16") {
                elevationImage.imageData = new Int16Array(xhr.response);
                elevationImage.size = elevationImage.imageData.length * 2;
            } else if (this.retrievalImageFormat == "application/bil32") {
                elevationImage.imageData = new Float32Array(xhr.response);
                elevationImage.size = elevationImage.imageData.length * 4;
            }

            if (elevationImage.imageData) {
                elevationImage.findMinAndMaxElevation();
                this.imageCache.putEntry(tile.imagePath, elevationImage, elevationImage.size);
                this.timestamp = Date.now();
            }
        };

        return ElevationModel;

    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports Terrain
 * @version $Id: Terrain.js 3018 2015-04-14 17:50:06Z dcollins $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(1),
        __webpack_require__(0),
        __webpack_require__(2)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
              Logger,
              Vec3) {
        "use strict";

        /**
         * Constructs a Terrain object.
         * @alias Terrain
         * @constructor
         * @classdesc Represents terrain and provides functions for computing points on or relative to the terrain.
         * Applications do not typically interact directly with this class.
         */
        var Terrain = function (globe, tessellator, terrainTiles, verticalExaggeration) {

            /**
             * The globe associated with this terrain.
             * @type {Globe}
             */
            this.globe = globe;

            /**
             * The vertical exaggeration of this terrain.
             * @type {Number}
             */
            this.verticalExaggeration = verticalExaggeration;

            /**
             * The sector spanned by this terrain.
             * @type {Sector}
             */
            this.sector = terrainTiles.sector;

            /**
             * The tessellator used to generate this terrain.
             * @type {Tessellator}
             */
            this.tessellator = tessellator;

            /**
             * The surface geometry for this terrain
             * @type {TerrainTile[]}
             */
            this.surfaceGeometry = terrainTiles.tileArray;

            /**
             * A string identifying this terrain's current state. Used to compare states during rendering to
             * determine whether state dependent cached values must be updated. Applications typically do not
             * interact with this property.
             * @readonly
             * @type {String}
             */
            this.stateKey = globe.stateKey + " ve " + verticalExaggeration.toString();
        };

        Terrain.scratchPoint = new Vec3(0, 0, 0);

        /**
         * Computes a Cartesian point at a location on the surface of this terrain.
         * @param {Number} latitude The location's latitude.
         * @param {Number} longitude The location's longitude.
         * @param {Number} offset Distance above the terrain, in meters, at which to compute the point.
         * @param {Vec3} result A pre-allocated Vec3 in which to return the computed point.
         * @returns {Vec3} The specified result parameter, set to the coordinates of the computed point. If the
         * specfied location is not within this terrain, the associated globe is used to compute the point.
         * @throws {ArgumentError} If the specified result argument is null or undefined.
         */
        Terrain.prototype.surfacePoint = function (latitude, longitude, offset, result) {
            if (!result) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Terrain", "surfacePoint", "missingResult"));
            }

            for (var i = 0, len = this.surfaceGeometry.length; i < len; i++) {
                if (this.surfaceGeometry[i].sector.containsLocation(latitude, longitude)) {
                    this.surfaceGeometry[i].surfacePoint(latitude, longitude, result);

                    if (offset) {
                        var normal = this.globe.surfaceNormalAtPoint(result[0], result[1], result[2], Terrain.scratchPoint);
                        result[0] += normal[0] * offset;
                        result[1] += normal[1] * offset;
                        result[2] += normal[2] * offset;
                    }

                    return result;
                }
            }

            // No tile was found that contains the location, so approximate one using the globe.
            var h = offset + this.globe.elevationAtLocation(latitude, longitude) * this.verticalExaggeration;
            this.globe.computePointFromPosition(latitude, longitude, h, result);

            return result;
        };

        /**
         * Computes a Cartesian point at a location on the surface of this terrain according to a specified
         * altitude mode.
         * @param {Number} latitude The location's latitude.
         * @param {Number} longitude The location's longitude.
         * @param {Number} offset Distance above the terrain, in meters relative to the specified altitude mode, at
         * which to compute the point.
         * @param {String} altitudeMode The altitude mode to use to compute the point. Recognized values are
         * WorldWind.ABSOLUTE, WorldWind.CLAMP_TO_GROUND and
         * WorldWind.RELATIVE_TO_GROUND. The mode WorldWind.ABSOLUTE is used if the
         * specified mode is null, undefined or unrecognized, or if the specified location is outside this terrain.
         * @param {Vec3} result A pre-allocated Vec3 in which to return the computed point.
         * @returns {Vec3} The specified result parameter, set to the coordinates of the computed point.
         * @throws {ArgumentError} If the specified result argument is null or undefined.
         */
        Terrain.prototype.surfacePointForMode = function (latitude, longitude, offset, altitudeMode, result) {
            if (!result) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Terrain", "surfacePointForMode", "missingResult"));
            }

            if (!altitudeMode)
                altitudeMode = WorldWind.ABSOLUTE;

            if (altitudeMode === WorldWind.CLAMP_TO_GROUND) {
                return this.surfacePoint(latitude, longitude, 0, result);
            } else if (altitudeMode === WorldWind.RELATIVE_TO_GROUND) {
                return this.surfacePoint(latitude, longitude, offset, result);
            } else {
                var height = offset * this.verticalExaggeration;
                this.globe.computePointFromPosition(latitude, longitude, height, result);
                return result;
            }
        };

        /**
         * Initializes rendering state to draw a succession of terrain tiles.
         * @param {DrawContext} dc The current draw context.
         */
        Terrain.prototype.beginRendering = function (dc) {
            if (this.globe && this.globe.tessellator) {
                this.globe.tessellator.beginRendering(dc);
            }
        };

        /**
         * Restores rendering state after drawing a succession of terrain tiles.
         * @param {DrawContext} dc The current draw context.
         */
        Terrain.prototype.endRendering = function (dc) {
            if (this.globe && this.globe.tessellator) {
                this.globe.tessellator.endRendering(dc);
            }
        };

        /**
         * Initializes rendering state for drawing a specified terrain tile.
         * @param {DrawContext} dc The current draw context.
         * @param {TerrainTile} terrainTile The terrain tile subsequently drawn via this tessellator's render function.
         * @throws {ArgumentError} If the specified tile is null or undefined.
         */
        Terrain.prototype.beginRenderingTile = function (dc, terrainTile) {
            if (!terrainTile) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Terrain", "beginRenderingTile", "missingTile"));
            }

            if (this.globe && this.globe.tessellator) {
                this.globe.tessellator.beginRenderingTile(dc, terrainTile);
            }
        };

        /**
         * Restores rendering state after drawing the most recent tile specified to
         * [beginRenderingTile]{@link Terrain#beginRenderingTile}.
         * @param {DrawContext} dc The current draw context.
         * @param {TerrainTile} terrainTile The terrain tile most recently rendered.
         * @throws {ArgumentError} If the specified tile is null or undefined.
         */
        Terrain.prototype.endRenderingTile = function (dc, terrainTile) {
            // Intentionally empty.
        };

        /**
         * Renders a specified terrain tile.
         * @param {DrawContext} dc The current draw context.
         * @param {TerrainTile} terrainTile The terrain tile to render.
         * @throws {ArgumentError} If the specified tile is null or undefined.
         */
        Terrain.prototype.renderTile = function (dc, terrainTile) {
            if (!terrainTile) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Terrain", "renderTile", "missingTile"));
            }

            if (this.globe && this.globe.tessellator) {
                this.globe.tessellator.renderTile(dc, terrainTile);
            }
        };

        /**
         * Causes this terrain to perform the picking operations appropriate for the draw context's pick settings.
         * Normally, this draws the terrain in a unique pick color and computes the picked terrain position. When the
         * draw context is set to region picking mode this omits the computation of a picked terrain position.
         * @param {DrawContext} dc The current draw context.
         */
        Terrain.prototype.pick = function (dc) {
            if (this.globe && this.globe.tessellator) {
                this.globe.tessellator.pick(dc, this.surfaceGeometry, this); // use this terrain as the userObject
            }
        };

        return Terrain;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports Layer
 * @version $Id: Layer.js 3414 2015-08-20 19:09:19Z tgaskins $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(0)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Logger) {
        "use strict";

        /**
         * Constructs a layer. This constructor is meant to be called by subclasses and not directly by an application.
         * @alias Layer
         * @constructor
         * @classdesc Provides an abstract base class for layer implementations. This class is not meant to be instantiated
         * directly.
         */
        var Layer = function (displayName) {

            /**
             * This layer's display name.
             * @type {String}
             * @default "Layer"
             */
            this.displayName = displayName ? displayName : "Layer";

            /**
             * Indicates whether to display this layer.
             * @type {Boolean}
             * @default true
             */
            this.enabled = true;

            /**
             * Indicates whether this layer is pickable.
             * @type {Boolean}
             * @default true
             */
            this.pickEnabled = true;

            /**
             * This layer's opacity, which is combined with the opacity of shapes within layers.
             * Opacity is in the range [0, 1], with 1 indicating fully opaque.
             * @type {Number}
             * @default 1
             */
            this.opacity = 1;

            /**
             * The eye altitude above which this layer is displayed, in meters.
             * @type {Number}
             * @default -Number.MAX_VALUE (always displayed)
             */
            this.minActiveAltitude = -Number.MAX_VALUE;

            /**
             * The eye altitude below which this layer is displayed, in meters.
             * @type {Number}
             * @default Number.MAX_VALUE (always displayed)
             */
            this.maxActiveAltitude = Number.MAX_VALUE;

            /**
             * Indicates whether elements of this layer were drawn in the most recently generated frame.
             * @type {Boolean}
             * @readonly
             */
            this.inCurrentFrame = false;

            /**
             * The time to display. This property selects the layer contents that represents the specified time.
             * If null, layer-type dependent contents are displayed.
             * @type {Date}
             */
            this.time = null;
        };

        /**
         * Refreshes the data associated with this layer. The behavior of this function varies with the layer
         * type. For image layers, it causes the images to be re-retrieved from their origin.
         */
        Layer.prototype.refresh = function () {
            // Default implementation does nothing.
        };

        /**
         * Displays this layer. Subclasses should generally not override this method but should instead override the
         * [doRender]{@link Layer#doRender} method. This method calls that method after verifying that the layer is
         * enabled, the eye point is within this layer's active altitudes and the layer is in view.
         * @param {DrawContext} dc The current draw context.
         */
        Layer.prototype.render = function (dc) {
            this.inCurrentFrame = false;

            if (!this.enabled)
                return;

            if (dc.pickingMode && !this.pickEnabled)
                return;

            if (!this.withinActiveAltitudes(dc))
                return;

            if (!this.isLayerInView(dc))
                return;

            this.doRender(dc);
        };

        /**
         * Subclass method called to display this layer. Subclasses should implement this method rather than the
         * [render]{@link Layer#render} method, which determines enable, pick and active altitude status and does not
         * call this doRender method if the layer should not be displayed.
         * @param {DrawContext} dc The current draw context.
         * @protected
         */
        Layer.prototype.doRender = function (dc) {
            // Default implementation does nothing.
        };

        /* INTENTIONALLY NOT DOCUMENTED
         * Indicates whether the current eye distance is within this layer's active-altitude range.
         * @param {DrawContext} dc The current draw context.
         * @returns {boolean} true If the eye distance is greater than or equal to this layer's minimum active
         * altitude and less than or equal to this layer's maximum active altitude, otherwise false.
         * @protected
         */
        Layer.prototype.withinActiveAltitudes = function (dc) {
            var eyePosition = dc.eyePosition;
            if (!eyePosition)
                return false;

            return eyePosition.altitude >= this.minActiveAltitude && eyePosition.altitude <= this.maxActiveAltitude;
       };

        /**
         * Indicates whether this layer is within the current view. Subclasses may override this method and
         * when called determine whether the layer contents are visible in the current view frustum. The default
         * implementation always returns true.
         * @param {DrawContext} dc The current draw context.
         * @returns {boolean} true If this layer is within the current view, otherwise false.
         * @protected
         */
        Layer.prototype.isLayerInView = function (dc) {
            return true; // default implementation always returns true
        };

        return Layer;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports TextureTile
 * @version $Id: TextureTile.js 2941 2015-03-30 21:11:43Z tgaskins $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(1),
        __webpack_require__(0),
        __webpack_require__(12)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
              Logger,
              Tile) {
        "use strict";

        /**
         * Constructs a texture tile.
         * @alias TextureTile
         * @constructor
         * @augments Tile
         * @classdesc Represents an image applied to a portion of a globe's terrain. Applications typically do not
         * interact with this class.
         * @param {Sector} sector The sector this tile covers.
         * @param {Level} level The level this tile is associated with.
         * @param {Number} row This tile's row in the associated level.
         * @param {Number} column This tile's column in the associated level.
         * @throws {ArgumentError} If the specified sector or level is null or undefined, the row or column arguments
         * are less than zero, or the specified image path is null, undefined or empty.
         *
         */
        var TextureTile = function (sector, level, row, column) {
            Tile.call(this, sector, level, row, column); // args are checked in the superclass' constructor

            /**
             * GPU cache key
             * @type {string}
             */
            this.gpuCacheKey = null;
        };

        TextureTile.prototype = Object.create(Tile.prototype);

        /**
         * Returns the size of the this tile in bytes.
         * @returns {Number} The size of this tile in bytes, not including the associated texture size.
         */
        TextureTile.prototype.size = function () {
            return Tile.prototype.size.call(this);
        };

        /**
         * Causes this tile's texture to be active. Implements [SurfaceTile.bind]{@link SurfaceTile#bind}.
         * @param {DrawContext} dc The current draw context.
         * @returns {Boolean} true if the texture was bound successfully, otherwise false.
         */
        TextureTile.prototype.bind = function (dc) {
            var texture = dc.gpuResourceCache.resourceForKey(this.gpuCacheKey);
            if (texture) {
                return texture.bind(dc);
            }

            return false;
        };

        /**
         * If this tile's fallback texture is used, applies the appropriate texture transform to a specified matrix.
         * Otherwise, this is a no-op.
         * @param {DrawContext} dc The current draw context.
         * @param {Matrix} matrix The matrix to apply the transform to.
         */
        TextureTile.prototype.applyInternalTransform = function (dc, matrix) {
            // Override this method if the tile has a fallback texture.
        };

        return TextureTile;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports SurfaceShape
 * @version $Id: SurfaceShape.js 3191 2015-06-15 19:35:57Z tgaskins $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(22),
        __webpack_require__(6),
        __webpack_require__(1),
        __webpack_require__(7),
        __webpack_require__(0),
        __webpack_require__(23),
        __webpack_require__(21),
        __webpack_require__(46),
        __webpack_require__(3),
        __webpack_require__(84),
        __webpack_require__(17),
        __webpack_require__(4)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (AbstractError,
              Angle,
              ArgumentError,
              Location,
              Logger,
              NotYetImplementedError,
              PickedObject,
              Renderable,
              Sector,
              ShapeAttributes,
              UnsupportedOperationError,
              WWMath) {
        "use strict";

        /**
         * Constructs a surface shape with an optionally specified bundle of default attributes.
         * @alias SurfaceShape
         * @constructor
         * @augments Renderable
         * @abstract
         * @classdesc Represents a surface shape. This is an abstract base class and is meant to be instantiated
         * only by subclasses.
         * <p>
         * Surface shapes other than SurfacePolyline {@link SurfacePolyline} have an interior and an outline and utilize
         * the corresponding attributes in their associated ShapeAttributes {@link ShapeAttributes}. They do not
         * utilize image-related attributes.
         *
         * @param {ShapeAttributes} attributes The attributes to apply to this shape. May be null, in which case
         * attributes must be set directly before the shape is drawn.
         */
        var SurfaceShape = function (attributes) {

            Renderable.call(this);

            // All these are documented with their property accessors below.
            this._displayName = "Surface Shape";
            this._attributes = attributes ? attributes : new ShapeAttributes(null);
            this._highlightAttributes = null;
            this._highlighted = false;
            this._enabled = true;
            this._pathType = WorldWind.GREAT_CIRCLE;
            this._maximumNumEdgeIntervals = SurfaceShape.DEFAULT_NUM_EDGE_INTERVALS;
            this._polarThrottle = SurfaceShape.DEFAULT_POLAR_THROTTLE;
            this._sector = null;

            /**
             * Indicates the object to return as the owner of this shape when picked.
             * @type {Object}
             * @default null
             */
            this.pickDelegate = null;

            /*
             * The bounding sectors for this tile, which may be needed for crossing the dateline.
             * @type {Sector[]}
             * @protected
             */
            this._sectors = [];

            /*
             * The raw collection of locations defining this shape and are explicitly specified by the client of this class.
             * @type {Location[]}
             * @protected
             */
            this._locations = null;

            /*
             * Boundaries that are either the user specified locations or locations that are algorithmically generated.
             * @type {Location[]}
             * @protected
             */
            this._boundaries = null;

            /*
             * The collection of locations that describes a closed curve which can be filled.
             * @type {Location[][]}
             * @protected
             */
            this._interiorGeometry = null;

            /*
             * The collection of locations that describe the outline of the shape.
             * @type {Location[][]}
             * @protected
             */
            this._outlineGeometry = null;

            /*
             * Internal use only.
             * Inhibit the filling of the interior. This is to be used ONLY by polylines.
             * @type {Boolean}
             * @protected
             */
            this._isInteriorInhibited = false;

            /*
             * Indicates whether this object's state key is invalid. Subclasses must set this value to true when their
             * attributes change. The state key will be automatically computed the next time it's requested. This flag
             * will be set to false when that occurs.
             * @type {Boolean}
             * @protected
             */
            this.stateKeyInvalid = true;

            // Internal use only. Intentionally not documented.
            this._attributesStateKey = null;

            // Internal use only. Intentionally not documented.
            this.isPrepared = false;

            // Internal use only. Intentionally not documented.
            this.layer = null;

            // Internal use only. Intentionally not documented.
            this.pickColor = null;
        };

        SurfaceShape.prototype = Object.create(Renderable.prototype);

        Object.defineProperties(SurfaceShape.prototype, {
            stateKey: {
                /**
                 * A hash key of the total visible external state of the surface shape.
                 * @memberof SurfaceShape.prototype
                 * @type {String}
                 */
                get: function() {
                    // If we don't have a state key for the shape attributes, consider this state key to be invalid.
                    if (!this._attributesStateKey) {
                        // Update the state key for the appropriate attributes for future
                        if (this._highlighted) {
                            if (!!this._highlightAttributes) {
                                this._attributesStateKey = this._highlightAttributes.stateKey;
                            }
                        } else {
                            if (!!this._attributes) {
                                this._attributesStateKey = this._attributes.stateKey;
                            }
                        }

                        // If we now actually have a state key for the attributes, it was previously invalid.
                        if (!!this._attributesStateKey) {
                            this.stateKeyInvalid = true;
                        }
                    } else {
                        // Detect a change in the appropriate attributes.
                        var currentAttributesStateKey = null;

                        if (this._highlighted) {
                            // If there are highlight attributes associated with this shape, ...
                            if (!!this._highlightAttributes) {
                                currentAttributesStateKey = this._highlightAttributes.stateKey;
                            }
                        } else {
                            if (!!this._attributes) {
                                currentAttributesStateKey = this._attributes.stateKey;
                            }
                        }

                        // If the attributes state key changed, ...
                        if (currentAttributesStateKey != this._attributesStateKey) {
                            this._attributesStateKey = currentAttributesStateKey;
                            this.stateKeyInvalid = true;
                        }
                    }

                    if (this.stateKeyInvalid) {
                        this._stateKey = this.computeStateKey();
                    }

                    return this._stateKey;
                }
            },

            /**
             * The shape's display name and label text.
             * @memberof SurfaceShape.prototype
             * @type {String}
             * @default Surface Shape
             */
            displayName: {
                get: function() {
                    return this._displayName;
                },
                set: function(value) {
                    this.stateKeyInvalid = true;
                    this._displayName = value;
                }
            },

            /**
             * The shape's attributes. If null and this shape is not highlighted, this shape is not drawn.
             * @memberof SurfaceShape.prototype
             * @type {ShapeAttributes}
             * @default see [ShapeAttributes]{@link ShapeAttributes}
             */
            attributes: {
                get: function() {
                    return this._attributes;
                },
                set: function(value) {
                    this.stateKeyInvalid = true;
                    this._attributes = value;
                    this._attributesStateKey = value.stateKey;
                }
            },

            /**
             * The attributes used when this shape's highlighted flag is true. If null and the
             * highlighted flag is true, this shape's normal attributes are used. If they, too, are null, this
             * shape is not drawn.
             * @memberof SurfaceShape.prototype
             * @type {ShapeAttributes}
             * @default null
             */
            highlightAttributes: {
                get: function() {
                    return this._highlightAttributes;
                },
                set: function(value) {
                    this.stateKeyInvalid = true;
                    this._highlightAttributes = value;
                }
            },

            /**
             * Indicates whether this shape displays with its highlight attributes rather than its normal attributes.
             * @memberof SurfaceShape.prototype
             * @type {Boolean}
             * @default false
             */
            highlighted: {
                get: function() {
                    return this._highlighted;
                },
                set: function(value) {
                    this.stateKeyInvalid = true;
                    this._highlighted = value;
                }
            },

            /**
             * Indicates whether this shape is drawn.
             * @memberof SurfaceShape.prototype
             * @type {Boolean}
             * @default true
             */
            enabled: {
                get: function() {
                    return this._enabled;
                },
                set: function(value) {
                    this.stateKeyInvalid = true;
                    this._enabled = value;
                }
            },

            /**
             * The path type to used to interpolate between locations on this shape. Recognized values are:
             * <ul>
             * <li>WorldWind.GREAT_CIRCLE</li>
             * <li>WorldWind.RHUMB_LINE</li>
             * <li>WorldWind.LINEAR</li>
             * </ul>
             * @memberof SurfaceShape.prototype
             * @type {String}
             * @default WorldWind.GREAT_CIRCLE
             */
            pathType: {
                get: function() {
                    return this._pathType;
                },
                set: function(value) {
                    this.stateKeyInvalid = true;
                    this._pathType = value;
                }
            },

            /**
             * The maximum number of intervals an edge will be broken into. This is the number of intervals that an
             * edge that spans to opposite side of the globe would be broken into. This is strictly an upper bound
             * and the number of edge intervals may be lower if this resolution is not needed.
             * @memberof SurfaceShape.prototype
             * @type {Number}
             * @default SurfaceShape.DEFAULT_NUM_EDGE_INTERVALS
             */
            maximumNumEdgeIntervals: {
                get: function() {
                    return this._maximumNumEdgeIntervals;
                },
                set: function(value) {
                    this.stateKeyInvalid = true;
                    this._maximumNumEdgeIntervals = value;
                }
            },

            /**
             * A dimensionless number that controls throttling of edge traversal near the poles where edges need to be
             * sampled more closely together.
             * A value of 0 indicates that no polar throttling is to be performed.
             * @memberof SurfaceShape.prototype
             * @type {Number}
             * @default SurfaceShape.DEFAULT_POLAR_THROTTLE
             */
            polarThrottle: {
                get: function () {
                    return this._polarThrottle;
                },
                set: function (value) {
                    this.stateKeyInvalid = true;
                    this._polarThrottle = value;
                }
            },

            /**
             * Defines the extent of the shape in latitude and longitude.
             * This sector only has valid data once the boundary is defined. Prior to this, it is null.
             * @memberof SurfaceShape.prototype
             * @type {Sector}
             */
            sector: {
                get: function() {
                    return this._sector;
                }
            }
        });

        SurfaceShape.staticStateKey = function(shape) {
            shape.stateKeyInvalid = false;

            if (shape.highlighted) {
                if (!shape._highlightAttributes) {
                    if (!shape._attributes) {
                        shape._attributesStateKey = null;
                    } else {
                        shape._attributesStateKey = shape._attributes.stateKey;
                    }
                } else {
                    shape._attributesStateKey = shape._highlightAttributes.stateKey;
                }
            } else {
                if (!shape._attributes) {
                    shape._attributesStateKey = null;
                } else {
                    shape._attributesStateKey = shape._attributes.stateKey;
                }
            }

            return   "dn " + shape.displayName +
                    " at " + (!shape._attributesStateKey ? "null" : shape._attributesStateKey) +
                    " hi " + shape.highlighted +
                    " en " + shape.enabled +
                    " pt " + shape.pathType +
                    " ne " + shape.maximumNumEdgeIntervals +
                    " po " + shape.polarThrottle +
                    " se " + "[" +
                        shape.sector.minLatitude + "," +
                        shape.sector.maxLatitude + "," +
                        shape.sector.minLongitude + "," +
                        shape.sector.maxLongitude +
                    "]";
        };

        SurfaceShape.prototype.computeStateKey = function() {
            return SurfaceShape.staticStateKey(this);
        };

        /**
         * Returns this shape's area in square meters.
         * @param {Globe} globe The globe on which to compute the area.
         * @param {Boolean} terrainConformant If true, the returned area is that of the terrain,
         * including its hillsides and other undulations. If false, the returned area is the shape's
         * projected area.
         */
        SurfaceShape.prototype.area = function (globe, terrainConformant) {
            throw new NotYetImplementedError(
                Logger.logMessage(Logger.LEVEL_SEVERE, "SurfaceShape", "area", "notYetImplemented"));
        };

        // Internal function. Intentionally not documented.
        SurfaceShape.prototype.computeBoundaries = function(globe) {
            // This method is in the base class and should be overridden if the boundaries are generated.
            // It should be called only if the geometry has been provided by the user and does not need to be generated.
            // assert(!this._boundaries);

            throw new AbstractError(
                Logger.logMessage(Logger.LEVEL_SEVERE, "SurfaceShape", "computeBoundaries", "abstractInvocation"));
        };

        // Internal function. Intentionally not documented.
        SurfaceShape.prototype.render = function(dc) {
            if (!this.enabled) {
                return;
            }

            this.layer = dc.currentLayer;

            this.prepareBoundaries(dc);

            dc.surfaceShapeTileBuilder.insertSurfaceShape(this);
        };

        // Internal function. Intentionally not documented.
        SurfaceShape.prototype.interpolateLocations = function(locations) {
            var first  = locations[0],
                next = first,
                prev,
                isNextFirst = true,
                isPrevFirst = true,// Don't care initially, this will get set in first iteration.
                countFirst = 0,
                isInterpolated = true,
                idx, len;

            this._locations = [first];

            for (idx = 1, len = locations.length; idx < len; idx += 1) {
                // Advance to next location, retaining previous location.
                prev = next;
                isPrevFirst = isNextFirst;

                next = locations[idx];

                // Detect whether the next location and the first location are the same.
                isNextFirst = next.latitude == first.latitude && next.longitude == first.longitude;

                // Inhibit interpolation if either endpoint if the first location,
                // except for the first segement which will be the actual first location or that location
                // as the polygon closes the first time.
                // All subsequent encounters of the first location are used to connected secondary domains with the
                // primary domain in multiply-connected geometry (an outer ring with multiple inner rings).
                isInterpolated = true;
                if (isNextFirst || isPrevFirst) {
                    countFirst += 1;

                    if (countFirst > 2) {
                        isInterpolated = false;
                    }
                }

                if (isInterpolated) {
                    this.interpolateEdge(prev, next, this._locations);
                }

                this._locations.push(next);

                prev = next;
            }

            // Force the closing of the border.
            if (!this._isInteriorInhibited) {
                // Avoid duplication if the first endpoint was already emitted.
                if (prev.latitude != first.latitude || prev.longitude != first.longitude) {
                    this.interpolateEdge(prev, first, this._locations);
                    this._locations.push(first);
                }
            }
        };

        // Internal function. Intentionally not documented.
        SurfaceShape.prototype.interpolateEdge = function(start, end, locations) {
            var distanceRadians = Location.greatCircleDistance(start, end),
                steps = Math.round(this._maximumNumEdgeIntervals * distanceRadians / Math.PI),
                dt,
                location;

            if (steps > 0) {
                dt = 1 / steps;
                location = start;

                for (var t = this.throttledStep(dt, location); t < 1; t += this.throttledStep(dt, location)) {
                    location = new Location(0, 0);
                    Location.interpolateAlongPath(this._pathType, t, start, end, location);
                    locations.push(location);
                }
            }
        };

        // Internal function. Intentionally not documented.
        // Return a throttled step size when near the poles.
        SurfaceShape.prototype.throttledStep = function(dt, location) {
            var cosLat = Math.cos(location.latitude * Angle.DEGREES_TO_RADIANS);
            cosLat *= cosLat; // Square cos to emphasize poles and de-emphasize equator.

            // Remap polarThrotle:
            //  0 .. INF => 0 .. 1
            // This acts as a weight between no throttle and fill throttle.
            var weight = this._polarThrottle / (1 + this._polarThrottle);

            return dt * ((1 - weight) + weight * cosLat);
        };

        // Internal function. Intentionally not documented.
        SurfaceShape.prototype.prepareBoundaries = function(dc) {
            if (this.isPrepared) return;

            // Some shapes generate boundaries, such as ellipses and sectors;
            // others don't, such as polylines and polygons.
            // Handle the latter below.
            if (!this._boundaries) {
                this.computeBoundaries(dc);
            }

            if (!this._locations) {
                this.interpolateLocations(this._boundaries);
            }

            this.prepareGeometry(dc);

            this.prepareSectors();

            this.isPrepared = true;
        };

        /**
         * Computes the bounding sectors for the shape. There will be more than one if the shape crosses the date line,
         * but does not enclose a pole.
         *
         * @param {DrawContext} dc The drawing context containing a globe.
         *
         * @return {Sector[]}  Bounding sectors for the shape.
         */
        SurfaceShape.prototype.computeSectors = function(dc) {
            // Return a previously computed value if it already exists.
            if (this._sectors && this._sectors.length > 0) {
                return this._sectors;
            }

            this.prepareBoundaries(dc);

            return this._sectors;
        };

        // Internal function. Intentionally not documented.
        SurfaceShape.prototype.prepareSectors = function() {
            var boundaries = this._boundaries;
            if (!boundaries) {
                return;
            }

            this._sector = new Sector(-90, 90, -180, 180);
            this._sector.setToBoundingSector(boundaries);

            var pole = this.containsPole(boundaries);
            if (pole != Location.poles.NONE) {
                // If the shape contains a pole, then the bounding sector is defined by the shape's extreme latitude, the
                // latitude of the pole, and the full range of longitude.
                if (pole == Location.poles.NORTH) {
                    this._sector = new Sector(this._sector.minLatitude, 90, -180, 180);
                }
                else {
                    this._sector = new Sector(-90, this._sector.maxLatitude, -180, 180);
                }

                this._sectors = [this._sector];
            }
            else if (Location.locationsCrossDateLine(boundaries)) {
                this._sectors = Sector.splitBoundingSectors(boundaries);
            }
            else {
                 if (!this._sector.isEmpty()) {
                    this._sectors = [this._sector];
                }
            }

            if (!this._sectors) {
                return;
            }

            // Great circle paths between two latitudes may result in a latitude which is greater or smaller than either of
            // the two latitudes. All other path types are bounded by the defining locations.
            if (this._pathType === WorldWind.GREAT_CIRCLE) {
                for (var idx = 0, len = this._sectors.length; idx < len; idx += 1) {
                    var sector = this._sectors[idx];

                    var extremes = Location.greatCircleArcExtremeLocations(boundaries);

                    var minLatitude = Math.min(sector.minLatitude, extremes[0].latitude);
                    var maxLatitude = Math.max(sector.maxLatitude, extremes[1].latitude);

                    this._sectors[idx] = new Sector(minLatitude, maxLatitude, sector.minLongitude, sector.maxLongitude);
                }
            }
        };

        // Internal function. Intentionally not documented.
        SurfaceShape.prototype.prepareGeometry = function(dc) {
            var datelineLocations;

            this._interiorGeometry = [];
            this._outlineGeometry = [];

            var locations = this._locations;

            var pole = this.containsPole(locations);
            if (pole != Location.poles.NONE) {
                // Wrap the shape interior around the pole and along the anti-meridian. See WWJ-284.
                var poleLocations = this.cutAlongDateLine(locations, pole, dc.globe);
                this._interiorGeometry.push(poleLocations);

                // The outline need only compensate for dateline crossing. See WWJ-452.
                datelineLocations = this.repeatAroundDateline(locations);
                this._outlineGeometry.push(datelineLocations[0]);
                if (datelineLocations.length > 1) {
                    this._outlineGeometry.push(datelineLocations[1]);
                }
            }
            else if (Location.locationsCrossDateLine(locations)) {
                datelineLocations = this.repeatAroundDateline(locations);
                this._interiorGeometry.push(datelineLocations[0]); //this._interiorGeometry.addAll(datelineLocations);
                this._interiorGeometry.push(datelineLocations[1]); //this._interiorGeometry.addAll(datelineLocations);
                this._outlineGeometry.push(datelineLocations[0]); //this._outlineGeometry.addAll(datelineLocations);
                this._outlineGeometry.push(datelineLocations[1]); //this._outlineGeometry.addAll(datelineLocations);
            }
            else {
                this._interiorGeometry.push(locations);
                this._outlineGeometry.push(locations);
            }
        };

        /**
         * Determine if a list of geographic locations encloses either the North or South pole. The list is treated as a
         * closed loop. (If the first and last positions are not equal the loop will be closed for purposes of this
         * computation.)
         *
         * @param {Location[]} locations Locations to test.
         *
         * @return {Number} Location.poles.NORTH if the North Pole is enclosed,
         *                  Location.poles.SOUTH if the South Pole is enclosed, or
         *                  Location.poles.NONE if neither pole is enclosed.
         *                  Always returns Location.poles.NONE if {@link #canContainPole()} returns false.
         *
         * TODO: handle a shape that contains both poles.
         */
        SurfaceShape.prototype.containsPole = function(locations) {
            // Determine how many times the path crosses the date line. Shapes that include a pole will cross an odd number of times.
            var containsPole = false;

            var minLatitude = 90.0;
            var maxLatitude = -90.0;

            var prev = locations[0];
            for (var idx = 1, len = locations.length; idx < len; idx += 1) {
                var next = locations[idx];

                if (Location.locationsCrossDateLine([prev, next])) {
                    containsPole = !containsPole;
                }

                minLatitude = Math.min(minLatitude, next.latitude);
                maxLatitude = Math.max(maxLatitude, next.latitude);

                prev = next;
            }

            // Close the loop by connecting the last position to the first. If the loop is already closed then the following
            // test will always fail, and will not affect the result.
            var first = locations[0];
            if (Location.locationsCrossDateLine([first, prev])) {
                containsPole = !containsPole;
            }

            if (!containsPole) {
                return Location.poles.NONE;
            }

            // Determine which pole is enclosed. If the shape is entirely in one hemisphere, then assume that it encloses
            // the pole in that hemisphere. Otherwise, assume that it encloses the pole that is closest to the shape's
            // extreme latitude.
            if (minLatitude > 0) {
                return Location.poles.NORTH; // Entirely in Northern Hemisphere.
            }
            else if (maxLatitude < 0) {
                return Location.poles.SOUTH; // Entirely in Southern Hemisphere.
            }
            else if (Math.abs(maxLatitude) >= Math.abs(minLatitude)) {
                return Location.poles.NORTH; // Spans equator, but more north than south.
            }
            else {
                return Location.poles.SOUTH; // Spans equator, but more south than north.
            }
        };

        /**
         * Divide a list of locations that encloses a pole along the international date line. This method determines where
         * the locations cross the date line, and inserts locations to the pole, and then back to the intersection position.
         * This allows the shape to be "unrolled" when projected in a lat-lon projection.
         *
         * @param {Location[]} locations    Locations to cut at date line. This list is not modified.
         * @param {Number} pole             Pole contained by locations, either AVKey.NORTH or AVKey.SOUTH.
         * @param {Globe} globe             Current globe.
         *
         * @return {Location[]} New location list with locations added to correctly handle date line intersection.
         */
        SurfaceShape.prototype.cutAlongDateLine = function(locations, pole, globe)
        {
            // If the locations do not contain a pole, then there's nothing to do.
            if (pole == Location.poles.NONE) {
                return locations;
            }

            var newLocations = [];

            var poleLat = pole == Location.poles.NORTH ? 90 : -90;

            var prev = locations[locations.length - 1];
            for (var idx = 0, len = locations.length; idx < len; idx += 1) {
                var next = locations[idx];

                newLocations.push(prev);
                if (Location.locationsCrossDateLine([prev, next])) {
                    // Determine where the segment crosses the date line.
                    var latitude = Location.intersectionWithMeridian(prev, next, 180, globe);
                    var sign = WWMath.signum(prev.longitude);

                    var lat = latitude;
                    var thisSideLon = 180 * sign;
                    var otherSideLon = -thisSideLon;

                    // Add locations that run from the intersection to the pole, then back to the intersection. Note
                    // that the longitude changes sign when the path returns from the pole.
                    //         . Pole
                    //      2 ^ | 3
                    //        | |
                    //      1 | v 4
                    // --->---- ------>
                    newLocations.push(new Location(lat, thisSideLon));
                    newLocations.push(new Location(poleLat, thisSideLon));
                    newLocations.push(new Location(poleLat, otherSideLon));
                    newLocations.push(new Location(lat, otherSideLon));
                }

                prev = next;
            }
            newLocations.push(prev);

            return newLocations;
        };

        /**
         * Returns a list containing two copies of the specified list of locations crossing the dateline: one that extends
         * across the -180 longitude  boundary and one that extends across the +180 longitude boundary. If the list of
         * locations does not cross the dateline this returns a list containing a copy of the original list.
         *
         * @param {Location[]} locations Locations to repeat. This is list not modified.
         *
         * @return {Location[][]} A list containing two new location lists, one copy for either side of the date line.
         */
        SurfaceShape.prototype.repeatAroundDateline = function(locations) {
            var lonOffset = 0,
                applyLonOffset = false;

            var newLocations = [];

            var prev= locations[0];
            newLocations.push(prev);
            for (var idx = 1, len = locations.length; idx < len; idx += 1) {
                var next = locations[idx];

                if (Location.locationsCrossDateLine([prev, next])) {
                    if (lonOffset == 0) {
                        lonOffset = prev.longitude < 0 ? -360 : 360;
                    }

                    applyLonOffset = !applyLonOffset;
                }

                if (applyLonOffset) {
                    newLocations.push(new Location(next.latitude, next.longitude + lonOffset));
                }
                else {
                    newLocations.push(next);
                }

                prev = next;
            }

            var locationGroup = [newLocations];

            if (lonOffset != 0) {
                var oldLocations = newLocations;
                newLocations = [];

                for (idx = 0, len = oldLocations.length; idx < len; idx += 1) {
                    var cur = oldLocations[idx];

                    newLocations.push(new Location(cur.latitude, cur.longitude - lonOffset));
                }

                locationGroup.push(newLocations);
            }

            return locationGroup;
        };

        // Internal use only. Intentionally not documented.
        SurfaceShape.prototype.resetPickColor = function() {
            this.pickColor = null;
        };

        /**
         * Internal use only.
         * Render the shape onto the texture map of the tile.
         * @param {DrawContext} dc The draw context to render onto.
         * @param {CanvasRenderingContext2D} ctx2D The rendering context for SVG.
         * @param {Number} xScale The multiplicative scale factor in the horizontal direction.
         * @param {Number} yScale The multiplicative scale factor in the vertical direction.
         * @param {Number} dx The additive offset in the horizontal direction.
         * @param {Number} dy The additive offset in the vertical direction.
         */
        SurfaceShape.prototype.renderToTexture = function(dc, ctx2D, xScale, yScale, dx, dy) {
            var idx,
                len,
                path = [],
                idxPath,
                lenPath,
                isPicking = dc.pickingMode,
                attributes = (this._highlighted ? (this._highlightAttributes || this._attributes) : this._attributes);

            if (isPicking && !this.pickColor) {
                this.pickColor = dc.uniquePickColor();
            }

            // Fill the interior of the shape.
            if (!this._isInteriorInhibited && attributes.drawInterior) {
                ctx2D.fillStyle = isPicking ? this.pickColor.toRGBAString() : attributes.interiorColor.toRGBAString();

                for (idx = 0, len = this._interiorGeometry.length; idx < len; idx += 1) {
                    idxPath = 0;
                    lenPath = this._outlineGeometry[idx].length * 2;
                    path.splice(0, path.length);

                    // Convert the geometry to a transformed path that can be drawn directly, and as a side effect,
                    // detect if the path is smaller than a pixel. If it is, don't bother drawing it.
                    if (this.transformPath(this._interiorGeometry[idx], xScale, yScale, dx, dy, path)) {
                        ctx2D.beginPath();

                        ctx2D.moveTo(path[idxPath++], path[idxPath++]);

                        while (idxPath < lenPath) {
                            ctx2D.lineTo(path[idxPath++], path[idxPath++]);
                        }

                        ctx2D.closePath();

                        ctx2D.fill();
                    }
                }
            }

            // Draw the outline of the shape.
            if (attributes.drawOutline && attributes.outlineWidth > 0) {
                ctx2D.lineWidth = 4 * attributes.outlineWidth;
                ctx2D.strokeStyle = isPicking ? this.pickColor.toRGBAString() : attributes.outlineColor.toRGBAString();

                var pattern = this._attributes.outlineStipplePattern,
                    factor = this._attributes.outlineStippleFactor;

                for (idx = 0, len = this._outlineGeometry.length; idx < len; idx += 1) {
                    path.splice(0, path.length);

                    // Convert the geometry to a transformed path that can be drawn directly, and as a side effect,
                    // detect if the path is smaller than a pixel. If it is, don't bother drawing it.
                    if (this.transformPath(this._outlineGeometry[idx], xScale, yScale, dx, dy, path)) {
                        // NOTE: this code used to be written as:
                        //      a single beginPath() call,
                        //      followed by a single moveTo() call,
                        //      followed by as many lineTo() calls as there were vertices remaining in the path,
                        //      followed by a stroke().
                        // Performance was BAD!
                        // The code was rewritten this way and it doesn't have any performance issues.
                        // That shouldn't be the case, but it is.
                        var xFirst = path[0],
                            yFirst = path[1],
                            xPrev = xFirst,
                            yPrev = yFirst,
                            xNext = xFirst,
                            yNext = yFirst,
                            isPrevFirst = true,
                            isNextFirst = true,
                            countFirst = 0;

                        for (idxPath = 2, lenPath = path.length; idxPath < lenPath; ) {
                            // Remember the previous point in the path.
                            xPrev = xNext;
                            yPrev = yNext;
                            isPrevFirst = isNextFirst;

                            // Extract the next point in the path.
                            xNext = path[idxPath++];
                            yNext = path[idxPath++];

                            isNextFirst = xNext == xFirst && yNext == yFirst;

                            // Avoid drawing virtual edges that reconnect to the first point
                            // when drawing multiply connected domains.
                            if (isPrevFirst || isNextFirst) {
                                countFirst += 1;

                                if (countFirst > 2) {
                                    continue;
                                }
                            }

                            // Draw the path one line segment at a time.
                            ctx2D.beginPath();
                            ctx2D.moveTo(xPrev, yPrev);

                            ctx2D.lineTo(xNext, yNext);

                            ctx2D.stroke();
                        }
                    }
                }
            }

            if (isPicking) {
                var po = new PickedObject(this.pickColor.clone(), this.pickDelegate ? this.pickDelegate : this,
                    null, this.layer, false);
                dc.resolvePick(po);
            }
        };

        //
        // Internal use only.
        // Transform a path and compute its extrema.
        // In the process of transforming it, optimize out line segments that are too short (shorter than some threshold).
        // Return an indicator of the path is "big enough".
        SurfaceShape.prototype.transformPath = function(path, xScale, yScale, xOffset, yOffset, result) {
            var xPrev, yPrev,
                xNext, yNext,
                xFirst, yFirst,
                xLast, yLast,
                xMin, yMin,
                xMax, yMax,
                dx, dy, dr2,
                dr2Min = 4, // Squared length of minimum length line that must be drawn.
                isNextFirst,
                location, idxResult, idxPath, lenPath;

            idxResult = 0;

            location = path[0];

            xFirst = location.longitude * xScale + xOffset;
            yFirst = location.latitude * yScale + yOffset;

            isNextFirst = true;

            xMin = xMax = xPrev = xNext = xFirst;
            yMin = yMax = yPrev = yNext = yFirst;

            result[idxResult++] = xNext;
            result[idxResult++] = yNext;

            for (idxPath = 1, lenPath = path.length; idxPath < lenPath; idxPath += 1) {
                location = path[idxPath];

                // Capture the last point even it it was optimized out.
                xLast = xNext;
                yLast = yNext;

                xNext = location.longitude * xScale + xOffset;
                yNext = location.latitude * yScale + yOffset;

                // Detect whether the next point is the same as the first point.
                isNextFirst = (xNext == xFirst) && (yNext == yFirst);

                // Compute the length from the previous point that was emitted to the next point.
                dx = xNext - xPrev;
                dy = yNext - yPrev;
                dr2 = dx * dx + dy * dy;

                // If the line is smaller than a single pixel, accumulate more data before emitting,
                // unless the point is the same as the first point, in which case it is always emitted.
                if (isNextFirst || dr2 >= dr2Min) {
                    xMin = Math.min(xMin, xNext);
                    xMax = Math.max(xMax, xNext);
                    yMin = Math.min(yMin, yNext);
                    yMax = Math.max(yMax, yNext);

                    // If the last point was optimized out because the line it contributed to was too short,
                    // force it to be emitted.
                    if (result[idxResult - 2] != xLast || result[idxResult - 1] != yLast) {
                        result[idxResult++] = xLast;
                        result[idxResult++] = yLast;
                    }

                    result[idxResult++] = xNext;
                    result[idxResult++] = yNext;

                    xPrev = xNext;
                    yPrev = yNext;
                }
            }

            return (xMax - xMin) >= 2 || (yMax - yMin) >= 2;
        };

        /**
         * Default value for the maximum number of edge intervals. This results in a maximum error of 480 m for an arc
         * that spans the entire globe.
         *
         * Other values for this parameter have the associated errors below:
         * Intervals        Maximum error (meters)
         *      2           1280253.5
         *      4           448124.5
         *      8           120837.6
         *      16          30628.3
         *      32          7677.9
         *      64          1920.6
         *      128         480.2
         *      256         120.0
         *      512         30.0
         *      1024        7.5
         *      2048        1.8
         * The errors cited above are upper bounds and the actual error may be lower.
         * @type {Number}
         */
        SurfaceShape.DEFAULT_NUM_EDGE_INTERVALS = 128;

        /**
         * The defualt value for the polar throttle, which slows edge traversal near the poles.
         * @type {Number}
         */
        SurfaceShape.DEFAULT_POLAR_THROTTLE = 10;

        return SurfaceShape;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

var WorldWindow = __webpack_require__(57);
var AtmosphereLayer = __webpack_require__(68);
//var HttpTiledImageLayer = require('../layer/HttpTiledImageLayer');
var SingleImageLayer = __webpack_require__(91);
var Globe3D = __webpack_require__(15);
var Globe2D = __webpack_require__(38);
//var EarthElevationModel = require('../../node_modules/web-world-wind/src/globe/EarthElevationModel');
var ZeroElevationModel = __webpack_require__(41);

var mainGlobe = new Globe3D(new ZeroElevationModel(), null);
var alterGlobe = new Globe2D();

var earth = new WorldWindow('canvas', mainGlobe);
earth.addLayer(new SingleImageLayer('day.jpg'));
//earth.addLayer(new HttpTiledImageLayer('localhost'));
earth.addLayer(new AtmosphereLayer('night.png'));
earth.redraw();

earth.switchGlobe = function () {
    earth.globe = [alterGlobe, alterGlobe = earth.globe][0]; // swap globes
    earth.redraw();
};

module.exports = earth;

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports GpuResourceCache
 * @version $Id: GpuResourceCache.js 3023 2015-04-15 20:24:17Z tgaskins $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(52),
        __webpack_require__(1),
        __webpack_require__(54),
        __webpack_require__(0),
        __webpack_require__(16),
        __webpack_require__(25)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (AbsentResourceList,
              ArgumentError,
              ImageSource,
              Logger,
              MemoryCache,
              Texture) {
        "use strict";

        /**
         * Constructs a GPU resource cache for a specified size and low-water value.
         * @alias GpuResourceCache
         * @constructor
         * @classdesc Maintains a cache of GPU resources such as textures and GLSL programs.
         * Applications typically do not interact with this class unless they create their own shapes.
         * @param {Number} capacity The cache capacity, in bytes.
         * @param {Number} lowWater The number of bytes to clear the cache to when it exceeds its capacity.
         * @throws {ArgumentError} If the specified capacity is undefined, 0 or negative or the low-water value is
         * undefined, negative or not less than the capacity.
         */
        var GpuResourceCache = function (capacity, lowWater) {
            if (!capacity || capacity < 1) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "GpuResourceCache", "constructor",
                        "Specified cache capacity is undefined, 0 or negative."));
            }

            if (!lowWater || lowWater < 0 || lowWater >= capacity) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "GpuResourceCache", "constructor",
                        "Specified cache low-water value is undefined, negative or not less than the capacity."));
            }

            // Private. Holds the actual cache entries.
            this.entries = new MemoryCache(capacity, lowWater);

            // Private. Counter for generating cache keys.
            this.cacheKeyPool = 0;

            // Private. List of retrievals currently in progress.
            this.currentRetrievals = {};

            // Private. Identifies requested resources that whose retrieval failed.
            this.absentResourceList = new AbsentResourceList(3, 60e3);
        };

        Object.defineProperties(GpuResourceCache.prototype, {
            /**
             * Indicates the capacity of this cache in bytes.
             * @type {Number}
             * @readonly
             * @memberof GpuResourceCache.prototype
             */
            capacity: {
                get: function () {
                    return this.entries.capacity;
                }
            },

            /**
             * Indicates the low-water value for this cache in bytes, the size this cache is cleared to when it
             * exceeds its capacity.
             * @type {Number}
             * @readonly
             * @memberof GpuResourceCache.prototype
             */
            lowWater: {
                get: function () {
                    return this.entries.lowWater;
                }
            },

            /**
             * Indicates the number of bytes currently used by this cache.
             * @type {Number}
             * @readonly
             * @memberof GpuResourceCache.prototype
             */
            usedCapacity: {
                get: function () {
                    return this.entries.usedCapacity;
                }
            },

            /**
             * Indicates the number of free bytes in this cache.
             * @type {Number}
             * @readonly
             * @memberof GpuResourceCache.prototype
             */
            freeCapacity: {
                get: function () {
                    return this.entries.freeCapacity;
                }
            }
        });

        /**
         * Creates a cache key unique to this cache, typically for a resource about to be added to this cache.
         * @returns {String} The generated cache key.
         */
        GpuResourceCache.prototype.generateCacheKey = function () {
            return "GpuResourceCache " + ++this.cacheKeyPool;
        };

        /**
         * Adds a specified resource to this cache. Replaces the existing resource for the specified key if the
         * cache currently contains a resource for that key.
         * @param {String|ImageSource} key The key or image source of the resource to add.
         * @param {Object} resource The resource to add to the cache.
         * @param {Number} size The resource's size in bytes. Must be greater than 0.
         * @throws {ArgumentError} If either the key or resource arguments is null or undefined
         * or if the specified size is less than 1.
         */
        GpuResourceCache.prototype.putResource = function (key, resource, size) {
            if (!key) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "GpuResourceCache", "putResource", "missingKey."));
            }

            if (!resource) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "GpuResourceCache", "putResource", "missingResource."));
            }

            if (!size || size < 1) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "GpuResourceCache", "putResource",
                        "The specified resource size is undefined or less than 1."));
            }

            var entry = {
                resource: resource
            };

            this.entries.putEntry(key instanceof ImageSource ? key.key : key, entry, size);
        };

        /**
         * Returns the resource associated with a specified key.
         * @param {String|ImageSource} key The key or image source of the resource to find.
         * @returns {Object} The resource associated with the specified key, or null if the resource is not in
         * this cache or the specified key is null or undefined.
         */
        GpuResourceCache.prototype.resourceForKey = function (key) {
            var entry = (key instanceof ImageSource)
                ? this.entries.entryForKey(key.key) : this.entries.entryForKey(key);

            return entry ? entry.resource : null;
        };

        /**
         * Indicates whether a specified resource is in this cache.
         * @param {String|ImageSource} key The key or image source of the resource to find.
         * @returns {Boolean} true If the resource is in this cache, false if the resource
         * is not in this cache or the specified key is null or undefined.
         */
        GpuResourceCache.prototype.containsResource = function (key) {
            return this.entries.containsKey(key instanceof ImageSource ? key.key : key);
        };

        /**
         * Removes the specified resource from this cache. The cache is not modified if the specified key is null or
         * undefined or does not correspond to an entry in the cache.
         * @param {String|ImageSource} key The key or image source of the resource to remove.
         */
        GpuResourceCache.prototype.removeResource = function (key) {
            this.entries.removeEntry(key instanceof ImageSource ? key.key : key);
        };

        /**
         * Removes all resources from this cache.
         */
        GpuResourceCache.prototype.clear = function () {
            this.entries.clear(false);
        };

        /**
         * Retrieves an image and adds it to this cache when it arrives. If the specified image source is a URL, a
         * retrieval request for the image is made and this method returns immediately with a value of null. A redraw
         * event is generated when the image subsequently arrives and is added to this cache. If the image source is an
         * {@link ImageSource}, the image is used immediately and this method returns the {@link Texture} created and
         * cached for the image. No redraw event is generated in this case.
         * @param {WebGLRenderingContext} gl The current WebGL context.
         * @param {String|ImageSource} imageSource The image source, either a {@link ImageSource} or a String
         * giving the URL of the image.
         * @param {GL.enum} wrapMode Optional. Specifies the wrap mode of the texture. Defaults to gl.CLAMP_TO_EDGE
         * @returns {Texture} The {@link Texture} created for the image if the specified image source is an
         * {@link ImageSource}, otherwise null.
         */
        GpuResourceCache.prototype.retrieveTexture = function (gl, imageSource, wrapMode) {
            if (!imageSource) {
                return null;
            }

            if (imageSource instanceof ImageSource) {
                var t = new Texture(gl, imageSource.image, wrapMode);
                this.putResource(imageSource.key, t, t.size);
                return t;
            }

            if (this.currentRetrievals[imageSource] || this.absentResourceList.isResourceAbsent(imageSource)) {
                return null;
            }

            var cache = this,
                image = new Image();

            image.onload = function () {
                Logger.log(Logger.LEVEL_INFO, "Image retrieval succeeded: " + imageSource);

                var texture = new Texture(gl, image, wrapMode);

                cache.putResource(imageSource, texture, texture.size);

                delete cache.currentRetrievals[imageSource];
                cache.absentResourceList.unmarkResourceAbsent(imageSource);

                // Send an event to request a redraw.
                var e = document.createEvent('Event');
                e.initEvent(WorldWind.REDRAW_EVENT_TYPE, true, true);
                window.dispatchEvent(e);
            };

            image.onerror = function () {
                delete cache.currentRetrievals[imageSource];
                cache.absentResourceList.markResourceAbsent(imageSource);
                Logger.log(Logger.LEVEL_WARNING, "Image retrieval failed: " + imageSource);
            };

            this.currentRetrievals[imageSource] = imageSource;
            image.crossOrigin = 'anonymous';
            image.src = imageSource;

            return null;
        };

        return GpuResourceCache;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports BoundingBox
 * @version $Id: BoundingBox.js 3345 2015-07-28 20:28:35Z dcollins $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(1),
        __webpack_require__(48),
        __webpack_require__(24),
        __webpack_require__(0),
        __webpack_require__(5),
        __webpack_require__(23),
        __webpack_require__(18),
        __webpack_require__(3),
        __webpack_require__(2),
        __webpack_require__(4),
        __webpack_require__(28)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
              BasicProgram,
              Frustum,
              Logger,
              Matrix,
              NotYetImplementedError,
              Plane,
              Sector,
              Vec3,
              WWMath,
              WWUtil) {
        "use strict";

        /**
         * Constructs a unit bounding box.
         * The unit box has its R, S and T axes aligned with the X, Y and Z axes, respectively, and has its length,
         * width and height set to 1.
         * @alias BoundingBox
         * @constructor
         * @classdesc Represents a bounding box in Cartesian coordinates. Typically used as a bounding volume.
         */
        var BoundingBox = function () {

            /**
             * The box's center point.
             * @type {Vec3}
             * @default (0, 0, 0)
             */
            this.center = new Vec3(0, 0, 0);

            /**
             * The center point of the box's bottom. (The origin of the R axis.)
             * @type {Vec3}
             * @default (-0.5, 0, 0)
             */
            this.bottomCenter = new Vec3(-0.5, 0, 0);

            /**
             * The center point of the box's top. (The end of the R axis.)
             * @type {Vec3}
             * @default (0.5, 0, 0)
             */
            this.topCenter = new Vec3(0.5, 0, 0);

            /**
             * The box's R axis, its longest axis.
             * @type {Vec3}
             * @default (1, 0, 0)
             */
            this.r = new Vec3(1, 0, 0);

            /**
             * The box's S axis, its mid-length axis.
             * @type {Vec3}
             * @default (0, 1, 0)
             */
            this.s = new Vec3(0, 1, 0);

            /**
             * The box's T axis, its shortest axis.
             * @type {Vec3}
             * @default (0, 0, 1)
             */
            this.t = new Vec3(0, 0, 1);

            /**
             * The box's radius. (The half-length of its diagonal.)
             * @type {number}
             * @default sqrt(3)
             */
            this.radius = Math.sqrt(3);

            // Internal use only. Intentionally not documented.
            this.tmp1 = new Vec3(0, 0, 0);
            this.tmp2 = new Vec3(0, 0, 0);
            this.tmp3 = new Vec3(0, 0, 0);

            // Internal use only. Intentionally not documented.
            this.scratchElevations = new Float64Array(9);
            this.scratchPoints = new Float64Array(3 * this.scratchElevations.length);
        };

        // Internal use only. Intentionally not documented.
        BoundingBox.scratchMatrix = Matrix.fromIdentity();

        /**
         * Sets this bounding box such that it minimally encloses a specified collection of points.
         * @param {Float32Array} points The points to contain.
         * @returns {BoundingBox} This bounding box set to contain the specified points.
         * @throws {ArgumentError} If the specified list of points is null, undefined or empty.
         */
        BoundingBox.prototype.setToPoints = function (points) {
            if (!points || points.length < 3) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "BoundingBox", "setToPoints", "missingArray"));
            }

            var rMin = +Number.MAX_VALUE,
                rMax = -Number.MAX_VALUE,
                sMin = +Number.MAX_VALUE,
                sMax = -Number.MAX_VALUE,
                tMin = +Number.MAX_VALUE,
                tMax = -Number.MAX_VALUE,
                r = this.r, s = this.s, t = this.t,
                p = new Vec3(0, 0, 0),
                pdr, pds, pdt, rLen, sLen, tLen, rSum, sSum, tSum,
                rx_2, ry_2, rz_2, cx, cy, cz;

            Matrix.principalAxesFromPoints(points, r, s, t);

            for (var i = 0, len = points.length / 3; i < len; i++) {
                p[0] = points[i * 3];
                p[1] = points[i * 3 + 1];
                p[2] = points[i * 3 + 2];

                pdr = p.dot(r);
                if (rMin > pdr)
                    rMin = pdr;
                if (rMax < pdr)
                    rMax = pdr;

                pds = p.dot(s);
                if (sMin > pds)
                    sMin = pds;
                if (sMax < pds)
                    sMax = pds;

                pdt = p.dot(t);
                if (tMin > pdt)
                    tMin = pdt;
                if (tMax < pdt)
                    tMax = pdt;
            }

            if (rMax === rMin)
                rMax = rMin + 1;
            if (sMax === sMin)
                sMax = sMin + 1;
            if (tMax === tMin)
                tMax = tMin + 1;

            rLen = rMax - rMin;
            sLen = sMax - sMin;
            tLen = tMax - tMin;
            rSum = rMax + rMin;
            sSum = sMax + sMin;
            tSum = tMax + tMin;

            rx_2 = 0.5 * r[0] * rLen;
            ry_2 = 0.5 * r[1] * rLen;
            rz_2 = 0.5 * r[2] * rLen;

            cx = 0.5 * (r[0] * rSum + s[0] * sSum + t[0] * tSum);
            cy = 0.5 * (r[1] * rSum + s[1] * sSum + t[1] * tSum);
            cz = 0.5 * (r[2] * rSum + s[2] * sSum + t[2] * tSum);

            this.center[0] = cx;
            this.center[1] = cy;
            this.center[2] = cz;

            this.topCenter[0] = cx + rx_2;
            this.topCenter[1] = cy + ry_2;
            this.topCenter[2] = cz + rz_2;

            this.bottomCenter[0] = cx - rx_2;
            this.bottomCenter[1] = cy - ry_2;
            this.bottomCenter[2] = cz - rz_2;

            r.multiply(rLen);
            s.multiply(sLen);
            t.multiply(tLen);

            this.radius = 0.5 * Math.sqrt(rLen * rLen + sLen * sLen + tLen * tLen);

            return this;
        };

        /**
         * Sets this bounding box such that it contains a specified sector on a specified globe with min and max elevation.
         * <p>
         * To create a bounding box that contains the sector at mean sea level, specify zero for the minimum and maximum
         * elevations.
         * To create a bounding box that contains the terrain surface in this sector, specify the actual minimum and maximum
         * elevation values associated with the sector, multiplied by the model's vertical exaggeration.
         * @param {Sector} sector The sector for which to create the bounding box.
         * @param {Globe} globe The globe associated with the sector.
         * @param {Number} minElevation The minimum elevation within the sector.
         * @param {Number} maxElevation The maximum elevation within the sector.
         * @returns {BoundingBox} This bounding box set to contain the specified sector.
         * @throws {ArgumentError} If either the specified sector or globe is null or undefined.
         */
        BoundingBox.prototype.setToSector = function (sector, globe, minElevation, maxElevation) {
            if (!sector) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "BoundingBox", "setToSector", "missingSector"));
            }

            if (!globe) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "BoundingBox", "setToSector", "missingGlobe"));
            }

            // Compute the cartesian points for a 3x3 geographic grid. This grid captures enough detail to bound the
            // sector. Use minimum elevation at the corners and max elevation everywhere else.
            var elevations = this.scratchElevations,
                points = this.scratchPoints;

            WWUtil.fillArray(elevations, maxElevation);
            elevations[0] = elevations[2] = elevations[6] = elevations[8] = minElevation;
            globe.computePointsForGrid(sector, 3, 3, elevations, Vec3.ZERO, points);

            // Compute the local coordinate axes. Since we know this box is bounding a geographic sector, we use the
            // local coordinate axes at its centroid as the box axes. Using these axes results in a box that has +-10%
            // the volume of a box with axes derived from a principal component analysis, but is faster to compute.
            var index = 12; // index to the center point's X coordinate
            this.tmp1.set(points[index], points[index + 1], points[index + 2]);
            WWMath.localCoordinateAxesAtPoint(this.tmp1, globe, this.r, this.s, this.t);

            // Find the extremes along each axis.
            var rExtremes = [Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY],
                sExtremes = [Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY],
                tExtremes = [Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY];

            for (var i = 0, len = points.length; i < len; i += 3) {
                this.tmp1.set(points[i], points[i + 1], points[i + 2]);
                this.adjustExtremes(this.r, rExtremes, this.s, sExtremes, this.t, tExtremes, this.tmp1);
            }

            // Sort the axes from most prominent to least prominent. The frustum intersection methods in WWBoundingBox assume
            // that the axes are defined in this way.
            if (rExtremes[1] - rExtremes[0] < sExtremes[1] - sExtremes[0]) {
                this.swapAxes(this.r, rExtremes, this.s, sExtremes);
            }
            if (sExtremes[1] - sExtremes[0] < tExtremes[1] - tExtremes[0]) {
                this.swapAxes(this.s, sExtremes, this.t, tExtremes);
            }
            if (rExtremes[1] - rExtremes[0] < sExtremes[1] - sExtremes[0]) {
                this.swapAxes(this.r, rExtremes, this.s, sExtremes);
            }

            // Compute the box properties from its unit axes and the extremes along each axis.
            var rLen = rExtremes[1] - rExtremes[0],
                sLen = sExtremes[1] - sExtremes[0],
                tLen = tExtremes[1] - tExtremes[0],
                rSum = rExtremes[1] + rExtremes[0],
                sSum = sExtremes[1] + sExtremes[0],
                tSum = tExtremes[1] + tExtremes[0],

                cx = 0.5 * (this.r[0] * rSum + this.s[0] * sSum + this.t[0] * tSum),
                cy = 0.5 * (this.r[1] * rSum + this.s[1] * sSum + this.t[1] * tSum),
                cz = 0.5 * (this.r[2] * rSum + this.s[2] * sSum + this.t[2] * tSum),
                rx_2 = 0.5 * this.r[0] * rLen,
                ry_2 = 0.5 * this.r[1] * rLen,
                rz_2 = 0.5 * this.r[2] * rLen;

            this.center.set(cx, cy, cz);
            this.topCenter.set(cx + rx_2, cy + ry_2, cz + rz_2);
            this.bottomCenter.set(cx - rx_2, cy - ry_2, cz - rz_2);

            this.r.multiply(rLen);
            this.s.multiply(sLen);
            this.t.multiply(tLen);

            this.radius = 0.5 * Math.sqrt(rLen * rLen + sLen * sLen + tLen * tLen);

            return this;
        };

        /**
         * Translates this bounding box by a specified translation vector.
         * @param {Vec3} translation The translation vector.
         * @returns {BoundingBox} This bounding box translated by the specified translation vector.
         * @throws {ArgumentError} If the specified translation vector is null or undefined.
         */
        BoundingBox.prototype.translate = function (translation) {
            if (!translation) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "BoundingBox", "translate", "missingVector"));
            }

            this.bottomCenter.add(translation);
            this.topCenter.add(translation);
            this.center.add(translation);

            return this;
        };

        /**
         * Computes the approximate distance between this bounding box and a specified point.
         * <p>
         * This calculation treats the bounding box as a sphere with the same radius as the box.
         * @param {Vec3} point The point to compute the distance to.
         * @returns {Number} The distance from the edge of this bounding box to the specified point.
         * @throws {ArgumentError} If the specified point is null or undefined.
         */
        BoundingBox.prototype.distanceTo = function (point) {
            if (!point) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "BoundingBox", "distanceTo", "missingPoint"));
            }

            var d = this.center.distanceTo(point) - this.radius;

            return d >= 0 ? d : -d;
        };

        /**
         * Computes the effective radius of this bounding box relative to a specified plane.
         * @param {Plane} plane The plane of interest.
         * @returns {Number} The effective radius of this bounding box to the specified plane.
         * @throws {ArgumentError} If the specified plane is null or undefined.
         */
        BoundingBox.prototype.effectiveRadius = function (plane) {
            if (!plane) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "BoundingBox", "effectiveRadius", "missingPlane"));
            }

            var n = plane.normal;

            return 0.5 * (WWMath.fabs(this.r.dot(n)) + WWMath.fabs(this.s.dot(n)) + WWMath.fabs(this.t.dot(n)));
        };

        /**
         * Indicates whether this bounding box intersects a specified frustum.
         * @param {Frustum} frustum The frustum of interest.
         * @returns {boolean} true if the specified frustum intersects this bounding box, otherwise false.
         * @throws {ArgumentError} If the specified frustum is null or undefined.
         */
        BoundingBox.prototype.intersectsFrustum = function (frustum) {
            if (!frustum) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "BoundingBox", "intersectsFrustum", "missingFrustum"));
            }

            this.tmp1.copy(this.bottomCenter);
            this.tmp2.copy(this.topCenter);

            if (this.intersectionPoint(frustum.near) < 0) {
                return false;
            }
            if (this.intersectionPoint(frustum.far) < 0) {
                return false;
            }
            if (this.intersectionPoint(frustum.left) < 0) {
                return false;
            }
            if (this.intersectionPoint(frustum.right) < 0) {
                return false;
            }
            if (this.intersectionPoint(frustum.top) < 0) {
                return false;
            }
            if (this.intersectionPoint(frustum.bottom) < 0) {
                return false;
            }

            return true;
        };

        // Internal. Intentionally not documented.
        BoundingBox.prototype.intersectionPoint = function (plane) {
            var n = plane.normal,
                effectiveRadius = 0.5 * (Math.abs(this.s.dot(n)) + Math.abs(this.t.dot(n)));

            return this.intersectsAt(plane, effectiveRadius, this.tmp1, this.tmp2);
        };

        // Internal. Intentionally not documented.
        BoundingBox.prototype.intersectsAt = function (plane, effRadius, endPoint1, endPoint2) {
            // Test the distance from the first end-point.
            var dq1 = plane.dot(endPoint1);
            var bq1 = dq1 <= -effRadius;

            // Test the distance from the second end-point.
            var dq2 = plane.dot(endPoint2);
            var bq2 = dq2 <= -effRadius;

            if (bq1 && bq2) { // endpoints more distant from plane than effective radius; box is on neg. side of plane
                return -1;
            }

            if (bq1 == bq2) { // endpoints less distant from plane than effective radius; can't draw any conclusions
                return 0;
            }

            // Compute and return the endpoints of the box on the positive side of the plane
            this.tmp3.copy(endPoint1);
            this.tmp3.subtract(endPoint2);
            var t = (effRadius + dq1) / plane.normal.dot(this.tmp3);

            this.tmp3.copy(endPoint2);
            this.tmp3.subtract(endPoint1);
            this.tmp3.multiply(t);
            this.tmp3.add(endPoint1);

            // Truncate the line to only that in the positive halfspace, e.g., inside the frustum.
            if (bq1) {
                endPoint1.copy(this.tmp3);
            }
            else {
                endPoint2.copy(this.tmp3);
            }

            return t;
        };

        // Internal. Intentionally not documented.
        BoundingBox.prototype.adjustExtremes = function (r, rExtremes, s, sExtremes, t, tExtremes, p) {
            var pdr = p.dot(r);
            if (rExtremes[0] > pdr) {
                rExtremes[0] = pdr;
            }
            if (rExtremes[1] < pdr) {
                rExtremes[1] = pdr;
            }

            var pds = p.dot(s);
            if (sExtremes[0] > pds) {
                sExtremes[0] = pds;
            }
            if (sExtremes[1] < pds) {
                sExtremes[1] = pds;
            }

            var pdt = p.dot(t);
            if (tExtremes[0] > pdt) {
                tExtremes[0] = pdt;
            }
            if (tExtremes[1] < pdt) {
                tExtremes[1] = pdt;
            }
        };

        // Internal. Intentionally not documented.
        BoundingBox.prototype.swapAxes = function (a, aExtremes, b, bExtremes) {
            a.swap(b);

            var tmp = aExtremes[0];
            aExtremes[0] = bExtremes[0];
            bExtremes[0] = tmp;

            tmp = aExtremes[1];
            aExtremes[1] = bExtremes[1];
            bExtremes[1] = tmp;
        };

        /**
         * Renders this bounding box in a semi-transparent color with a highlighted outline. This function is intended
         * for diagnostic use only.
         * @param dc {DrawContext} dc The current draw context.
         */
        BoundingBox.prototype.render = function (dc) {
            var gl = dc.currentGlContext,
                matrix = BoundingBox.scratchMatrix,
                program = dc.findAndBindProgram(BasicProgram);

            try {
                // Setup to transform unit cube coordinates to this bounding box's local coordinates, as viewed by the
                // current navigator state.
                matrix.copy(dc.navigatorState.modelviewProjection);
                matrix.multiply(
                    this.r[0], this.s[0], this.t[0], this.center[0],
                    this.r[1], this.s[1], this.t[1], this.center[1],
                    this.r[2], this.s[2], this.t[2], this.center[2],
                    0, 0, 0, 1);
                matrix.multiplyByTranslation(-0.5, -0.5, -0.5);
                program.loadModelviewProjection(gl, matrix);

                // Setup to draw the geometry when the eye point is inside or outside the box.
                gl.disable(gl.CULL_FACE);

                // Bind the shared unit cube vertex buffer and element buffer.
                gl.bindBuffer(gl.ARRAY_BUFFER, dc.unitCubeBuffer());
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, dc.unitCubeElements());
                gl.enableVertexAttribArray(program.vertexPointLocation);
                gl.vertexAttribPointer(program.vertexPointLocation, 3, gl.FLOAT, false, 0, 0);

                // Draw bounding box fragments that are below the terrain.
                program.loadColorComponents(gl, 0, 1, 0, 0.6);
                gl.drawElements(gl.LINES, 24, gl.UNSIGNED_SHORT, 72);
                program.loadColorComponents(gl, 1, 1, 1, 0.3);
                gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            } finally {
                // Restore World Wind's default WebGL state.
                gl.enable(gl.CULL_FACE);
                gl.bindBuffer(gl.ARRAY_BUFFER, null);
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
            }
        };

        return BoundingBox;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports PanRecognizer
 * @version $Id: PanRecognizer.js 3239 2015-06-22 23:28:12Z dcollins $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(19)], __WEBPACK_AMD_DEFINE_RESULT__ = function (GestureRecognizer) {
        "use strict";

        /**
         * Constructs a pan gesture recognizer.
         * @alias PanRecognizer
         * @constructor
         * @augments GestureRecognizer
         * @classdesc A concrete gesture recognizer subclass that looks for touch panning gestures.
         * @param {EventTarget} target The document element this gesture recognizer observes for mouse and touch events.
         * @param {Function} callback An optional function to call when this gesture is recognized. If non-null, the
         * function is called when this gesture is recognized, and is passed a single argument: this gesture recognizer,
         * e.g., <code>gestureCallback(recognizer)</code>.
         * @throws {ArgumentError} If the specified target is null or undefined.
         */
        var PanRecognizer = function (target, callback) {
            GestureRecognizer.call(this, target, callback);

            /**
             *
             * @type {Number}
             */
            this.minNumberOfTouches = 1;

            /**
             *
             * @type {Number}
             */
            this.maxNumberOfTouches = Number.MAX_VALUE;

            // Intentionally not documented.
            this.interpretDistance = 20;
        };

        PanRecognizer.prototype = Object.create(GestureRecognizer.prototype);

        // Documented in superclass.
        PanRecognizer.prototype.mouseDown = function (event) {
            if (this.state == WorldWind.POSSIBLE) {
                this.state = WorldWind.FAILED; // touch gestures fail upon receiving a mouse event
            }
        };

        // Documented in superclass.
        PanRecognizer.prototype.touchMove = function (touch) {
            if (this.state == WorldWind.POSSIBLE) {
                if (this.shouldInterpret()) {
                    if (this.shouldRecognize()) {
                        this.state = WorldWind.BEGAN;
                    } else {
                        this.state = WorldWind.FAILED;
                    }
                }
            } else if (this.state == WorldWind.BEGAN || this.state == WorldWind.CHANGED) {
                this.state = WorldWind.CHANGED;
            }
        };

        // Documented in superclass.
        PanRecognizer.prototype.touchEnd = function (touch) {
            if (this.touchCount == 0) { // last touch ended
                if (this.state == WorldWind.POSSIBLE) {
                    this.state = WorldWind.FAILED;
                } else if (this.state == WorldWind.BEGAN || this.state == WorldWind.CHANGED) {
                    this.state = WorldWind.ENDED;
                }
            }
        };

        // Documented in superclass.
        PanRecognizer.prototype.touchCancel = function (touch) {
            if (this.touchCount == 0) { // last touch cancelled
                if (this.state == WorldWind.POSSIBLE) {
                    this.state = WorldWind.FAILED;
                } else if (this.state == WorldWind.BEGAN || this.state == WorldWind.CHANGED) {
                    this.state = WorldWind.CANCELLED;
                }
            }
        };

        // Documented in superclass.
        PanRecognizer.prototype.prepareToRecognize = function () {
            // set translation to zero when the pan begins
            this.translationX = 0;
            this.translationY = 0;
        };

        /**
         *
         * @returns {boolean}
         * @protected
         */
        PanRecognizer.prototype.shouldInterpret = function () {
            var dx = this.translationX,
                dy = this.translationY,
                distance = Math.sqrt(dx * dx + dy * dy);
            return distance > this.interpretDistance; // interpret touches when the touch centroid moves far enough
        };

        /**
         *
         * @returns {boolean}
         * @protected
         */
        PanRecognizer.prototype.shouldRecognize = function () {
            var touchCount = this.touchCount;
            return touchCount != 0
                && touchCount >= this.minNumberOfTouches
                && touchCount <= this.maxNumberOfTouches
        };

        return PanRecognizer;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports Globe2D
 * @version $Id: Globe2D.js 3205 2015-06-17 18:05:23Z tgaskins $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(15),
        __webpack_require__(72),
        __webpack_require__(41)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Globe,
              ProjectionEquirectangular,
              ZeroElevationModel) {
        "use strict";

        /**
         * Constructs a 2D globe with a default {@link ZeroElevationModel} and
         * [equirectangular projection]{@link ProjectionEquirectangular}.
         * @alias Globe2D
         * @constructor
         * @augments Globe
         * @classdesc Represents a 2D flat globe with a configurable projection.
         * The default rectangular projection scrolls longitudinally.
         */
        var Globe2D = function () {
            Globe.call(this, new ZeroElevationModel(), new ProjectionEquirectangular());
        };

        Globe2D.prototype = Object.create(Globe.prototype);

        return Globe2D;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports TerrainTile
 * @version $Id: TerrainTile.js 2936 2015-03-27 22:04:59Z tgaskins $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(1),
        __webpack_require__(0),
        __webpack_require__(5),
        __webpack_require__(12)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
              Logger,
              Matrix,
              Tile) {
        "use strict";

        /**
         * Constructs a terrain tile.
         * @alias TerrainTile
         * @constructor
         * @augments Tile
         * @classdesc Represents a portion of a globe's terrain. Applications typically do not interact directly with
         * this class.
         * @param {Sector} sector The sector this tile covers.
         * @param {Level} level The level this tile is associated with.
         * @param {Number} row This tile's row in the associated level.
         * @param {Number} column This tile's column in the associated level.
         * @throws {ArgumentError} If the specified sector or level is null or undefined or the row or column arguments
         * are less than zero.
         */
        var TerrainTile = function (sector, level, row, column) {
            Tile.call(this, sector, level, row, column); // args are checked in the superclass' constructor

            /**
             * The transformation matrix that maps tile local coordinates to model coordinates.
             * @type {Matrix}
             */
            this.transformationMatrix = Matrix.fromIdentity();

            /**
             * The tile's model coordinate points.
             * @type {Float32Array}
             */
            this.points = null;

            /**
             * Indicates the state of this tile when the model coordinate points were last updated. This is used to
             * invalidate the points when this tile's state changes.
             * @type {String}
             */
            this.pointsStateKey = null;

            /**
             * Indicates the state of this tile when the model coordinate VBO was last uploaded to GL. This is used to
             * invalidate the VBO when the tile's state changes.
             * @type {String}
             */
            this.pointsVboStateKey = null;

            // Internal use. Intentionally not documented.
            this.neighborMap = {};
            this.neighborMap[WorldWind.NORTH] = null;
            this.neighborMap[WorldWind.SOUTH] = null;
            this.neighborMap[WorldWind.EAST] = null;
            this.neighborMap[WorldWind.WEST] = null;

            // Internal use. Intentionally not documented.
            this._stateKey = null;

            // Internal use. Intentionally not documented.
            this._elevationTimestamp = null;

            // Internal use. Intentionally not documented.
            this.scratchArray = [];
        };

        TerrainTile.prototype = Object.create(Tile.prototype);

        Object.defineProperties(TerrainTile.prototype, {
            /**
             * A string identifying the state of this tile as a function of the elevation model's timestamp and this
             * tile's neighbors. Used to compare states during rendering to determine whether cached values must be
             * updated. Applications typically do not interact with this property.
             * @type {String}
             * @memberof TerrainTile.prototype
             * @readonly
             */
            stateKey: {
                get: function () {
                    if (!this._stateKey) {
                        this._stateKey = this.computeStateKey();
                    }

                    return this._stateKey;
                }
            }
        });

        /**
         * Indicates the level of the tile adjacent to this tile in a specified direction. This returns null when this
         * tile has no neighbor in that direction.
         * @param {String} direction The cardinal direction. Must be one of WorldWind.NORTH, WorldWind.SOUTH,
         * WorldWind.EAST or WorldWind.WEST.
         * @returns {Level} The neighbor tile's level in the specified direction, or null if there is no neighbor.
         */
        TerrainTile.prototype.neighborLevel = function (direction) {
            return this.neighborMap[direction];
        };

        /**
         * Specifies the level of the tile adjacent to this tile in a specified direction.
         * @param {String} direction The cardinal direction. Must be one of WorldWind.NORTH, WorldWind.SOUTH,
         * WorldWind.EAST or WorldWind.WEST.
         * @param {Level} level The neighbor tile's level in the specified direction, or null to indicate that there is
         * no neighbor in that direction.
         */
        TerrainTile.prototype.setNeighborLevel = function (direction, level) {
            this.neighborMap[direction] = level;
            this._stateKey = null; // cause updates to any neighbor-dependent cached state
        };

        /**
         * Computes a point on the terrain at a specified location.
         * @param {Number} latitude The location's latitude.
         * @param {Number} longitude The location's longitude.
         * @param {Vec3} result A pre-allocated Vec3 in which to return the computed point.
         * @returns {Vec3} The result argument set to the computed point.
         * @throws {ArgumentError} If the specified result argument is null or undefined.
         */
        TerrainTile.prototype.surfacePoint = function (latitude, longitude, result) {
            if (!result) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "TerrainTile", "surfacePoint", "missingResult"));
            }

            var tileSector = this.sector,
                minLat = tileSector.minLatitude,
                maxLat = tileSector.maxLatitude,
                minLon = tileSector.minLongitude,
                maxLon = tileSector.maxLongitude,
                tileWidth = this.tileWidth,
                tileHeight = this.tileHeight,
                s, t, si, ti, rowStride, vertices, points, k, sf, tf, x, y, z;

            // Compute the location's horizontal (s) and vertical (t) parameterized coordinates within the tiles 2D grid of
            // points as a floating-point value in the range [0, tileWidth] and [0, tileHeight]. These coordinates indicate
            // which cell contains the location, as well as the location's placement within the cell. Note that this method
            // assumes that the caller has tested whether the location is contained within the tile's sector.
            s = (longitude - minLon) / (maxLon - minLon) * tileWidth;
            t = (latitude - minLat) / (maxLat - minLat) * tileHeight;

            // Get the coordinates for the four vertices defining the cell this point is in. Tile vertices start in the lower
            // left corner and proceed in row major order across the tile. The tile contains one more vertex per row or
            // column than the tile width or height. Vertices in the points array are organized in the
            // following order: lower-left, lower-right, upper-left, upper-right. The cell's diagonal starts at the
            // lower-left vertex and ends at the upper-right vertex.
            si = s < tileWidth ? Math.floor(s) : tileWidth - 1;
            ti = t < tileHeight ? Math.floor(t) : tileHeight - 1;
            rowStride = tileWidth + 1;

            vertices = this.points;
            points = this.scratchArray; // temporary working buffer
            k = 3 * (si + ti * rowStride); // lower-left and lower-right vertices
            for (var i = 0; i < 6; i++) {
                points[i] = vertices[k + i];
            }

            k = 3 * (si + (ti + 1) * rowStride); // upper-left and upper-right vertices
            for (var j = 6; j < 12; j++) {
                points[j] = vertices[k + (j - 6)];
            }

            // Compute the location's corresponding point on the cell in tile local coordinates,
            // given the fractional portion of the parameterized s and t coordinates. These values indicate the location's
            // relative placement within the cell. The cell's vertices are defined in the following order: lower-left,
            // lower-right, upper-left, upper-right. The cell's diagonal starts at the lower-right vertex and ends at the
            // upper-left vertex.
            sf = (s < tileWidth ? s - Math.floor(s) : 1);
            tf = (t < tileHeight ? t - Math.floor(t) : 1);

            if (sf > tf) {
                result[0] = points[0] + sf * (points[3] - points[0]) + tf * (points[6] - points[0]);
                result[1] = points[1] + sf * (points[4] - points[1]) + tf * (points[7] - points[1]);
                result[2] = points[2] + sf * (points[5] - points[2]) + tf * (points[8] - points[2]);
            }
            else {
                result[0] = points[9] + (1 - sf) * (points[6] - points[9]) + (1 - tf) * (points[3] - points[9]);
                result[1] = points[10] + (1 - sf) * (points[7] - points[10]) + (1 - tf) * (points[4] - points[10]);
                result[2] = points[11] + (1 - sf) * (points[8] - points[11]) + (1 - tf) * (points[5] - points[11]);
            }

            result[0] += this.referencePoint[0];
            result[1] += this.referencePoint[1];
            result[2] += this.referencePoint[2];

            return result;
        };

        TerrainTile.prototype.update = function (dc) {
            Tile.prototype.update.call(this, dc);

            var elevationTimestamp = dc.globe.elevationTimestamp();
            if (this._elevationTimestamp != elevationTimestamp) {
                this._elevationTimestamp = elevationTimestamp;
                this._stateKey = null; // cause updates to any elevation-dependent cached state
            }
        };

        // Intentionally not documented.
        TerrainTile.prototype.computeStateKey = function () {
            var array = [];
            array.push(this._elevationTimestamp);
            array.push(this.neighborMap[WorldWind.NORTH] ? this.neighborMap[WorldWind.NORTH].compare(this.level) : 0);
            array.push(this.neighborMap[WorldWind.SOUTH] ? this.neighborMap[WorldWind.SOUTH].compare(this.level) : 0);
            array.push(this.neighborMap[WorldWind.EAST] ? this.neighborMap[WorldWind.EAST].compare(this.level) : 0);
            array.push(this.neighborMap[WorldWind.WEST] ? this.neighborMap[WorldWind.WEST].compare(this.level) : 0);

            return array.join(".");
        };

        return TerrainTile;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports TerrainTileList
 * @version $Id: TerrainTileList.js 2758 2015-02-09 00:20:46Z tgaskins $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1),
        __webpack_require__(0),
        __webpack_require__(3)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
              Logger,
              Sector) {
        "use strict";

        /**
         * Constructs a terrain tile list, a container for terrain tiles that also has a tessellator and a sector
         * associated with it.
         * @alias TerrainTileList
         * @constructor
         * @classdesc Represents a portion of a globe's terrain.
         * @param {Tessellator} tessellator The tessellator that created this terrain tile list.
         *
         */
        var TerrainTileList = function TerrainTileList(tessellator) {
            if (!tessellator) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "TerrainTileList", "TerrainTileList", "missingTessellator"));
            }
            this.tessellator = tessellator;
            this.sector = null;
            this.tileArray = [];
        };

        Object.defineProperties(TerrainTileList.prototype, {
            /**
             * The number of terrain tiles in this terrain tile list.
             * @memberof TerrainTileList.prototype
             * @readonly
             * @type {Number}
             */
            length: {
                get: function () {
                    return this.tileArray.length
                }
            }
        });

        TerrainTileList.prototype.addTile = function (tile) {
            if (!tile) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "TerrainTileList", "addTile", "missingTile"));
            }

            if (this.tileArray.indexOf(tile) == -1) {
                this.tileArray.push(tile);

                if (!this.sector) {
                    this.sector = new Sector(0, 0, 0, 0);
                    this.sector.copy(tile.sector);
                } else {
                    this.sector.union(tile.sector);
                }
            }
        };

        TerrainTileList.prototype.removeAllTiles = function () {
            this.tileArray = [];
            this.sector = null;
        };

        return TerrainTileList;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports ZeroElevationModel
 * @version $Id: ZeroElevationModel.js 2936 2015-03-27 22:04:59Z tgaskins $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(1),
        __webpack_require__(29),
        __webpack_require__(7),
        __webpack_require__(0),
        __webpack_require__(3)], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
              ElevationModel,
              Location,
              Logger,
              Sector) {
        "use strict";

        /**
         * Constructs a Zero elevation model whose elevations are zero at every location.
         * @alias ZeroElevationModel
         * @constructor
         * @classdesc Represents an elevation model whose elevations are zero at all locations.
         * @augments ElevationModel
         */
        var ZeroElevationModel = function () {
            ElevationModel.call(this, Sector.FULL_SPHERE, new Location(45, 45), 1, " ", " ", 150, 150);

            /**
             * Indicates this elevation model's display name.
             * @type {string}
             * @default "Zero Elevations"
             */
            this.displayName = "Zero Elevations";

            /**
             * Indicates the last time this elevation model changed. Since a zero elevation model never changes, this
             * property always returns the date and time at which the elevation model was constructed, in milliseconds
             * since midnight Jan 1, 1970.
             * @type {number}
             * @default Date.getTime() at construction
             * @readonly
             */
            this.timestamp = Date.now();

            /**
             * This elevation model's minimum elevation, which is always 0.
             * @type {number}
             * @default 0
             * @readonly
             */
            this.minElevation = 0;

            /**
             * This elevation model's maximum elevation, which is always 0.
             * @type {number}
             * @default 0
             * @readonly
             */
            this.maxElevation = 0;
        };

        // Inherit from the abstract elevation model class.
        ZeroElevationModel.prototype = Object.create(ElevationModel.prototype);

        /**
         * Returns minimum and maximum elevations of 0.
         * @param {Sector} sector The sector for which to determine extreme elevations.
         * @returns {Number[]} An array containing minimum and maximum elevations of 0.
         */
        ZeroElevationModel.prototype.minAndMaxElevationsForSector = function (sector) {
            return [0, 0];
        };

        /**
         * Returns 0 as the elevation at a specified location.
         * @param {Number} latitude The location's latitude in degrees.
         * @param {Number} longitude The location's longitude in degrees.
         * @returns {Number} 0.
         */
        ZeroElevationModel.prototype.elevationAtLocation = function (latitude, longitude) {
            return 0;
        };

        /**
         * Returns the elevations at locations within a specified sector. For this elevation model they are all 0.
         * @param {Sector} sector The sector for which to determine the elevations.
         * @param {Number} numLat The number of latitudinal sample locations within the sector.
         * @param {Number} numLon The number of longitudinal sample locations within the sector.
         * @param {Number} targetResolution The desired elevation resolution.
         * @param {Number[]} result An array of size numLat x numLon to contain the requested elevations.
         * This array must be allocated when passed to this function.
         * @returns {Number} The resolution actually achieved, which may be greater than that requested if the
         * elevation data for the requested resolution is not currently available.
         * @throws {ArgumentError} If the specified sector or result array is null or undefined, if either of the
         * specified numLat or numLon values is less than 1, or the result array is not of sufficient length
         * to hold numLat x numLon values.
         */
        ZeroElevationModel.prototype.elevationsForGrid = function (sector, numLat, numLon, targetResolution, result) {
            if (!sector) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "ZeroElevationModel", "elevationsForSector", "missingSector"));
            }

            if (numLat <= 0 || numLon <= 0) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "ZeroElevationModel",
                    "elevationsForSector", "numLat or numLon is less than 1"));
            }

            if (!result || result.length < numLat * numLon) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "ZeroElevationModel",
                    "elevationsForSector", "missingArray"));
            }

            for (var i = 0, len = result.length; i < len; i++) {
                result[i] = 0;
            }

            return 0;
        };

        return ZeroElevationModel;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports PickedObjectList
 * @version $Id: PickedObjectList.js 2940 2015-03-30 17:58:36Z tgaskins $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
        "use strict";

        /**
         * Constructs a picked-object list.
         * @alias PickedObjectList
         * @constructor
         * @classdesc Holds a collection of picked objects.
         */
        var PickedObjectList = function () {
            /**
             * The picked objects.
             * @type {Array}
             */
            this.objects = [];
        };

        /**
         * Indicates whether this list contains picked objects that are not terrain.
         * @returns {Boolean} true if this list contains objects that are not terrain,
         * otherwise false.
         */
        PickedObjectList.prototype.hasNonTerrainObjects = function () {
            return this.objects.length > 1 || (this.objects.length === 1 && this.terrainObject() == null);
        };

        /**
         * Returns the terrain object within this list, if this list contains a terrain object.
         * @returns {PickedObject} The terrain object, or null if this list does not contain a terrain object.
         */
        PickedObjectList.prototype.terrainObject = function () {
            for (var i = 0, len = this.objects.length; i < len; i++) {
                if (this.objects[i].isTerrain) {
                    return this.objects[i];
                }
            }

            return null;
        };

        /**
         * Adds a picked object to this list.
         * If the picked object is a terrain object and the list already contains a terrain object, the terrain
         * object in the list is replaced by the specified one.
         * @param {PickedObject} pickedObject The picked object to add. If null, this list remains unchanged.
         */
        PickedObjectList.prototype.add = function (pickedObject) {
            if (pickedObject) {
                if (pickedObject.isTerrain) {
                    var terrainObjectIndex = this.objects.length;

                    for (var i = 0, len = this.objects.length; i < len; i++) {
                        if (this.objects[i].isTerrain) {
                            terrainObjectIndex = i;
                            break;
                        }
                    }

                    this.objects[terrainObjectIndex] = pickedObject;
                } else {
                    this.objects.push(pickedObject);
                }
            }
        };

        /**
         * Removes all items from this list.
         */
        PickedObjectList.prototype.clear = function () {
            this.objects = [];
        };

        /**
         * Returns the top-most picked object in this list.
         * @returns {PickedObject} The top-most picked object in this list, or null if this list is empty.
         */
        PickedObjectList.prototype.topPickedObject = function () {
            var size = this.objects.length;

            if (size > 1) {
                for (var i = 0; i < size; i++) {
                    if (this.objects[[i].isOnTop]) {
                        return this.objects[i];
                    }
                }
            }

            if (size > 0) {
                return this.objects[0];
            }

            return null;
        };

        return PickedObjectList;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports GeographicProjection
 * @version $Id: GeographicProjection.js 2821 2015-02-20 16:59:27Z dcollins $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(1),
        __webpack_require__(0),
        __webpack_require__(3),
        __webpack_require__(17)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
              Logger,
              Sector,
              UnsupportedOperationError) {
        "use strict";

        /**
         * Constructs a base geographic projection.
         * @alias GeographicProjection
         * @constructor
         * @classdesc Represents a geographic projection.
         * This is an abstract class and is meant to be instantiated only by subclasses.
         * See the following projections:
         * <ul>
         *     <li>{@link ProjectionEquirectangular}</li>
         *     <li>{@link ProjectionMercator}</li>
         *     <li>{@link ProjectionPolarEquidistant}</li>
         *     <li>{@link ProjectionUPS}</li>
         </ul>
         * @param {String} displayName The projection's display name.
         * @param {boolean} continuous Indicates whether this projection is continuous.
         * @param {Sector} projectionLimits This projection's projection limits. May be null to indicate the full
         * range of latitude and longitude, +/- 90 degrees latitude, +/- 180 degrees longitude.
         */
        var GeographicProjection = function (displayName, continuous, projectionLimits) {

            /**
             * This projection's display name.
             * @type {string}
             */
            this.displayName = displayName || "Geographic Projection";

            /**
             * Indicates whether this projection should be treated as continuous with itself. If true, the 2D map
             * will appear to scroll continuously horizontally.
             * @type {boolean}
             * @readonly
             */
            this.continuous = continuous;

            /**
             * Indicates the geographic limits of this projection.
             * @type {Sector}
             * @readonly
             */
            this.projectionLimits = projectionLimits;

            /**
             * Indicates whether this projection is a 2D projection.
             * @type {boolean}
             * @readonly
             */
            this.is2D = true;
        };

        /**
         * Converts a geographic position to Cartesian coordinates.
         *
         * @param {Globe} globe The globe this projection is applied to.
         * @param {number} latitude The latitude of the position, in degrees.
         * @param {number} longitude The longitude of the position, in degrees.
         * @param {number} elevation The elevation of the position, in meters.
         * @param {Vec3} offset An offset to apply to the Cartesian output. Typically only projections that are
         * continuous (see [continuous]{@link GeographicProjection#continuous}) apply to this offset. Others ignore
         * it. May be null to indicate no offset is applied.
         * @param {Vec3} result A variable in which to store the computed Cartesian point.
         *
         * @returns {Vec3} The specified result argument containing the computed point.
         * @throws {ArgumentError} If the specified globe or result is null or undefined.
         */
        GeographicProjection.prototype.geographicToCartesian = function (globe, latitude, longitude, elevation,
                                                                         offset, result) {
            throw new UnsupportedOperationError(
                Logger.logMessage(Logger.LEVEL_SEVERE, "GeographicProjection", "geographicToCartesian", "abstractInvocation"));
        };

        /**
         * Computes a grid of Cartesian points within a specified sector and relative to a specified Cartesian
         * reference point.
         * <p>
         * This method is used to compute a collection of points within a sector. It is used by tessellators to
         * efficiently generate a tile's interior points. The number of points to generate is indicated by the tileWidth
         * and tileHeight parameters but is one more in each direction. Width refers to the longitudinal direction,
         * height to the latitudinal.
         * <p>
         * For each implied position within the sector, an elevation value is specified via an array of elevations. The
         * calculation at each position incorporates the associated elevation.
         * There must be (tileWidth + 1) x (tileHeight + 1) elevations in the array.
         *
         * @param {Globe} globe The globe this projection applies to.
         * @param {Sector} sector The sector in which to compute the points.
         * @param {Number} numLat The number of latitudinal sections a tile is divided into.
         * @param {Number} numLon The number of longitudinal sections a tile is divided into.
         * @param {Number[]} elevations An array of elevations to incorporate in the point calculations. There must be
         * one elevation value in the array for each generated point. Elevations are in meters.
         * There must be (tileWidth + 1) x (tileHeight + 1) elevations in the array.
         * @param {Vec3} referencePoint The X, Y and Z Cartesian coordinates to subtract from the computed coordinates.
         * This makes the computed coordinates relative to the specified point. May be null.
         * @param {Vec3} offset An offset to apply to the Cartesian output points. Typically only projections that
         * are continuous (see [continuous]{@link GeographicProjection#continuous}) apply this offset. Others ignore it.
         * May be null to indicate that no offset is applied.
         * @param {Float32Array} result A typed array to hold the computed coordinates. It must be at least of
         * size (tileWidth + 1) x (tileHeight + 1) * 3.
         * The points are returned in row major order, beginning with the row of minimum latitude.
         * @returns {Float32Array} The specified result argument, populated with the computed Cartesian coordinates.
         * @throws {ArgumentError} if any of the specified globe, sector, elevations array or results arrays is null or
         * undefined.
         */
        GeographicProjection.prototype.geographicToCartesianGrid = function (globe, sector, numLat, numLon, elevations,
                                                                             referencePoint, offset, result) {
            throw new UnsupportedOperationError(
                Logger.logMessage(Logger.LEVEL_SEVERE, "GeographicProjection", "geographicToCartesianGrid", "abstractInvocation"));
        };

        /**
         * Converts a Cartesian point to a geographic position.
         * @param {Globe} globe The globe this projection is applied to.
         * @param {number} x The X component of the Cartesian point.
         * @param {number} y The Y component of the Cartesian point.
         * @param {number} z The Z component of the Cartesian point.
         * @param {Vec3} offset An offset to apply to the Cartesian output points. Typically only projections that
         * are continuous (see [continuous]{@link GeographicProjection#continuous}) apply this offset. Others ignore it.
         * May be null to indicate that no offset is applied.
         * @param {Position} result A variable in which to return the computed position.
         *
         * @returns {Position} The specified result argument containing the computed position.
         * @throws {ArgumentError} If either the specified globe or result argument is null or undefined.
         */
        GeographicProjection.prototype.cartesianToGeographic = function (globe, x, y, z, offset, result) {
            throw new UnsupportedOperationError(
                Logger.logMessage(Logger.LEVEL_SEVERE, "GeographicProjection", "cartesianToGeographic", "abstractInvocation"));
        };

        /**
         * Computes a Cartesian vector that points north and is tangent to the meridian at a specified geographic
         * location.
         *
         * @param {Globe} globe The globe this projection is applied to.
         * @param {number} latitude The latitude of the location, in degrees.
         * @param {number} longitude The longitude of the location, in degrees.
         * @param {Vec3} result A variable in which to return the computed vector.
         *
         * @returns{Vec3} The specified result argument containing the computed vector.
         * @throws {ArgumentError} If either the specified globe or result argument is null or undefined.
         */
        GeographicProjection.prototype.northTangentAtLocation = function (globe, latitude, longitude, result) {
            if (!result) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "ProjectionEquirectangular",
                    "northTangentAtLocation", "missingResult"));
            }

            result[0] = 0;
            result[1] = 1;
            result[2] = 0;

            return result;
        };

        /**
         * Computes a Cartesian vector that points north and is tangent to the meridian at a specified Cartesian
         * point.
         *
         * @param {Globe} globe The globe this projection is applied to.
         * @param {number} x The X component of the Cartesian point.
         * @param {number} y The Y component of the Cartesian point.
         * @param {number} z The Z component of the Cartesian point.
         * @param {Vec3} offset An offset to apply to the Cartesian point. Typically only projections that
         * are continuous (see [continuous]{@link GeographicProjection#continuous}) apply this offset. Others ignore it.
         * May be null to indicate that no offset is applied.
         * @param {Vec3} result A variable in which to return the computed vector.
         *
         * @returns{Vec3} The specified result argument containing the computed vector.
         * @throws {ArgumentError} If either the specified globe or result argument is null or undefined.
         */
        GeographicProjection.prototype.northTangentAtPoint = function (globe, x, y, z, offset, result) {
            if (!result) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "ProjectionEquirectangular",
                    "northTangentAtPoint", "missingResult"));
            }

            result[0] = 0;
            result[1] = 1;
            result[2] = 0;

            return result;
        };

        /**
         * Computes the Cartesian surface normal vector at a specified Cartesian point.
         *
         * @param {Globe} globe The globe this projection is applied to.
         * @param {number} x The X component of the Cartesian point.
         * @param {number} y The Y component of the Cartesian point.
         * @param {number} z The Z component of the Cartesian point.
         * @param {Vec3} result A variable in which to return the computed vector.
         *
         * @returns{Vec3} The specified result argument containing the computed vector.
         * @throws {ArgumentError} If either the specified globe or result argument is null or undefined.
         */
        GeographicProjection.prototype.surfaceNormalAtPoint = function (globe, x, y, z, result) {
            if (!result) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "GeographicProjection", "surfaceNormalAtPoint",
                    "missingResult"));
            }

            result[0] = 0;
            result[1] = 0;
            result[2] = 1;

            return result;
        };

        return GeographicProjection;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports DrawContext
 * @version $Id: DrawContext.js 3351 2015-07-28 22:03:20Z dcollins $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(1),
        __webpack_require__(8),
        __webpack_require__(53),
        __webpack_require__(45),
        __webpack_require__(75),
        __webpack_require__(24),
        __webpack_require__(15),
        __webpack_require__(11),
        __webpack_require__(35),
        __webpack_require__(31),
        __webpack_require__(0),
        __webpack_require__(5),
        __webpack_require__(20),
        __webpack_require__(42),
        __webpack_require__(18),
        __webpack_require__(10),
        __webpack_require__(9),
        __webpack_require__(76),
        __webpack_require__(3),
        __webpack_require__(33),
        __webpack_require__(51),
        __webpack_require__(78),
        __webpack_require__(79),
        __webpack_require__(14),
        __webpack_require__(2),
        __webpack_require__(4)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
              Color,
              FrameStatistics,
              FramebufferTexture,
              FramebufferTileController,
              Frustum,
              Globe,
              GpuProgram,
              GpuResourceCache,
              Layer,
              Logger,
              Matrix,
              NavigatorState,
              PickedObjectList,
              Plane,
              Position,
              Rectangle,
              ScreenCreditController,
              Sector,
              SurfaceShape,
              SurfaceShapeTileBuilder,
              SurfaceTileRenderer,
              TextSupport,
              Vec2,
              Vec3,
              WWMath) {
        "use strict";

        /**
         * Constructs a DrawContext. Applications do not call this constructor. A draw context is created by a
         * {@link WorldWindow} during its construction.
         * @alias DrawContext
         * @constructor
         * @classdesc Provides current state during rendering. The current draw context is passed to most rendering
         * methods in order to make those methods aware of current state.
         * @param {WebGLRenderingContext} gl The WebGL rendering context this draw context is associated with.
         * @throws {ArgumentError} If the specified WebGL rendering context is null or undefined.
         */
        var DrawContext = function (gl) {
            if (!gl) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "Texture", "constructor",
                    "missingGlContext"));
            }

            /**
             * The current WebGL rendering context.
             * @type {WebGLRenderingContext}
             */
            this.currentGlContext = gl;

            /**
             * A 2D canvas for creating texture maps.
             * @type {HTMLElement}
             */
            this.canvas2D = document.createElement("canvas");

            /**
             * A 2D context for this draw context's [canvas property]{@link DrawContext#canvas}.
             */
            this.ctx2D = this.canvas2D.getContext("2d");

            /**
             * The current clear color.
             * @type {Color}
             * @default Color.TRANSPARENT (red = 0, green = 0, blue = 0, alpha = 0)
             */
            this.clearColor = Color.TRANSPARENT;

            /**
             * The GPU resource cache, which tracks WebGL resources.
             * @type {GpuResourceCache}
             */
            this.gpuResourceCache = new GpuResourceCache(WorldWind.configuration.gpuCacheSize,
                0.8 * WorldWind.configuration.gpuCacheSize);

            /**
             * The surface-tile-renderer to use for drawing surface tiles.
             * @type {SurfaceTileRenderer}
             */
            this.surfaceTileRenderer = new SurfaceTileRenderer();

            /**
             * The surface shape tile builder used to create and draw surface shapes.
             * @type {SurfaceShapeTileBuilder}
             */
            this.surfaceShapeTileBuilder = new SurfaceShapeTileBuilder();

            /**
             * Provides access to a multi-resolution WebGL framebuffer arranged as adjacent tiles in a pyramid. Surface
             * shapes use these tiles internally to draw on the terrain surface.
             * @type {FramebufferTileController}
             */
            this.surfaceShapeTileController = new FramebufferTileController();

            /**
             * The screen credit controller responsible for collecting and drawing screen credits.
             * @type {ScreenCreditController}
             */
            this.screenCreditController = new ScreenCreditController();

            /**
             * A shared TextSupport instance.
             * @type {TextSupport}
             */
            this.textSupport = new TextSupport();

            /**
             * The current WebGL framebuffer. Null indicates that the default WebGL framebuffer is active.
             * @type {FramebufferTexture}
             */
            this.currentFramebuffer = null;

            /**
             * The current WebGL program. Null indicates that no WebGL program is active.
             * @type {GpuProgram}
             */
            this.currentProgram = null;

            /**
             * The list of surface renderables.
             * @type {Array}
             */
            this.surfaceRenderables = [];

            /**
             * Indicates whether this draw context is in ordered rendering mode.
             * @type {Boolean}
             */
            this.orderedRenderingMode = false;

            /**
             * The list of ordered renderables.
             * @type {Array}
             */
            this.orderedRenderables = [];

            /**
             * The list of screen renderables.
             * @type {Array}
             */
            this.screeRenderables = [];

            // Internal. Intentionally not documented. Provides ordinal IDs to ordered renderables.
            this.orderedRenderablesCounter = 0; // Number

            /**
             * The starting time of the current frame, in milliseconds. The frame timestamp is updated immediately
             * before the World Window associated with this draw context is rendered, either as a result of redrawing or
             * as a result of a picking operation.
             * @type {Number}
             * @readonly
             */
            this.timestamp = Date.now();

            /**
             * The [time stamp]{@link DrawContext#timestamp} of the last visible frame, in milliseconds. This indicates
             * the time stamp that was current during the World Window's last frame, ignoring frames associated with a
             * picking operation. The difference between the previous redraw time stamp and the current time stamp
             * indicates the duration between visible frames, e.g. <code style='white-space:nowrap'>timeStamp - previousRedrawTimestamp</code>.
             * @type {Number}
             * @readonly
             */
            this.previousRedrawTimestamp = this.timestamp;

            /**
             * Indicates whether a redraw has been requested during the current frame. When true, this causes the World
             * Window associated with this draw context to redraw after the current frame.
             * @type {Boolean}
             */
            this.redrawRequested = false;

            /**
             * The globe being rendered.
             * @type {Globe}
             */
            this.globe = null;

            /**
             * A copy of the current globe's state key. Provided here to avoid having to recompute it every time
             * it's needed.
             * @type {String}
             */
            this.globeStateKey = null;

            /**
             * The layers being rendered.
             * @type {Layer[]}
             */
            this.layers = null;

            /**
             * The layer being rendered.
             * @type {Layer}
             */
            this.currentLayer = null;

            /**
             * The current state of the associated navigator.
             * @type {NavigatorState}
             */
            this.navigatorState = null;

            /**
             * The current eye position.
             * @type {Position}
             */
            this.eyePosition = new Position(0, 0, 0);

            /**
             * The current screen projection matrix.
             * @type {Matrix}
             */
            this.screenProjection = Matrix.fromIdentity();

            /**
             * The terrain for the current frame.
             * @type {Terrain}
             */
            this.terrain = null;

            /**
             * The current vertical exaggeration.
             * @type {Number}
             */
            this.verticalExaggeration = 1;

            /**
             * The number of milliseconds over which to fade shapes that support fading. Fading is most typically
             * used during decluttering.
             * @type {Number}
             * @default 500
             */
            this.fadeTime = 500;

            /**
             * The opacity to apply to terrain and surface shapes. Should be a number between 0 and 1.
             * @type {Number}
             * @default 1
             */
            this.surfaceOpacity = 1;

            /**
             * Frame statistics.
             * @type {FrameStatistics}
             */
            this.frameStatistics = null;

            /**
             * Indicates whether the frame is being drawn for picking.
             * @type {Boolean}
             */
            this.pickingMode = false;

            /**
             * Indicates that picking will return only the terrain object, if the pick point is over the terrain.
             * @type {Boolean}
             * @default false
             */
            this.pickTerrainOnly = false;

            /**
             * Indicates that picking will return all objects at the pick point, if any. The top-most object will have
             * its isOnTop flag set to true. If [deep picking]{@link WorldWindow#deepPicking} is false, the default,
             * only the top-most object is returned, plus the picked-terrain object if the pick point is over the
             * terrain.
             * @type {Boolean}
             * @default false
             */
            this.deepPicking = false;

            /**
             * Indicates that picking will return all objects that intersect the pick region, if any. Visible objects
             * will have the isOnTop flag set to true.
             * @type {Boolean}
             * @default false
             */
            this.regionPicking = false;

            /**
             * The current pick point, in screen coordinates.
             * @type {Vec2}
             */
            this.pickPoint = null;

            /**
             * The current pick rectangle, in WebGL (lower-left origin) screen coordinates.
             * @type {Rectangle}
             */
            this.pickRectangle = null;

            /**
             * The off-screen WebGL framebuffer used during picking.
             * @type {FramebufferTexture}
             * @readonly
             */
            this.pickFramebuffer = null;

            /**
             * The current pick frustum, created anew each picking frame.
             * @type {Frustum}
             * @readonly
             */
            this.pickFrustum = null;

            // Internal. Keeps track of the current pick color.
            this.pickColor = new Color(0, 0, 0, 1);

            /**
             * The objects at the current pick point.
             * @type {PickedObjectList}
             * @readonly
             */
            this.objectsAtPickPoint = new PickedObjectList();

            // Intentionally not documented.
            this.pixelScale = 1;
        };

        // Internal use. Intentionally not documented.
        DrawContext.unitCubeKey = "DrawContextUnitCubeKey";
        DrawContext.unitCubeElementsKey = "DrawContextUnitCubeElementsKey";
        DrawContext.unitQuadKey = "DrawContextUnitQuadKey";
        DrawContext.unitQuadKey3 = "DrawContextUnitQuadKey3";

        /**
         * Prepare this draw context for the drawing of a new frame.
         */
        DrawContext.prototype.reset = function () {
            // Reset the draw context's internal properties.
            this.screenCreditController.clear();
            this.surfaceRenderables = []; // clears the surface renderables array
            this.orderedRenderingMode = false;
            this.orderedRenderables = []; // clears the ordered renderables array
            this.screenRenderables = [];
            this.orderedRenderablesCounter = 0;

            // Advance the per-frame timestamp.
            var previousTimestamp = this.timestamp;
            this.timestamp = Date.now();
            if (this.timestamp === previousTimestamp)
                ++this.timestamp;

            // Reset properties set by the World Window every frame.
            this.redrawRequested = false;
            this.globe = null;
            this.globeStateKey = null;
            this.layers = null;
            this.currentLayer = null;
            this.navigatorState = null;
            this.terrain = null;
            this.verticalExaggeration = 1;
            this.frameStatistics = null;
            this.accumulateOrderedRenderables = true;

            // Reset picking properties that may be set by the World Window.
            this.pickingMode = false;
            this.pickTerrainOnly = false;
            this.deepPicking = false;
            this.regionPicking = false;
            this.pickPoint = null;
            this.pickRectangle = null;
            this.pickFrustum = null;
            this.pickColor = new Color(0, 0, 0, 1);
            this.objectsAtPickPoint.clear();
        };

        /**
         * Computes any values necessary to render the upcoming frame. Called after all draw context state for the
         * frame has been set.
         */
        DrawContext.prototype.update = function () {
            var gl = this.currentGlContext,
                eyePoint = this.navigatorState.eyePoint;

            this.globeStateKey = this.globe.stateKey;
            this.globe.computePositionFromPoint(eyePoint[0], eyePoint[1], eyePoint[2], this.eyePosition);
            this.screenProjection.setToScreenProjection(gl.drawingBufferWidth, gl.drawingBufferHeight);
        };

        /**
         * Notifies this draw context that the current WebGL rendering context has been lost. This function removes all
         * cached WebGL resources and resets all properties tracking the current WebGL state.
         */
        DrawContext.prototype.contextLost = function () {
            // Remove all cached WebGL resources, which are now invalid.
            this.gpuResourceCache.clear();
            this.pickFramebuffer = null;
            // Reset properties tracking the current WebGL state, which are now invalid.
            this.currentFramebuffer = null;
            this.currentProgram = null;
        };

        /**
         * Notifies this draw context that the current WebGL rendering context has been restored. This function prepares
         * this draw context to resume rendering.
         */
        DrawContext.prototype.contextRestored = function () {
            // Remove all cached WebGL resources. This cache is already cleared when the context is lost, but
            // asynchronous load operations that complete between context lost and context restored populate the cache
            // with invalid entries.
            this.gpuResourceCache.clear();
        };

        /**
         * Binds a specified WebGL framebuffer. This function also makes the framebuffer the active framebuffer.
         * @param {FramebufferTexture} framebuffer The framebuffer to bind. May be null or undefined, in which case the
         * default WebGL framebuffer is made active.
         */
        DrawContext.prototype.bindFramebuffer = function (framebuffer) {
            if (this.currentFramebuffer != framebuffer) {
                this.currentGlContext.bindFramebuffer(this.currentGlContext.FRAMEBUFFER,
                    framebuffer ? framebuffer.framebufferId : null);
                this.currentFramebuffer = framebuffer;
            }
        };

        /**
         * Binds a specified WebGL program. This function also makes the program the current program.
         * @param {GpuProgram} program The program to bind. May be null or undefined, in which case the currently
         * bound program is unbound.
         */
        DrawContext.prototype.bindProgram = function (program) {
            if (this.currentProgram != program) {
                this.currentGlContext.useProgram(program ? program.programId : null);
                this.currentProgram = program;
            }
        };

        /**
         * Binds a potentially cached WebGL program, creating and caching it if it isn't already cached.
         * This function also makes the program the current program.
         * @param {function} programConstructor The constructor to use to create the program.
         * @returns {GpuProgram} The bound program.
         * @throws {ArgumentError} If the specified constructor is null or undefined.
         */
        DrawContext.prototype.findAndBindProgram = function (programConstructor) {
            if (!programConstructor) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "DrawContext", "findAndBindProgram",
                        "The specified program constructor is null or undefined."));
            }

            var program = this.gpuResourceCache.resourceForKey(programConstructor.key);
            if (program) {
                this.bindProgram(program);
            } else {
                try {
                    program = new programConstructor(this.currentGlContext);
                    this.bindProgram(program);
                    this.gpuResourceCache.putResource(programConstructor.key, program, program.size);
                } catch (e) {
                    Logger.log(Logger.LEVEL_SEVERE, "Error attempting to create GPU program.")
                }
            }

            return program;
        };

        /**
         * Adds a surface renderable to this draw context's surface renderable list.
         * @param {SurfaceRenderable} surfaceRenderable The surface renderable to add. May be null, in which case the
         * current surface renderable list remains unchanged.
         */
        DrawContext.prototype.addSurfaceRenderable = function (surfaceRenderable) {
            if (surfaceRenderable) {
                this.surfaceRenderables.push(surfaceRenderable);
            }
        };

        /**
         * Returns the surface renderable at the head of the surface renderable list without removing it from the list.
         * @returns {SurfaceRenderable} The first surface renderable in this draw context's surface renderable list, or
         * null if the surface renderable list is empty.
         */
        DrawContext.prototype.peekSurfaceRenderable = function () {
            if (this.surfaceRenderables.length > 0) {
                return this.surfaceRenderables[this.surfaceRenderables.length - 1];
            } else {
                return null;
            }
        };

        /**
         * Returns the surface renderable at the head of the surface renderable list and removes it from the list.
         * @returns {SurfaceRenderable} The first surface renderable in this draw context's surface renderable list, or
         * null if the surface renderable list is empty.
         */
        DrawContext.prototype.popSurfaceRenderable = function () {
            if (this.surfaceRenderables.length > 0) {
                return this.surfaceRenderables.pop();
            } else {
                return null;
            }
        };

        /**
         * Reverses the surface renderable list in place. After this function completes, the functions
         * peekSurfaceRenderable and popSurfaceRenderable return renderables in the order in which they were added to
         * the surface renderable list.
         */
        DrawContext.prototype.reverseSurfaceRenderables = function () {
            this.surfaceRenderables.reverse();
        };

        /**
         * Adds an ordered renderable to this draw context's ordered renderable list.
         * @param {OrderedRenderable} orderedRenderable The ordered renderable to add. May be null, in which case the
         * current ordered renderable list remains unchanged.
         * @param {Number} eyeDistance An optional argument indicating the ordered renderable's eye distance.
         * If this parameter is not specified then the ordered renderable must have an eyeDistance property.
         */
        DrawContext.prototype.addOrderedRenderable = function (orderedRenderable, eyeDistance) {
            if (orderedRenderable) {
                var ore = {
                    orderedRenderable: orderedRenderable,
                    insertionOrder: this.orderedRenderablesCounter++,
                    eyeDistance: eyeDistance || orderedRenderable.eyeDistance,
                    globeStateKey: this.globeStateKey
                };

                if (this.globe.continuous) {
                    ore.globeOffset = this.globe.offset;
                }

                if (ore.eyeDistance === 0) {
                    this.screenRenderables.push(ore);
                } else {
                    this.orderedRenderables.push(ore);
                }
            }
        };

        /**
         * Adds an ordered renderable to the end of this draw context's ordered renderable list, denoting it as the
         * most distant from the eye point.
         * @param {OrderedRenderable} orderedRenderable The ordered renderable to add. May be null, in which case the
         * current ordered renderable list remains unchanged.
         */
        DrawContext.prototype.addOrderedRenderableToBack = function (orderedRenderable) {
            if (orderedRenderable) {
                var ore = {
                    orderedRenderable: orderedRenderable,
                    insertionOrder: this.orderedRenderablesCounter++,
                    eyeDistance: Number.MAX_VALUE,
                    globeStateKey: this.globeStateKey
                };

                if (this.globe.continuous) {
                    ore.globeOffset = this.globe.offset;
                }

                this.orderedRenderables.push(ore);
            }
        };

        /**
         * Returns the ordered renderable at the head of the ordered renderable list without removing it from the list.
         * @returns {OrderedRenderable} The first ordered renderable in this draw context's ordered renderable list, or
         * null if the ordered renderable list is empty.
         */
        DrawContext.prototype.peekOrderedRenderable = function () {
            if (this.orderedRenderables.length > 0) {
                return this.orderedRenderables[this.orderedRenderables.length - 1].orderedRenderable;
            } else {
                return null;
            }
        };

        /**
         * Returns the ordered renderable at the head of the ordered renderable list and removes it from the list.
         * @returns {OrderedRenderable} The first ordered renderable in this draw context's ordered renderable list, or
         * null if the ordered renderable list is empty.
         */
        DrawContext.prototype.popOrderedRenderable = function () {
            if (this.orderedRenderables.length > 0) {
                var ore = this.orderedRenderables.pop();
                this.globeStateKey = ore.globeStateKey;

                if (this.globe.continuous) {
                    // Restore the globe state to that when the ordered renderable was created.
                    this.globe.offset = ore.globeOffset;
                }

                return ore.orderedRenderable;
            } else {
                return null;
            }
        };

        /**
         * Returns the ordered renderable at the head of the ordered renderable list and removes it from the list.
         * @returns {OrderedRenderable} The first ordered renderable in this draw context's ordered renderable list, or
         * null if the ordered renderable list is empty.
         */
        DrawContext.prototype.nextScreenRenderable = function () {
            if (this.screenRenderables.length > 0) {
                var ore = this.screenRenderables.shift();
                this.globeStateKey = ore.globeStateKey;

                if (this.globe.continuous) {
                    // Restore the globe state to that when the ordered renderable was created.
                    this.globe.offset = ore.globeOffset;
                }

                return ore.orderedRenderable;
            } else {
                return null;
            }
        };

        /**
         * Sorts the ordered renderable list from nearest to the eye point to farthest from the eye point.
         */
        DrawContext.prototype.sortOrderedRenderables = function () {
            // Sort the ordered renderables by eye distance from front to back and then by insertion time. The ordered
            // renderable peek and pop access the back of the ordered renderable list, thereby causing ordered renderables to
            // be processed from back to front.

            this.orderedRenderables.sort(function (oreA, oreB) {
                var eA = oreA.eyeDistance,
                    eB = oreB.eyeDistance;

                if (eA < eB) { // orA is closer to the eye than orB; sort orA before orB
                    return -1;
                } else if (eA > eB) { // orA is farther from the eye than orB; sort orB before orA
                    return 1;
                } else { // orA and orB are the same distance from the eye; sort them based on insertion time
                    var tA = oreA.insertionOrder,
                        tB = oreB.insertionOrder;

                    if (tA > tB) {
                        return -1;
                    } else if (tA < tB) {
                        return 1;
                    } else {
                        return 0;
                    }
                }
            });
        };

        /**
         * Reads the color from the current render buffer at a specified point. Used during picking to identify the item most
         * recently affecting the pixel at the specified point.
         * @param {Vec2} pickPoint The current pick point.
         * @returns {Color} The color at the pick point.
         */
        DrawContext.prototype.readPickColor = function (pickPoint) {
            var glPickPoint = this.navigatorState.convertPointToViewport(pickPoint, new Vec2(0, 0)),
                colorBytes = new Uint8Array(4);

            this.currentGlContext.readPixels(glPickPoint[0], glPickPoint[1], 1, 1, this.currentGlContext.RGBA,
                this.currentGlContext.UNSIGNED_BYTE, colorBytes);

            if (this.clearColor.equalsBytes(colorBytes)) {
                return null;
            }

            return Color.colorFromByteArray(colorBytes);
        };

        /**
         * Reads the current pick buffer colors in a specified rectangle. Used during region picking to identify
         * the items not occluded.
         * @param {Rectangle} pickRectangle The rectangle for which to read the colors.
         * @returns {{}} An object containing the unique colors in the specified rectangle, excluding the current
         * clear color. The colors are referenced by their byte string
         * (see [Color.toByteString]{@link Color#toByteString}.
         */
        DrawContext.prototype.readPickColors = function (pickRectangle) {
            var gl = this.currentGlContext,
                colorBytes = new Uint8Array(pickRectangle.width * pickRectangle.height * 4),
                uniqueColors = {},
                color,
                blankColor = new Color(0, 0, 0, 0),
                packAlignment = gl.getParameter(gl.PACK_ALIGNMENT);

            gl.pixelStorei(gl.PACK_ALIGNMENT, 1); // read byte aligned
            this.currentGlContext.readPixels(pickRectangle.x, pickRectangle.y,
                pickRectangle.width, pickRectangle.height,
                gl.RGBA, gl.UNSIGNED_BYTE, colorBytes);
            gl.pixelStorei(gl.PACK_ALIGNMENT, packAlignment); // restore the pack alignment

            for (var i = 0, len = pickRectangle.width * pickRectangle.height; i < len; i++) {
                var k = i * 4;
                color = Color.colorFromBytes(colorBytes[k], colorBytes[k + 1], colorBytes[k + 2], colorBytes[k + 3]);
                if (color.equals(this.clearColor) || color.equals(blankColor))
                    continue;
                uniqueColors[color.toByteString()] = color;
            }

            return uniqueColors;
        };

        /**
         * Determines whether a specified picked object is under the pick point, and if it is adds it to this draw
         * context's list of picked objects. This method should be called by shapes during ordered rendering
         * after the shape is drawn. If this draw context is in single-picking mode, the specified pickable object
         * is added to the list of picked objects whether or not it is under the pick point.
         * @param pickableObject
         * @returns {null}
         */
        DrawContext.prototype.resolvePick = function (pickableObject) {
            if (!(pickableObject.userObject instanceof SurfaceShape) && this.deepPicking && !this.regionPicking) {
                var color = this.readPickColor(this.pickPoint);
                if (!color) { // getPickColor returns null if the pick point selects the clear color
                    return null;
                }

                if (pickableObject.color.equals(color)) {
                    this.addPickedObject(pickableObject);
                }
            } else {
                // Don't resolve. Just add the object to the pick list. It will be resolved later.
                this.addPickedObject(pickableObject);
            }
        };

        /**
         * Adds an object to the current picked-object list. The list identifies objects that are at the pick point
         * but not necessarily the top-most object.
         * @param  {PickedObject} pickedObject The object to add.
         */
        DrawContext.prototype.addPickedObject = function (pickedObject) {
            if (pickedObject) {
                this.objectsAtPickPoint.add(pickedObject);
            }
        };

        /**
         * Computes a unique color to use as a pick color.
         * @returns {Color} A unique color.
         */
        DrawContext.prototype.uniquePickColor = function () {
            var color = this.pickColor.nextColor().clone();

            return color.equals(this.clearColor) ? color.nextColor() : color;
        };

        /**
         * Creates an off-screen WebGL framebuffer for use during picking and stores it in this draw context. The
         * framebuffer width and height match the WebGL rendering context's drawingBufferWidth and drawingBufferHeight.
         */
        DrawContext.prototype.makePickFramebuffer = function () {
            var gl = this.currentGlContext,
                width = gl.drawingBufferWidth,
                height = gl.drawingBufferHeight;

            if (!this.pickFramebuffer ||
                this.pickFramebuffer.width != width ||
                this.pickFramebuffer.height != height) {

                this.pickFramebuffer = new FramebufferTexture(gl, width, height, true); // enable depth buffering
            }

            return this.pickFramebuffer;
        };

        /**
         * Creates a pick frustum for the current pick point and stores it in this draw context. If this context's
         * pick rectangle is null or undefined then a pick rectangle is also computed and assigned to this context.
         * If the existing pick rectangle extends beyond the viewport then it is truncated by this method to fit
         * within the viewport.
         * This method assumes that this draw context's pick point or pick rectangle has been set. It returns
         * false if neither one of these exists.
         *
         * @returns {Boolean} <code>true</code> if the pick frustum could be created, otherwise <code>false</code>.
         */
        DrawContext.prototype.makePickFrustum = function () {
            if (!this.pickPoint && !this.pickRectangle) {
                return false;
            }

            var lln, llf, lrn, lrf, uln, ulf, urn, urf, // corner points of frustum
                nl, nr, nt, nb, nn, nf, // normal vectors of frustum planes
                l, r, t, b, n, f, // frustum planes
                va, vb = new Vec3(0, 0, 0), // vectors formed by the corner points
                apertureRadius = 2, // radius of pick window in screen coordinates
                screenPoint = new Vec3(0, 0, 0),
                pickPoint,
                pickRectangle = this.pickRectangle,
                viewport = this.navigatorState.viewport;

            // Compute the pick rectangle if necessary.
            if (!pickRectangle) {
                pickPoint = this.navigatorState.convertPointToViewport(this.pickPoint, new Vec2(0, 0));
                pickRectangle = new Rectangle(
                    pickPoint[0] - apertureRadius,
                    pickPoint[1] - apertureRadius,
                    2 * apertureRadius,
                    2 * apertureRadius);
            }

            // Clamp the pick rectangle to the viewport.

            var xl = pickRectangle.x,
                xr = pickRectangle.x + pickRectangle.width,
                yb = pickRectangle.y,
                yt = pickRectangle.y + pickRectangle.height;

            if (xr < 0 || yt < 0 || xl > viewport.x + viewport.width || yb > viewport.y + viewport.height) {
                return false; // pick rectangle is outside the viewport.
            }

            pickRectangle.x = WWMath.clamp(xl, viewport.x, viewport.x + viewport.width);
            pickRectangle.y = WWMath.clamp(yb, viewport.y, viewport.y + viewport.height);
            pickRectangle.width = WWMath.clamp(xr, viewport.x, viewport.x + viewport.width) - pickRectangle.x;
            pickRectangle.height = WWMath.clamp(yt, viewport.y, viewport.y + viewport.height) - pickRectangle.y;
            this.pickRectangle = pickRectangle;

            // Compute the pick frustum.

            screenPoint[0] = pickRectangle.x;
            screenPoint[1] = pickRectangle.y;
            screenPoint[2] = 0;
            this.navigatorState.unProject(screenPoint, lln = new Vec3(0, 0, 0));

            screenPoint[0] = pickRectangle.x;
            screenPoint[1] = pickRectangle.y;
            screenPoint[2] = 1;
            this.navigatorState.unProject(screenPoint, llf = new Vec3(0, 0, 0));

            screenPoint[0] = pickRectangle.x + pickRectangle.width;
            screenPoint[1] = pickRectangle.y;
            screenPoint[2] = 0;
            this.navigatorState.unProject(screenPoint, lrn = new Vec3(0, 0, 0));

            screenPoint[0] = pickRectangle.x + pickRectangle.width;
            screenPoint[1] = pickRectangle.y;
            screenPoint[2] = 1;
            this.navigatorState.unProject(screenPoint, lrf = new Vec3(0, 0, 0));

            screenPoint[0] = pickRectangle.x;
            screenPoint[1] = pickRectangle.y + pickRectangle.height;
            screenPoint[2] = 0;
            this.navigatorState.unProject(screenPoint, uln = new Vec3(0, 0, 0));

            screenPoint[0] = pickRectangle.x;
            screenPoint[1] = pickRectangle.y + pickRectangle.height;
            screenPoint[2] = 1;
            this.navigatorState.unProject(screenPoint, ulf = new Vec3(0, 0, 0));

            screenPoint[0] = pickRectangle.x + pickRectangle.width;
            screenPoint[1] = pickRectangle.y + pickRectangle.height;
            screenPoint[2] = 0;
            this.navigatorState.unProject(screenPoint, urn = new Vec3(0, 0, 0));

            screenPoint[0] = pickRectangle.x + pickRectangle.width;
            screenPoint[1] = pickRectangle.y + pickRectangle.height;
            screenPoint[2] = 1;
            this.navigatorState.unProject(screenPoint, urf = new Vec3(0, 0, 0));

            va = new Vec3(ulf[0] - lln[0], ulf[1] - lln[1], ulf[2] - lln[2]);
            vb.set(uln[0] - llf[0], uln[1] - llf[1], uln[2] - llf[2]);
            nl = va.cross(vb);
            l = new Plane(nl[0], nl[1], nl[2], -nl.dot(lln));
            l.normalize();

            va = new Vec3(urn[0] - lrf[0], urn[1] - lrf[1], urn[2] - lrf[2]);
            vb.set(urf[0] - lrn[0], urf[1] - lrn[1], urf[2] - lrn[2]);
            nr = va.cross(vb);
            r = new Plane(nr[0], nr[1], nr[2], -nr.dot(lrn));
            r.normalize();

            va = new Vec3(ulf[0] - urn[0], ulf[1] - urn[1], ulf[2] - urn[2]);
            vb.set(urf[0] - uln[0], urf[1] - uln[1], urf[2] - uln[2]);
            nt = va.cross(vb);
            t = new Plane(nt[0], nt[1], nt[2], -nt.dot(uln));
            t.normalize();

            va = new Vec3(lrf[0] - lln[0], lrf[1] - lln[1], lrf[2] - lln[2]);
            vb.set(llf[0] - lrn[0], llf[1] - lrn[1], llf[2] - lrn[2]);
            nb = va.cross(vb);
            b = new Plane(nb[0], nb[1], nb[2], -nb.dot(lrn));
            b.normalize();

            va = new Vec3(uln[0] - lrn[0], uln[1] - lrn[1], uln[2] - lrn[2]);
            vb.set(urn[0] - lln[0], urn[1] - lln[1], urn[2] - lln[2]);
            nn = va.cross(vb);
            n = new Plane(nn[0], nn[1], nn[2], -nn.dot(lln));
            n.normalize();

            va = new Vec3(urf[0] - llf[0], urf[1] - llf[1], urf[2] - llf[2]);
            vb.set(ulf[0] - lrf[0], ulf[1] - lrf[1], ulf[2] - lrf[2]);
            nf = va.cross(vb);
            f = new Plane(nf[0], nf[1], nf[2], -nf.dot(llf));
            f.normalize();

            this.pickFrustum = new Frustum(l, r, b, t, n, f);

            return true;
        };

        /**
         * Indicates whether an extent is smaller than a specified number of pixels.
         * @param {BoundingBox} extent The extent to test.
         * @param {Number} numPixels The number of pixels below which the extent is considered small.
         * @returns {Boolean} True if the extent is smaller than the specified number of pixels, otherwise false.
         * Returns false if the extent is null or undefined.
         */
        DrawContext.prototype.isSmall = function (extent, numPixels) {
            if (!extent) {
                return false;
            }

            var distance = this.navigatorState.eyePoint.distanceTo(extent.center),
                pixelSize = this.navigatorState.pixelSizeAtDistance(distance);

            return (2 * extent.radius) < (numPixels * pixelSize); // extent diameter less than size of num pixels
        };

        /**
         * Returns the VBO ID of an array buffer containing a unit cube expressed as eight 3D vertices at (0, 1, 0),
         * (0, 0, 0), (1, 1, 0), (1, 0, 0), (0, 1, 1), (0, 0, 1), (1, 1, 1) and (1, 0, 1). The buffer is created on
         * first use and cached. Subsequent calls to this method return the cached buffer.
         * @returns {Object} The VBO ID identifying the array buffer.
         */
        DrawContext.prototype.unitCubeBuffer = function () {
            var vboId = this.gpuResourceCache.resourceForKey(DrawContext.unitCubeKey);

            if (!vboId) {
                var gl = this.currentGlContext,
                    points = new Float32Array(24),
                    i = 0;

                points[i++] = 0; // upper left corner, z = 0
                points[i++] = 1;
                points[i++] = 0;
                points[i++] = 0; // lower left corner, z = 0
                points[i++] = 0;
                points[i++] = 0;
                points[i++] = 1; // upper right corner, z = 0
                points[i++] = 1;
                points[i++] = 0;
                points[i++] = 1; // lower right corner, z = 0
                points[i++] = 0;
                points[i++] = 0;

                points[i++] = 0; // upper left corner, z = 1
                points[i++] = 1;
                points[i++] = 1;
                points[i++] = 0; // lower left corner, z = 1
                points[i++] = 0;
                points[i++] = 1;
                points[i++] = 1; // upper right corner, z = 1
                points[i++] = 1;
                points[i++] = 1;
                points[i++] = 1; // lower right corner, z = 1
                points[i++] = 0;
                points[i] = 1;

                vboId = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, vboId);
                gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);
                gl.bindBuffer(gl.ARRAY_BUFFER, null);
                this.frameStatistics.incrementVboLoadCount(1);

                this.gpuResourceCache.putResource(DrawContext.unitCubeKey, vboId, points.length * 4);
            }

            return vboId;
        };

        /**
         * Returns the VBO ID of a element array buffer containing the tessellation of a unit cube expressed as
         * a single buffer containing both triangle indices and line indices. This is intended for use in conjunction
         * with <code>unitCubeBuffer</code>. The unit cube's interior and outline may be rasterized as shown in the
         * following WebGL pseudocode:
         * <code><pre>
         * // Assumes that the VBO returned by unitCubeBuffer is used as the source of vertex positions.
         * bindBuffer(ELEMENT_ARRAY_BUFFER, drawContext.unitCubeElements());
         * drawElements(TRIANGLES, 36, UNSIGNED_SHORT, 0); // draw the unit cube interior
         * drawElements(LINES, 24, UNSIGNED_SHORT, 72); // draw the unit cube outline
         * </pre></code>
         * The buffer is created on first use
         * and cached. Subsequent calls to this method return the cached buffer.
         * @returns {Object} The VBO ID identifying the element array buffer.
         */
        DrawContext.prototype.unitCubeElements = function () {
            var vboId = this.gpuResourceCache.resourceForKey(DrawContext.unitCubeElementsKey);

            if (!vboId) {
                var gl = this.currentGlContext,
                    elems = new Int16Array(60),
                    i = 0;

                // interior

                elems[i++] = 1; // -z face
                elems[i++] = 0;
                elems[i++] = 3;
                elems[i++] = 3;
                elems[i++] = 0;
                elems[i++] = 2;

                elems[i++] = 4; // +z face
                elems[i++] = 5;
                elems[i++] = 6;
                elems[i++] = 6;
                elems[i++] = 5;
                elems[i++] = 7;

                elems[i++] = 5; // -y face
                elems[i++] = 1;
                elems[i++] = 7;
                elems[i++] = 7;
                elems[i++] = 1;
                elems[i++] = 3;

                elems[i++] = 6; // +y face
                elems[i++] = 2;
                elems[i++] = 4;
                elems[i++] = 4;
                elems[i++] = 2;
                elems[i++] = 0;

                elems[i++] = 4; // -x face
                elems[i++] = 0;
                elems[i++] = 5;
                elems[i++] = 5;
                elems[i++] = 0;
                elems[i++] = 1;

                elems[i++] = 7; // +x face
                elems[i++] = 3;
                elems[i++] = 6;
                elems[i++] = 6;
                elems[i++] = 3;
                elems[i++] = 2;

                // outline

                elems[i++] = 0; // left, -z
                elems[i++] = 1;
                elems[i++] = 1; // bottom, -z
                elems[i++] = 3;
                elems[i++] = 3; // right, -z
                elems[i++] = 2;
                elems[i++] = 2; // top, -z
                elems[i++] = 0;

                elems[i++] = 4; // left, +z
                elems[i++] = 5;
                elems[i++] = 5; // bottom, +z
                elems[i++] = 7;
                elems[i++] = 7; // right, +z
                elems[i++] = 6;
                elems[i++] = 6; // top, +z
                elems[i++] = 4;

                elems[i++] = 0; // upper left
                elems[i++] = 4;
                elems[i++] = 5; // lower left
                elems[i++] = 1;
                elems[i++] = 2; // upper right
                elems[i++] = 6;
                elems[i++] = 7; // lower right
                elems[i] = 3;

                vboId = gl.createBuffer();
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vboId);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, elems, gl.STATIC_DRAW);
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
                this.frameStatistics.incrementVboLoadCount(1);

                this.gpuResourceCache.putResource(DrawContext.unitCubeElementsKey, vboId, elems.length * 2);
            }

            return vboId;
        };

        /**
         * Returns the VBO ID of a buffer containing a unit quadrilateral expressed as four 2D vertices at (0, 1),
         * (0, 0), (1, 1) and (1, 0). The four vertices are in the order required by a triangle strip. The buffer is
         * created on first use and cached. Subsequent calls to this method return the cached buffer.
         * @returns {Object} The VBO ID identifying the vertex buffer.
         */
        DrawContext.prototype.unitQuadBuffer = function () {
            var vboId = this.gpuResourceCache.resourceForKey(DrawContext.unitQuadKey);

            if (!vboId) {
                var gl = this.currentGlContext,
                    points = new Float32Array(8);

                points[0] = 0; // upper left corner
                points[1] = 1;
                points[2] = 0; // lower left corner
                points[3] = 0;
                points[4] = 1; // upper right corner
                points[5] = 1;
                points[6] = 1; // lower right corner
                points[7] = 0;

                vboId = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, vboId);
                gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);
                gl.bindBuffer(gl.ARRAY_BUFFER, null);
                this.frameStatistics.incrementVboLoadCount(1);

                this.gpuResourceCache.putResource(DrawContext.unitQuadKey, vboId, points.length * 4);
            }

            return vboId;
        };

        /**
         * Returns the VBO ID of a buffer containing a unit quadrilateral expressed as four 3D vertices at (0, 1, 0),
         * (0, 0, 0), (1, 1, 0) and (1, 0, 0).
         * The four vertices are in the order required by a triangle strip. The buffer is created
         * on first use and cached. Subsequent calls to this method return the cached buffer.
         * @returns {Object} The VBO ID identifying the vertex buffer.
         */
        DrawContext.prototype.unitQuadBuffer3 = function () {
            var vboId = this.gpuResourceCache.resourceForKey(DrawContext.unitQuadKey3);

            if (!vboId) {
                var gl = this.currentGlContext,
                    points = new Float32Array(12);

                points[0] = 0; // upper left corner
                points[1] = 1;
                points[2] = 0;
                points[3] = 0; // lower left corner
                points[4] = 0;
                points[5] = 0;
                points[6] = 1; // upper right corner
                points[7] = 1;
                points[8] = 0;
                points[9] = 1; // lower right corner
                points[10] = 0;
                points[11] = 0;

                vboId = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, vboId);
                gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);
                gl.bindBuffer(gl.ARRAY_BUFFER, null);
                this.frameStatistics.incrementVboLoadCount(1);

                this.gpuResourceCache.putResource(DrawContext.unitQuadKey3, vboId, points.length * 4);
            }

            return vboId;
        };

        /**
         * Computes a Cartesian point at a location on the surface of this terrain according to a specified
         * altitude mode. If there is no current terrain, this function approximates the returned point by assuming
         * the terrain is the globe's ellipsoid.
         * @param {Number} latitude The location's latitude.
         * @param {Number} longitude The location's longitude.
         * @param {Number} offset Distance above the terrain, in meters relative to the specified altitude mode, at
         * which to compute the point.
         * @param {String} altitudeMode The altitude mode to use to compute the point. Recognized values are
         * WorldWind.ABSOLUTE, WorldWind.CLAMP_TO_GROUND and
         * WorldWind.RELATIVE_TO_GROUND. The mode WorldWind.ABSOLUTE is used if the
         * specified mode is null, undefined or unrecognized, or if the specified location is outside this terrain.
         * @param {Vec3} result A pre-allocated Vec3 in which to return the computed point.
         * @returns {Vec3} The specified result parameter, set to the coordinates of the computed point.
         * @throws {ArgumentError} If the specified result argument is null or undefined.
         */
        DrawContext.prototype.surfacePointForMode = function (latitude, longitude, offset, altitudeMode, result) {
            if (!result) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "DrawContext", "surfacePointForMode", "missingResult"));
            }

            if (this.terrain) {
                this.terrain.surfacePointForMode(latitude, longitude, offset, altitudeMode, result);
            } else {
                var h = offset + this.globe.elevationAtLocation(latitude, longitude) * this.verticalExaggeration;
                this.globe.computePointFromPosition(latitude, longitude, h, result);
            }

            return result;
        };

        return DrawContext;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2015 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports FramebufferTexture
 * @version $Id: FramebufferTexture.js 3345 2015-07-28 20:28:35Z dcollins $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(1),
        __webpack_require__(0),
        __webpack_require__(4)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
              Logger) {
        "use strict";

        /**
         * Constructs a framebuffer texture with the specified dimensions and an optional depth buffer. Use the
         * [DrawContext.bindFramebuffer]{@link DrawContext#bindFramebuffer} function to make the program current during rendering.
         *
         * @alias FramebufferTexture
         * @constructor
         * @classdesc Represents an off-screen WebGL framebuffer. The framebuffer has color buffer stored in a 32
         * bit RGBA texture, and has an optional depth buffer of at least 16 bits. Applications typically do not
         * interact with this class. WebGL framebuffers are created by instances of this class and made current when the
         * DrawContext.bindFramebuffer function is invoked.
         * @param {WebGLRenderingContext} gl The current WebGL rendering context.
         * @param {Number} width The width of the framebuffer, in pixels.
         * @param {Number} height The height of the framebuffer, in pixels.
         * @param {Boolean} depth true to configure the framebuffer with a depth buffer of at least 16 bits, false to
         * disable depth buffering.
         * @throws {ArgumentError} If the specified draw context is null or undefined, or if the width or height is less
         * than zero.
         */
        var FramebufferTexture = function (gl, width, height, depth) {
            if (!gl) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "FramebufferTexture", "constructor",
                    "missingGlContext"));
            }

            if (width < 0 || height < 0) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "FramebufferTexture", "constructor",
                    "The framebuffer width or height is less than zero."));
            }

            /**
             * The width of this framebuffer, in pixels.
             * @type {Number}
             * @readonly
             */
            this.width = width;

            /**
             * The height of this framebuffer, in pixels.
             * @type {Number}
             * @readonly
             */
            this.height = height;

            /**
             * Indicates whether or not this framebuffer has a depth buffer.
             * @type {Boolean}
             * @readonly
             */
            this.depth = depth;

            /**
             * Indicates the size of this framebuffer's WebGL resources, in bytes.
             * @type {Number}
             * @readonly
             */
            this.size = (width * height * 4) + (depth ? width * height * 2 : 0);

            /**
             * Indicates the WebGL framebuffer object object associated with this framebuffer texture.
             * @type {WebGLFramebuffer}
             * @readonly
             */
            this.framebufferId = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebufferId);

            // Internal. Intentionally not documented. Configure this framebuffer's color buffer.
            this.texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, this.texture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER,
                gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER,
                gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S,
                gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T,
                gl.CLAMP_TO_EDGE);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0,
                gl.RGBA, gl.UNSIGNED_BYTE, null);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0,
                gl.TEXTURE_2D, this.texture, 0);

            // Internal. Intentionally not documented. Configure this framebuffer's optional depth buffer.
            this.depthBuffer = null;
            if (depth) {
                this.depthBuffer = gl.createRenderbuffer();
                gl.bindRenderbuffer(gl.RENDERBUFFER, this.depthBuffer);
                gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16,
                    width, height);
                gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT,
                    gl.RENDERBUFFER, this.depthBuffer);
            }

            var e = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
            if (e != gl.FRAMEBUFFER_COMPLETE) {
                Logger.logMessage(Logger.LEVEL_WARNING, "FramebufferTexture", "constructor",
                    "Error creating framebuffer: " + e);
                this.framebufferId = null;
                this.texture = null;
                this.depthBuffer = null;
            }

            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.bindRenderbuffer(gl.RENDERBUFFER, null);
            gl.bindTexture(gl.TEXTURE_2D, null);
        };

        /**
         * Binds this off-screen framebuffer's texture in the current WebGL graphics context. This texture contains
         * color fragments resulting from WebGL operations executed when this framebuffer is bound by a call to
         * [FramebufferTexture.bindFramebuffer]{@link FramebufferTexture#bindFramebuffer}.
         *
         * @param {DrawContext} dc The current draw context.
         * @returns {Boolean} true if this framebuffer's texture was bound successfully, otherwise false.
         */
        FramebufferTexture.prototype.bind = function (dc) {
            if (this.texture) {
                dc.currentGlContext.bindTexture(gl.TEXTURE_2D, this.texture);
            }

            return !!this.texture;
        };

        return FramebufferTexture;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports Renderable
 * @version $Id: Renderable.js 2951 2015-03-31 23:31:08Z tgaskins $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(0),
        __webpack_require__(17)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Logger,
              UnsupportedOperationError) {
        "use strict";

        /**
         * Constructs a base renderable.
         * @alias Renderable
         * @constructor
         * @classdesc Represents a shape or other object that can be rendered. This is an abstract class and is not
         * meant to be instantiated directly.
         */
        var Renderable = function () {

            /**
             * The display name of the renderable.
             * @type {String}
             * @default "Renderable"
             */
            this.displayName = "Renderable";

            /**
             * Indicates whether to display this renderable.
             * @type {Boolean}
             * @default true
             */
            this.enabled = true;

            /**
             * Indicates the object to return as the userObject of this shape when picked. If null,
             * then this shape is returned as the userObject.
             * @type {Object}
             * @default null
             * @see  [PickedObject.userObject]{@link PickedObject#userObject}
             */
            this.pickDelegate = null;

            /**
             * An application defined object associated with this renderable. A typical use case is to associate
             * application defined data with a picked renderable.
             * @type {Object}
             * @default An empty object
             */
            this.userProperties = {};
        };

        /**
         * Render this renderable. Some shapes actually draw themselves during this call, others only add themselves
         * to the draw context's ordered rendering list for subsequent drawing when their renderOrdered method is called.
         * This method is intended to be called by layers such as {@link RenderableLayer} and not by applications.
         * @param {DrawContext} dc The current draw context.
         */
        Renderable.prototype.render = function (dc) {
            throw new UnsupportedOperationError(
                Logger.logMessage(Logger.LEVEL_SEVERE, "Renderable", "render", "abstractInvocation"));
        };

        return Renderable;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports AtmosphereProgram
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(1),
        __webpack_require__(11),
        __webpack_require__(0)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
              GpuProgram,
              Logger) {
        "use strict";

        /**
         * Constructs a new program.
         * Initializes, compiles and links this GLSL program with the source code for its vertex and fragment shaders.
         * <p>
         * This method creates WebGL shaders for the program's shader sources and attaches them to a new GLSL program.
         * This method then compiles the shaders and then links the program if compilation is successful.
         *
         * @alias AtmosphereProgram
         * @constructor
         * @augments GpuProgram
         * @classdesc AtmosphereProgram is a GLSL program that draws the atmosphere.
         * @param {WebGLRenderingContext} gl The current WebGL context.
         * @throws {ArgumentError} If the shaders cannot be compiled, or linking of
         * the compiled shaders into a program fails.
         */
        var AtmosphereProgram = function (gl, vertexShaderSource, fragmentShaderSource, attribute) {

            // Call to the superclass, which performs shader program compiling and linking.
            GpuProgram.call(this, gl, vertexShaderSource, fragmentShaderSource, attribute);


            // Frag color mode indicates the atmospheric scattering color components written to the fragment color.
            this.FRAGMODE_SKY = 1;
            this.FRAGMODE_GROUND_PRIMARY = 2;
            this.FRAGMODE_GROUND_SECONDARY = 3;
            this.FRAGMODE_GROUND_PRIMARY_TEX_BLEND = 4;

            /**
             * The globe's atmosphere altitude.
             * @type {Number}
             * @default 160000.0 meters
             */
            this.altitude = 160000;

            /**
             * This atmosphere's Rayleigh scale depth.
             * @type {Number}
             * @default 0.25
             */
            this.rayleighScaleDepth = 0.25;

            /**
             * The WebGL location for this program's 'fragMode' uniform.
             * @type {WebGLUniformLocation}
             * @readonly
             */
            this.fragModeLocation = this.uniformLocation(gl, "fragMode");

            /**
             * The WebGL location for this program's 'mvpMatrix' uniform.
             * @type {WebGLUniformLocation}
             * @readonly
             */
            this.mvpMatrixLocation = this.uniformLocation(gl, "mvpMatrix");

            /**
             * The WebGL location for this program's 'texCoordMatrix' uniform.
             * @type {WebGLUniformLocation}
             * @readonly
             */
            this.texCoordMatrixLocation = this.uniformLocation(gl, "texCoordMatrix");

            /**
             * The WebGL location for this program's 'vertexOrigin' uniform.
             * @type {WebGLUniformLocation}
             * @readonly
             */
            this.vertexOriginLocation = this.uniformLocation(gl, "vertexOrigin");

            /**
             * The WebGL location for this program's 'eyePoint' uniform.
             * @type {WebGLUniformLocation}
             * @readonly
             */
            this.eyePointLocation = this.uniformLocation(gl, "eyePoint");

            /**
             * The WebGL location for this program's 'eyeMagnitude' uniform.
             * @type {WebGLUniformLocation}
             * @readonly
             */
            this.eyeMagnitudeLocation = this.uniformLocation(gl, "eyeMagnitude");

            /**
             * The WebGL location for this program's 'eyeMagnitude2' uniform.
             * @type {WebGLUniformLocation}
             * @readonly
             */
            this.eyeMagnitude2Location = this.uniformLocation(gl, "eyeMagnitude2");

            /**
             * The WebGL location for this program's 'lightDirection' uniform.
             * @type {WebGLUniformLocation}
             * @readonly
             */
            this.lightDirectionLocation = this.uniformLocation(gl, "lightDirection");

            /**
             * The WebGL location for this program's 'atmosphereRadius' uniform.
             * @type {WebGLUniformLocation}
             * @readonly
             */
            this.atmosphereRadiusLocation = this.uniformLocation(gl, "atmosphereRadius");

            /**
             * The WebGL location for this program's 'atmosphereRadius2' uniform.
             * @type {WebGLUniformLocation}
             * @readonly
             */
            this.atmosphereRadius2Location = this.uniformLocation(gl, "atmosphereRadius2");

            /**
             * The WebGL location for this program's 'globeRadius' uniform.
             * @type {WebGLUniformLocation}
             * @readonly
             */
            this.globeRadiusLocation = this.uniformLocation(gl, "globeRadius");

            /**
             * The WebGL location for this program's 'scale' uniform.
             * @type {WebGLUniformLocation}
             * @readonly
             */
            this.scaleLocation = this.uniformLocation(gl, "scale");

            /**
             * The WebGL location for this program's 'scaleDepth' uniform.
             * @type {WebGLUniformLocation}
             * @readonly
             */
            this.scaleDepthLocation = this.uniformLocation(gl, "scaleDepth");

            /**
             * The WebGL location for this program's 'scaleOverScaleDepth' uniform.
             * @type {WebGLUniformLocation}
             * @readonly
             */
            this.scaleOverScaleDepthLocation = this.uniformLocation(gl, "scaleOverScaleDepth");
            
            this.scratchArray9 = new Float32Array(9);
        };

        /**
         * A string that uniquely identifies this program.
         * @type {string}
         * @readonly
         */
        AtmosphereProgram.key = "WorldWindGpuAtmosphereProgram";

        // Inherit from GpuProgram.
        AtmosphereProgram.prototype = Object.create(GpuProgram.prototype);

        /**
         * Returns the atmosphere's altitude.
         * @returns {Number} The atmosphere's altitude in meters.
         */
        AtmosphereProgram.prototype.getAltitude = function () {
            return this.altitude;
        };

        /**
         * Loads the specified number as the value of this program's 'fragMode' uniform variable.
         *
         * @param {WebGLRenderingContext} gl The current WebGL context.
         * @param {Number} fragMode The frag mode value.
         * @throws {ArgumentError} If the specified number is null or undefined.
         */
        AtmosphereProgram.prototype.loadFragMode = function (gl, fragMode) {
            if (!fragMode) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "AtmosphereProgram", "loadFragMode", "missingFragMode"));
            }

            gl.uniform1i(this.fragModeLocation, fragMode);
        };

        /**
         * Loads the specified matrix as the value of this program's 'mvpMatrix' uniform variable.
         *
         * @param {WebGLRenderingContext} gl The current WebGL context.
         * @param {Matrix} matrix The matrix to load.
         * @throws {ArgumentError} If the specified matrix is null or undefined.
         */
        AtmosphereProgram.prototype.loadModelviewProjection = function (gl, matrix) {
            if (!matrix) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "AtmosphereProgram", "loadModelviewProjection",
                        "missingMatrix"));
            }

            this.loadUniformMatrix(gl, matrix, this.mvpMatrixLocation);
        };

        /**
         * Loads the specified vector as the value of this program's 'vertexOrigin' uniform variable.
         *
         * @param {WebGLRenderingContext} gl The current WebGL context.
         * @param {Vec3} vector The vector to load.
         * @throws {ArgumentError} If the specified vector is null or undefined.
         */
        AtmosphereProgram.prototype.loadVertexOrigin = function (gl, vector) {
            if (!vector) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "AtmosphereProgram", "loadVertexOrigin", "missingVector"));
            }

            gl.uniform3f(this.vertexOriginLocation, vector[0], vector[1], vector[2]);
        };

        /**
         * Loads the specified vector as the value of this program's 'lightDirection' uniform variable.
         *
         * @param {WebGLRenderingContext} gl The current WebGL context.
         * @param {Vec3} vector The vector to load.
         * @throws {ArgumentError} If the specified vector is null or undefined.
         */
        AtmosphereProgram.prototype.loadLightDirection = function (gl, vector) {
            if (!vector) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "AtmosphereProgram", "loadLightDirection", "missingVector"));
            }

            gl.uniform3f(this.lightDirectionLocation, vector[0], vector[1], vector[2]);
        };

        /**
         * Loads the specified vector as the value of this program's 'lightDirection' uniform variable,
         * the magnitude's specified vector as the value of this program's 'eyeMagnitude' uniform variable and
         * the squared magnitude's specified vector as the value of this program's 'eyeMagnitude2' uniform variable.
         *
         * @param {WebGLRenderingContext} gl The current WebGL context.
         * @param {Vec3} vector The vector to load.
         * @throws {ArgumentError} If the specified vector is null or undefined.
         */
        AtmosphereProgram.prototype.loadEyePoint = function (gl, vector) {
            if (!vector) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "AtmosphereProgram", "loadEyePoint", "missingVector"));
            }

            gl.uniform3f(this.eyePointLocation, vector[0], vector[1], vector[2]);
            gl.uniform1f(this.eyeMagnitudeLocation, vector.magnitude());
            gl.uniform1f(this.eyeMagnitude2Location, vector.magnitudeSquared());
        };

        /**
         * Loads the specified number as the value of this program's 'globeRadius' uniform variable and the specified
         * number which add the altitude value as the value of this program's 'atmosphereRadius' uniform variable.
         *
         * @param {WebGLRenderingContext} gl The current WebGL context.
         * @param {Number} globeRadius The globe radius value.
         * @throws {ArgumentError} If the specified number is null or undefined.
         */
        AtmosphereProgram.prototype.loadGlobeRadius = function (gl, globeRadius) {
            if (!globeRadius) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "AtmosphereProgram", "loadGlobeRadius",
                        "missingGlobeRadius"));
            }

            var gr = globeRadius;
            var ar = gr + this.altitude;

            gl.uniform1f(this.globeRadiusLocation, gr);
            gl.uniform1f(this.atmosphereRadiusLocation, ar);
            gl.uniform1f(this.atmosphereRadius2Location, ar * ar);
        };

        /**
         * Sets the program's 'scale', 'scaleDepth' and 'scaleOverScaleDepth' uniform variables.
         *
         * @param {WebGLRenderingContext} gl The current WebGL context.
         */
        AtmosphereProgram.prototype.setScale = function (gl) {
            gl.uniform1f(this.scaleLocation, 1 / this.getAltitude());
            gl.uniform1f(this.scaleDepthLocation, this.rayleighScaleDepth);
            gl.uniform1f(this.scaleOverScaleDepthLocation, (1 / this.getAltitude()) / this.rayleighScaleDepth);
        };

        /**
         * Loads the specified matrix as the value of this program's 'texCoordMatrix' uniform variable.
         * @param {WebGLRenderingContext} gl The current WebGL context.
         * @param {Matrix3} matrix The texture coordinate matrix.
         */
        AtmosphereProgram.prototype.loadTexMatrix = function(gl, matrix){
            if (!matrix) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "AtmosphereProgram", "loadTexMatrix",
                        "missingMatrix"));
            }

            matrix.columnMajorComponents(this.scratchArray9);
            gl.uniformMatrix3fv(this.texCoordMatrixLocation, false, this.scratchArray9);
        };

        return AtmosphereProgram;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports BasicProgram
 * @version $Id: BasicProgram.js 3327 2015-07-21 19:03:39Z dcollins $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(1),
        __webpack_require__(8),
        __webpack_require__(11),
        __webpack_require__(0)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
              Color,
              GpuProgram,
              Logger) {
        "use strict";

        /**
         * Constructs a new program.
         * Initializes, compiles and links this GLSL program with the source code for its vertex and fragment shaders.
         * <p>
         * This method creates WebGL shaders for the program's shader sources and attaches them to a new GLSL program. This
         * method then compiles the shaders and then links the program if compilation is successful. Use the bind method to make the
         * program current during rendering.
         *
         * @alias BasicProgram
         * @constructor
         * @augments GpuProgram
         * @classdesc BasicProgram is a GLSL program that draws geometry in a solid color.
         * @param {WebGLRenderingContext} gl The current WebGL context.
         * @throws {ArgumentError} If the shaders cannot be compiled, or linking of
         * the compiled shaders into a program fails.
         */
        var BasicProgram = function (gl) {
            var vertexShaderSource =
                    'attribute vec4 vertexPoint;\n' +
                    'uniform mat4 mvpMatrix;\n' +
                    'void main() {gl_Position = mvpMatrix * vertexPoint;}',
                fragmentShaderSource =
                    'precision mediump float;\n' +
                    'uniform vec4 color;\n' +
                    'void main() {gl_FragColor = color;}';

            // Call to the superclass, which performs shader program compiling and linking.
            GpuProgram.call(this, gl, vertexShaderSource, fragmentShaderSource);

            /**
             * The WebGL location for this program's 'vertexPoint' attribute.
             * @type {Number}
             * @readonly
             */
            this.vertexPointLocation = this.attributeLocation(gl, "vertexPoint");

            /**
             * The WebGL location for this program's 'mvpMatrix' uniform.
             * @type {WebGLUniformLocation}
             * @readonly
             */
            this.mvpMatrixLocation = this.uniformLocation(gl, "mvpMatrix");

            /**
             * The WebGL location for this program's 'color' uniform.
             * @type {WebGLUniformLocation}
             * @readonly
             */
            this.colorLocation = this.uniformLocation(gl, "color");
        };

        /**
         * A string that uniquely identifies this program.
         * @type {string}
         * @readonly
         */
        BasicProgram.key = "WorldWindGpuBasicProgram";

        // Inherit from GpuProgram.
        BasicProgram.prototype = Object.create(GpuProgram.prototype);

        /**
         * Loads the specified matrix as the value of this program's 'mvpMatrix' uniform variable.
         *
         * @param {WebGLRenderingContext} gl The current WebGL context.
         * @param {Matrix} matrix The matrix to load.
         * @throws {ArgumentError} If the specified matrix is null or undefined.
         */
        BasicProgram.prototype.loadModelviewProjection = function (gl, matrix) {
            if (!matrix) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "BasicProgram", "loadModelviewProjection", "missingMatrix"));
            }

            this.loadUniformMatrix(gl, matrix, this.mvpMatrixLocation);
        };

        /**
         * Loads the specified color as the value of this program's 'color' uniform variable.
         *
         * @param {WebGLRenderingContext} gl The current WebGL context.
         * @param {Color} color The color to load.
         * @throws {ArgumentError} If the specified color is null or undefined.
         */
        BasicProgram.prototype.loadColor = function (gl, color) {
            if (!color) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "BasicProgram", "loadColor", "missingColor"));
            }

            this.loadUniformColor(gl, color, this.colorLocation);
        };

        /**
         * Loads the specified RGBA color components as the value of this program's 'color' uniform variable.
         *
         * @param {WebGLRenderingContext} gl The current WebGL context.
         * @param {Number} red The red component, a number between 0 and 1.
         * @param {Number} green The green component, a number between 0 and 1.
         * @param {Number} blue The blue component, a number between 0 and 1.
         * @param {Number} alpha The alpha component, a number between 0 and 1.
         */
        BasicProgram.prototype.loadColorComponents = function (gl, red, green, blue, alpha) {
            this.loadUniformColorComponents(gl, red, green, blue, alpha, this.colorLocation);
        };

        return BasicProgram;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports BasicTextureProgram
 * @version $Id: BasicTextureProgram.js 3327 2015-07-21 19:03:39Z dcollins $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(1),
        __webpack_require__(8),
        __webpack_require__(11),
        __webpack_require__(0)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
              Color,
              GpuProgram,
              Logger) {
        "use strict";

        /**
         * Constructs a new program.
         * Initializes, compiles and links this GLSL program with the source code for its vertex and fragment shaders.
         * <p>
         * This method creates WebGL shaders for the program's shader sources and attaches them to a new GLSL program. This
         * method then compiles the shaders and then links the program if compilation is successful. Use the bind method to make the
         * program current during rendering.
         *
         * @alias BasicTextureProgram
         * @constructor
         * @augments GpuProgram
         * @classdesc BasicTextureProgram is a GLSL program that draws textured or untextured geometry.
         * @param {WebGLRenderingContext} gl The current WebGL context.
         * @throws {ArgumentError} If the shaders cannot be compiled, or if linking of
         * the compiled shaders into a program fails.
         */
        var BasicTextureProgram = function (gl) {
            var vertexShaderSource =
                    'attribute vec4 vertexPoint;\n' +
                    'attribute vec4 vertexTexCoord;\n' +
                    'attribute vec4 normalVector;\n' +
                    'uniform mat4 mvpMatrix;\n' +
                    'uniform mat4 mvInverseMatrix;\n' +
                    'uniform mat4 texCoordMatrix;\n' +
                    'uniform bool applyLighting;\n' +
                    'varying vec2 texCoord;\n' +
                    'varying vec4 normal;\n' +
                    'void main() {gl_Position = mvpMatrix * vertexPoint;\n' +
                    'texCoord = (texCoordMatrix * vertexTexCoord).st;\n' +
                    'if (applyLighting) {normal = mvInverseMatrix * normalVector;}\n' +
                    '}',
                fragmentShaderSource =
                    'precision mediump float;\n' +
                    'uniform float opacity;\n' +
                    'uniform vec4 color;\n' +
                    'uniform bool enableTexture;\n' +
                    'uniform bool modulateColor;\n' +
                    'uniform sampler2D textureSampler;\n' +
                    'uniform bool applyLighting;\n' +
                    'varying vec2 texCoord;\n' +
                    'varying vec4 normal;\n' +
                    'void main() {\n' +
                    'vec4 textureColor = texture2D(textureSampler, texCoord);\n' +
                    'float ambient = 0.15; vec4 lightDirection = vec4(0, 0, 1, 0);\n' +
                    'if (enableTexture && !modulateColor)\n' +
                    '    gl_FragColor = textureColor * color * opacity;\n' +
                    'else if (enableTexture && modulateColor)\n' +
                    '    gl_FragColor = color * floor(textureColor.a + 0.5);\n' +
                    'else\n' +
                    '    gl_FragColor = color * opacity;\n' +
                    'if (gl_FragColor.a == 0.0) {discard;}\n' +
                    'if (applyLighting) {\n' +
                    '    vec4 n = normal * (gl_FrontFacing ? 1.0 : -1.0);\n' +
                    '    gl_FragColor.rgb *= clamp(ambient + dot(lightDirection, n), 0.0, 1.0);\n' +
                    '}\n' +
                    '}';

            // Specify bindings to avoid the WebGL performance warning that's generated when normalVector gets
            // bound to location 0.
            var bindings = ["vertexPoint", "normalVector", "vertexTexCoord"];

            // Call to the superclass, which performs shader program compiling and linking.
            GpuProgram.call(this, gl, vertexShaderSource, fragmentShaderSource, bindings);

            /**
             * The WebGL location for this program's 'vertexPoint' attribute.
             * @type {Number}
             * @readonly
             */
            this.vertexPointLocation = this.attributeLocation(gl, "vertexPoint");

            /**
             * The WebGL location for this program's 'normalVector' attribute.
             * @type {Number}
             * @readonly
             */
            this.normalVectorLocation = this.attributeLocation(gl, "normalVector");

            /**
             * The WebGL location for this program's 'vertexTexCoord' attribute.
             * @type {Number}
             * @readonly
             */
            this.vertexTexCoordLocation = this.attributeLocation(gl, "vertexTexCoord");

            /**
             * The WebGL location for this program's 'mvpMatrix' uniform.
             * @type {WebGLUniformLocation}
             * @readonly
             */
            this.mvpMatrixLocation = this.uniformLocation(gl, "mvpMatrix");

            /**
             * The WebGL location for this program's 'mvInverseMatrix' uniform.
             * @type {WebGLUniformLocation}
             * @readonly
             */
            this.mvInverseMatrixLocation = this.uniformLocation(gl, "mvInverseMatrix");

            /**
             * The WebGL location for this program's 'color' uniform.
             * @type {WebGLUniformLocation}
             * @readonly
             */
            this.colorLocation = this.uniformLocation(gl, "color");

            /**
             * The WebGL location for this program's 'enableTexture' uniform.
             * @type {WebGLUniformLocation}
             * @readonly
             */
            this.textureEnabledLocation = this.uniformLocation(gl, "enableTexture");

            /**
             * The WebGL location for this program's 'modulateColor' uniform.
             * @type {WebGLUniformLocation}
             * @readonly
             */
            this.modulateColorLocation = this.uniformLocation(gl, "modulateColor");

            /**
             * The WebGL location for this program's 'textureSampler' uniform.
             * @type {WebGLUniformLocation}
             * @readonly
             */
            this.textureUnitLocation = this.uniformLocation(gl, "textureSampler");

            /**
             * The WebGL location for this program's 'texCoordMatrix' uniform.
             * @type {WebGLUniformLocation}
             * @readonly
             */
            this.textureMatrixLocation = this.uniformLocation(gl, "texCoordMatrix");

            /**
             * The WebGL location for this program's 'opacity' uniform.
             * @type {WebGLUniformLocation}
             * @readonly
             */
            this.opacityLocation = this.uniformLocation(gl, "opacity");

            /**
             * The WegGL location for this program's 'enableLighting' uniform.
             * @type {WebGLUniformLocation}
             * @readonly
             */
            this.applyLightingLocation = this.uniformLocation(gl, "applyLighting");
        };

        /**
         * A string that uniquely identifies this program.
         * @type {string}
         * @readonly
         */
        BasicTextureProgram.key = "WorldWindGpuBasicTextureProgram";

        // Inherit from GpuProgram.
        BasicTextureProgram.prototype = Object.create(GpuProgram.prototype);

        /**
         * Loads the specified matrix as the value of this program's 'mvInverseMatrix' uniform variable.
         *
         * @param {WebGLRenderingContext} gl The current WebGL context.
         * @param {Matrix} matrix The matrix to load.
         * @throws {ArgumentError} If the specified matrix is null or undefined.
         */
        BasicTextureProgram.prototype.loadModelviewInverse = function (gl, matrix) {
            if (!matrix) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "BasicTextureProgram", "loadModelviewInverse", "missingMatrix"));
            }

            this.loadUniformMatrix(gl, matrix, this.mvInverseMatrixLocation);
        };

        /**
         * Loads the specified matrix as the value of this program's 'mvpMatrix' uniform variable.
         *
         * @param {WebGLRenderingContext} gl The current WebGL context.
         * @param {Matrix} matrix The matrix to load.
         * @throws {ArgumentError} If the specified matrix is null or undefined.
         */
        BasicTextureProgram.prototype.loadModelviewProjection = function (gl, matrix) {
            if (!matrix) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "BasicTextureProgram", "loadModelviewProjection", "missingMatrix"));
            }

            this.loadUniformMatrix(gl, matrix, this.mvpMatrixLocation);
        };

        /**
         * Loads the specified color as the value of this program's 'color' uniform variable.
         *
         * @param {WebGLRenderingContext} gl The current WebGL context.
         * @param {Color} color The color to load.
         * @throws {ArgumentError} If the specified color is null or undefined.
         */
        BasicTextureProgram.prototype.loadColor = function (gl, color) {
            if (!color) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "BasicTextureProgram", "loadColor", "missingColor"));
            }

            this.loadUniformColor(gl, color, this.colorLocation);
        };

        /**
         * Loads the specified boolean as the value of this program's 'enableTexture' uniform variable.
         * @param {WebGLRenderingContext} gl The current WebGL context.
         * @param {Boolean} enable true to enable texturing, false to disable texturing.
         */
        BasicTextureProgram.prototype.loadTextureEnabled = function (gl, enable) {
            gl.uniform1i(this.textureEnabledLocation, enable ? 1 : 0);
        };

        /**
         * Loads the specified boolean as the value of this program's 'modulateColor' uniform variable. When this
         * value is true and the value of the textureEnabled variable is true, the color uniform of this shader is
         * multiplied by the rounded alpha component of the texture color at each fragment. This causes the color
         * to be either fully opaque or fully transparent depending on the value of the texture color's alpha value.
         * This is used during picking to replace opaque or mostly opaque texture colors with the pick color, and
         * to make all other texture colors transparent.
         * @param {WebGLRenderingContext} gl The current WebGL context.
         * @param {Boolean} enable true to enable modulation, false to disable modulation.
         */
        BasicTextureProgram.prototype.loadModulateColor = function (gl, enable) {
            gl.uniform1i(this.modulateColorLocation, enable ? 1 : 0);
        };

        /**
         * Loads the specified number as the value of this program's 'textureSampler' uniform variable.
         * @param {WebGLRenderingContext} gl The current WebGL context.
         * @param {Number} unit The texture unit.
         */
        BasicTextureProgram.prototype.loadTextureUnit = function (gl, unit) {
            gl.uniform1i(this.textureUnitLocation, unit - gl.TEXTURE0);
        };

        /**
         * Loads the specified matrix as the value of this program's 'texCoordMatrix' uniform variable.
         * @param {WebGLRenderingContext} gl The current WebGL context.
         * @param {Matrix} matrix The texture coordinate matrix.
         */
        BasicTextureProgram.prototype.loadTextureMatrix = function (gl, matrix) {
            this.loadUniformMatrix(gl, matrix, this.textureMatrixLocation);
        };

        /**
         * Loads the specified number as the value of this program's 'opacity' uniform variable.
         * @param {WebGLRenderingContext} gl The current WebGL context.
         * @param {Number} opacity The opacity in the range [0, 1].
         */
        BasicTextureProgram.prototype.loadOpacity = function (gl, opacity) {
            gl.uniform1f(this.opacityLocation, opacity);
        };

        /**
         * Loads the specified boolean as the value of this program's 'applyLighting' uniform variable.
         * @param {WebGLRenderingContext} gl The current WebGL context.
         * @param {Number} applyLighting true to apply lighting, otherwise false.
         */
        BasicTextureProgram.prototype.loadApplyLighting = function (gl, applyLighting) {
            gl.uniform1i(this.applyLightingLocation, applyLighting);
        };

        return BasicTextureProgram;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports SurfaceShapeTile
 * @version $Id: SurfaceShapeTile.js 3048 2015-04-23 23:26:47Z danm $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(6),
        __webpack_require__(1),
        __webpack_require__(26),
        __webpack_require__(0),
        __webpack_require__(3),
        __webpack_require__(25),
        __webpack_require__(32)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Angle,
              ArgumentError,
              Level,
              Logger,
              Sector,
              Texture,
              TextureTile) {
        "use strict";

        /**
         * Constructs a surface shape tile.
         * @alias SurfaceShapeTile
         * @constructor
         * @classdesc Represents a texture map containing renditions of surface shapes applied to a portion of a globe's terrain.
         * @param {Sector} sector The sector this tile covers.
         * @param {Level} level The level this tile is associated with.
         * @param {number} row This tile's row in the associated level.
         * @param {number} column This tile's column in the associated level.
         * @throws {ArgumentError} If the specified sector or level is null or undefined, the row or column arguments
         * are less than zero, or the specified image path is null, undefined or empty.
         *
         */
        var SurfaceShapeTile = function(sector, level, row, column) {
            TextureTile.call(this, sector, level, row, column); // args are checked in the superclass' constructor

            /**
             * The surface shapes that affect this tile.
             * @type {SurfaceShape[]}
             */
            this.surfaceShapes = [];

            /**
             * The sector that bounds this tile.
             * @type {Sector}
             */
            this.sector = sector;

            /**
             * A string to use as a cache key.
             * @type {string}
             */
            this.cacheKey = null;

            /**
             * Internal use only. Intentionally not documented.
             * @type {number}
             */
            this.pickSequence = 0;

            // Internal use only. Intentionally not documented.
            this.surfaceShapeStateKeys = [];

            // Internal use only. Intentionally not documented.
            this.prevSurfaceShapes = [];

            this.createCtx2D();
        };

        SurfaceShapeTile.prototype = Object.create(TextureTile.prototype);

        /**
         * Clear all collected surface shapes.
         */
        SurfaceShapeTile.prototype.clearShapes = function() {
            // Exchange previous and next surface shape lists to avoid allocating memory.
            var swap = this.prevSurfaceShapes;
            this.prevSurfaceShapes = this.surfaceShapes;
            this.surfaceShapes = swap;

            // Clear out next surface shape list.
            this.surfaceShapes.splice(0, this.surfaceShapes.length);
        };

        /**
         * Query whether any surface shapes have been collected.
         * @returns {boolean} Returns true if there are collected surface shapes.
         */
        SurfaceShapeTile.prototype.hasShapes = function() {
            return this.surfaceShapes.length > 0;
        };

        /**
         * Get all shapes that this tile references.
         * @returns {SurfaceShape[]} The collection of surface shapes referenced by this tile.
         */
        SurfaceShapeTile.prototype.getShapes = function() {
            return this.surfaceShapes;
        };

        /**
         * Set the shapes this tile should reference.
         * @param {SurfaceShape[]} surfaceShapes The collection of surface shapes to be referenced by this tile.
         */
        SurfaceShapeTile.prototype.setShapes = function(surfaceShapes) {
            this.surfaceShapes = surfaceShapes;
        };

        /**
         * The sector that bounds this tile.
         * @returns {Sector}
         */
        SurfaceShapeTile.prototype.getSector = function() {
            return this.sector;
        };

        /**
         * Add a surface shape to this tile's collection of surface shapes.
         * @param {SurfaceShape} surfaceShape The surface shape to add.
         */
        SurfaceShapeTile.prototype.addSurfaceShape = function(surfaceShape) {
            this.surfaceShapes.push(surfaceShape);
            this.surfaceShapeStateKeys.push(surfaceShape.stateKey);
        };

        /**
         * Add multiple surface shapes to this tile's collection.
         * @param {SurfaceShape[]} shapes A collection of surface shapes to add to the collection of this tile.
         */
        SurfaceShapeTile.prototype.addAllSurfaceShapes = function(shapes) {
            for (var idx = 0, len = shapes.length; idx < len; idx += 1) {
                var shape = shapes[idx];
                this.addAllSurfaceShapes(shape);
            }
        };

        // Internal use only. Intentionally not documented.
        SurfaceShapeTile.prototype.needsUpdate = function(dc) {
            var idx, len, surfaceShape, surfaceShapeStateKey;

            // If the number of shapes have changed, ... (cheap test)
            if (this.prevSurfaceShapes.length != this.surfaceShapes.length) {
                return true;
            }

            // If shapes have been removed since the previous iteration, ...
            for (idx = 0, len = this.prevSurfaceShapes.length; idx < len; idx += 1) {
                surfaceShape = this.prevSurfaceShapes[idx];

                if (this.surfaceShapes.indexOf(surfaceShape) < 0) {
                    return true;
                }
            }

            // If shapes added since the previous iteration, ...
            for (idx = 0, len = this.surfaceShapes.length; idx < len; idx += 1) {
                surfaceShape = this.surfaceShapes[idx];

                if (this.prevSurfaceShapes.indexOf(surfaceShape) < 0) {
                    return true;
                }
            }

            // If the state key of the shape is different than the saved state key for that shape, ...
            for (idx = 0, len = this.surfaceShapes.length; idx < len; idx += 1) {
                surfaceShape = this.surfaceShapes[idx];
                surfaceShapeStateKey = this.surfaceShapeStateKeys[idx];

                if (surfaceShapeStateKey != surfaceShape.stateKey) {
                    return true;
                }
            }

            // If a texture does not already exist, ...
            if (!this.hasTexture(dc)) {
                return true;
            }

            // If you get here, the texture can be reused.
            return false;
        };

        /**
         * Determine whether the surface shape tile has a valid texture.
         * @param {DrawContext} dc The draw context.
         * @returns {boolean} True if the surface shape tile has a valid texture, else false.
         */
        SurfaceShapeTile.prototype.hasTexture = function(dc) {
            if (dc.pickingMode) {
                return false;
            }

            var gpuResourceCache = dc.gpuResourceCache;

            if (!this.gpuCacheKey) {
                this.gpuCacheKey = this.getCacheKey();
            }

            var texture = gpuResourceCache.resourceForKey(this.gpuCacheKey);

            return !!texture;
        };

        /**
         * Redraw all of the surface shapes onto the texture for this tile.
         * @param {DrawContext} dc
         * @returns {Texture}
         */
        SurfaceShapeTile.prototype.updateTexture = function(dc) {
            var gl = dc.currentGlContext,
                canvas = SurfaceShapeTile.canvas;

            canvas.width = this.tileWidth;
            canvas.height = this.tileHeight;

            var ctx2D = SurfaceShapeTile.ctx2D;

            // Mapping from lat/lon to x/y:
            //  lon = minlon => x = 0
            //  lon = maxLon => x = 256
            //  lat = minLat => y = 256
            //  lat = maxLat => y = 0
            //  (assuming texture size is 256)
            // So:
            //  x = 256 / sector.dlon * (lon - minLon)
            //  y = -256 / sector.dlat * (lat - maxLat)
            var xScale = this.tileWidth / this.sector.deltaLongitude(),
                yScale = -this.tileHeight / this.sector.deltaLatitude(),
                xOffset = -this.sector.minLongitude * xScale,
                yOffset = -this.sector.maxLatitude * yScale;

            for (var idx = 0, len = this.surfaceShapes.length; idx < len; idx += 1) {
                var shape = this.surfaceShapes[idx];
                this.surfaceShapeStateKeys[idx] = shape.stateKey;

                shape.renderToTexture(dc, ctx2D, xScale, yScale, xOffset, yOffset);
            }

            var texture = new Texture(gl, canvas);

            var gpuResourceCache = dc.gpuResourceCache;

            this.gpuCacheKey = this.getCacheKey();

            gpuResourceCache.putResource(this.gpuCacheKey, texture, texture.size);

            return texture;
        };

        /**
         * Get a key suitable for cache look-ups.
         * @returns {string}
         */
        SurfaceShapeTile.prototype.getCacheKey = function() {
            if (!this.cacheKey) {
                this.cacheKey = "SurfaceShapeTile:" +
                this.tileKey + "," +
                this.pickSequence.toString();
            }

            return this.cacheKey;
        };

        /**
         * Create a new canvas and its 2D context on demand.
         */
        SurfaceShapeTile.prototype.createCtx2D = function() {
            // If the context was previously created, ...
            if (!SurfaceShapeTile.ctx2D) {
                SurfaceShapeTile.canvas = document.createElement("canvas");
                SurfaceShapeTile.ctx2D = SurfaceShapeTile.canvas.getContext("2d");
            }
        };

        /*
         * For internal use only.
         * 2D canvas and context, which is created lazily on demand.
         */
        SurfaceShapeTile.canvas = null;
        SurfaceShapeTile.ctx2D = null;

        return SurfaceShapeTile;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports SurfaceShapeTileBuilder
 * @version $Id: SurfaceShapeTileBuilder.js 3048 2015-04-23 23:26:47Z danm $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(1),
        __webpack_require__(44),
        __webpack_require__(15),
        __webpack_require__(11),
        __webpack_require__(26),
        __webpack_require__(27),
        __webpack_require__(7),
        __webpack_require__(0),
        __webpack_require__(5),
        __webpack_require__(16),
        __webpack_require__(20),
        __webpack_require__(23),
        __webpack_require__(21),
        __webpack_require__(9),
        __webpack_require__(3),
        __webpack_require__(33),
        __webpack_require__(50),
        __webpack_require__(30),
        __webpack_require__(39),
        __webpack_require__(40),
        __webpack_require__(32),
        __webpack_require__(12)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
              DrawContext,
              Globe,
              GpuProgram,
              Level,
              LevelSet,
              Location,
              Logger,
              Matrix,
              MemoryCache,
              NavigatorState,
              NotYetImplementedError,
              PickedObject,
              Rectangle,
              Sector,
              SurfaceShape,
              SurfaceShapeTile,
              Terrain,
              TerrainTile,
              TerrainTileList,
              TextureTile,
              Tile) {
        "use strict";

        var SurfaceShapeTileBuilder = function() {
            // Parameterize top level subdivision in one place.

            // TilesInTopLevel describes the most coarse tile structure.
            this.numRowsTilesInTopLevel = 4;
            this.numColumnsTilesInTopLevel = 8;

            // The maximum number of levels that will ever be tessellated.
            this.maximumSubdivisionDepth = 15;

            // tileWidth, tileHeight - the number of subdivisions a single tile has; this determines the sampling grid.
            this.tileWidth = 256;
            this.tileHeight = 256;

            /**
             * The collection of levels.
             * @type {LevelSet}
             */
            this.levels = new LevelSet(
                Sector.FULL_SPHERE,
                new Location(
                    180 / this.numRowsTilesInTopLevel,
                    360 / this.numColumnsTilesInTopLevel),
                this.maximumSubdivisionDepth,
                this.tileWidth,
                this.tileHeight);

            /**
             * The collection of surface shapes processed by this class.
             * @type {SurfaceShape[]}
             */
            this.surfaceShapes = [];

            /**
             * The collection of surface shape tiles that actually contain surface shapes.
             * @type {SurfaceShapeTile[]}
             */
            this.surfaceShapeTiles = [];

            /**
             * The collection of top level surface shape tiles, from which actual tiles are derived.
             * @type {SurfaceShapeTile[]}
             */
            this.topLevelTiles = [];

            /**
             * Accumulator of all sectors for surface shapes
             * @type {Sector}
             */
            this.sector = new Sector(-90, 90, -180, 180);

            /**
             * The default split scale. The split scale 2.9 has been empirically determined to render sharp lines and edges with
             * the SurfaceShapes such as SurfacePolyline and SurfacePolygon.
             *
             * @type {Number}
             */
            this.detailControl = 1.25;

            // Internal use only. Intentionally not documented.
            this.tileCache = new MemoryCache(500000, 400000);
        };

        /**
         * Clear all transient state from the surface shape tile builder.
         */
        SurfaceShapeTileBuilder.prototype.clear = function() {
            this.surfaceShapeTiles.splice(0, this.surfaceShapeTiles.length);
            this.surfaceShapes.splice(0, this.surfaceShapes.length);
        };

        /**
         * Insert a surface shape to be rendered into the surface shape tile builder.
         * 
         * @param {SurfaceShape} surfaceShape A surfave shape to be processed.
         */
        SurfaceShapeTileBuilder.prototype.insertSurfaceShape = function(surfaceShape) {
            this.surfaceShapes.push(surfaceShape);
        };

        /**
         * Perform the rendering of any accumulated surface shapes by building the surface shape tiles that contain these
         * shapes and then rendering those tiles.
         * 
         * @param {DrawContext} dc The drawing context.
         */
        SurfaceShapeTileBuilder.prototype.doRender = function(dc) {
            if (dc.pickingMode) {
                // Picking rendering strategy:
                //  1) save all tiles created prior to picking,
                //  2) construct and render new tiles with pick-based contents (colored with pick IDs),
                //  3) restore all prior tiles.
                // This has a big potential win for normal rendering, since there is a lot of coherence
                // from frame to frame if no picking is occurring.
                for (var idx = 0, len = this.surfaceShapes.length; idx < len; idx += 1) {
                    this.surfaceShapes[idx].resetPickColor();
                }

                SurfaceShapeTileBuilder.pickSequence += 1;

                var savedTiles = this.surfaceShapeTiles;
                var savedTopLevelTiles = this.topLevelTiles;

                this.surfaceShapeTiles = [];
                this.topLevelTiles = [];

                this.buildTiles(dc);

                if (dc.deepPicking) {
                    // Normally, we render all shapes together in one tile (or a small number, but this detail
                    // doesn't matter). For deep picking, we need to render each shape individually.
                    this.doDeepPickingRender(dc);

                } else {
                    dc.surfaceTileRenderer.renderTiles(dc, this.surfaceShapeTiles, 1);
                }

                this.surfaceShapeTiles = savedTiles;
                this.topLevelTiles = savedTopLevelTiles;
            } else {
                this.buildTiles(dc);

                dc.surfaceTileRenderer.renderTiles(dc, this.surfaceShapeTiles, 1);
            }
        };

        SurfaceShapeTileBuilder.prototype.doDeepPickingRender = function (dc) {
            var idxTile, lenTiles, idxShape, lenShapes, idxPick, lenPicks, po, shape, tile;

            // Determine the shapes that were drawn during buildTiles. These shapes may not actually be
            // at the pick point, but they are candidates for deep picking.
            var deepPickShapes = [];
            for (idxPick = 0, lenPicks = dc.objectsAtPickPoint.objects.length; idxPick < lenPicks; idxPick += 1) {
                po = dc.objectsAtPickPoint.objects[idxPick];
                if (po.userObject instanceof SurfaceShape) {
                    shape = po.userObject;

                    // If the shape was not already in the collection of deep picked shapes, ...
                    if (deepPickShapes.indexOf(shape) < 0) {
                        deepPickShapes.push(shape);

                        // Delete the shape that was drawn during buildTiles from the pick list.
                        dc.objectsAtPickPoint.objects.splice(idxPick, 1);

                        // Update the index and length to reflect the deletion.
                        idxPick -= 1;
                        lenPicks -= 1;
                    }
                }
            }

            if (deepPickShapes.length <= 0) {
                return;
            }

            // For all shapes,
            //  1) force that shape to be the only shape in a tile,
            //  2) re-render the tile, and
            //  3) use the surfaceTileRenderer to render the tile on the terrain,
            //  4) read the color to see if it is attributable to the current shape.
            var resolvablePickObjects = [];
            for (idxShape = 0, lenShapes = deepPickShapes.length; idxShape < lenShapes; idxShape += 1) {
                shape = deepPickShapes[idxShape];
                for (idxTile = 0, lenTiles = this.surfaceShapeTiles.length; idxTile < lenTiles; idxTile += 1) {
                    tile = this.surfaceShapeTiles[idxTile];
                    tile.setShapes([shape]);
                    tile.updateTexture(dc);
                }

                dc.surfaceTileRenderer.renderTiles(dc, this.surfaceShapeTiles, 1);

                var pickColor = dc.readPickColor(dc.pickPoint);
                if (!!pickColor && shape.pickColor.equals(pickColor)) {
                    po = new PickedObject(shape.pickColor.clone(),
                        shape.pickDelegate ? shape.pickDelegate : shape, null, shape.layer, false);
                    resolvablePickObjects.push(po);
                }
            }

            // Flush surface shapes that have accumulated in the updateTexture pass just completed on all shapes.
            for (idxPick = 0, lenPicks = dc.objectsAtPickPoint.objects.length; idxPick < lenPicks; idxPick += 1) {
                po = dc.objectsAtPickPoint.objects[idxPick];
                if (po.userObject instanceof SurfaceShape) {
                    // Delete the shape that was picked in the most recent pass.
                    dc.objectsAtPickPoint.objects.splice(idxPick, 1);

                    // Update the index and length to reflect the deletion.
                    idxPick -= 1;
                    lenPicks -= 1;
                }
            }

            // Add the resolvable pick objects for surface shapes that were actually visible at the pick point
            // to the pick list.
            for (idxPick = 0, lenPicks = resolvablePickObjects.length; idxPick < lenPicks; idxPick += 1) {
                po = resolvablePickObjects[idxPick];
                dc.objectsAtPickPoint.objects.push(po);
            }
        };

        /**
         * Assembles the surface tiles and draws any surface shapes that have been accumulated into those offscreen tiles. The
         * surface tiles are assembled to meet the necessary resolution of to the draw context's. 
         * <p/>
         * This does nothing if there are no surface shapes associated with this builder.
         *
         * @param {DrawContext} dc The draw context to build tiles for.
         *
         * @throws {ArgumentError} If the draw context is null.
         */
        SurfaceShapeTileBuilder.prototype.buildTiles = function(dc) {
            if (!dc) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "SurfaceShapeTileBuilder", "buildTiles", "missingDc"));
            }

            if (!this.surfaceShapes || this.surfaceShapes.length < 1) {
                return;
            }

            // Assemble the current visible tiles and update their associated textures if necessary.
            this.assembleTiles(dc);

            // Clean up references to all surface shapes to avoid dangling references. The surface shape list is no
            // longer needed, now that the shapes are held by each tile.
            this.surfaceShapes.splice(0, this.surfaceShapes.length);
            for (var idx = 0, len = this.surfaceShapeTiles.length; idx < len; idx += 1) {
                var tile = this.surfaceShapeTiles[idx];
                tile.clearShapes();
            }
        };

        /**
         * Assembles a set of surface tiles that are visible in the specified DrawContext and meet the tile builder's
         * resolution criteria. Tiles are culled against the current surface shape list, against the DrawContext's view
         * frustum during rendering mode, and against the DrawContext's pick frustums during picking mode. If a tile does
         * not meet the tile builder's resolution criteria, it's split into four sub-tiles and the process recursively
         * repeated on the sub-tiles.
         * <p/>
         * During assembly, each surface shape in {@link #surfaceShapes} is sorted into the tiles they
         * intersect. The top level tiles are used as an index to quickly determine which tiles each shape intersects.
         * Surface shapes are sorted into sub-tiles by simple intersection tests, and are added to each tile's surface
         * renderable list at most once. See {@link SurfaceShapeTileBuilder.SurfaceShapeTile#addSurfaceShape(SurfaceShape,
         * gov.nasa.worldwind.geom.Sector)}. Tiles that don't intersect any surface shapes are discarded.
         *
         * @param {DrawContext} dc The DrawContext to assemble tiles for.
         */
        SurfaceShapeTileBuilder.prototype.assembleTiles = function(dc) {
            var tile, idxShape, lenShapes, idxTile, lenTiles, idxSector, lenSectors;

            // Create a set of top level tiles only if that set doesn't exist yet.
            if (this.topLevelTiles.length < 1) {
                this.createTopLevelTiles();
            }

            // Store the top level tiles in a set to ensure that each top level tile is added only once. Store the tiles
            // that intersect each surface shape in a set to ensure that each object is added to a tile at most once.
            var intersectingTiles = {};

            // Iterate over the current surface shapes, adding each surface shape to the top level tiles that it
            // intersects. This produces a set of top level tiles containing the surface shapes that intersect each
            // tile. We use the tile structure as an index to quickly determine the tiles a surface shape intersects,
            // and add object to those tiles. This has the effect of quickly sorting the objects into the top level tiles.
            // We collect the top level tiles in a HashSet to ensure there are no duplicates when multiple objects intersect
            // the same top level tiles.
            for (idxShape = 0, lenShapes = this.surfaceShapes.length; idxShape < lenShapes; idxShape += 1) {
                var surfaceShape = this.surfaceShapes[idxShape];

                var sectors = surfaceShape.computeSectors(dc);
                if (!sectors) {
                    continue;
                }

                for (idxSector = 0, lenSectors = sectors.length; idxSector < lenSectors; idxSector += 1) {
                    var sector = sectors[idxSector];

                    for (idxTile = 0, lenTiles = this.topLevelTiles.length; idxTile < lenTiles; idxTile += 1) {
                        tile = this.topLevelTiles[idxTile];

                        if (tile.sector.intersects(sector)) {
                            var cacheKey = tile.tileKey;
                            intersectingTiles[cacheKey] = tile;
                            tile.addSurfaceShape(surfaceShape);
                        }
                    }
                }
            }

            // Add each top level tile or its descendants to the current tile list.
            //for (var idxTile = 0, lenTiles = this.topLevelTiles.length; idxTile < lenTiles; idxTile += 1) {
            for (var key in intersectingTiles) {
                if (intersectingTiles.hasOwnProperty(key)) {
                    tile = intersectingTiles[key];

                    this.addTileOrDescendants(dc, this.levels, null, tile);
                }
            }
        };

        /**
         * Potentially adds the specified tile or its descendants to the tile builder's surface shape tile collection.
         * The tile and its descendants are discarded if the tile is not visible or does not intersect any surface shapes in the
         * parent's surface shape list.
         * <p/>
         * If the tile meet the tile builder's resolution criteria it's added to the tile builder's
         * <code>currentTiles</code> list. Otherwise, it's split into four sub-tiles and each tile is recursively processed.
         *
         * @param {DrawContext} dc              The current DrawContext.
         * @param {LevelSet} levels             The tile's LevelSet.
         * @param {SurfaceShapeTile} parent     The tile's parent, or null if the tile is a top level tile.
         * @param {SurfaceShapeTile} tile       The tile to add.
         */
        SurfaceShapeTileBuilder.prototype.addTileOrDescendants = function (dc, levels, parent, tile) {
            // Ignore this tile if it falls completely outside the frustum. This may be the viewing frustum or the pick
            // frustum, depending on the implementation.
            if (!this.intersectsFrustum(dc, tile)) {
                // This tile is not added to the current tile list, so we clear it's object list to prepare it for use
                // during the next frame.
                tile.clearShapes();
                return;
            }

            // If the parent tile is not null, add any parent surface shapes that intersect this tile.
            if (parent != null) {
                this.addIntersectingShapes(dc, parent, tile);
            }

            // Ignore tiles that do not intersect any surface shapes.
            if (!tile.hasShapes()) {
                return;
            }

            // If this tile meets the current rendering criteria, add it to the current tile list. This tile's object list
            // is cleared after the tile update operation.
            if (this.meetsRenderCriteria(dc, levels, tile)) {
                this.addTile(dc, tile);
                return;
            }

            var nextLevel = levels.level(tile.level.levelNumber + 1);
            var subTiles = dc.pickingMode ?
                tile.subdivide(nextLevel, this) :
                tile.subdivideToCache(nextLevel, this, this.tileCache);
            for (var idxTile = 0, lenTiles = subTiles.length; idxTile < lenTiles; idxTile += 1) {
                var subTile = subTiles[idxTile];
                this.addTileOrDescendants(dc, levels, tile, subTile);
            }

            // This tile is not added to the current tile list, so we clear it's object list to prepare it for use during
            // the next frame.
            tile.clearShapes();
        };

        /**
         * Adds surface shapes from the parent's object list to the specified tile's object list. If the tile's sector
         * does not intersect the sector bounding the parent's object list, this does nothing. Otherwise, this adds any of
         * the parent's surface shapes that intersect the tile's sector to the tile's object list.
         *
         * @param {DrawContext} dc              The current DrawContext.
         * @param {SurfaceShapeTile} parent     The tile's parent.
         * @param {SurfaceShapeTile} tile       The tile to add intersecting surface shapes to.
         */
        SurfaceShapeTileBuilder.prototype.addIntersectingShapes = function(dc, parent, tile) {
            // If the parent has no objects, then there's nothing to add to this tile and we exit immediately.
            if (!parent.hasShapes())
                return;

            // If this tile does not intersect the parent's object bounding sector, then none of the parent's objects
            // intersect this tile. Therefore we exit immediately, and do not add any objects to this tile.
            if (!tile.sector.intersects(parent.sector))
                return;

            // If this tile contains the parent's object bounding sector, then all of the parent's objects intersect this
            // tile. Therefore we just add all of the parent's objects to this tile. Additionally, the parent's object
            // bounding sector becomes this tile's object bounding sector.
            if (tile.getSector().contains(parent.sector)) {
                tile.addAllSurfaceShapes(parent.getShapes());
            }
            // Otherwise, the tile may intersect some of the parent's object list. Compute which objects intersect this
            // tile, and compute this tile's bounding sector as the union of those object's sectors.
            else {
                var shapes = parent.getShapes();
                for (var idxShape = 0, lenShapes = shapes.length; idxShape < lenShapes; idxShape += 1) {
                    var shape = shapes[idxShape];

                    var sectors = shape.computeSectors(dc);
                    if (!sectors) {
                        continue;
                    }

                    // Test intersection against each of the surface shape's sectors. We break after finding an
                    // intersection to avoid adding the same object to the tile more than once.
                    for (var idxSector = 0, lenSectors = sectors.length; idxSector < lenSectors; idxSector += 1) {
                        var sector = sectors[idxSector];

                        if (tile.getSector().intersects(sector)) {
                            tile.addSurfaceShape(shape);
                            break;
                        }
                    }
                }
            }
        };

        /**
         * Adds the specified tile to this tile builder's surface tile collection.
         *
         * @param {DrawContext} dc The draw context.
         * @param {SurfaceShapeTile} tile The tile to add.
         */
        SurfaceShapeTileBuilder.prototype.addTile = function(dc, tile) {
            if (dc.pickingMode) {
                tile.pickSequence = SurfaceShapeTileBuilder.pickSequence;
            }

            if (tile.needsUpdate(dc)) {
                tile.updateTexture(dc);
            }

            this.surfaceShapeTiles.push(tile);
        };

        /**
         * Internal use only.
         *
         * Returns a new SurfaceObjectTile corresponding to the specified {@code sector}, {@code level}, {@code row},
         * and {@code column}.
         *
         * CAUTION: it is assumed that there exists a single SurfaceShapeTileBuilder. This algorithm might be invalid if there
         * are more of them (or it might actually work, although it hasn't been tested in that context).
         *
         * @param {Sector} sector       The tile's Sector.
         * @param {Level} level         The tile's Level in a {@link LevelSet}.
         * @param {Number} row          The tile's row in the Level, starting from 0 and increasing to the right.
         * @param {Number} column       The tile's column in the Level, starting from 0 and increasing upward.
         *
         * @return {SurfaceShapeTile} a new SurfaceShapeTile.
         */
        SurfaceShapeTileBuilder.prototype.createTile = function(sector, level, row, column) {
            return new SurfaceShapeTile(sector, level, row, column);
        };

        SurfaceShapeTileBuilder.prototype.createTopLevelTiles = function() {
            Tile.createTilesForLevel(this.levels.firstLevel(), this, this.topLevelTiles);
        };

        /**
         * Test if the tile intersects the specified draw context's frustum. During picking mode, this tests intersection
         * against all of the draw context's pick frustums. During rendering mode, this tests intersection against the draw
         * context's viewing frustum.
         *
         * @param {DrawContext} dc   The draw context the surface shape is related to.
         * @param {SurfaceShapeTile} tile The tile to test for intersection.
         *
         * @return {Boolean} true if the tile intersects the draw context's frustum; false otherwise.
         */
        SurfaceShapeTileBuilder.prototype.intersectsFrustum = function(dc, tile) {
            if (dc.globe.projectionLimits && !tile.sector.overlaps(dc.globe.projectionLimits)) {
                return false;
            }

            tile.update(dc);

            return tile.extent.intersectsFrustum(dc.pickingMode ? dc.pickFrustum : dc.navigatorState.frustumInModelCoordinates);
        };

        /**
         * Tests if the specified tile meets the rendering criteria on the specified draw context. This returns true if the
         * tile is from the level set's final level, or if the tile achieves the desired resolution on the draw context.
         *
         * @param {DrawContext} dc          The current draw context.
         * @param {LevelSet} levels         The level set the tile belongs to.
         * @param {SurfaceShapeTile} tile   The tile to test.
         *
         * @return {Boolean} true if the tile meets the rendering criteria; false otherwise.
         */
        SurfaceShapeTileBuilder.prototype.meetsRenderCriteria = function(dc, levels, tile) {
            return tile.level.levelNumber == levels.lastLevel().levelNumber || !tile.mustSubdivide(dc, this.detailControl);
        };

        /**
         * Internal use only.
         * Count of pick operations. This is used to give a surface shape tile a unique pick sequence number if it is
         * participating in picking.
         * @type {Number}
         */
        SurfaceShapeTileBuilder.pickSequence = 0;

        return SurfaceShapeTileBuilder;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports AbsentResourceList
 * @version $Id: AbsentResourceList.js 2952 2015-04-01 00:33:54Z tgaskins $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
        "use strict";

        /**
         * Constructs an absent resource list.
         * @alias AbsentResourceList
         * @constructor
         * @classdesc Provides a collection to keep track of resources whose retrieval failed and when retrieval
         * may be tried again. Applications typically do not use this class directly.
         * @param {Number} maxTrys The number of attempts to make before the resource is marked as absent.
         * @param {Number} minCheckInterval The amount of time to wait between attempts, in milliseconds.
         * @constructor
         */
        var AbsentResourceList = function (maxTrys, minCheckInterval) {

            /**
             * The number  of attempts to make before the resource is marked as absent.
             * @type {Number}
             */
            this.maxTrys = maxTrys;

            /**
             * The amount of time to wait before each attempt.
             * @type {Number}
             */
            this.minCheckInterval = minCheckInterval;

            /**
             * The amount of time, in milliseconds, beyond which retrieval attempts should again be allowed.
             * When this time has elapsed from the most recent failed attempt the number of trys attempted is
             * reset to 0. This prevents the resource from being permanently blocked.
             * @type {number}
             * @default 60,000 milliseconds (one minute)
             */
            this.tryAgainInterval = 60e3; // 60 seconds

            this.possiblyAbsent = {};
        };

        /**
         * Indicates whether a specified resource is marked as absent.
         * @param {String} resourceId The resource identifier.
         * @returns {Boolean} true if the resource is marked as absent, otherwise false.
         */
        AbsentResourceList.prototype.isResourceAbsent = function (resourceId) {
            var entry = this.possiblyAbsent[resourceId];

            if (!entry) {
                return false;
            }

            if (entry.permanent) {
                return true;
            }

            var timeSinceLastMark = Date.now() - entry.timeOfLastMark;

            if (timeSinceLastMark > this.tryAgainInterval) {
                delete this.possiblyAbsent[resourceId];
                return false;
            }

            return timeSinceLastMark < this.minCheckInterval || entry.numTrys > this.maxTrys;
        };

        /**
         * Marks a resource attempt as having failed. This increments the number-of-tries counter and sets the time
         * of the last attempt. When this method has been called [this.maxTrys]{@link AbsentResourceList#maxTrys}
         * times the resource is marked as absent until this absent resource list's
         * [try-again-interval]{@link AbsentResourceList#tryAgainInterval} is reached.
         * @param {String} resourceId The resource identifier.
         */
        AbsentResourceList.prototype.markResourceAbsent = function (resourceId) {
            var entry = this.possiblyAbsent[resourceId];

            if (!entry) {
                entry = {
                    timeOfLastMark: Date.now(),
                    numTrys: 0
                };
                this.possiblyAbsent[resourceId] = entry;
            }

            entry.numTrys = entry.numTrys + 1;
            entry.timeOfLastMark = Date.now();
        };

        /**
         * Marks a resource attempt as having failed permanently. No attempt will ever again be made to retrieve
         * the resource.
         * @param {String} resourceId The resource identifier.
         */
        AbsentResourceList.prototype.markResourceAbsentPermanently = function (resourceId) {
            var entry = this.possiblyAbsent[resourceId];

            if (!entry) {
                entry = {
                    timeOfLastMark: Date.now(),
                    numTrys: 0
                };
                this.possiblyAbsent[resourceId] = entry;
            }

            entry.numTrys = entry.numTrys + 1;
            entry.timeOfLastMark = Date.now();
            entry.permanent = true;
        };

        /**
         * Removes the specified resource from this absent resource list. Call this method when retrieval attempts
         * succeed.
         * @param {String} resourceId The resource identifier.
         */
        AbsentResourceList.prototype.unmarkResourceAbsent = function (resourceId) {
            var entry = this.possiblyAbsent[resourceId];

            if (entry) {
                delete this.possiblyAbsent[resourceId];
            }
        };

        return AbsentResourceList;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports FrameStatistics
 * @version $Id: FrameStatistics.js 3343 2015-07-28 18:22:59Z dcollins $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
        "use strict";

        /**
         * Constructs a performance statistics instance. This is performed internally by the {@link WorldWindow}.
         * Applications do not construct instances of this class.
         * @alias FrameStatistics
         * @constructor
         * @classdesc Captures performance statistics.
         */
        var FrameStatistics = function () {

            // Internal: intentionally not documented
            this.frameCount = 0;

            // Internal: intentionally not documented
            this.frameTimeCumulative = 0;

            // Internal: intentionally not documented
            this.frameTimeBase = 0;

            // Internal: intentionally not documented
            this.frameTimeExtremes = [Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY];

            /**
             * The number of milliseconds required to render the most recent frame.
             * @type {Number}
             */
            this.frameTime = 0;

            /**
             * The number of milliseconds spent tessellating the terrain during the most recent frame.
             * @type {Number}
             */
            this.tessellationTime = 0;

            /**
             * The number of milliseconds spent rendering the active layers during the most recent frame.
             * @type {Number}
             */
            this.layerRenderingTime = 0;

            /**
             * The number of milliseconds spent rendering ordered renderables during the most recent frame.
             * @type {Number}
             */
            this.orderedRenderingTime = 0;

            /**
             * The number of terrain tiles in the most recent frame.
             * @type {Number}
             */
            this.terrainTileCount = 0;

            /**
             * The number of image tiles in the most recent frame.
             * @type {Number}
             */
            this.imageTileCount = 0;

            /**
             * The number of terrain tile renderings. Since terrain tiles are generally rendered more than once per
             * frame, this count will be greater than the number of terrain tiles created for the frame.
             * @type {Number}
             */
            this.renderedTileCount = 0;

            /**
             * The number of calls to [Tile.update()]{@link Tile#update} during the most recent frame.
             * @type {Number}
             */
            this.tileUpdateCount = 0;

            /**
             * The number of texture bind calls during the most recent frame.
             * @type {Number}
             */
            this.textureLoadCount = 0;

            /**
             * The number of WebGL VBO loads during the most recent frame.
             * @type {Number}
             */
            this.vboLoadCount = 0;

            /**
             * The average frame time over the most recent two seconds.
             * @type {Number}
             */
            this.frameTimeAverage = 0;

            /**
             * The average frame rate over the most recent two seconds.
             * @type {Number}
             */
            this.frameRateAverage = 0;

            /**
             * The minimum frame time over the most recent two seconds.
             * @type {Number}
             */
            this.frameTimeMin = 0;

            /**
             * The maximum frame time over the most recent two seconds.
             * @type {Number}
             */
            this.frameTimeMax = 0;
        };

        /**
         * Initializes this frame statistics with initial values.
         */
        FrameStatistics.prototype.beginFrame = function () {
            this.frameTime = Date.now();
            this.tessellationTime = 0;
            this.layerRenderingTime = 0;
            this.orderedRenderingTime = 0;
            this.terrainTileCount = 0;
            this.imageTileCount = 0;
            this.renderedTileCount = 0;
            this.tileUpdateCount = 0;
            this.textureLoadCount = 0;
            this.vboLoadCount = 0;

            ++this.frameCount;
        };

        /**
         * Computes the statistics for the most recent frame.
         */
        FrameStatistics.prototype.endFrame = function () {
            var now = Date.now();
            this.frameTime = now - this.frameTime;
            this.frameTimeCumulative += this.frameTime;
            this.frameTimeExtremes[0] = Math.min(this.frameTimeExtremes[0], this.frameTime);
            this.frameTimeExtremes[1] = Math.max(this.frameTimeExtremes[1], this.frameTime);

            // Compute averages every 2 seconds.
            if (now - this.frameTimeBase > 2000) {
                this.frameTimeAverage = this.frameTimeCumulative / this.frameCount;
                this.frameRateAverage = 1000 * this.frameCount / (now - this.frameTimeBase);
                this.frameTimeMin = this.frameTimeExtremes[0];
                this.frameTimeMax = this.frameTimeExtremes[1];
                this.frameCount = 0;
                this.frameTimeCumulative = 0;
                this.frameTimeBase = now;
                this.frameTimeExtremes = [Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY];
                //console.log(this.frameTimeAverage.toString() + ", " + this.frameRateAverage.toString());
            }
        };

        /**
         * Increments the rendered tile count.
         * @param {Number} tileCount The amount to increment the counter.
         */
        FrameStatistics.prototype.incrementRenderedTileCount = function (tileCount) {
            this.renderedTileCount += tileCount;
        };

        /**
         * Sets the terrain tile count.
         * @param {Number} tileCount The amount to set the counter to.
         */
        FrameStatistics.prototype.setTerrainTileCount = function (tileCount) {
            this.terrainTileCount = tileCount;
        };

        /**
         * Increments the image tile count.
         * @param {Number} tileCount The amount to increment the counter.
         */
        FrameStatistics.prototype.incrementImageTileCount = function (tileCount) {
            this.imageTileCount = tileCount;
        };

        /**
         * Increments the tile update count.
         * @param {Number} count The amount to increment the counter.
         */
        FrameStatistics.prototype.incrementTileUpdateCount = function (count) {
            this.tileUpdateCount += count;
        };

        /**
         * Increments the texture load count.
         * @param {Number} count The amount to increment the counter.
         */
        FrameStatistics.prototype.incrementTextureLoadCount = function (count) {
            this.textureLoadCount += count;
        };

        /**
         * Increments the VBO load count.
         * @param {Number} count The amount to increment the counter.
         */
        FrameStatistics.prototype.incrementVboLoadCount = function (count) {
            this.vboLoadCount += count;
        };

        return FrameStatistics;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2015 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports ImageSource
 * @version $Id: ImageSource.js 3023 2015-04-15 20:24:17Z tgaskins $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(1),
        __webpack_require__(8),
        __webpack_require__(0)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
              Color,
              Logger) {
        "use strict";

        /**
         * Constructs an image source.
         * @alias ImageSource
         * @constructor
         * @classdesc Holds an Image with an associated key that uniquely identifies that image. The key is
         * automatically generated but may be reassigned after construction. Instances of this class are used to
         * specify dynamically created image sources for {@link Placemark}, {@link SurfaceImage},
         * {@link Polygon} textures and other shapes that display imagery.
         * @param {Image} image The image for this image source.
         * @throws {ArgumentError} If the specified image is null or undefined.
         */
        var ImageSource = function (image) {
            if (!image) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "ImageSource", "constructor",
                    "missingImage"));
            }

            /**
             * This image source's image
             * @type {Image}
             * @readonly
             */
            this.image = image;

            /**
             * This image source's key. A unique key is automatically generated and assigned during construction.
             * Applications may assign a different key after construction.
             * @type {String}
             * @default A unique string for this image source.
             */
            this.key = "ImageSource " + ++ImageSource.keyPool;
        };

        // Internal. Intentionally not documented.
        ImageSource.keyPool = 0; // source of unique ids

        return ImageSource;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 55 */
/***/ (function(module, exports) {

// see original ../node_modules/web-world-wind/src/WorldWind

WorldWind = {

    /**
     * Holds configuration parameters for World Wind. Applications may modify these parameters prior to creating
     * their first World Wind objects. Configuration properties are:
     * <ul>
     *     <li><code>gpuCacheSize</code>: A Number indicating the size in bytes to allocate from GPU memory for
     *     resources such as textures, GLSL programs and buffer objects. Default is 250e6 (250 MB).</li>
     *     <li><code>baseUrl</code>: The URL of the directory containing the World Wind Library and its resources.</li>
     * </ul>
     * @type {{gpuCacheSize: number}}
     */
    configuration: {
        gpuCacheSize: 250e6
    },

    /**
     * The World Wind version number.
     * @default "0.0.0"
     * @constant
     */
    VERSION: "0.0.0",

    /**
     * Indicates an altitude mode relative to the globe's ellipsoid.
     * @constant
     */
    ABSOLUTE: "absolute",

    /**
     * Indicates that a redraw callback has been called immediately after a redraw.
     * @constant
     */
    AFTER_REDRAW: "afterRedraw",

    /**
     * Indicates that a redraw callback has been called immediately before a redraw.
     * @constant
     */
    BEFORE_REDRAW: "beforeRedraw",

    /**
     * The BEGAN gesture recognizer state. Continuous gesture recognizers transition to this state from the
     * POSSIBLE state when the gesture is first recognized.
     * @constant
     */
    BEGAN: "began",

    /**
     * The CANCELLED gesture recognizer state. Continuous gesture recognizers may transition to this state from
     * the BEGAN state or the CHANGED state when the touch events are cancelled.
     * @constant
     */
    CANCELLED: "cancelled",

    /**
     * The CHANGED gesture recognizer state. Continuous gesture recognizers transition to this state from the
     * BEGAN state or the CHANGED state, whenever an input event indicates a change in the gesture.
     * @constant
     */
    CHANGED: "changed",

    /**
     * Indicates an altitude mode always on the terrain.
     * @constant
     */
    CLAMP_TO_GROUND: "clampToGround",

    /**
     * The radius of Earth.
     * @constant
     */
    EARTH_RADIUS: 6371e3,

    /**
     * Indicates the cardinal direction east.
     * @constant
     */
    EAST: "east",

    /**
     * The ENDED gesture recognizer state. Continuous gesture recognizers transition to this state from either
     * the BEGAN state or the CHANGED state when the current input no longer represents the gesture.
     * @constant
     */
    ENDED: "ended",

    /**
     * The FAILED gesture recognizer state. Gesture recognizers transition to this state from the POSSIBLE state
     * when the gesture cannot be recognized given the current input.
     * @constant
     */
    FAILED: "failed",

    /**
     * Indicates a great circle path.
     * @constant
     */
    GREAT_CIRCLE: "greatCircle",

    /**
     * Indicates a linear, straight line path.
     * @constant
     */
    LINEAR: "linear",

    /**
     * Indicates a multi-point shape, typically within a shapefile.
     */
    MULTI_POINT: "multiPoint",

    /**
     * Indicates the cardinal direction north.
     * @constant
     */
    NORTH: "north",

    /**
     * Indicates a null shape, typically within a shapefile.
     * @constant
     */
    NULL: "null",

    /**
     * Indicates that the associated parameters are fractional values of the virtual rectangle's width or
     * height in the range [0, 1], where 0 indicates the rectangle's origin and 1 indicates the corner
     * opposite its origin.
     * @constant
     */
    OFFSET_FRACTION: "fraction",

    /**
     * Indicates that the associated parameters are in units of pixels relative to the virtual rectangle's
     * corner opposite its origin corner.
     * @constant
     */
    OFFSET_INSET_PIXELS: "insetPixels",

    /**
     * Indicates that the associated parameters are in units of pixels relative to the virtual rectangle's
     * origin.
     * @constant
     */
    OFFSET_PIXELS: "pixels",

    /**
     * Indicates a point shape, typically within a shapefile.
     */
    POINT: "point",

    /**
     * Indicates a polyline shape, typically within a shapefile.
     */
    POLYLINE: "polyline",

    /**
     * Indicates a polygon shape, typically within a shapefile.
     */
    POLYGON: "polygon",

    /**
     * The POSSIBLE gesture recognizer state. Gesture recognizers in this state are idle when there is no input
     * event to evaluate, or are evaluating input events to determine whether or not to transition into another
     * state.
     * @constant
     */
    POSSIBLE: "possible",

    /**
     * The RECOGNIZED gesture recognizer state. Discrete gesture recognizers transition to this state from the
     * POSSIBLE state when the gesture is recognized.
     * @constant
     */
    RECOGNIZED: "recognized",

    /**
     * The event name of World Wind redraw events.
     */
    REDRAW_EVENT_TYPE: "WorldWindRedraw",

    /**
     * Indicates that the related value is specified relative to the globe.
     * @constant
     */
    RELATIVE_TO_GLOBE: "relativeToGlobe",

    /**
     * Indicates an altitude mode relative to the terrain.
     * @constant
     */
    RELATIVE_TO_GROUND: "relativeToGround",

    /**
     * Indicates that the related value is specified relative to the plane of the screen.
     * @constant
     */
    RELATIVE_TO_SCREEN: "relativeToScreen",

    /**
     * Indicates a rhumb path -- a path of constant bearing.
     * @constant
     */
    RHUMB_LINE: "rhumbLine",

    /**
     * Indicates the cardinal direction south.
     * @constant
     */
    SOUTH: "south",

    /**
     * Indicates the cardinal direction west.
     * @constant
     */
    WEST: "west"
};





/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

var globe = __webpack_require__(34);

var switchGlobe = document.querySelector("#switch-globe");
switchGlobe.onclick = function(){
    globe.switchGlobe();
    switchGlobe.innerHTML = switchGlobe.innerHTML == "2D" ? "3D" : "2D";
};




/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports WorldWindow
 * @version $Id: WorldWindow.js 3402 2015-08-14 17:28:09Z tgaskins $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(1),
        __webpack_require__(44),
        __webpack_require__(64),
        __webpack_require__(53),
        __webpack_require__(15),
        __webpack_require__(38),
        __webpack_require__(87),
        __webpack_require__(35),
        __webpack_require__(0),
        __webpack_require__(70),
        __webpack_require__(20),
        __webpack_require__(42),
        __webpack_require__(9),
        __webpack_require__(3),
        __webpack_require__(33),
        __webpack_require__(51),
        __webpack_require__(30),
        __webpack_require__(14)], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
              DrawContext,
              EarthElevationModel,
              FrameStatistics,
              Globe,
              Globe2D,
              GoToAnimator,
              GpuResourceCache,
              Logger,
              LookAtNavigator,
              NavigatorState,
              PickedObjectList,
              Rectangle,
              Sector,
              SurfaceShape,
              SurfaceShapeTileBuilder,
              Terrain,
              Vec2) {
        "use strict";

        /**
         * Constructs a World Wind window for an HTML canvas.
         * @alias WorldWindow
         * @constructor
         * @classdesc Represents a World Wind window for an HTML canvas.
         * @param {String} canvasName The name assigned to the HTML canvas in the document.
         * @param {ElevationModel} elevationModel An optional argument indicating the elevation model to use for the World
         * Window. If missing or null, a default elevation model is used.
         * @throws {ArgumentError} If there is no HTML element with the specified name in the document, or if the
         * HTML canvas does not support WebGL.
         */
        var WorldWindow = function (canvasName, elevationModel) {
            if (!(window.WebGLRenderingContext)) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "WorldWindow", "constructor",
                        "The specified canvas does not support WebGL."));
            }

            // Attempt to get the HTML canvas with the specified name.
            var canvas = document.getElementById(canvasName);
            if (!canvas) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "WorldWindow", "constructor",
                        "The specified canvas name is not in the document."));
            }

            // Create the WebGL context associated with the HTML canvas.
            var gl = this.createContext(canvas);

            // Internal. Intentionally not documented.
            this.drawContext = new DrawContext(gl);

            // Internal. Intentionally not documented. Must be initialized before the navigator is created.
            this.eventListeners = {};

            // Internal. Intentionally not documented. Initially true in order to redraw at least once.
            this.redrawRequested = true;

            // Internal. Intentionally not documented.
            this.redrawRequestId = null;

            /**
             * The HTML canvas associated with this World Window.
             * @type {HTMLElement}
             * @readonly
             */
            this.canvas = canvas;

            /**
             * The number of bits in the depth buffer associated with this World Window.
             * @type {number}
             * @readonly
             */
            this.depthBits = gl.getParameter(gl.DEPTH_BITS);

            /**
             * The current viewport of this World Window.
             * @type {Rectangle}
             * @readonly
             */
            this.viewport = new Rectangle(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);

            /**
             * The globe displayed.
             * @type {Globe}
             */
            this.globe = new Globe(elevationModel || new EarthElevationModel());

            /**
             * The layers to display in this world window.
             * This property is read-only. Use [addLayer]{@link WorldWindow#addLayer} or
             * [insertLayer]{@link WorldWindow#insertLayer} to add layers to this world window.
             * Use [removeLayer]{@link WorldWindow#removeLayer} to remove layers from this world window.
             * @type {Layer[]}
             * @readonly
             */
            this.layers = [];

            /**
             * The navigator used to manipulate the globe.
             * @type {LookAtNavigator}
             * @default [LookAtNavigator]{@link LookAtNavigator}
             */
            this.navigator = new LookAtNavigator(this);

            /**
             * The vertical exaggeration to apply to the terrain.
             * @type {Number}
             */
            this.verticalExaggeration = 1;

            /**
             * Indicates that picking will return all objects at the pick point, if any. The top-most object will have
             * its isOnTop flag set to true.
             * If deep picking is false, the default, only the top-most object is returned, plus
             * the picked-terrain object if the pick point is over the terrain.
             * @type {boolean}
             * @default false
             */
            this.deepPicking = false;

            /**
             * Indicates whether this World Window should be configured for sub-surface rendering. If true, shapes
             * below the terrain can be seen when the terrain is made transparent. If false, sub-surface shapes are
             * not visible, however, performance is slightly increased.
             * @type {boolean}
             * @default false
             */
            this.subsurfaceMode = false;

            /**
             * The opacity to apply to terrain and surface shapes. This property is typically used when viewing
             * the sub-surface. It modifies the opacity of the terrain and surface shapes as a whole. It should be
             * a number between 0 and 1. It is compounded with the individual opacities of the image layers and
             * surface shapes on the terrain.
             * @type {Number}
             * @default 1
             */
            this.surfaceOpacity = 1;

            /**
             * Performance statistics for this WorldWindow.
             * @type {FrameStatistics}
             */
            this.frameStatistics = new FrameStatistics();

            /**
             * The {@link GoToAnimator} used by this world window to respond to its goTo method.
             * @type {GoToAnimator}
             */
            this.goToAnimator = new GoToAnimator(this);

            // Documented with its property accessor below.
            this._redrawCallbacks = [];

            // Documented with its property accessor below.
            this._orderedRenderingFilters = [
                function (dc) {
                    thisWindow.declutter(dc, 1);
                },
                function (dc) {
                    thisWindow.declutter(dc, 2);
                }
            ];

            // Intentionally not documented.
            this.pixelScale = 1;

            // Set up to handle WebGL context lost events.
            var thisWindow = this;

            function handleContextLost(event) {
                thisWindow.handleContextLost(event);
            }

            this.canvas.addEventListener("webglcontextlost", handleContextLost, false);

            // Set up to handle WebGL context restored events.
            function handleContextRestored(event) {
                thisWindow.handleContextRestored(event);
            }

            this.canvas.addEventListener("webglcontextrestored", handleContextRestored, false);

            // Set up to handle WebGL context events and World Wind redraw request events. Imagery uses the canvas
            // redraw events because images are generally specific to the WebGL context associated with the canvas.
            // Elevation models use the global window redraw events because they can be shared among world windows.
            function handleRedrawEvent(event) {
                thisWindow.handleRedrawEvent(event)
            }

            this.canvas.addEventListener(WorldWind.REDRAW_EVENT_TYPE, handleRedrawEvent, false);
            window.addEventListener(WorldWind.REDRAW_EVENT_TYPE, handleRedrawEvent, false);

            // Render to the WebGL context in an animation frame loop until the WebGL context is lost.
            this.animationFrameLoop();
        };

        Object.defineProperties(WorldWindow.prototype, {
            /**
             * An array of functions to call during ordered rendering prior to rendering the ordered renderables.
             * Each function is passed one argument, the current draw context. The function may modify the
             * ordered renderables in the draw context's ordered renderable list, which has been sorted from front
             * to back when the filter function is called. Ordered rendering filters are typically used to apply
             * decluttering. The default set of filter functions contains one function that declutters shapes with
             * declutter group ID of 1 ({@link GeographicText} by default) and one function that declutters shapes
             * with declutter group ID 2 ({@link Placemark} by default). Applications can add functions to this
             * array or remove them.
             * @type {Function[]}
             * @default [WorldWindow.declutter]{@link WorldWindow#declutter} with a group ID of 1
             * @readonly
             * @memberof WorldWindow.prototype
             */
            orderedRenderingFilters: {
                get: function () {
                    return this._orderedRenderingFilters;
                }
            },
            /**
             * The list of callbacks to call immediately before and immediately after performing a redraw. The callbacks
             * have two arguments: this world window and the redraw stage, e.g., <code style='white-space:nowrap'>redrawCallback(worldWindow, stage);</code>.
             * The stage will be either WorldWind.BEFORE_REDRAW or WorldWind.AFTER_REDRAW indicating whether the
             * callback has been called either immediately before or immediately after a redraw, respectively.
             * Applications may add functions to this array or remove them.
             * @type {Function[]}
             * @readonly
             * @memberof WorldWindow.prototype
             */
            redrawCallbacks: {
                get: function () {
                    return this._redrawCallbacks;
                }
            }
        });

        /**
         * Converts window coordinates to coordinates relative to this World Window's canvas.
         * @param {Number} x The X coordinate to convert.
         * @param {Number} y The Y coordinate to convert.
         * @returns {Vec2} The converted coordinates.
         */
        WorldWindow.prototype.canvasCoordinates = function (x, y) {
            var bbox = this.canvas.getBoundingClientRect(),
                xc = x - (bbox.left + this.canvas.clientLeft),// * (this.canvas.width / bbox.width),
                yc = y - (bbox.top + this.canvas.clientTop);// * (this.canvas.height / bbox.height);

            return new Vec2(xc, yc);
        };

        /**
         * Registers an event listener for the specified event type on this World Window's canvas. This function
         * delegates the processing of events to the World Window's canvas. For details on this function and its
         * arguments, see the W3C [EventTarget]{@link https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget}
         * documentation.
         *
         * Registering event listeners using this function enables applications to prevent the World Window's default
         * navigation behavior. To prevent default navigation behavior, call the [Event]{@link https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-Event}'s
         * preventDefault method from within an event listener for any events the navigator should not respond to.
         *
         * When an event occurs, this calls the registered event listeners in order of reverse registration. Since the
         * World Window registers its navigator event listeners first, application event listeners are called before
         * navigator event listeners.
         *
         * @param type The event type to listen for.
         * @param listener The function to call when the event occurs.
         * @throws {ArgumentError} If any argument is null or undefined.
         */
        WorldWindow.prototype.addEventListener = function (type, listener) {
            if (!type) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "WorldWindow", "addEventListener", "missingType"));
            }

            if (!listener) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "WorldWindow", "addEventListener", "missingListener"));
            }

            var thisWorldWindow = this;
            var entry = this.eventListeners[type];
            if (!entry) {
                entry = {
                    listeners: [],
                    callback: function (event) { // calls listeners in reverse registration order
                        event.worldWindow = thisWorldWindow;
                        for (var i = 0, len = entry.listeners.length; i < len; i++) {
                            entry.listeners[i](event);
                        }
                    }
                };
                this.eventListeners[type] = entry;
            }

            var index = entry.listeners.indexOf(listener);
            if (index == -1) { // suppress duplicate listeners
                entry.listeners.splice(0, 0, listener); // insert the listener at the beginning of the list

                if (entry.listeners.length == 1) { // first listener added, add the event listener callback
                    this.canvas.addEventListener(type, entry.callback, false);
                }
            }
        };

        /**
         * Removes an event listener for the specified event type from this World Window's canvas. The listener must be
         * the same object passed to addEventListener. Calling removeEventListener with arguments that do not identify a
         * currently registered listener has no effect.
         *
         * @param type Indicates the event type the listener registered for.
         * @param listener The listener to remove. Must be the same function object passed to addEventListener.
         * @throws {ArgumentError} If any argument is null or undefined.
         */
        WorldWindow.prototype.removeEventListener = function (type, listener) {
            if (!type) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "WorldWindow", "removeEventListener", "missingType"));
            }

            if (!listener) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "WorldWindow", "removeEventListener", "missingListener"));
            }

            var entry = this.eventListeners[type];
            if (!entry) {
                return; // no entry for the specified type
            }

            var index = entry.listeners.indexOf(listener);
            if (index != -1) {
                entry.listeners.splice(index, 1); // remove the listener from the list

                if (entry.listeners.length == 0) { // last listener removed, remove the event listener callback
                    this.canvas.removeEventListener(type, entry.callback, false);
                }
            }
        };

        /**
         * Causes this World Window to redraw itself at the next available opportunity. The redraw occurs on the main
         * thread at a time of the browser's discretion. Applications should call redraw after changing the World
         * Window's state, but should not expect that change to be reflected on screen immediately after this function
         * returns. This is the preferred method for requesting a redraw of the World Window.
         */
        WorldWindow.prototype.redraw = function () {
            this.redrawRequested = true; // redraw during the next animation frame
        };

        /**
         * Requests the World Wind objects displayed at a specified screen-coordinate point.
         *
         * If the point intersects the terrain, the returned list contains an object identifying the associated geographic
         * position. This returns an empty list when nothing in the World Wind scene intersects the specified point.
         *
         * @param pickPoint The point to examine in this World Window's screen coordinates.
         * @returns {PickedObjectList} A list of picked World Wind objects at the specified pick point.
         * @throws {ArgumentError} If the specified pick point is null or undefined.
         */
        WorldWindow.prototype.pick = function (pickPoint) {
            if (!pickPoint) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "WorldWindow", "pick", "missingPoint"));
            }

            // Suppress the picking operation and return an empty list when the WebGL context has been lost.
            if (this.drawContext.currentGlContext.isContextLost()) {
                return new PickedObjectList();
            }

            this.resize();
            this.resetDrawContext();
            this.drawContext.pickingMode = true;
            this.drawContext.pickPoint = pickPoint;
            this.drawFrame();

            return this.drawContext.objectsAtPickPoint;
        };

        /**
         * Requests the position of the World Wind terrain at a specified screen-coordinate point. If the point
         * intersects the terrain, the returned list contains a single object identifying the associated geographic
         * position. Otherwise this returns an empty list.
         * @param pickPoint The point to examine in this World Window's screen coordinates.
         * @returns {PickedObjectList} A list containing the picked World Wind terrain position at the specified point,
         * or an empty list if the point does not intersect the terrain.
         * @throws {ArgumentError} If the specified pick point is null or undefined.
         */
        WorldWindow.prototype.pickTerrain = function (pickPoint) {
            if (!pickPoint) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "WorldWindow", "pickTerrain", "missingPoint"));
            }

            // Suppress the picking operation and return an empty list when the WebGL context has been lost.
            if (this.drawContext.currentGlContext.isContextLost()) {
                return new PickedObjectList();
            }

            this.resize();
            this.resetDrawContext();
            this.drawContext.pickingMode = true;
            this.drawContext.pickTerrainOnly = true;
            this.drawContext.pickPoint = pickPoint;
            this.drawFrame();

            return this.drawContext.objectsAtPickPoint;
        };

        /**
         * Requests the World Wind objects displayed within a specified screen-coordinate region. This returns all
         * objects that intersect the specified region, regardless of whether or not an object is actually visible, and
         * marks objects that are visible as on top.
         * @param {Rectangle} rectangle The screen coordinate rectangle identifying the region to search.
         * @returns {PickedObjectList} A list of visible World Wind objects within the specified region.
         * @throws {ArgumentError} If the specified rectangle is null or undefined.
         */
        WorldWindow.prototype.pickShapesInRegion = function (rectangle) {
            if (!rectangle) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "WorldWindow", "pickShapesInRegion", "missingRectangle"));
            }

            // Suppress the picking operation and return an empty list when the WebGL context has been lost.
            if (this.drawContext.currentGlContext.isContextLost()) {
                return new PickedObjectList();
            }

            this.resize();
            this.resetDrawContext();
            this.drawContext.pickingMode = true;
            this.drawContext.regionPicking = true;
            this.drawContext.pickRectangle =
                new Rectangle(rectangle.x, this.canvas.height - rectangle.y, rectangle.width, rectangle.height);
            this.drawFrame();

            return this.drawContext.objectsAtPickPoint;
        };

        // Internal function. Intentionally not documented.
        WorldWindow.prototype.createContext = function (canvas) {
            // Request a WebGL context with antialiasing is disabled. Antialiasing causes gaps to appear at the edges of
            // terrain tiles.
            var glAttrs = {antialias: false, stencil: true},
                gl = canvas.getContext("webgl", glAttrs);
            if (!gl) {
                gl = canvas.getContext("experimental-webgl", glAttrs);
            }

            var actualAttributes = gl.getContextAttributes();
            this.hasStencilBuffer = actualAttributes.stencil;

            // uncomment to debug WebGL
            //var gl = WebGLDebugUtils.makeDebugContext(this.canvas.getContext("webgl"),
            //        this.throwOnGLError,
            //        this.logAndValidate
            //);

            return gl;
        };

        // Internal function. Intentionally not documented.
        WorldWindow.prototype.handleContextLost = function (event) {
            Logger.log(Logger.LEVEL_INFO, "WebGL context event: " + event.statusMessage);
            // Inform WebGL that we handle context restoration, enabling the context restored event to be delivered.
            event.preventDefault();
            // Notify the draw context that the WebGL rendering context has been lost.
            this.drawContext.contextLost();
            // Stop the rendering animation frame loop, resuming only if the WebGL context is restored.
            window.cancelAnimationFrame(this.redrawRequestId);
        };

        // Internal function. Intentionally not documented.
        WorldWindow.prototype.handleContextRestored = function (event) {
            Logger.log(Logger.LEVEL_INFO, "WebGL context event: " + event.statusMessage);
            // Notify the draw context that the WebGL rendering context has been restored.
            this.drawContext.contextRestored();
            // Resume the rendering animation frame loop until the WebGL context is lost.
            this.redraw();
            this.animationFrameLoop();
        };

        // Internal function. Intentionally not documented.
        WorldWindow.prototype.handleRedrawEvent = function (event) {
            this.redraw(); // redraw in the next animation frame
        };

        // Internal function. Intentionally not documented.
        WorldWindow.prototype.animationFrameLoop = function () {
            // Render to the WebGL context as needed.
            this.redrawIfNeeded();

            // Continue the animation frame loop until the WebGL context is lost.
            var thisWindow = this;

            function animationFrameCallback() {
                thisWindow.animationFrameLoop();
            }

            this.redrawRequestId = window.requestAnimationFrame(animationFrameCallback);
        };

        // Internal function. Intentionally not documented.
        WorldWindow.prototype.redrawIfNeeded = function () {
            // Check if the drawing buffer needs to resize to match its screen size, which requires a redraw.
            this.resize();

            // Redraw the WebGL drawing buffer only when necessary.
            if (!this.redrawRequested) {
                return;
            }

            try {
                // Prepare to redraw and notify the redraw callbacks that a redraw is about to occur.
                this.redrawRequested = false;
                this.drawContext.previousRedrawTimestamp = this.drawContext.timestamp;
                this.callRedrawCallbacks(WorldWind.BEFORE_REDRAW);
                // Redraw the WebGL drawing buffer.
                this.resetDrawContext();
                this.drawFrame();
            } catch (e) {
                Logger.logMessage(Logger.LEVEL_SEVERE, "WorldWindow", "redrawIfNeeded",
                    "Exception occurred during redrawing.\n" + e.toString());
            } finally {
                // Notify the redraw callbacks that a redraw has completed.
                this.callRedrawCallbacks(WorldWind.AFTER_REDRAW);
                // Handle rendering code redraw requests.
                if (this.drawContext.redrawRequested) {
                    this.redrawRequested = true;
                }
            }
        };

        // Internal function. Intentionally not documented.
        WorldWindow.prototype.resize = function () {
            var gl = this.drawContext.currentGlContext,
                width = gl.canvas.clientWidth * this.pixelScale,
                height = gl.canvas.clientHeight * this.pixelScale;

            if (gl.canvas.width != width ||
                gl.canvas.height != height) {

                // Make the canvas drawing buffer size match its screen size.
                gl.canvas.width = width;
                gl.canvas.height = height;

                // Set the WebGL viewport to match the canvas drawing buffer size.
                gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
                this.viewport = new Rectangle(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);

                // Cause this World Window to redraw with the new size.
                this.redrawRequested = true;
            }
        };

        // Internal. Intentionally not documented.
        WorldWindow.prototype.resetDrawContext = function () {
            this.globe.offset = 0;

            var dc = this.drawContext;
            dc.reset();
            dc.globe = this.globe;
            dc.layers = this.layers;
            dc.navigatorState = this.navigator.currentState();
            dc.verticalExaggeration = this.verticalExaggeration;
            dc.surfaceOpacity = this.surfaceOpacity;
            dc.deepPicking = this.deepPicking;
            dc.frameStatistics = this.frameStatistics;
            dc.pixelScale = this.pixelScale;
            dc.update();
        };

        /* useful stuff to debug WebGL */
        /*
         function logGLCall(functionName, args) {
         console.log("gl." + functionName + "(" +
         WebGLDebugUtils.glFunctionArgsToString(functionName, args) + ")");
         };

         function validateNoneOfTheArgsAreUndefined(functionName, args) {
         for (var ii = 0; ii < args.length; ++ii) {
         if (args[ii] === undefined) {
         console.error("undefined passed to gl." + functionName + "(" +
         WebGLDebugUtils.glFunctionArgsToString(functionName, args) + ")");
         }
         }
         };

         WorldWindow.prototype.logAndValidate = function logAndValidate(functionName, args) {
         logGLCall(functionName, args);
         validateNoneOfTheArgsAreUndefined (functionName, args);
         };

         WorldWindow.prototype.throwOnGLError = function throwOnGLError(err, funcName, args) {
         throw WebGLDebugUtils.glEnumToString(err) + " was caused by call to: " + funcName;
         };
         */

        // Internal function. Intentionally not documented.
        WorldWindow.prototype.drawFrame = function () {
            try {
                this.drawContext.frameStatistics.beginFrame();
                this.beginFrame();

                if (this.drawContext.globe.is2D() && this.drawContext.globe.continuous) {
                    this.do2DContiguousRepaint();
                } else {
                    this.doNormalRepaint();
                }

            } finally {
                this.endFrame();
                this.drawContext.frameStatistics.endFrame();
                //console.log(this.drawContext.frameStatistics.frameTime);
            }
        };

        WorldWindow.prototype.doNormalRepaint = function () {
            this.createTerrain();
            this.clearFrame();
            this.deferOrderedRendering = false;
            if (this.drawContext.pickingMode) {
                if (this.drawContext.makePickFrustum()) {
                    this.doPick();
                    this.resolvePick();
                }
            } else {
                this.doDraw();
                if (this.subsurfaceMode && this.hasStencilBuffer) {
                    this.redrawSurface();
                    this.drawScreenRenderables();
                }
            }
        };

        WorldWindow.prototype.do2DContiguousRepaint = function () {
            this.createTerrain2DContiguous();
            this.clearFrame();
            if (this.drawContext.pickingMode) {
                if (this.drawContext.makePickFrustum()) {
                    this.pick2DContiguous();
                    this.resolvePick();
                }
            } else {
                this.draw2DContiguous();
            }
        };

        WorldWindow.prototype.resolvePick = function () {
            if (this.drawContext.pickTerrainOnly) {
                this.resolveTerrainPick();
            } else if (this.drawContext.regionPicking) {
                this.resolveRegionPick();
            } else {
                this.resolveTopPick();
            }
        };

        // Internal function. Intentionally not documented.
        WorldWindow.prototype.beginFrame = function () {
            var gl = this.drawContext.currentGlContext;
            gl.enable(gl.BLEND);
            gl.enable(gl.CULL_FACE);
            gl.enable(gl.DEPTH_TEST);
            gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
            gl.depthFunc(gl.LEQUAL);

            if (this.drawContext.pickingMode) {
                this.drawContext.makePickFramebuffer();
                this.drawContext.bindFramebuffer(this.drawContext.pickFramebuffer);
            }
        };

        // Internal function. Intentionally not documented.
        WorldWindow.prototype.endFrame = function () {
            var gl = this.drawContext.currentGlContext;
            gl.disable(gl.BLEND);
            gl.disable(gl.CULL_FACE);
            gl.disable(gl.DEPTH_TEST);
            gl.blendFunc(gl.ONE, gl.ZERO);
            gl.depthFunc(gl.LESS);
            gl.clearColor(0, 0, 0, 1);

            this.drawContext.bindFramebuffer(null);
            this.drawContext.bindProgram(null);
        };

        // Internal function. Intentionally not documented.
        WorldWindow.prototype.clearFrame = function () {
            var dc = this.drawContext,
                gl = dc.currentGlContext;

            gl.clearColor(dc.clearColor.red, dc.clearColor.green, dc.clearColor.blue, dc.clearColor.alpha);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        };

        // Internal function. Intentionally not documented.
        WorldWindow.prototype.doDraw = function () {
            this.drawContext.renderShapes = true;

            if (this.subsurfaceMode && this.hasStencilBuffer) {
                // Draw the surface and collect the ordered renderables.
                this.drawContext.currentGlContext.disable(this.drawContext.currentGlContext.STENCIL_TEST);
                this.drawContext.surfaceShapeTileBuilder.clear();
                this.drawLayers(true);
                this.drawSurfaceRenderables();
                this.drawContext.surfaceShapeTileBuilder.doRender(this.drawContext);

                if (!this.deferOrderedRendering) {
                    // Clear the depth and stencil buffers prior to rendering the ordered renderables. This allows
                    // sub-surface renderables to be drawn beneath the terrain. Turn on stenciling to capture the
                    // fragments that ordered renderables draw. The terrain and surface shapes will be subsequently
                    // drawn again, and the stencil buffer will ensure that they are drawn only where they overlap
                    // the fragments drawn by the ordered renderables.
                    this.drawContext.currentGlContext.clear(
                        this.drawContext.currentGlContext.DEPTH_BUFFER_BIT | this.drawContext.currentGlContext.STENCIL_BUFFER_BIT);
                    this.drawContext.currentGlContext.enable(this.drawContext.currentGlContext.STENCIL_TEST);
                    this.drawContext.currentGlContext.stencilFunc(this.drawContext.currentGlContext.ALWAYS, 1, 1);
                    this.drawContext.currentGlContext.stencilOp(
                        this.drawContext.currentGlContext.REPLACE, this.drawContext.currentGlContext.REPLACE, this.drawContext.currentGlContext.REPLACE);
                    this.drawOrderedRenderables();

                    this.drawContext.screenCreditController.drawCredits(this.drawContext);
                }
            } else {
                this.drawContext.surfaceShapeTileBuilder.clear();
                this.drawLayers(true);
                this.drawSurfaceRenderables();
                this.drawContext.surfaceShapeTileBuilder.doRender(this.drawContext);

                if (!this.deferOrderedRendering) {
                    this.drawOrderedRenderables();
                    this.drawScreenRenderables();
                }

                this.drawContext.screenCreditController.drawCredits(this.drawContext);
            }
        };

        WorldWindow.prototype.redrawSurface = function () {
            // Draw the terrain and surface shapes but only where the current stencil buffer is non-zero.
            // The non-zero fragments are from drawing the ordered renderables previously.
            this.drawContext.currentGlContext.enable(this.drawContext.currentGlContext.STENCIL_TEST);
            this.drawContext.currentGlContext.stencilFunc(this.drawContext.currentGlContext.EQUAL, 1, 1);
            this.drawContext.currentGlContext.stencilOp(
                this.drawContext.currentGlContext.KEEP, this.drawContext.currentGlContext.KEEP, this.drawContext.currentGlContext.KEEP);
            this.drawContext.surfaceShapeTileBuilder.clear();
            this.drawLayers(false);
            this.drawSurfaceRenderables();
            this.drawContext.surfaceShapeTileBuilder.doRender(this.drawContext);
            this.drawContext.currentGlContext.disable(this.drawContext.currentGlContext.STENCIL_TEST);
        };

        // Internal function. Intentionally not documented.
        WorldWindow.prototype.doPick = function () {
            if (this.drawContext.terrain) {
                this.drawContext.terrain.pick(this.drawContext);
            }

            if (!this.drawContext.pickTerrainOnly) {
                if (this.subsurfaceMode && this.hasStencilBuffer) {
                    // Draw the surface and collect the ordered renderables.
                    this.drawContext.currentGlContext.disable(this.drawContext.currentGlContext.STENCIL_TEST);
                    this.drawContext.surfaceShapeTileBuilder.clear();
                    this.drawLayers(true);
                    this.drawSurfaceRenderables();
                    this.drawContext.surfaceShapeTileBuilder.doRender(this.drawContext);

                    if (!this.deferOrderedRendering) {
                        // Clear the depth and stencil buffers prior to rendering the ordered renderables. This allows
                        // sub-surface renderables to be drawn beneath the terrain. Turn on stenciling to capture the
                        // fragments that ordered renderables draw. The terrain and surface shapes will be subsequently
                        // drawn again, and the stencil buffer will ensure that they are drawn only where they overlap
                        // the fragments drawn by the ordered renderables.
                        this.drawContext.currentGlContext.clear(
                            this.drawContext.currentGlContext.DEPTH_BUFFER_BIT | this.drawContext.currentGlContext.STENCIL_BUFFER_BIT);
                        this.drawContext.currentGlContext.enable(this.drawContext.currentGlContext.STENCIL_TEST);
                        this.drawContext.currentGlContext.stencilFunc(this.drawContext.currentGlContext.ALWAYS, 1, 1);
                        this.drawContext.currentGlContext.stencilOp(
                            this.drawContext.currentGlContext.REPLACE, this.drawContext.currentGlContext.REPLACE, this.drawContext.currentGlContext.REPLACE);
                        this.drawOrderedRenderables();
                        this.drawContext.terrain.pick(this.drawContext);
                        this.drawScreenRenderables();
                    }
                } else {
                    this.drawContext.surfaceShapeTileBuilder.clear();

                    this.drawLayers(true);
                    this.drawSurfaceRenderables();

                    this.drawContext.surfaceShapeTileBuilder.doRender(this.drawContext);

                    if (!this.deferOrderedRendering) {
                        this.drawOrderedRenderables();
                        this.drawScreenRenderables();
                    }
                }
            }
        };

        // Internal function. Intentionally not documented.
        WorldWindow.prototype.createTerrain = function () {
            var dc = this.drawContext;
            dc.terrain = this.globe.tessellator.tessellate(dc);
            dc.frameStatistics.setTerrainTileCount(dc.terrain ? dc.terrain.surfaceGeometry.length : 0);
        };

        WorldWindow.prototype.makeCurrent = function (offset) {
            var dc = this.drawContext;
            dc.globe.offset = offset;
            dc.globeStateKey = dc.globe.stateKey;

            switch (offset) {
                case -1:
                    dc.terrain = this.terrainLeft;
                    break;

                case 0:
                    dc.terrain = this.terrainCenter;
                    break;

                case 1:
                    dc.terrain = this.terrainRight;
                    break;
            }
        };

        WorldWindow.prototype.createTerrain2DContiguous = function () {
            var dc = this.drawContext;

            this.terrainCenter = null;
            dc.globe.offset = 0;
            dc.globeStateKey = dc.globe.stateKey;
            if (dc.globe.intersectsFrustum(dc.navigatorState.frustumInModelCoordinates)) {
                this.terrainCenter = dc.globe.tessellator.tessellate(dc);
            }

            this.terrainRight = null;
            dc.globe.offset = 1;
            dc.globeStateKey = dc.globe.stateKey;
            if (dc.globe.intersectsFrustum(dc.navigatorState.frustumInModelCoordinates)) {
                this.terrainRight = dc.globe.tessellator.tessellate(dc);
            }

            this.terrainLeft = null;
            dc.globe.offset = -1;
            dc.globeStateKey = dc.globe.stateKey;
            if (dc.globe.intersectsFrustum(dc.navigatorState.frustumInModelCoordinates)) {
                this.terrainLeft = dc.globe.tessellator.tessellate(dc);
            }
        };

        WorldWindow.prototype.draw2DContiguous = function () {
            var drawing = "";

            if (this.terrainCenter) {
                drawing += " 0 ";
                this.makeCurrent(0);
                this.deferOrderedRendering = this.terrainLeft || this.terrainRight;
                this.doDraw();
            }

            if (this.terrainRight) {
                drawing += " 1 ";
                this.makeCurrent(1);
                this.deferOrderedRendering = this.terrainLeft || this.terrainLeft;
                this.doDraw();
            }

            this.deferOrderedRendering = false;

            if (this.terrainLeft) {
                drawing += " -1 ";
                this.makeCurrent(-1);
                this.doDraw();
            }
            //
            //console.log(drawing);

            if (this.subsurfaceMode && this.hasStencilBuffer) {
                this.deferOrderedRendering = true;

                if (this.terrainCenter) {
                    drawing += " 0 ";
                    this.makeCurrent(0);
                    this.redrawSurface();
                }

                if (this.terrainRight) {
                    drawing += " 1 ";
                    this.makeCurrent(1);
                    this.redrawSurface();
                }

                if (this.terrainLeft) {
                    drawing += " -1 ";
                    this.makeCurrent(-1);
                    this.redrawSurface();
                }
            }

            this.drawScreenRenderables();
        };

        WorldWindow.prototype.pick2DContiguous = function () {
            if (this.terrainCenter) {
                this.makeCurrent(0);
                this.deferOrderedRendering = this.terrainLeft || this.terrainRight;
                this.doPick();
            }

            if (this.terrainRight) {
                this.makeCurrent(1);
                this.deferOrderedRendering = this.terrainLeft || this.terrainLeft;
                this.doPick();
            }

            this.deferOrderedRendering = false;

            if (this.terrainLeft) {
                this.makeCurrent(-1);
                this.doPick();
            }
        };

        // Internal function. Intentionally not documented.
        WorldWindow.prototype.drawLayers = function (accumulateOrderedRenderables) {
            // Draw all the layers attached to this WorldWindow.

            var beginTime = Date.now(),
                dc = this.drawContext,
                layers = dc.layers,
                layer;

            dc.accumulateOrderedRenderables = accumulateOrderedRenderables;

            for (var i = 0, len = layers.length; i < len; i++) {
                layer = layers[i];
                if (layer) {
                    dc.currentLayer = layer;
                    try {
                        layer.render(dc);
                    } catch (e) {
                        Logger.log(Logger.LEVEL_SEVERE, "Error while rendering layer " + layer.displayName + ".\n"
                            + e.toString());
                        // Keep going. Render the rest of the layers.
                    }
                }
            }

            var now = Date.now();
            dc.frameStatistics.layerRenderingTime = now - beginTime;
        };

        /**
         * Adds a specified layer to the end of this world window.
         * @param {Layer} layer The layer to add. May be null or undefined, in which case this world window is not modified.
         */
        WorldWindow.prototype.addLayer = function (layer) {
            this.layers.push(layer);
        };

        /**
         * Removes the first instance of a specified layer from this world window.
         * @param {Layer} layer The layer to remove. May be null or undefined, in which case this world window is not
         * modified. This world window is also not modified if the specified layer does not exist in this world
         * window's layer list.
         */
        WorldWindow.prototype.removeLayer = function (layer) {
            if (!layer)
                return;

            var index = -1;
            for (var i = 0, len = this.layers.length; i < len; i++) {
                if (this.layers[i] == layer) {
                    index = i;
                    break;
                }
            }

            if (index >= 0) {
                this.layers.splice(index, 1);
            }
        };

        /**
         * Inserts a specified layer at a specified position in this world window's layer list.
         * @param {number} index The index at which to insert the layer. May be negative to specify the position
         * from the end of the array.
         * @param {Layer} layer The layer to insert. This world window's layer list is not changed if the specified
         * layer is null or undefined.
         */
        WorldWindow.prototype.insertLayer = function (index, layer) {
            if (layer) {
                this.layers.splice(index, 0, layer);
            }
        };

        // Internal function. Intentionally not documented.
        WorldWindow.prototype.drawSurfaceRenderables = function () {
            var dc = this.drawContext,
                sr;

            dc.reverseSurfaceRenderables();

            while (sr = dc.popSurfaceRenderable()) {
                try {
                    sr.renderSurface(dc);
                } catch (e) {
                    Logger.logMessage(Logger.LEVEL_WARNING, "WorldWindow", "drawSurfaceRenderables",
                        "Error while rendering a surface renderable.\n" + e.message);
                    // Keep going. Render the rest of the surface renderables.
                }
            }
        };

        // Internal function. Intentionally not documented.
        WorldWindow.prototype.drawOrderedRenderables = function () {
            var beginTime = Date.now(),
                dc = this.drawContext,
                or;

            dc.sortOrderedRenderables();

            if (this._orderedRenderingFilters) {
                for (var f = 0; f < this._orderedRenderingFilters.length; f++) {
                    this._orderedRenderingFilters[f](this.drawContext);
                }
            }

            dc.orderedRenderingMode = true;

            while (or = dc.popOrderedRenderable()) {
                try {
                    or.renderOrdered(dc);
                } catch (e) {
                    Logger.logMessage(Logger.LEVEL_WARNING, "WorldWindow", "drawOrderedRenderables",
                        "Error while rendering an ordered renderable.\n" + e.message);
                    // Keep going. Render the rest of the ordered renderables.
                }
            }

            dc.orderedRenderingMode = false;
            dc.frameStatistics.orderedRenderingTime = Date.now() - beginTime;
        };

        WorldWindow.prototype.drawScreenRenderables = function () {
            var dc = this.drawContext,
                or;

            while (or = dc.nextScreenRenderable()) {
                try {
                    or.renderOrdered(dc);
                } catch (e) {
                    Logger.logMessage(Logger.LEVEL_WARNING, "WorldWindow", "drawOrderedRenderables",
                        "Error while rendering a screen renderable.\n" + e.message);
                    // Keep going. Render the rest of the screen renderables.
                }
            }
        };

        // Internal function. Intentionally not documented.
        WorldWindow.prototype.resolveTopPick = function () {
            if (this.drawContext.objectsAtPickPoint.objects.length == 0) {
                return; // nothing picked; avoid calling readPickColor unnecessarily
            }

            // Make a last reading to determine what's on top.

            var pickedObjects = this.drawContext.objectsAtPickPoint,
                pickColor = this.drawContext.readPickColor(this.drawContext.pickPoint),
                topObject = null,
                terrainObject = null;

            if (pickColor) {
                // Find the picked object with the top color code and set its isOnTop flag.
                for (var i = 0, len = pickedObjects.objects.length; i < len; i++) {
                    var po = pickedObjects.objects[i];

                    if (po.isTerrain) {
                        terrainObject = po;
                    }

                    if (po.color.equals(pickColor)) {
                        po.isOnTop = true;
                        topObject = po;

                        if (terrainObject) {
                            break; // no need to search for more than the top object and the terrain object
                        }
                    }
                }

                // In single-pick mode provide only the top-most object and the terrain object, if any.
                if (!this.drawContext.deepPicking) {
                    pickedObjects.clear();
                    if (topObject) {
                        pickedObjects.add(topObject);
                    }
                    if (terrainObject && terrainObject != topObject) {
                        pickedObjects.add(terrainObject);
                    }
                }
            } else {
                pickedObjects.clear(); // nothing drawn at the pick point
            }
        };

        // Internal. Intentionally not documented.
        WorldWindow.prototype.resolveTerrainPick = function () {
            var pickedObjects = this.drawContext.objectsAtPickPoint,
                po;

            // Mark the first picked terrain object as "on top". The picked object list should contain only one entry
            // indicating the picked terrain object, but we iterate over the list contents anyway.
            for (var i = 0, len = pickedObjects.objects.length; i < len; i++) {
                po = pickedObjects.objects[i];
                if (po.isTerrain) {
                    po.isOnTop = true;
                    break;
                }
            }
        };

        // Internal. Intentionally not documented.
        WorldWindow.prototype.resolveRegionPick = function () {
            if (this.drawContext.objectsAtPickPoint.objects.length == 0) {
                return; // nothing picked; avoid calling readPickColors unnecessarily
            }

            // Mark every picked object with a color in the pick buffer as "on top".

            var pickedObjects = this.drawContext.objectsAtPickPoint,
                uniquePickColors = this.drawContext.readPickColors(this.drawContext.pickRectangle),
                po,
                color;

            for (var i = 0, len = pickedObjects.objects.length; i < len; i++) {
                po = pickedObjects.objects[i];
                if (!po) continue;
                var poColor = po.color.toByteString();
                color = uniquePickColors[poColor];
                if (color) {
                    po.isOnTop = true;
                } else if (po.userObject instanceof SurfaceShape) {
                    // SurfaceShapes ALWAYS get added to the pick list, since their rendering is deferred
                    // until the tile they are cached by is rendered. So a SurfaceShape may be in the pick list
                    // but is not seen in the pick rectangle.
                    //
                    // Remove the SurfaceShape that was not visible to the pick rectangle.
                    pickedObjects.objects.splice(i, 1);
                    i -= 1;
                }
            }
        };

        // Internal. Intentionally not documented.
        WorldWindow.prototype.callRedrawCallbacks = function (stage) {
            for (var i = 0, len = this._redrawCallbacks.length; i < len; i++) {
                try {
                    this._redrawCallbacks[i](this, stage);
                } catch (e) {
                    Logger.log(Logger.LEVEL_SEVERE, "Exception calling redraw callback.\n" + e.toString());
                    // Keep going. Execute the rest of the callbacks.
                }
            }
        };

        /**
         * Moves this world window's navigator to a specified location or position.
         * @param {Location | Position} position The location or position to move the navigator to. If this
         * argument contains an "altitude" property, as {@link Position} does, the end point of the navigation is
         * at the specified altitude. Otherwise the end point is at the current altitude of the navigator.
         *
         * This function uses this world window's {@link GoToAnimator} property to perform the move. That object's
         * properties can be specified by the application to modify its behavior during calls to this function.
         * It's cancel method can also be used to cancel the move initiated by this function.
         * @param {Function} completionCallback If not null or undefined, specifies a function to call when the
         * animation completes. The completion callback is called with a single argument, this animator.
         * @throws {ArgumentError} If the specified location or position is null or undefined.
         */
        WorldWindow.prototype.goTo = function (position, completionCallback) {
            this.goToAnimator.goTo(position, completionCallback);
        };

        /**
         * Declutters the current ordered renderables with a specified group ID. This function is not called by
         * applications directly. It's meant to be invoked as an ordered rendering filter in this World Window's
         * [orderedRenderingFilters]{@link WorldWindow#orderedRenderingFilters} property.
         * <p>
         * The function operates by setting the target visibility of occluded shapes to 0 and unoccluded shapes to 1.
         * @param {DrawContext} dc The current draw context.
         * @param {Number} groupId The ID of the group to declutter. Must not be null, undefined or 0.
         * @throws {ArgumentError} If the specified group ID is null, undefined or 0.
         */
        WorldWindow.prototype.declutter = function (dc, groupId) {
            if (!groupId) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "WorldWindow", "declutter",
                        "Group ID is null, undefined or 0."));
            }

            // Collect all the declutterables in the specified group.
            var declutterables = [];
            for (var i = 0; i < dc.orderedRenderables.length; i++) {
                var orderedRenderable = dc.orderedRenderables[i].orderedRenderable;
                if (orderedRenderable.declutterGroup === groupId) {
                    declutterables.push(orderedRenderable);
                }
            }

            // Filter the declutterables by determining which are partially occluded. Since the ordered renderable
            // list was already sorted from front to back, the front-most will represent an entire occluded group.
            var rects = [];
            for (var j = 0; j < declutterables.length; j++) {
                var declutterable = declutterables[j],
                    screenBounds = declutterable.screenBounds;

                if (screenBounds && screenBounds.intersectsRectangles(rects)) {
                    declutterable.targetVisibility = 0;
                } else {
                    declutterable.targetVisibility = 1;
                    if (screenBounds) {
                        rects.push(screenBounds);
                    }
                }
            }
        };

        return WorldWindow;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports Matrix3
 */

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(1),
        __webpack_require__(0)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
              Logger) {
        "use strict";

        /**
         * Constructs a 3 x 3  matrix.
         * @alias Matrix3
         * @constructor
         * @classdesc Represents a 3 x 3 double precision matrix stored in a Float64Array in row-major order.
         * @param {Number} m11 matrix element at row 1, column 1.
         * @param {Number} m12 matrix element at row 1, column 2.
         * @param {Number} m13 matrix element at row 1, column 3.
         * @param {Number} m21 matrix element at row 2, column 1.
         * @param {Number} m22 matrix element at row 2, column 2.
         * @param {Number} m23 matrix element at row 2, column 3.
         * @param {Number} m31 matrix element at row 3, column 1.
         * @param {Number} m32 matrix element at row 3, column 2.
         * @param {Number} m33 matrix element at row 3, column 3.
         */
        var Matrix3 = function (m11, m12, m13,
                                m21, m22, m23,
                                m31, m32, m33) {
            this[0] = m11;
            this[1] = m12;
            this[2] = m13;
            this[3] = m21;
            this[4] = m22;
            this[5] = m23;
            this[6] = m31;
            this[7] = m32;
            this[8] = m33;
        };

        // Derives from Float64Array.
        Matrix3.prototype = new Float64Array(9);

        /**
         * Creates an identity matrix.
         * @returns {Matrix3} A new identity matrix.
         */
        Matrix3.fromIdentity = function () {
            return new Matrix3(
                1, 0, 0,
                0, 1, 0,
                0, 0, 1
            );
        };

        /**
         * Sets this matrix to one that flips and shifts the y-axis.
         * <p>
         * The resultant matrix maps Y=0 to Y=1 and Y=1 to Y=0. All existing values are overwritten. This matrix is
         * usually used to change the coordinate origin from an upper left coordinate origin to a lower left coordinate
         * origin. This is typically necessary to align the coordinate system of images (top-left origin) with that of
         * OpenGL (bottom-left origin).
         * @returns {Matrix3} This matrix set to values described above.
         */
        Matrix3.prototype.setToUnitYFlip = function () {
            this[0] = 1;
            this[1] = 0;
            this[2] = 0;
            this[3] = 0;
            this[4] = -1;
            this[5] = 1;
            this[6] = 0;
            this[7] = 0;
            this[8] = 1;
            return this;
        };

        /**
         * Multiplies this matrix by a specified matrix.
         *
         * @param {Matrix3} matrix The matrix to multiply with this matrix.
         * @returns {Matrix3} This matrix after multiplying it by the specified matrix.
         * @throws {ArgumentError} if the specified matrix is null or undefined.
         */
        Matrix3.prototype.multiplyMatrix = function (matrix) {
            if (!matrix) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Matrix3", "multiplyMatrix", "missingMatrix"));
            }

            var ma = this,
                mb = matrix,
                ma0, ma1, ma2;

            // Row 1
            ma0 = ma[0];
            ma1 = ma[1];
            ma2 = ma[2];
            ma[0] = (ma0 * mb[0]) + (ma1 * mb[3]) + (ma2 * mb[6]);
            ma[1] = (ma0 * mb[1]) + (ma1 * mb[4]) + (ma2 * mb[7]);
            ma[2] = (ma0 * mb[2]) + (ma1 * mb[5]) + (ma2 * mb[8]);

            // Row 2
            ma0 = ma[3];
            ma1 = ma[4];
            ma2 = ma[5];
            ma[3] = (ma0 * mb[0]) + (ma1 * mb[3]) + (ma2 * mb[6]);
            ma[4] = (ma0 * mb[1]) + (ma1 * mb[4]) + (ma2 * mb[7]);
            ma[5] = (ma0 * mb[2]) + (ma1 * mb[5]) + (ma2 * mb[8]);

            // Row 3
            ma0 = ma[6];
            ma1 = ma[7];
            ma2 = ma[8];
            ma[6] = (ma0 * mb[0]) + (ma1 * mb[3]) + (ma2 * mb[6]);
            ma[7] = (ma0 * mb[1]) + (ma1 * mb[4]) + (ma2 * mb[7]);
            ma[8] = (ma0 * mb[2]) + (ma1 * mb[5]) + (ma2 * mb[8]);

            return this;

        };

        /**
         * Multiplies this matrix by a matrix that transforms normalized coordinates from a source sector to a destination
         * sector. Normalized coordinates within a sector range from 0 to 1, with (0, 0) indicating the lower left corner
         * and (1, 1) indicating the upper right. The resultant matrix maps a normalized source coordinate (X, Y) to its
         * corresponding normalized destination coordinate (X', Y').
         * <p/>
         * This matrix typically necessary to transform texture coordinates from one geographic region to another. For
         * example, the texture coordinates for a terrain tile spanning one region must be transformed to coordinates
         * appropriate for an image tile spanning a potentially different region.
         *
         * @param {Sector} src the source sector
         * @param {Sector} dst the destination sector
         *
         * @returns {Matrix3} this matrix multiplied by the transform matrix implied by values described above
         */
        Matrix3.prototype.multiplyByTileTransform = function (src, dst) {

            var srcDeltaLat = src.deltaLatitude();
            var srcDeltaLon = src.deltaLongitude();
            var dstDeltaLat = dst.deltaLatitude();
            var dstDeltaLon = dst.deltaLongitude();

            var xs = srcDeltaLon / dstDeltaLon;
            var ys = srcDeltaLat / dstDeltaLat;
            var xt = (src.minLongitude - dst.minLongitude) / dstDeltaLon;
            var yt = (src.minLatitude - dst.minLatitude) / dstDeltaLat;

            // This is equivalent to the following operation, but is potentially much faster:
            /*var m = new Matrix3(
                xs, 0, xt,
                0, ys, yt,
                0, 0, 1);
            this.multiplyMatrix(m);*/

            // This inline version eliminates unnecessary multiplication by 1 and 0 in the matrix's components, reducing
            // the total number of primitive operations from 63 to 18.

            var m = this;

             // Must be done before modifying m0, m1, etc. below.
             m[2] += (m[0] * xt) + (m[1] * yt);
             m[5] += (m[3] * xt) + (m[4] * yt);
             m[8] += (m[6] * xt) + (m[6] * yt);

             m[0] *= xs;
             m[1] *= ys;

             m[3] *= xs;
             m[4] *= ys;

             m[6] *= xs;
             m[7] *= ys;

            return this;
        };

        /**
         * Stores this matrix's components in column-major order in a specified array.
         * <p>
         * The array must have space for at least 9 elements. This matrix's components are stored in the array
         * starting with row 0 column 0 in index 0, row 1 column 0 in index 1, row 2 column 0 in index 2, and so on.
         *
         * @param {Float32Array | Float64Array | Number[]} result An array of at least 9 elements. Upon return,
         * contains this matrix's components in column-major.
         * @returns {Float32Array} The specified result array.
         * @throws {ArgumentError} If the specified result array in null or undefined.
         */
        Matrix3.prototype.columnMajorComponents = function (result) {
            if (!result) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Matrix3", "columnMajorComponents", "missingResult"));
            }

            // Column 1
            result[0] = this[0];
            result[1] = this[3];
            result[2] = this[6];

            // Column 2
            result[3] = this[1];
            result[4] = this[4];
            result[5] = this[7];

            // Column 3
            result[6] = this[2];
            result[7] = this[5];
            result[8] = this[8];

            return result;
        };

        return Matrix3;

    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports DragRecognizer
 * @version $Id: DragRecognizer.js 3223 2015-06-19 23:16:36Z dcollins $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(19)], __WEBPACK_AMD_DEFINE_RESULT__ = function (GestureRecognizer) {
        "use strict";

        /**
         * Constructs a mouse drag gesture recognizer.
         * @alias DragRecognizer
         * @constructor
         * @augments GestureRecognizer
         * @classdesc A concrete gesture recognizer subclass that looks for mouse drag gestures.
         * @param {EventTarget} target The document element this gesture recognizer observes for mouse and touch events.
         * @param {Function} callback An optional function to call when this gesture is recognized. If non-null, the
         * function is called when this gesture is recognized, and is passed a single argument: this gesture recognizer,
         * e.g., <code>gestureCallback(recognizer)</code>.
         * @throws {ArgumentError} If the specified target is null or undefined.
         */
        var DragRecognizer = function (target, callback) {
            GestureRecognizer.call(this, target, callback);

            /**
             *
             * @type {Number}
             */
            this.button = 0;

            // Intentionally not documented.
            this.interpretDistance = 5;
        };

        DragRecognizer.prototype = Object.create(GestureRecognizer.prototype);

        // Documented in superclass.
        DragRecognizer.prototype.mouseMove = function (event) {
            if (this.state == WorldWind.POSSIBLE) {
                if (this.shouldInterpret()) {
                    if (this.shouldRecognize()) {
                        this.translationX = 0; // set translation to zero when the drag begins
                        this.translationY = 0;
                        this.state = WorldWind.BEGAN;
                    } else {
                        this.state = WorldWind.FAILED;
                    }
                }
            } else if (this.state == WorldWind.BEGAN || this.state == WorldWind.CHANGED) {
                this.state = WorldWind.CHANGED;
            }
        };

        // Documented in superclass.
        DragRecognizer.prototype.mouseUp = function (event) {
            if (this.mouseButtonMask == 0) { // last button up
                if (this.state == WorldWind.POSSIBLE) {
                    this.state = WorldWind.FAILED;
                } else if (this.state == WorldWind.BEGAN || this.state == WorldWind.CHANGED) {
                    this.state = WorldWind.ENDED;
                }
            }
        };

        // Documented in superclass.
        DragRecognizer.prototype.touchStart = function (touch) {
            if (this.state == WorldWind.POSSIBLE) {
                this.state = WorldWind.FAILED; // mouse gestures fail upon receiving a touch event
            }
        };

        /**
         *
         * @returns {Boolean}
         * @protected
         */
        DragRecognizer.prototype.shouldInterpret = function () {
            var dx = this.translationX,
                dy = this.translationY,
                distance = Math.sqrt(dx * dx + dy * dy);
            return distance > this.interpretDistance; // interpret mouse movement when the cursor moves far enough
        };

        /**
         *
         * @returns {Boolean}
         * @protected
         */
        DragRecognizer.prototype.shouldRecognize = function () {
            var buttonBit = (1 << this.button);
            return buttonBit == this.mouseButtonMask; // true when the specified button is the only button down
        };

        return DragRecognizer;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports PinchRecognizer
 * @version $Id: PinchRecognizer.js 3239 2015-06-22 23:28:12Z dcollins $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(19)], __WEBPACK_AMD_DEFINE_RESULT__ = function (GestureRecognizer) {
        "use strict";

        /**
         * Constructs a pinch gesture recognizer.
         * @alias PinchRecognizer
         * @constructor
         * @augments GestureRecognizer
         * @classdesc A concrete gesture recognizer subclass that looks for two finger pinch gestures.
         * @param {EventTarget} target The document element this gesture recognizer observes for mouse and touch events.
         * @param {Function} callback An optional function to call when this gesture is recognized. If non-null, the
         * function is called when this gesture is recognized, and is passed a single argument: this gesture recognizer,
         * e.g., <code>gestureCallback(recognizer)</code>.
         * @throws {ArgumentError} If the specified target is null or undefined.
         */
        var PinchRecognizer = function (target, callback) {
            GestureRecognizer.call(this, target, callback);

            // Intentionally not documented.
            this._scale = 1;

            // Intentionally not documented.
            this._offsetScale = 1;

            // Intentionally not documented.
            this.referenceDistance = 0;

            // Intentionally not documented.
            this.interpretThreshold = 20;

            // Intentionally not documented.
            this.weight = 0.4;

            // Intentionally not documented.
            this.pinchTouches = [];
        };

        PinchRecognizer.prototype = Object.create(GestureRecognizer.prototype);

        Object.defineProperties(PinchRecognizer.prototype, {
            scale: {
                get: function () {
                    return this._scale * this._offsetScale;
                }
            }
        });

        // Documented in superclass.
        PinchRecognizer.prototype.reset = function () {
            GestureRecognizer.prototype.reset.call(this);

            this._scale = 1;
            this._offsetScale = 1;
            this.referenceDistance = 0;
            this.pinchTouches = [];
        };

        // Documented in superclass.
        PinchRecognizer.prototype.mouseDown = function (event) {
            if (this.state == WorldWind.POSSIBLE) {
                this.state = WorldWind.FAILED; // touch gestures fail upon receiving a mouse event
            }
        };

        // Documented in superclass.
        PinchRecognizer.prototype.touchStart = function (touch) {
            if (this.pinchTouches.length < 2) {
                if (this.pinchTouches.push(touch) == 2) {
                    this.referenceDistance = this.currentPinchDistance();
                    this._offsetScale *= this._scale;
                    this._scale = 1;
                }
            }
        };

        // Documented in superclass.
        PinchRecognizer.prototype.touchMove = function (touch) {
            if (this.pinchTouches.length == 2) {
                if (this.state == WorldWind.POSSIBLE) {
                    if (this.shouldRecognize()) {
                        this.state = WorldWind.BEGAN;
                    }
                } else if (this.state == WorldWind.BEGAN || this.state == WorldWind.CHANGED) {
                    var distance = this.currentPinchDistance(),
                        newScale = Math.abs(distance / this.referenceDistance),
                        w = this.weight;
                    this._scale = this._scale * (1 - w) + newScale * w;
                    this.state = WorldWind.CHANGED;
                }
            }
        };

        // Documented in superclass.
        PinchRecognizer.prototype.touchEnd = function (touch) {
            var index = this.pinchTouches.indexOf(touch);
            if (index != -1) {
                this.pinchTouches.splice(index, 1);
            }

            // Transition to the ended state if this was the last touch.
            if (this.touchCount == 0) { // last touch ended
                if (this.state == WorldWind.POSSIBLE) {
                    this.state = WorldWind.FAILED;
                } else if (this.state == WorldWind.BEGAN || this.state == WorldWind.CHANGED) {
                    this.state = WorldWind.ENDED;
                }
            }
        };

        // Documented in superclass.
        PinchRecognizer.prototype.touchCancel = function (touch) {
            var index = this.pinchTouches.indexOf(touch);
            if (index != -1) {
                this.pinchTouches.splice(index, 1);
            }

            // Transition to the cancelled state if this was the last touch.
            if (this.touchCount == 0) {
                if (this.state == WorldWind.POSSIBLE) {
                    this.state = WorldWind.FAILED;
                } else if (this.state == WorldWind.BEGAN || this.state == WorldWind.CHANGED) {
                    this.state = WorldWind.CANCELLED;
                }
            }
        };

        // Documented in superclass.
        PinchRecognizer.prototype.prepareToRecognize = function () {
            this.referenceDistance = this.currentPinchDistance();
            this._scale = 1;
        };

        // Intentionally not documented.
        PinchRecognizer.prototype.shouldRecognize = function () {
            var distance = this.currentPinchDistance();

            return Math.abs(distance - this.referenceDistance) > this.interpretThreshold
        };

        // Intentionally not documented.
        PinchRecognizer.prototype.currentPinchDistance = function () {
            var touch0 = this.pinchTouches[0],
                touch1 = this.pinchTouches[1],
                dx = touch0.clientX - touch1.clientX,
                dy = touch0.clientY - touch1.clientY;

            return Math.sqrt(dx * dx + dy * dy);
        };

        return PinchRecognizer;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports RotationRecognizer
 * @version $Id: RotationRecognizer.js 3239 2015-06-22 23:28:12Z dcollins $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(6),
        __webpack_require__(19)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Angle,
              GestureRecognizer) {
        "use strict";

        /**
         * Constructs a rotation gesture recognizer.
         * @alias RotationRecognizer
         * @constructor
         * @augments GestureRecognizer
         * @classdesc A concrete gesture recognizer subclass that looks for two finger rotation gestures.
         * @param {EventTarget} target The document element this gesture recognizer observes for mouse and touch events.
         * @param {Function} callback An optional function to call when this gesture is recognized. If non-null, the
         * function is called when this gesture is recognized, and is passed a single argument: this gesture recognizer,
         * e.g., <code>gestureCallback(recognizer)</code>.
         * @throws {ArgumentError} If the specified target is null or undefined.
         */
        var RotationRecognizer = function (target, callback) {
            GestureRecognizer.call(this, target, callback);

            // Intentionally not documented.
            this._rotation = 0;

            // Intentionally not documented.
            this._offsetRotation = 0;

            // Intentionally not documented.
            this.referenceAngle = 0;

            // Intentionally not documented.
            this.interpretThreshold = 20;

            // Intentionally not documented.
            this.weight = 0.4;

            // Intentionally not documented.
            this.rotationTouches = [];
        };

        RotationRecognizer.prototype = Object.create(GestureRecognizer.prototype);

        Object.defineProperties(RotationRecognizer.prototype, {
            rotation: {
                get: function () {
                    return this._rotation + this._offsetRotation;
                }
            }
        });

        // Documented in superclass.
        RotationRecognizer.prototype.reset = function () {
            GestureRecognizer.prototype.reset.call(this);

            this._rotation = 0;
            this._offsetRotation = 0;
            this.referenceAngle = 0;
            this.rotationTouches = [];
        };

        // Documented in superclass.
        RotationRecognizer.prototype.mouseDown = function (event) {
            if (this.state == WorldWind.POSSIBLE) {
                this.state = WorldWind.FAILED; // touch gestures fail upon receiving a mouse event
            }
        };

        // Documented in superclass.
        RotationRecognizer.prototype.touchStart = function (touch) {
            if (this.rotationTouches.length < 2) {
                if (this.rotationTouches.push(touch) == 2) {
                    this.referenceAngle = this.currentTouchAngle();
                    this._offsetRotation += this._rotation;
                    this._rotation = 0;
                }
            }
        };

        // Documented in superclass.
        RotationRecognizer.prototype.touchMove = function (touch) {
            if (this.rotationTouches.length == 2) {
                if (this.state == WorldWind.POSSIBLE) {
                    if (this.shouldRecognize()) {
                        this.state = WorldWind.BEGAN;
                    }
                } else if (this.state == WorldWind.BEGAN || this.state == WorldWind.CHANGED) {
                    var angle = this.currentTouchAngle(),
                        newRotation = Angle.normalizedDegrees(angle - this.referenceAngle),
                        w = this.weight;
                    this._rotation = this._rotation * (1 - w) + newRotation * w;
                    this.state = WorldWind.CHANGED;
                }
            }
        };

        // Documented in superclass.
        RotationRecognizer.prototype.touchEnd = function (touch) {
            var index = this.rotationTouches.indexOf(touch);
            if (index != -1) {
                this.rotationTouches.splice(index, 1);
            }

            // Transition to the ended state if this was the last touch.
            if (this.touchCount == 0) { // last touch ended
                if (this.state == WorldWind.POSSIBLE) {
                    this.state = WorldWind.FAILED;
                } else if (this.state == WorldWind.BEGAN || this.state == WorldWind.CHANGED) {
                    this.state = WorldWind.ENDED;
                }
            }
        };

        // Documented in superclass.
        RotationRecognizer.prototype.touchCancel = function (touch) {
            var index = this.rotationTouches.indexOf(touch);
            if (index != -1) {
                this.rotationTouches.splice(index, 1);

                // Transition to the cancelled state if this was the last touch.
                if (this.touchCount == 0) {
                    if (this.state == WorldWind.POSSIBLE) {
                        this.state = WorldWind.FAILED;
                    } else if (this.state == WorldWind.BEGAN || this.state == WorldWind.CHANGED) {
                        this.state = WorldWind.CANCELLED;
                    }
                }
            }
        };

        // Documented in superclass.
        RotationRecognizer.prototype.prepareToRecognize = function () {
            this.referenceAngle = this.currentTouchAngle();
            this._rotation = 0;
        };

        // Intentionally not documented.
        RotationRecognizer.prototype.shouldRecognize = function () {
            var angle = this.currentTouchAngle(),
                rotation = Angle.normalizedDegrees(angle - this.referenceAngle);

            return Math.abs(rotation) > this.interpretThreshold;
        };

        // Intentionally not documented.
        RotationRecognizer.prototype.currentTouchAngle = function () {
            var touch0 = this.rotationTouches[0],
                touch1 = this.rotationTouches[1],
                dx = touch0.clientX - touch1.clientX,
                dy = touch0.clientY - touch1.clientY;

            return Math.atan2(dy, dx) * Angle.RADIANS_TO_DEGREES;
        };

        return RotationRecognizer;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports TiltRecognizer
 * @version $Id: TiltRecognizer.js 3223 2015-06-19 23:16:36Z dcollins $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(37)], __WEBPACK_AMD_DEFINE_RESULT__ = function (PanRecognizer) {
        "use strict";

        /**
         * Constructs a tilt gesture recognizer.
         * @alias TiltRecognizer
         * @constructor
         * @augments PanRecognizer
         * @classdesc A concrete gesture recognizer subclass that looks for two finger tilt gestures.
         * @param {EventTarget} target The document element this gesture recognizer observes for mouse and touch events.
         * @param {Function} callback An optional function to call when this gesture is recognized. If non-null, the
         * function is called when this gesture is recognized, and is passed a single argument: this gesture recognizer,
         * e.g., <code>gestureCallback(recognizer)</code>.
         * @throws {ArgumentError} If the specified target is null or undefined.
         */
        var TiltRecognizer = function (target, callback) {
            PanRecognizer.call(this, target, callback);

            // Intentionally not documented.
            this.maxTouchDistance = 250;

            // Intentionally not documented.
            this.maxTouchDivergence = 50;
        };

        // Intentionally not documented.
        TiltRecognizer.LEFT = (1 << 0);

        // Intentionally not documented.
        TiltRecognizer.RIGHT = (1 << 1);

        // Intentionally not documented.
        TiltRecognizer.UP = (1 << 2);

        // Intentionally not documented.
        TiltRecognizer.DOWN = (1 << 3);

        TiltRecognizer.prototype = Object.create(PanRecognizer.prototype);

        // Documented in superclass.
        TiltRecognizer.prototype.shouldInterpret = function () {
            for (var i = 0, count = this.touchCount; i < count; i++) {
                var touch = this.touch(i),
                    dx = touch.translationX,
                    dy = touch.translationY,
                    distance = Math.sqrt(dx * dx + dy * dy);
                if (distance > this.interpretDistance) {
                    return true; // interpret touches when any touch moves far enough
                }
            }

            return false;
        };

        // Documented in superclass.
        TiltRecognizer.prototype.shouldRecognize = function () {
            var touchCount = this.touchCount;
            if (touchCount < 2) {
                return false;
            }

            var touch0 = this.touch(0),
                touch1 = this.touch(1),
                dx = touch0.clientX - touch1.clientX,
                dy = touch0.clientY - touch1.clientY,
                distance = Math.sqrt(dx * dx + dy * dy);
            if (distance > this.maxTouchDistance) {
                return false; // touches must be close together
            }

            var tx = touch0.translationX - touch1.translationX,
                ty = touch0.translationY - touch1.translationY,
                divergence = Math.sqrt(tx * tx + ty * ty);
            if (divergence > this.maxTouchDivergence) {
                return false; // touches must be moving in a mostly parallel direction
            }

            var verticalMask = TiltRecognizer.UP | TiltRecognizer.DOWN,
                dirMask0 = this.touchDirection(touch0) & verticalMask,
                dirMask1 = this.touchDirection(touch1) & verticalMask;
            return (dirMask0 & dirMask1) != 0; // touches must move in the same vertical direction
        };

        // Intentionally not documented.
        TiltRecognizer.prototype.touchDirection = function (touch) {
            var dx = touch.translationX,
                dy = touch.translationY,
                dirMask = 0;

            if (Math.abs(dx) > Math.abs(dy)) {
                dirMask |= (dx < 0 ? TiltRecognizer.LEFT : 0);
                dirMask |= (dx > 0 ? TiltRecognizer.RIGHT : 0);
            } else {
                dirMask |= (dy < 0 ? TiltRecognizer.UP : 0);
                dirMask |= (dy > 0 ? TiltRecognizer.DOWN : 0);
            }

            return dirMask;
        };

        return TiltRecognizer;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2015 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports Touch
 * @version $Id: Touch.js 3221 2015-06-19 22:55:04Z dcollins $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
        "use strict";

        /**
         * Constructs a touch point.
         * @alias Touch
         * @constructor
         * @classdesc Represents a touch point.
         * @param {Color} identifier A number uniquely identifying the touch point
         * @param {Number} clientX The X coordinate of the touch point's location.
         * @param {Number} clientY The Y coordinate of the touch point's location.
         */
        var Touch = function (identifier, clientX, clientY) {

            /**
             * A number uniquely identifying this touch point.
             * @type {Number}
             * @readonly
             */
            this.identifier = identifier;

            // Intentionally not documented.
            this._clientX = clientX;

            // Intentionally not documented.
            this._clientY = clientY;

            // Intentionally not documented.
            this._clientStartX = clientX;

            // Intentionally not documented.
            this._clientStartY = clientY;
        };

        Object.defineProperties(Touch.prototype, {
            /**
             * Indicates the X coordinate of this touch point's location.
             * @type {Number}
             * @memberof Touch.prototype
             */
            clientX: {
                get: function () {
                    return this._clientX;
                },
                set: function (value) {
                    this._clientX = value;
                }
            },

            /**
             * Indicates the Y coordinate of this touch point's location.
             * @type {Number}
             * @memberof Touch.prototype
             */
            clientY: {
                get: function () {
                    return this._clientY;
                },
                set: function (value) {
                    this._clientY = value;
                }
            },

            /**
             * Indicates this touch point's translation along the X axis since the touch started.
             * @type {Number}
             * @memberof Touch.prototype
             */
            translationX: {
                get: function () {
                    return this._clientX - this._clientStartX;
                },
                set: function (value) {
                    this._clientStartX = this._clientX - value;
                }
            },

            /**
             * Indicates this touch point's translation along the Y axis since the touch started.
             * @type {Number}
             * @memberof Touch.prototype
             */
            translationY: {
                get: function () {
                    return this._clientY - this._clientStartY;
                },
                set: function (value) {
                    this._clientStartY = this._clientY - value;
                }
            }
        });

        return Touch;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports EarthElevationModel
 * @version $Id: EarthElevationModel.js 2936 2015-03-27 22:04:59Z tgaskins $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(7),
        __webpack_require__(3),
        __webpack_require__(29),
        __webpack_require__(89)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Location,
              Sector,
              ElevationModel,
              WmsUrlBuilder) {
        "use strict";

        /**
         * Constructs an Earth elevation model.
         * @alias EarthElevationModel
         * @constructor
         * @augments ElevationModel
         * @classdesc Provides elevations for Earth. Elevations are drawn from the NASA World Wind elevation service.
         */
        var EarthElevationModel = function () {
            ElevationModel.call(this,
                Sector.FULL_SPHERE, new Location(45, 45), 12, "application/bil16", "EarthElevations256", 256, 256);

            this.displayName = "Earth Elevation Model";
            this.minElevation = -11000; // Depth of Marianas Trench, in meters
            this.maxElevation = 8850; // Height of Mt. Everest
            this.pixelIsPoint = false; // World Wind WMS elevation layers return pixel-as-area images

            this.urlBuilder = new WmsUrlBuilder("https://worldwind26.arc.nasa.gov/elev",
                "GEBCO,aster_v2,USGS-NED", "", "1.3.0");
        };

        EarthElevationModel.prototype = Object.create(ElevationModel.prototype);

        return EarthElevationModel;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports ElevationImage
 * @version $Id: ElevationImage.js 2936 2015-03-27 22:04:59Z tgaskins $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(1),
        __webpack_require__(0),
        __webpack_require__(4)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
              Logger,
              WWMath) {
        "use strict";

        /**
         * Constructs an elevation image.
         * @alias ElevationImage
         * @constructor
         * @classdesc Holds elevation values for an elevation tile.
         * This class is typically not used directly by applications.
         * @param {String} imagePath A string uniquely identifying this elevation image relative to other elevation
         * images.
         * @param {Sector} sector The sector spanned by this elevation image.
         * @param {Number} imageWidth The number of longitudinal sample points in this elevation image.
         * @param {Number} imageHeight The number of latitudinal sample points in this elevation image.
         * @throws {ArgumentError} If the specified image path is null, undefined or empty, or the specified
         * sector is null or undefined.
         */
        var ElevationImage = function (imagePath, sector, imageWidth, imageHeight) {
            if (!imagePath || (imagePath.length < 1)) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "ElevationImage", "constructor",
                        "The specified image path is null, undefined or zero length."));
            }

            if (!sector) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "ElevationImage", "constructor", "missingSector"));
            }

            /**
             * The sector spanned by this elevation image.
             * @type {Sector}
             * @readonly
             */
            this.sector = sector;

            /**
             * A string uniquely identifying this elevation image.
             * @type {String}
             * @readonly
             */
            this.imagePath = imagePath;

            /**
             * The number of longitudinal sample points in this elevation image.
             * @type {Number}
             * @readonly
             */
            this.imageWidth = imageWidth;

            /**
             * The number of latitudinal sample points in this elevation image.
             * @type {Number}
             * @readonly
             */
            this.imageHeight = imageHeight;

            /**
             * The size in bytes of this elevation image.
             * @type {number}
             * @readonly
             */
            this.size = this.imageWidth * this.imageHeight;
        };

        /**
         * Returns the pixel value at a specified coordinate in this elevation image. The coordinate origin is the
         * image's lower left corner, so (0, 0) indicates the lower left pixel and (imageWidth-1, imageHeight-1)
         * indicates the upper right pixel. This returns 0 if the coordinate indicates a pixel outside of this elevation
         * image.
         * @param x The pixel's X coordinate.
         * @param y The pixel's Y coordinate.
         * @returns {Number} The pixel value at the specified coordinate in this elevation image.
         * Returns 0 if the coordinate indicates a pixel outside of this elevation image.
         */
        ElevationImage.prototype.pixel = function (x, y) {
            if (x < 0 || x >= this.imageWidth) {
                return 0;
            }

            if (y < 0 || y >= this.imageHeight) {
                return 0;
            }

            y = this.imageHeight - y - 1; // flip the y coordinate origin to the lower left corner
            return this.imageData[x + y * this.imageWidth];
        };

        /**
         * Returns the elevation at a specified geographic location.
         * @param {Number} latitude The location's latitude.
         * @param {Number} longitude The location's longitude.
         * @returns {Number} The elevation at the specified location.
         */
        ElevationImage.prototype.elevationAtLocation = function (latitude, longitude) {
            var maxLat = this.sector.maxLatitude,
                minLon = this.sector.minLongitude,
                deltaLat = this.sector.deltaLatitude(),
                deltaLon = this.sector.deltaLongitude(),
                x = (this.imageWidth - 1) * (longitude - minLon) / deltaLon,
                y = (this.imageHeight - 1) * (maxLat - latitude) / deltaLat,
                x0 = Math.floor(WWMath.clamp(x, 0, this.imageWidth - 1)),
                x1 = Math.floor(WWMath.clamp(x0 + 1, 0, this.imageWidth - 1)),
                y0 = Math.floor(WWMath.clamp(y, 0, this.imageHeight - 1)),
                y1 = Math.floor(WWMath.clamp(y0 + 1, 0, this.imageHeight - 1)),
                pixels = this.imageData,
                x0y0 = pixels[x0 + y0 * this.imageWidth],
                x1y0 = pixels[x1 + y0 * this.imageWidth],
                x0y1 = pixels[x0 + y1 * this.imageWidth],
                x1y1 = pixels[x1 + y1 * this.imageWidth],
                xf = x - x0,
                yf = y - y0;

            return (1 - xf) * (1 - yf) * x0y0 +
                xf * (1 - yf) * x1y0 +
                (1 - xf) * yf * x0y1 +
                xf * yf * x1y1;
        };

        /**
         * Returns elevations for a specified sector.
         * @param {Sector} sector The sector for which to return the elevations.
         * @param {Number} numLat The number of sample points in the longitudinal direction.
         * @param {Number} numLon The number of sample points in the latitudinal direction.
         * @param {Number[]} result An array in which to return the computed elevations.
         * @throws {ArgumentError} If either the specified sector or result argument is null or undefined, or if the
         * specified number of sample points in either direction is less than 1.
         */
        ElevationImage.prototype.elevationsForGrid = function (sector, numLat, numLon, result) {
            if (!sector) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "ElevationImage", "elevationsForSector", "missingSector"));
            }

            if (numLat < 1 || numLon < 1) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "ElevationImage", "elevationsForSector",
                        "The specified number of sample points is less than 1."));
            }

            if (!result) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "ElevationImage", "elevationsForSector", "missingResult"));
            }

            var minLatSelf = this.sector.minLatitude,
                maxLatSelf = this.sector.maxLatitude,
                minLonSelf = this.sector.minLongitude,
                maxLonSelf = this.sector.maxLongitude,
                deltaLatSelf = maxLatSelf - minLatSelf,
                deltaLonSelf = maxLonSelf - minLonSelf,
                minLat = sector.minLatitude,
                maxLat = sector.maxLatitude,
                minLon = sector.minLongitude,
                maxLon = sector.maxLongitude,
                deltaLat = (maxLat - minLat) / (numLat > 1 ? numLat - 1 : 1),
                deltaLon = (maxLon - minLon) / (numLon > 1 ? numLon - 1 : 1),
                lat, lon,
                i, j, index = 0,
                pixels = this.imageData;

            for (j = 0, lat = minLat; j < numLat; j += 1, lat += deltaLat) {
                if (j === numLat - 1) {
                    lat = maxLat; // explicitly set the last lat to the max latitude to ensure alignment
                }

                if (lat >= minLatSelf && lat <= maxLatSelf) {
                    // Image y-coordinate of the specified location, given an image origin in the top-left corner.
                    var y = (this.imageHeight - 1) * (maxLatSelf - lat) / deltaLatSelf,
                        y0 = Math.floor(WWMath.clamp(y, 0, this.imageHeight - 1)),
                        y1 = Math.floor(WWMath.clamp(y0 + 1, 0, this.imageHeight - 1)),
                        yf = y - y0;

                    for (i = 0, lon = minLon; i < numLon; i += 1, lon += deltaLon) {
                        if (i === numLon - 1) {
                            lon = maxLon; // explicitly set the last lon to the max longitude to ensure alignment
                        }

                        if (lon >= minLonSelf && lon <= maxLonSelf) {
                            // Image x-coordinate of the specified location, given an image origin in the top-left corner.
                            var x = (this.imageWidth - 1) * (lon - minLonSelf) / deltaLonSelf,
                                x0 = Math.floor(WWMath.clamp(x, 0, this.imageWidth - 1)),
                                x1 = Math.floor(WWMath.clamp(x0 + 1, 0, this.imageWidth - 1)),
                                xf = x - x0;

                            var x0y0 = pixels[x0 + y0 * this.imageWidth],
                                x1y0 = pixels[x1 + y0 * this.imageWidth],
                                x0y1 = pixels[x0 + y1 * this.imageWidth],
                                x1y1 = pixels[x1 + y1 * this.imageWidth];

                            result[index] = (1 - xf) * (1 - yf) * x0y0 +
                            xf * (1 - yf) * x1y0 +
                            (1 - xf) * yf * x0y1 +
                            xf * yf * x1y1;
                        }

                        index++;
                    }
                } else {
                    index += numLon; // skip this row
                }
            }
        };

        /**
         * Returns the minimum and maximum elevations within a specified sector.
         * @param {Sector} sector The sector of interest. If null or undefined, the minimum and maximum elevations
         * for the sector associated with this tile are returned.
         * @returns {Number[]} An array containing the minimum and maximum elevations within the specified sector,
         * or null if the specified sector does not include this elevation image's coverage sector.
         */
        ElevationImage.prototype.minAndMaxElevationsForSector = function (sector) {
            var result = [];

            if (!sector) { // the sector is this sector
                result[0] = this.minElevation;
                result[1] = this.maxElevation;
            } else if (sector.contains(this.sector)) { // The specified sector completely contains this image; return the image min and max.
                if (result[0] > this.minElevation) {
                    result[0] = this.minElevation;
                }

                if (result[1] < this.maxElevation) {
                    result[1] = this.maxElevation;
                }
            } else { // The specified sector intersects a portion of this image; compute the min and max from intersecting pixels.
                var maxLatSelf = this.sector.maxLatitude,
                    minLonSelf = this.sector.minLongitude,
                    deltaLatSelf = this.sector.deltaLatitude(),
                    deltaLonSelf = this.sector.deltaLongitude(),
                    minLatOther = sector.minLatitude,
                    maxLatOther = sector.maxLatitude,
                    minLonOther = sector.minLongitude,
                    maxLonOther = sector.maxLongitude;

                // Image coordinates of the specified sector, given an image origin in the top-left corner. We take the floor and
                // ceiling of the min and max coordinates, respectively, in order to capture all pixels that would contribute to
                // elevations computed for the specified sector in a call to elevationsForSector.
                var minY = Math.floor((this.imageHeight - 1) * (maxLatSelf - maxLatOther) / deltaLatSelf),
                    maxY = Math.ceil((this.imageHeight - 1) * (maxLatSelf - minLatOther) / deltaLatSelf),
                    minX = Math.floor((this.imageWidth - 1) * (minLonOther - minLonSelf) / deltaLonSelf),
                    maxX = Math.ceil((this.imageWidth - 1) * (maxLonOther - minLonSelf) / deltaLonSelf);

                minY = WWMath.clamp(minY, 0, this.imageHeight - 1);
                maxY = WWMath.clamp(maxY, 0, this.imageHeight - 1);
                minX = WWMath.clamp(minX, 0, this.imageWidth - 1);
                maxX = WWMath.clamp(maxX, 0, this.imageWidth - 1);

                var pixels = this.imageData,
                    min = Number.MAX_VALUE,
                    max = -min;

                for (var y = minY; y <= maxY; y++) {
                    for (var x = minX; x <= maxX; x++) {
                        var p = pixels[Math.floor(x + y * this.imageWidth)];
                        if (min > p) {
                            min = p;
                        }

                        if (max < p) {
                            max = p;
                        }
                    }
                }

                if (result[0] > min) {
                    result[0] = min;
                }

                if (result[1] < max) {
                    result[1] = max;
                }
            }

            return result;
        };

        /**
         * Determines the minimum and maximum elevations within this elevation image and stores those values within
         * this object. See [minAndMaxElevationsForSector]{@link ElevationImage#minAndMaxElevationsForSector}
         */
        ElevationImage.prototype.findMinAndMaxElevation = function () {
            if (this.imageData && (this.imageData.length > 0)) {
                this.minElevation = Number.MAX_VALUE;
                this.maxElevation = -this.minElevation;

                var pixels = this.imageData,
                    pixelCount = this.imageWidth * this.imageHeight;

                for (var i = 0; i < pixelCount; i++) {
                    var p = pixels[i];

                    if (this.minElevation > p) {
                        this.minElevation = p;
                    }

                    if (this.maxElevation < p) {
                        this.maxElevation = p;
                    }
                }
            } else {
                this.minElevation = 0;
                this.maxElevation = 0;
            }
        };

        return ElevationImage;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports ElevationTile
 * @version $Id: ElevationTile.js 2936 2015-03-27 22:04:59Z tgaskins $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(1),
        __webpack_require__(0),
        __webpack_require__(12)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
              Logger,
              Tile) {
        "use strict";

        /**
         * Constructs an elevation tile.
         * @alias ElevationTile
         * @constructor
         * @augments Tile
         * @classdesc Represents a region of elevations. Applications typically do not interact directly with this class.
         * @param {Sector} sector The sector this tile covers.
         * @param {Level} level The level this tile is associated with.
         * @param {Number} row This tile's row in the associated level.
         * @param {Number} column This tile's column in the associated level.
         * @param {String} imagePath The full path to the image.
         * @param {MemoryCache} cache The cache to use for caching this elevation tile.
         * @throws {ArgumentError} If the specified sector or level is null or undefined, the row or column arguments
         * are less than zero, or the specified image path is null, undefined or empty.
         *
         */
        var ElevationTile = function (sector, level, row, column, imagePath, cache) {
            if (!imagePath || (imagePath.length < 1)) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "ElevationTile", "constructor",
                        "The specified image path is null, undefined or zero length."));
            }

            if (!cache) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "ElevationTile", "constructor",
                        "The specified cache is null or undefined."));
            }

            Tile.call(this, sector, level, row, column); // args are checked in the superclass' constructor

            /**
             * This tile's image path.
             * @type {String}
             */
            this.imagePath = imagePath;

            this.memoryCache = cache;
        };

        ElevationTile.prototype = Object.create(Tile.prototype);

        /**
         * Returns the size of the this tile in bytes.
         * @returns {Number} The size of this tile in bytes, not including the associated elevations image size.
         */
        ElevationTile.prototype.size = function () {
            return Tile.prototype.size.call(this) + this.imagePath.length + 8;
        };

        /**
         * Returns the {@link ElevationImage} associated with this tile.
         * @returns {ElevationImage} The elevation image associated with this tile, or null if that image is
         * currently not in the elevation image cache.
         */
        ElevationTile.prototype.image = function () {
            return this.memoryCache.entryForKey(this.imagePath);
        };

        return ElevationTile;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports Tessellator
 * @version $Id: Tessellator.js 3345 2015-07-28 20:28:35Z dcollins $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(1),
        __webpack_require__(48),
        __webpack_require__(15),
        __webpack_require__(11),
        __webpack_require__(26),
        __webpack_require__(27),
        __webpack_require__(7),
        __webpack_require__(0),
        __webpack_require__(5),
        __webpack_require__(16),
        __webpack_require__(20),
        __webpack_require__(23),
        __webpack_require__(21),
        __webpack_require__(10),
        __webpack_require__(9),
        __webpack_require__(3),
        __webpack_require__(30),
        __webpack_require__(39),
        __webpack_require__(40),
        __webpack_require__(12),
        __webpack_require__(4),
        __webpack_require__(28)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
              BasicProgram,
              Globe,
              GpuProgram,
              Level,
              LevelSet,
              Location,
              Logger,
              Matrix,
              MemoryCache,
              NavigatorState,
              NotYetImplementedError,
              PickedObject,
              Position,
              Rectangle,
              Sector,
              Terrain,
              TerrainTile,
              TerrainTileList,
              Tile,
              WWMath,
              WWUtil) {
        "use strict";

        /**
         * Constructs a Tessellator.
         * @alias Tessellator
         * @constructor
         * @classdesc Provides terrain tessellation for a globe.
         */
        var Tessellator = function () {
            // Parameterize top level subdivision in one place.

            // TilesInTopLevel describes the most coarse tile structure.
            this.numRowsTilesInTopLevel = 4; // baseline: 4
            this.numColumnsTilesInTopLevel = 8; // baseline: 8

            // The maximum number of levels that will ever be tessellated.
            this.maximumSubdivisionDepth = 15; // baseline: 15

            // tileWidth, tileHeight - the number of subdivisions a single tile has; this determines the sampling grid.
            this.tileWidth = 32; // baseline: 32
            this.tileHeight = 32; // baseline: 32

            /**
             * Controls the level of detail switching for this layer. The next highest resolution level is
             * used when an elevation tile's cell size is greater than this number of pixels, up to the maximum
             * resolution of the elevation model.
             * @type {Number}
             * @default 1.75
             */
            this.detailControl = 40;

            this.levels = new LevelSet(
                Sector.FULL_SPHERE,
                new Location(
                    180 / this.numRowsTilesInTopLevel,
                    360 / this.numColumnsTilesInTopLevel),
                this.maximumSubdivisionDepth,
                this.tileWidth,
                this.tileHeight);

            this.topLevelTiles = {};
            this.currentTiles = new TerrainTileList(this);

            this.tileCache = new MemoryCache(5000000, 4000000); // Holds 316 32x32 tiles.

            this.elevationTimestamp = undefined;
            this.lastModelViewProjection = undefined;

            this.vertexPointLocation = -1;
            this.vertexTexCoordLocation = -1;

            this.texCoords = null;
            this.texCoordVboCacheKey = 'global_tex_coords';

            this.indices = null;
            this.indicesVboCacheKey = 'global_indices';

            this.baseIndices = null;
            this.baseIndicesOffset = null;
            this.numBaseIndices = null;

            this.indicesNorth = null;
            this.indicesNorthOffset = null;
            this.numIndicesNorth = null;

            this.indicesSouth = null;
            this.indicesSouthOffset = null;
            this.numIndicesSouth = null;

            this.indicesWest = null;
            this.indicesWestOffset = null;
            this.numIndicesWest = null;

            this.indicesEast = null;
            this.indicesEastOffset = null;
            this.numIndicesEast = null;

            this.indicesLoresNorth = null;
            this.indicesLoresNorthOffset = null;
            this.numIndicesLoresNorth = null;

            this.indicesLoresSouth = null;
            this.indicesLoresSouthOffset = null;
            this.numIndicesLoresSouth = null;

            this.indicesLoresWest = null;
            this.indicesLoresWestOffset = null;
            this.numIndicesLoresWest = null;

            this.indicesLoresEast = null;
            this.indicesLoresEastOffset = null;
            this.numIndicesLoresEast = null;

            this.outlineIndicesOffset = null;
            this.numOutlineIndices = null;

            this.wireframeIndicesOffset = null;
            this.numWireframeIndices = null;

            this.scratchMatrix = Matrix.fromIdentity();
            this.scratchElevations = null;
            this.scratchPrevElevations = null;

            this.corners = {};
            this.tiles = [];
        };

        /**
         * Creates the visible terrain of the globe associated with the current draw context.
         * @param {DrawContext} dc The draw context.
         * @returns {Terrain} The computed terrain, or null if terrain could not be computed.
         * @throws {ArgumentError} If the dc is null or undefined.
         */
        Tessellator.prototype.tessellate = function (dc) {
            if (!dc) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Tessellator", "tessellate", "missingDC"));
            }

            var lastElevationsChange = dc.globe.elevationTimestamp();
            if (this.lastGlobeStateKey === dc.globeStateKey
                && this.lastVerticalExaggeration === dc.verticalExaggeration
                && this.elevationTimestamp === lastElevationsChange
                && this.lastModelViewProjection
                && dc.navigatorState.modelviewProjection.equals(this.lastModelViewProjection)) {

                return this.lastTerrain;
            }

            var navigatorState = dc.navigatorState;

            this.lastModelViewProjection = navigatorState.modelviewProjection;
            this.lastGlobeStateKey = dc.globeStateKey;
            this.elevationTimestamp = lastElevationsChange;
            this.lastVerticalExaggeration = dc.verticalExaggeration;

            this.currentTiles.removeAllTiles();

            if (!this.topLevelTiles[dc.globeStateKey] || this.topLevelTiles[dc.globeStateKey].length == 0) {
                this.createTopLevelTiles(dc);
            }

            this.corners = {};
            this.tiles = [];

            for (var index = 0, len = this.topLevelTiles[dc.globeStateKey].length; index < len; index += 1) {
                var tile = this.topLevelTiles[dc.globeStateKey][index];

                tile.update(dc);

                if (this.isTileVisible(dc, tile)) {
                    this.addTileOrDescendants(dc, tile);
                }
            }

            this.refineNeighbors(dc);
            this.finishTessellating(dc);

            this.lastTerrain = this.currentTiles.length === 0 ? null
                : new Terrain(dc.globe, this, this.currentTiles, dc.verticalExaggeration);

            return this.lastTerrain;
        };

        Tessellator.prototype.createTile = function (tileSector, level, row, column) {
            if (!tileSector) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Tile", "constructor", "missingSector"));
            }

            if (!level) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Tile", "constructor",
                        "The specified level is null or undefined."));
            }

            if (row < 0 || column < 0) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Tile", "constructor",
                        "The specified row or column is less than zero."));
            }

            return new TerrainTile(tileSector, level, row, column);
        };

        /**
         * Initializes rendering state to draw a succession of terrain tiles.
         * @param {DrawContext} dc The draw context.
         */
        Tessellator.prototype.beginRendering = function (dc) {
            var program = dc.currentProgram; // use the current program; the caller configures other program state
            if (!program) {
                Logger.logMessage(Logger.LEVEL_INFO, "Tessellator", "beginRendering", "Current Program is empty");
                return;
            }

            this.buildSharedGeometry();
            this.cacheSharedGeometryVBOs(dc);

            var gl = dc.currentGlContext,
                gpuResourceCache = dc.gpuResourceCache;

            // Keep track of the program's attribute locations. The tessellator does not know which program the caller has
            // bound, and therefore must look up the location of attributes by name.
            this.vertexPointLocation = program.attributeLocation(gl, "vertexPoint");
            this.vertexTexCoordLocation = program.attributeLocation(gl, "vertexTexCoord");
            gl.enableVertexAttribArray(this.vertexPointLocation);

            if (this.vertexTexCoordLocation >= 0) { // location of vertexTexCoord attribute is -1 when the basic program is bound
                var texCoordVbo = gpuResourceCache.resourceForKey(this.texCoordVboCacheKey);
                gl.bindBuffer(gl.ARRAY_BUFFER, texCoordVbo);
                gl.vertexAttribPointer(this.vertexTexCoordLocation, 2, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(this.vertexTexCoordLocation);
            }

            var indicesVbo = gpuResourceCache.resourceForKey(this.indicesVboCacheKey);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indicesVbo);

        };

        /**
         * Restores rendering state after drawing a succession of terrain tiles.
         * @param {DrawContext} dc The draw context.
         */
        Tessellator.prototype.endRendering = function (dc) {
            var gl = dc.currentGlContext;

            gl.bindBuffer(gl.ARRAY_BUFFER, null);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

            // Restore the global OpenGL vertex attribute array state.
            if (this.vertexPointLocation >= 0) {
                gl.disableVertexAttribArray(this.vertexPointLocation);
            }

            if (this.vertexTexCoordLocation >= 0) { // location of vertexTexCoord attribute is -1 when the basic program is bound
                gl.disableVertexAttribArray(this.vertexTexCoordLocation);
            }
        };

        /**
         * Initializes rendering state for drawing a specified terrain tile.
         * @param {DrawContext} dc The draw context.
         * @param {TerrainTile} terrainTile The terrain tile subsequently drawn via this tessellator's render function.
         * @throws {ArgumentError} If the specified tile is null or undefined.
         */
        Tessellator.prototype.beginRenderingTile = function (dc, terrainTile) {
            if (!terrainTile) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Tessellator", "beginRenderingTile", "missingTile"));
            }

            var gl = dc.currentGlContext,
                gpuResourceCache = dc.gpuResourceCache;

            this.scratchMatrix.setToMultiply(dc.navigatorState.modelviewProjection, terrainTile.transformationMatrix);
            dc.currentProgram.loadModelviewProjection(gl, this.scratchMatrix);

            var vboCacheKey = dc.globeStateKey + terrainTile.tileKey,
                vbo = gpuResourceCache.resourceForKey(vboCacheKey);
            if (!vbo) {
                vbo = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
                gl.bufferData(gl.ARRAY_BUFFER, terrainTile.points, gl.STATIC_DRAW);
                dc.frameStatistics.incrementVboLoadCount(1);
                gpuResourceCache.putResource(vboCacheKey, vbo, terrainTile.points.length * 4);
                terrainTile.pointsVboStateKey = terrainTile.pointsStateKey;
            }
            else if (terrainTile.pointsVboStateKey != terrainTile.pointsStateKey) {
                gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
                gl.bufferSubData(gl.ARRAY_BUFFER, 0, terrainTile.points);
                terrainTile.pointsVboStateKey = terrainTile.pointsStateKey;
            }
            else {
                dc.currentGlContext.bindBuffer(gl.ARRAY_BUFFER, vbo);
            }

            gl.vertexAttribPointer(this.vertexPointLocation, 3, gl.FLOAT, false, 0, 0);
        };

        /**
         * Restores rendering state after drawing the most recent tile specified to
         * [beginRenderingTile]{@link Tessellator#beginRenderingTile}.
         * @param {DrawContext} dc The draw context.
         * @param {TerrainTile} terrainTile The terrain tile most recently rendered.
         * @throws {ArgumentError} If the specified tile is null or undefined.
         */
        Tessellator.prototype.endRenderingTile = function (dc, terrainTile) {
            // Intentionally empty until there's some reason to add code here.
        };

        /**
         * Renders a specified terrain tile.
         * @param {DrawContext} dc The draw context.
         * @param {TerrainTile} terrainTile The terrain tile to render.
         * @throws {ArgumentError} If the specified tile is null or undefined.
         */
        Tessellator.prototype.renderTile = function (dc, terrainTile) {
            if (!terrainTile) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Tessellator", "renderTile", "missingTile"));
            }

            var gl = dc.currentGlContext,
                prim = gl.TRIANGLE_STRIP; // replace TRIANGLE_STRIP with LINE_STRIP to debug borders

            /*
             * Indices order in the buffer:
             *
             * base indices
             *
             * north border
             * south border
             * west border
             * east border
             *
             * north lores
             * south lores
             * west lores
             * east lores
             *
             * wireframe
             * outline
             */

            gl.drawElements(
                prim,
                this.numBaseIndices,
                gl.UNSIGNED_SHORT,
                this.baseIndicesOffset * 2);

            var level = terrainTile.level,
                neighborLevel;

            neighborLevel = terrainTile.neighborLevel(WorldWind.NORTH);
            if (neighborLevel && neighborLevel.compare(level) < 0) {
                gl.drawElements(
                    prim,
                    this.numIndicesLoresNorth,
                    gl.UNSIGNED_SHORT,
                    this.indicesLoresNorthOffset * 2);
            }
            else {
                gl.drawElements(
                    prim,
                    this.numIndicesNorth,
                    gl.UNSIGNED_SHORT,
                    this.indicesNorthOffset * 2);
            }

            neighborLevel = terrainTile.neighborLevel(WorldWind.SOUTH);
            if (neighborLevel && neighborLevel.compare(level) < 0) {
                gl.drawElements(
                    prim,
                    this.numIndicesLoresSouth,
                    gl.UNSIGNED_SHORT,
                    this.indicesLoresSouthOffset * 2);
            }
            else {
                gl.drawElements(
                    prim,
                    this.numIndicesSouth,
                    gl.UNSIGNED_SHORT,
                    this.indicesSouthOffset * 2);
            }

            neighborLevel = terrainTile.neighborLevel(WorldWind.WEST);
            if (neighborLevel && neighborLevel.compare(level) < 0) {
                gl.drawElements(
                    prim,
                    this.numIndicesLoresWest,
                    gl.UNSIGNED_SHORT,
                    this.indicesLoresWestOffset * 2);
            }
            else {
                gl.drawElements(
                    prim,
                    this.numIndicesWest,
                    gl.UNSIGNED_SHORT,
                    this.indicesWestOffset * 2);
            }

            neighborLevel = terrainTile.neighborLevel(WorldWind.EAST);
            if (neighborLevel && neighborLevel.compare(level) < 0) {
                gl.drawElements(
                    prim,
                    this.numIndicesLoresEast,
                    gl.UNSIGNED_SHORT,
                    this.indicesLoresEastOffset * 2);
            }
            else {
                gl.drawElements(
                    prim,
                    this.numIndicesEast,
                    gl.UNSIGNED_SHORT,
                    this.indicesEastOffset * 2);
            }
        };

        /**
         * Draws outlines of the triangles composing the tile.
         * @param {DrawContext} dc The current draw context.
         * @param {TerrainTile} terrainTile The tile to draw.
         * @throws {ArgumentError} If the specified tile is null or undefined.
         */
        Tessellator.prototype.renderWireframeTile = function (dc, terrainTile) {
            if (!terrainTile) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Tessellator", "renderWireframeTile", "missingTile"));
            }

            var gl = dc.currentGlContext;

            // Must turn off texture coordinates, which were turned on in beginRendering.
            if (this.vertexTexCoordLocation >= 0) {
                gl.disableVertexAttribArray(this.vertexTexCoordLocation);
            }

            gl.drawElements(
                gl.LINES,
                this.numWireframeIndices,
                gl.UNSIGNED_SHORT,
                this.wireframeIndicesOffset * 2);
        };

        /**
         * Draws the outer boundary of a specified terrain tile.
         * @param {DrawContext} dc The current draw context.
         * @param {TerrainTile} terrainTile The tile whose outer boundary to draw.
         * @throws {ArgumentError} If the specified tile is null or undefined.
         */
        Tessellator.prototype.renderTileOutline = function (dc, terrainTile) {
            if (!terrainTile) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Tessellator", "renderTileOutline", "missingTile"));
            }

            var gl = dc.currentGlContext;

            // Must turn off texture coordinates, which were turned on in beginRendering.
            if (this.vertexTexCoordLocation >= 0) {
                gl.disableVertexAttribArray(this.vertexTexCoordLocation);
            }

            gl.drawElements(
                gl.LINE_LOOP,
                this.numOutlineIndices,
                gl.UNSIGNED_SHORT,
                this.outlineIndicesOffset * 2);
        };

        /**
         * Causes this terrain to perform the picking operations on the specified tiles, as appropriate for the draw
         * context's pick settings. Normally, this draws the terrain in a unique pick color and computes the picked
         * terrain position. When the draw context is set to region picking mode, this omits the computation of a picked
         * terrain position.
         * @param {DrawContext} dc The current draw context.
         * @param {Array} tileList The list of tiles to pick.
         * @param {Object} pickDelegate Indicates the object to use as the picked object's <code>userObject</code>.
         * If null, then this tessellator is used as the <code>userObject</code>.
         * @throws {ArgumentError} If either the draw context or the tile list are null or undefined.
         */
        Tessellator.prototype.pick = function (dc, tileList, pickDelegate) {
            if (!dc) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Tessellator", "pick", "missingDc"));
            }

            if (!tileList) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Tessellator", "pick", "missingList"));
            }

            var color = null,
                userObject = pickDelegate || this,
                position = new Position(0, 0, 0),
                pickableTiles = [];

            // Assemble a list of tiles that intersect the pick frustum. This eliminates unnecessary work for tiles that
            // do not contribute to the pick result.
            for (var i = 0, len = tileList.length; i < len; i++) {
                var tile = tileList[i];
                if (tile.extent.intersectsFrustum(dc.pickFrustum)) {
                    pickableTiles.push(tile);
                }
            }

            // Draw the pickable tiles in a unique pick color. Suppress this step when picking the terrain only. In this
            // case drawing to the pick framebuffer is unnecessary.
            if (!dc.pickTerrainOnly) {
                color = dc.uniquePickColor();
                this.drawPickTiles(dc, pickableTiles, color);
            }

            // Determine the terrain position at the pick point. If the terrain is picked, add a corresponding picked
            // object to the draw context. Suppress this step in region picking mode.
            if (!dc.regionPicking) {
                var ray = dc.navigatorState.rayFromScreenPoint(dc.pickPoint),
                    point = this.computeNearestIntersection(ray, pickableTiles);
                if (point) {
                    dc.globe.computePositionFromPoint(point[0], point[1], point[2], position);
                    position.altitude = dc.globe.elevationAtLocation(position.latitude, position.longitude);
                    dc.addPickedObject(new PickedObject(color, userObject, position, null, true));
                }
            }
        };

        // Internal function. Intentionally not documented.
        Tessellator.prototype.drawPickTiles = function (dc, tileList, color) {
            var gl = dc.currentGlContext;

            try {
                dc.findAndBindProgram(BasicProgram);
                dc.currentProgram.loadColor(gl, color);
                this.beginRendering(dc);

                for (var i = 0, len = tileList.length; i < len; i++) {
                    var tile = tileList[i];
                    this.beginRenderingTile(dc, tile);
                    this.renderTile(dc, tile);
                    this.endRenderingTile(dc, tile);
                }
            } finally {
                this.endRendering(dc);
            }
        };

        // Internal function. Intentionally not documented.
        Tessellator.prototype.computeNearestIntersection = function (line, tileList) {
            // Compute all intersections between the specified line and tile list.
            var results = [];
            for (var i = 0, len = tileList.length; i < len; i++) {
                this.computeIntersections(line, tileList[i], results);
            }

            if (results.length == 0) {
                return null; // no intersection
            } else {
                // Find and return the intersection nearest to the line's origin.
                var minDistance = Number.POSITIVE_INFINITY,
                    minIndex;
                for (i = 0, len = results.length; i < len; i++) {
                    var distance = line.origin.distanceToSquared(results[i]);
                    if (minDistance > distance) {
                        minDistance = distance;
                        minIndex = i;
                    }
                }

                return results[minIndex];
            }
        };

        // Internal function. Intentionally not documented.
        Tessellator.prototype.computeIntersections = function (line, tile, results) {
            var level = tile.level,
                neighborLevel,
                points = tile.points,
                elements,
                firstResult = results.length;

            // Translate the line from model coordinates to tile local coordinates.
            line.origin.subtract(tile.referencePoint);

            // Assemble the shared tile index geometry. This initializes the index properties used below.
            this.buildSharedGeometry(tile);

            // Compute any intersections with the tile's interior triangles..
            elements = this.baseIndices;
            WWMath.computeTriStripIntersections(line, points, elements, results);

            // Compute any intersections with the tile's south border triangles.
            neighborLevel = tile.neighborLevel(WorldWind.SOUTH);
            elements = neighborLevel && neighborLevel.compare(level) < 0 ? this.indicesLoresSouth : this.indicesSouth;
            WWMath.computeTriStripIntersections(line, points, elements, results);

            // Compute any intersections with the tile's west border triangles.
            neighborLevel = tile.neighborLevel(WorldWind.WEST);
            elements = neighborLevel && neighborLevel.compare(level) < 0 ? this.indicesLoresWest : this.indicesWest;
            WWMath.computeTriStripIntersections(line, points, elements, results);

            // Compute any intersections with the tile's east border triangles.
            neighborLevel = tile.neighborLevel(WorldWind.EAST);
            elements = neighborLevel && neighborLevel.compare(level) < 0 ? this.indicesLoresEast : this.indicesEast;
            WWMath.computeTriStripIntersections(line, points, elements, results);

            // Compute any intersections with the tile's north border triangles.
            neighborLevel = tile.neighborLevel(WorldWind.NORTH);
            elements = neighborLevel && neighborLevel.compare(level) < 0 ? this.indicesLoresNorth : this.indicesNorth;
            WWMath.computeTriStripIntersections(line, points, elements, results);

            // Translate the line and the intersection results from tile local coordinates to model coordinates.
            line.origin.add(tile.referencePoint);
            for (var i = firstResult, len = results.length; i < len; i++) {
                results[i].add(tile.referencePoint);
            }
        };

        /***********************************************************************
         * Internal methods - assume that arguments have been validated already.
         ***********************************************************************/

        Tessellator.prototype.createTopLevelTiles = function (dc) {
            this.topLevelTiles[dc.globeStateKey] = [];
            Tile.createTilesForLevel(this.levels.firstLevel(), this, this.topLevelTiles[dc.globeStateKey]);
        };

        Tessellator.prototype.addTileOrDescendants = function (dc, tile) {
            if (this.tileMeetsRenderCriteria(dc, tile)) {
                this.addTile(dc, tile);
                return;
            }

            this.addTileDescendants(dc, tile);
        };

        Tessellator.prototype.addTileDescendants = function (dc, tile) {
            var nextLevel = tile.level.nextLevel();
            var subTiles = tile.subdivideToCache(nextLevel, this, this.tileCache);
            for (var index = 0; index < subTiles.length; index += 1) {
                var child = subTiles[index];

                child.update(dc);

                if (this.levels.sector.intersects(child.sector) && this.isTileVisible(dc, child)) {
                    this.addTileOrDescendants(dc, child);
                }
            }
        };

        Tessellator.prototype.addTile = function (dc, tile) {
            // Insert tile at index idx.
            var idx = this.tiles.length;
            this.tiles.push(tile);

            // Insert tile into corner data collection for later LOD neighbor analysis.
            var sector = tile.sector;

            // Corners of the tile.
            var neTileCorner = [sector.maxLatitude, sector.maxLongitude].toString(),
                seTileCorner = [sector.minLatitude, sector.maxLongitude].toString(),
                nwTileCorner = [sector.maxLatitude, sector.minLongitude].toString(),
                swTileCorner = [sector.minLatitude, sector.minLongitude].toString(),
                corner;

            corner = this.corners[swTileCorner];
            if (!corner) {
                this.corners[swTileCorner] = {'sw': idx}; //corner;
            }
            else {
                // assert(!corner.sw, "sw already defined");
                corner.sw = idx;
            }

            corner = this.corners[nwTileCorner];
            if (!corner) {
                this.corners[nwTileCorner] = {'nw': idx};
            }
            else {
                // assert(!corner.nw, "nw already defined");
                corner.nw = idx;
            }

            corner = this.corners[seTileCorner];
            if (!corner) {
                this.corners[seTileCorner] = {'se': idx};
            }
            else {
                // assert(!corver.se, "se already defined");
                corner.se = idx;
            }

            corner = this.corners[neTileCorner];
            if (!corner) {
                this.corners[neTileCorner] = {'ne': idx};
            }
            else {
                //assert(!corner.ne, "ne already defined");
                corner.ne = idx;
            }
        };

        Tessellator.prototype.refineNeighbors = function (dc) {
            var tileRefinementSet = {};

            for (var idx = 0, len = this.tiles.length; idx < len; idx += 1) {
                var tile = this.tiles[idx],
                    levelNumber = tile.level.levelNumber,
                    sector = tile.sector,
                    corner,
                    neighbor,
                    idx,
                    len;

                // Corners of the tile.
                var neTileCorner = [sector.maxLatitude, sector.maxLongitude].toString(),
                    seTileCorner = [sector.minLatitude, sector.maxLongitude].toString(),
                    nwTileCorner = [sector.maxLatitude, sector.minLongitude].toString(),
                    swTileCorner = [sector.minLatitude, sector.minLongitude].toString();

                corner = this.corners[neTileCorner];
                // assert(corner, "northeast corner not found");
                if (corner.hasOwnProperty('se')) {
                    neighbor = corner.se;
                    if (this.tiles[neighbor].level.levelNumber < levelNumber - 1) {
                        if (!tileRefinementSet[neighbor]) {
                            tileRefinementSet[neighbor] = true;
                        }
                    }
                }
                if (corner.hasOwnProperty('nw')) {
                    neighbor = corner.nw;
                    if (this.tiles[neighbor].level.levelNumber < levelNumber - 1) {
                        if (!tileRefinementSet[neighbor]) {
                            tileRefinementSet[neighbor] = true;
                        }
                    }
                }

                corner = this.corners[seTileCorner];
                // assert(corner, "southeast corner not found");
                if (corner.hasOwnProperty('ne')) {
                    neighbor = corner.ne;
                    if (this.tiles[neighbor].level.levelNumber < levelNumber - 1) {
                        if (!tileRefinementSet[neighbor]) {
                            tileRefinementSet[neighbor] = true;
                        }
                    }
                }
                if (corner.hasOwnProperty('sw')) {
                    neighbor = corner.sw;
                    if (this.tiles[neighbor].level.levelNumber < levelNumber - 1) {
                        if (!tileRefinementSet[neighbor]) {
                            tileRefinementSet[neighbor] = true;
                        }
                    }
                }

                corner = this.corners[nwTileCorner];
                // assert(corner, "northwest corner not found");
                if (corner.hasOwnProperty('ne')) {
                    neighbor = corner.ne;
                    if (this.tiles[neighbor].level.levelNumber < levelNumber - 1) {
                        if (!tileRefinementSet[neighbor]) {
                            tileRefinementSet[neighbor] = true;
                        }
                    }
                }
                if (corner.hasOwnProperty('sw')) {
                    neighbor = corner.sw;
                    if (this.tiles[neighbor].level.levelNumber < levelNumber - 1) {
                        if (!tileRefinementSet[neighbor]) {
                            tileRefinementSet[neighbor] = true;
                        }
                    }
                }

                corner = this.corners[swTileCorner];
                // assert(corner, "southwest corner not found");
                if (corner.hasOwnProperty('se')) {
                    neighbor = corner.se;
                    if (this.tiles[neighbor].level.levelNumber < levelNumber - 1) {
                        if (!tileRefinementSet[neighbor]) {
                            tileRefinementSet[neighbor] = true;
                        }
                    }
                }
                if (corner.hasOwnProperty('nw')) {
                    neighbor = corner.nw;
                    if (this.tiles[neighbor].level.levelNumber < levelNumber - 1) {
                        if (!tileRefinementSet[neighbor]) {
                            tileRefinementSet[neighbor] = true;
                        }
                    }
                }
            }

            // Partition tiles into those requiring refinement and those that don't need refinement.
            var tilesNeedingRefinement = [],
                tilesNotNeedingRefinement = [];
            for (idx = 0, len = this.tiles.length; idx < len; idx += 1) {
                tile = this.tiles[idx];
                if (tileRefinementSet[idx]) {
                    tilesNeedingRefinement.push(tile);
                }
                else {
                    tilesNotNeedingRefinement.push(tile);
                }
            }

            // When tiles need refinement, recur.
            if (tilesNeedingRefinement.length > 0) {
                // Reset refinement state.
                this.tiles = [];
                this.corners = {};

                // For tiles that don't need refinement, simply add the tile.
                for (idx = 0, len = tilesNotNeedingRefinement.length; idx < len; idx += 1) {
                    tile = tilesNotNeedingRefinement[idx];

                    this.addTile(dc, tile);
                }

                // For tiles that do need refinement, subdivide the tile and add its descendants.
                for (idx = 0, len = tilesNeedingRefinement.length; idx < len; idx += 1) {
                    var tile = tilesNeedingRefinement[idx];

                    this.addTileDescendants(dc, tile);
                }

                // Recur.
                this.refineNeighbors(dc);
            }
        };

        Tessellator.prototype.finishTessellating = function (dc) {
            for (var idx = 0, len = this.tiles.length; idx < len; idx += 1) {
                var tile = this.tiles[idx];
                this.setNeighbors(tile);
                this.regenerateTileGeometryIfNeeded(dc, tile);
                this.currentTiles.addTile(tile);
            }
        };

        Tessellator.prototype.setNeighbors = function (tile) {
            var sector = tile.sector;

            // Corners of the tile.
            var neTileCorner = [sector.maxLatitude, sector.maxLongitude].toString(),
                seTileCorner = [sector.minLatitude, sector.maxLongitude].toString(),
                nwTileCorner = [sector.maxLatitude, sector.minLongitude].toString(),
                swTileCorner = [sector.minLatitude, sector.minLongitude].toString();

            var neCorner = this.corners[neTileCorner],
                seCorner = this.corners[seTileCorner],
                nwCorner = this.corners[nwTileCorner],
                swCorner = this.corners[swTileCorner];

            var northIdx = -1, // neCorner.hasOwnProperty('se') ? neCorner.se : nwCorner.hasOwnProperty('sw') ? nwCorner.sw : -1,
                southIdx = -1, // seCorner.hasOwnProperty('ne') ? seCorner.ne : swCorner.hasOwnProperty('nw') ? swCorner.nw : -1,
                eastIdx = -1, // neCorner.hasOwnProperty('nw') ? neCorner.nw : seCorner.hasOwnProperty('sw') ? seCorner.sw : -1,
                westIdx = -1; //nwCorner.hasOwnProperty('ne') ? nwCorner.ne : swCorner.hasOwnProperty('se') ? swCorner.se : -1;

            if (neCorner.hasOwnProperty('se')) {
                northIdx = neCorner.se;
            }
            else if (nwCorner.hasOwnProperty('sw')) {
                northIdx = nwCorner.sw;
            }

            if (seCorner.hasOwnProperty('ne')) {
                southIdx = seCorner.ne;
            }
            else if (swCorner.hasOwnProperty('nw')) {
                southIdx = swCorner.nw;
            }

            if (neCorner.hasOwnProperty('nw')) {
                eastIdx = neCorner.nw;
            }
            else if (seCorner.hasOwnProperty('sw')) {
                eastIdx = seCorner.sw;
            }

            if (nwCorner.hasOwnProperty('ne')) {
                westIdx = nwCorner.ne;
            }
            else if (swCorner.hasOwnProperty('se')) {
                westIdx = swCorner.se;
            }

            tile.setNeighborLevel(WorldWind.NORTH, (northIdx >= 0) ? this.tiles[northIdx].level : null);
            tile.setNeighborLevel(WorldWind.SOUTH, (southIdx >= 0) ? this.tiles[southIdx].level : null);
            tile.setNeighborLevel(WorldWind.EAST, (eastIdx >= 0) ? this.tiles[eastIdx].level : null);
            tile.setNeighborLevel(WorldWind.WEST, (westIdx >= 0) ? this.tiles[westIdx].level : null);
        };

        Tessellator.prototype.isTileVisible = function (dc, tile) {
            if (dc.globe.projectionLimits && !tile.sector.overlaps(dc.globe.projectionLimits)) {
                return false;
            }

            return tile.extent.intersectsFrustum(dc.navigatorState.frustumInModelCoordinates);
        };

        Tessellator.prototype.tileMeetsRenderCriteria = function (dc, tile) {
            var s = this.detailControl;
            if (tile.sector.minLatitude >= 75 || tile.sector.maxLatitude <= -75) {
                s *= 2;
            }
            return tile.level.isLastLevel() || !tile.mustSubdivide(dc, s);
        };

        Tessellator.prototype.regenerateTileGeometryIfNeeded = function (dc, tile) {
            var stateKey = dc.globeStateKey + tile.stateKey + dc.verticalExaggeration;

            if (!tile.points || tile.pointsStateKey != stateKey) {
                this.regenerateTileGeometry(dc, tile);
                tile.pointsStateKey = stateKey;
            }
        };

        Tessellator.prototype.regenerateTileGeometry = function (dc, tile) {
            var numLat = tile.tileHeight + 1, // num points in each dimension is 1 more than the number of tile cells
                numLon = tile.tileWidth + 1,
                refPoint = tile.referencePoint,
                elevations = this.scratchElevations;

            // Allocate space for the tile's elevations.
            if (!elevations) {
                elevations = new Float64Array(numLat * numLon);
                this.scratchElevations = elevations;
            }

            // Allocate space for the tile's Cartesian coordinates.
            if (!tile.points) {
                tile.points = new Float32Array(numLat * numLon * 3);
            }

            // Retrieve the elevations for all points in the tile.
            WWUtil.fillArray(elevations, 0);
            dc.globe.elevationsForGrid(tile.sector, numLat, numLon, tile.texelSize, elevations);

            // Modify the elevations around the tile's border to match neighbors of lower resolution, if any.
            if (this.mustAlignNeighborElevations(dc, tile)) {
                this.alignNeighborElevations(dc, tile, elevations);
            }

            // Compute the tile's Cartesian coordinates relative to a local origin, called the reference point.
            WWUtil.multiplyArray(elevations, dc.verticalExaggeration);
            dc.globe.computePointsForGrid(tile.sector, numLat, numLon, elevations, refPoint, tile.points);

            // Establish a transform that is used later to move the tile coordinates into place relative to the globe.
            tile.transformationMatrix.setTranslation(refPoint[0], refPoint[1], refPoint[2]);
        };

        Tessellator.prototype.mustAlignNeighborElevations = function (dc, tile) {
            var level = tile.level,
                northLevel = tile.neighborLevel(WorldWind.NORTH),
                southLevel = tile.neighborLevel(WorldWind.SOUTH),
                eastLevel = tile.neighborLevel(WorldWind.EAST),
                westLevel = tile.neighborLevel(WorldWind.WEST);

            return (northLevel && northLevel.compare(level) < 0) ||
                (southLevel && southLevel.compare(level) < 0) ||
                (eastLevel && eastLevel.compare(level) < 0) ||
                (westLevel && westLevel.compare(level) < 0);
        };

        Tessellator.prototype.alignNeighborElevations = function (dc, tile, elevations) {
            var numLat = tile.tileHeight + 1, // num points in each dimension is 1 more than the number of tile cells
                numLon = tile.tileWidth + 1,
                level = tile.level,
                prevNumLat = Math.floor(numLat / 2) + 1, // num prev level points is 1 more than 1/2 the number of cells
                prevNumLon = Math.floor(numLon / 2) + 1,
                prevLevel = level.previousLevel(),
                prevElevations = this.scratchPrevElevations,
                neighborLevel,
                i, index, prevIndex;

            // Allocate space for the previous level elevations.
            if (!prevElevations) {
                prevElevations = new Float64Array(prevNumLat * prevNumLon);
                this.scratchPrevElevations = prevElevations;
            }

            // Retrieve the previous level elevations, using 1/2 the number of tile cells.
            WWUtil.fillArray(prevElevations, 0);
            dc.globe.elevationsForGrid(tile.sector, prevNumLat, prevNumLon, prevLevel.texelSize, prevElevations);

            // Use previous level elevations along the north edge when the northern neighbor is lower resolution.
            neighborLevel = tile.neighborLevel(WorldWind.NORTH);
            if (neighborLevel && neighborLevel.compare(level) < 0) {
                index = (numLat - 1) * numLon;
                prevIndex = (prevNumLat - 1) * prevNumLon;
                for (i = 0; i < prevNumLon; i++, index += 2, prevIndex += 1) {
                    elevations[index] = prevElevations[prevIndex];
                    if (i < prevNumLon - 1) {
                        elevations[index + 1] = 0.5 * (prevElevations[prevIndex] + prevElevations[prevIndex + 1]);
                    }
                }
            }

            // Use previous level elevations along the south edge when the southern neighbor is lower resolution.
            neighborLevel = tile.neighborLevel(WorldWind.SOUTH);
            if (neighborLevel && neighborLevel.compare(level) < 0) {
                index = 0;
                prevIndex = 0;
                for (i = 0; i < prevNumLon; i++, index += 2, prevIndex += 1) {
                    elevations[index] = prevElevations[prevIndex];
                    if (i < prevNumLon - 1) {
                        elevations[index + 1] = 0.5 * (prevElevations[prevIndex] + prevElevations[prevIndex + 1]);
                    }
                }
            }

            // Use previous level elevations along the east edge when the eastern neighbor is lower resolution.
            neighborLevel = tile.neighborLevel(WorldWind.EAST);
            if (neighborLevel && neighborLevel.compare(level) < 0) {
                index = numLon - 1;
                prevIndex = prevNumLon - 1;
                for (i = 0; i < prevNumLat; i++, index += 2 * numLon, prevIndex += prevNumLon) {
                    elevations[index] = prevElevations[prevIndex];
                    if (i < prevNumLat - 1) {
                        elevations[index + numLon] = 0.5 * (prevElevations[prevIndex] + prevElevations[prevIndex + prevNumLon]);
                    }
                }
            }

            // Use previous level elevations along the west edge when the western neighbor is lower resolution.
            neighborLevel = tile.neighborLevel(WorldWind.WEST);
            if (neighborLevel && neighborLevel.compare(level) < 0) {
                index = 0;
                prevIndex = 0;
                for (i = 0; i < prevNumLat; i++, index += 2 * numLon, prevIndex += prevNumLon) {
                    elevations[index] = prevElevations[prevIndex];
                    if (i < prevNumLat - 1) {
                        elevations[index + numLon] = 0.5 * (prevElevations[prevIndex] + prevElevations[prevIndex + prevNumLon]);
                    }
                }
            }
        };

        Tessellator.prototype.buildSharedGeometry = function () {
            // TODO: put all indices into a single buffer
            var tileWidth = this.levels.tileWidth,
                tileHeight = this.levels.tileHeight;

            if (!this.texCoords) {
                this.buildTexCoords(tileWidth, tileHeight);
            }

            if (!this.indices) {
                this.buildIndices(tileWidth, tileHeight);
            }
        };

        Tessellator.prototype.buildTexCoords = function (tileWidth, tileHeight) {
            var numCols = tileWidth + 1,
                numRows = tileHeight + 1,
                colDelta = 1 / tileWidth,
                rowDelta = 1 / tileHeight,
                buffer = new Float32Array(numCols * numRows * 2),
                index = 0;

            for (var row = 0, t = 0; row < numRows; row++, t += rowDelta) {
                if (row == numRows - 1) {
                    t = 1; // explicitly set the last row coordinate to ensure alignment
                }

                for (var col = 0, s = 0; col < numCols; col++, s += colDelta) {
                    if (col == numCols - 1) {
                        s = 1; // explicitly set the last column coordinate to ensure alignment
                    }

                    buffer[index++] = s;
                    buffer[index++] = t;
                }
            }

            this.texCoords = buffer;
        };

        Tessellator.prototype.buildIndices = function (tileWidth, tileHeight) {
            var vertexIndex; // The index of the vertex in the sample grid.

            // The number of vertices in each dimension is 1 more than the number of cells.
            var numLatVertices = tileHeight + 1,
                numLonVertices = tileWidth + 1,
                latIndexMid = tileHeight / 2,   // Assumption: tileHeight is even, so that there is a midpoint!
                lonIndexMid = tileWidth / 2;    // Assumption: tileWidth is even, so that there is a midpoint!

            // Each vertex has two indices associated with it: the current vertex index and the index of the row.
            // There are tileHeight rows.
            // There are tileHeight + 2 columns
            var numIndices = 2 * (numLatVertices - 3) * (numLonVertices - 2) + 2 * (numLatVertices - 3);
            var indices = [];

            // Inset core by one round of sub-tiles. Full grid is numLatVertices x numLonVertices. This must be used
            // to address vertices in the core as well.
            var index = 0;
            for (var lonIndex = 1; lonIndex < numLonVertices - 2; lonIndex += 1) {
                for (var latIndex = 1; latIndex < numLatVertices - 1; latIndex += 1) {
                    vertexIndex = lonIndex + latIndex * numLonVertices;

                    // Create a triangle strip joining each adjacent column of vertices, starting in the top left corner and
                    // proceeding to the right. The first vertex starts with the left row of vertices and moves right to create a
                    // counterclockwise winding order.
                    indices[index++] = vertexIndex;
                    indices[index++] = vertexIndex + 1;
                }

                // Insert indices to create 2 degenerate triangles:
                //      one for the end of the current row, and
                //      one for the beginning of the next row.
                indices[index++] = vertexIndex + 1;
                vertexIndex = (lonIndex + 1) + 1 * numLonVertices;
                indices[index++] = vertexIndex;
            }

            this.baseIndicesOffset = indices.length - numIndices;
            this.baseIndices = new Uint16Array(indices.slice(this.baseIndicesOffset));
            this.numBaseIndices = numIndices;

            // TODO: parameterize and refactor!!!!!
            // Software engineering notes: There are patterns being used in the following code that should be abstracted.
            // However, I suspect that the process of abstracting the patterns will result in as much code created
            // as gets removed. YMMV. If JavaScript had a meta-programming (a.k.a., macro) facility, that code would be
            // processed at "compile" time rather than "runtime". But it doesn't have such a facility that I know of.
            //
            // Patterns used:
            //  0) Each tile has four borders: north, south, east, and west.
            //  1) Counter-clockwise traversal around the outside results in clockwise meshes amendable to back-face elimination.
            //  2) For each vertex on the exterior, there corresponds a vertex on the interior that creates a diagonal.
            //  3) Each border construction is broken into three phases:
            //      a) The starting phase to generate the first half of the border,
            //      b) The middle phase, where a single vertex reference gets created, and
            //      c) The ending phase to complete the generation of the border.
            //  4) Each border is generated in two variants:
            //      a) one variant that mates with a tile at the same level of detail, and
            //      b) another variant that mates with a tile at the next lower level of detail.
            //  5) Borders that mate with the next lower level of detail are constrained to lie on even indices.
            //  6) Evenness is generated by ANDing the index with a mask that has 1's in all bits except for the LSB,
            //      which results in clearing the LSB os the index, making it even.
            //  7) The section that generates lower level LOD borders gives up any attempt to be optimal because of the
            //      complexity. Instead, correctness was preferred. That said, any performance lost is in the noise,
            //      since this code only gets run once.

            /*
             *  The following section of code generates full resolution boundary meshes. These are used to mate
             *  with neighboring tiles that are at the same level of detail.
             */
            // North border.
            numIndices = 2 * numLonVertices - 2;
            latIndex = numLatVertices - 1;

            // Corner vertex.
            lonIndex = numLonVertices - 1;
            vertexIndex = lonIndex + latIndex * numLonVertices;
            indices[index++] = vertexIndex;

            for (lonIndex = numLonVertices - 2; lonIndex > 0; lonIndex -= 1) {
                vertexIndex = lonIndex + latIndex * numLonVertices;
                indices[index++] = vertexIndex;
                indices[index++] = vertexIndex - numLonVertices;
            }

            // Corner vertex.
            lonIndex = 0;
            vertexIndex = lonIndex + latIndex * numLonVertices;
            indices[index++] = vertexIndex;

            this.indicesNorthOffset = indices.length - numIndices;
            this.indicesNorth = new Uint16Array(indices.slice(this.indicesNorthOffset));
            this.numIndicesNorth = numIndices;

            // South border.
            numIndices = 2 * numLonVertices - 2;
            latIndex = 0;

            // Corner vertex.
            lonIndex = 0;
            vertexIndex = lonIndex + latIndex * numLonVertices;
            indices[index++] = vertexIndex;

            for (lonIndex = 1; lonIndex < numLonVertices - 1; lonIndex += 1) {
                vertexIndex = lonIndex + latIndex * numLonVertices;
                indices[index++] = vertexIndex;
                indices[index++] = vertexIndex + numLonVertices;
            }

            // Corner vertex.
            lonIndex = numLonVertices - 1;
            vertexIndex = lonIndex + latIndex * numLonVertices;
            indices[index++] = vertexIndex;

            this.indicesSouthOffset = indices.length - numIndices;
            this.indicesSouth = new Uint16Array(indices.slice(this.indicesSouthOffset));
            this.numIndicesSouth = numIndices;

            // West border.
            numIndices = 2 * numLatVertices - 2;
            lonIndex = 0;

            // Corner vertex.
            latIndex = numLatVertices - 1;
            vertexIndex = lonIndex + latIndex * numLonVertices;
            indices[index++] = vertexIndex;

            for (latIndex = numLatVertices - 2; latIndex > 0; latIndex -= 1) {
                vertexIndex = lonIndex + latIndex * numLonVertices;
                indices[index++] = vertexIndex;
                indices[index++] = vertexIndex + 1;
            }

            // Corner vertex.
            latIndex = 0;
            vertexIndex = lonIndex + latIndex * numLonVertices;
            indices[index++] = vertexIndex;

            this.indicesWestOffset = indices.length - numIndices;
            this.indicesWest = new Uint16Array(indices.slice(this.indicesWestOffset));
            this.numIndicesWest = numIndices;

            // East border.
            numIndices = 2 * numLatVertices - 2;
            lonIndex = numLonVertices - 1;

            // Corner vertex.
            latIndex = 0;
            vertexIndex = lonIndex + latIndex * numLonVertices;
            indices[index++] = vertexIndex;

            for (latIndex = 1; latIndex < numLatVertices - 1; latIndex += 1) {
                vertexIndex = lonIndex + latIndex * numLonVertices;
                indices[index++] = vertexIndex;
                indices[index++] = vertexIndex - 1;
            }

            // Corner vertex.
            latIndex = numLatVertices - 1;
            vertexIndex = lonIndex + latIndex * numLonVertices;
            indices[index++] = vertexIndex;

            this.indicesEastOffset = indices.length - numIndices;
            this.indicesEast = new Uint16Array(indices.slice(this.indicesEastOffset));
            this.numIndicesEast = numIndices;

            /*
             *  The following section of code generates "lores" low resolution boundary meshes. These are used to mate
             *  with neighboring tiles that are at a lower level of detail. The property of these lower level meshes is that
             *  they have half the number of vertices.
             *
             *  To generate the boundary meshes, force the use of only even boundary vertex indices.
             */
            // North border.
            numIndices = 2 * numLonVertices - 2;
            latIndex = numLatVertices - 1;

            // Corner vertex.
            lonIndex = numLonVertices - 1;
            vertexIndex = lonIndex + latIndex * numLonVertices;
            indices[index++] = vertexIndex;

            for (lonIndex = numLonVertices - 2; lonIndex > 0; lonIndex -= 1) {
                // Exterior vertex rounded up to even index.
                vertexIndex = ((lonIndex + 1) & ~1) + latIndex * numLonVertices;
                indices[index++] = vertexIndex;

                // Interior vertex.
                vertexIndex = lonIndex + (latIndex - 1) * numLonVertices;
                indices[index++] = vertexIndex;
            }

            // Corner vertex.
            lonIndex = 0;
            vertexIndex = lonIndex + latIndex * numLonVertices;
            indices[index++] = vertexIndex;

            this.indicesLoresNorthOffset = indices.length - numIndices;
            this.indicesLoresNorth = new Uint16Array(indices.slice(this.indicesLoresNorthOffset));
            this.numIndicesLoresNorth = numIndices;

            // South border.
            numIndices = 2 * numLonVertices - 2;
            latIndex = 0;

            // Corner vertex.
            lonIndex = 0;
            vertexIndex = lonIndex + latIndex * numLonVertices;
            indices[index++] = vertexIndex;

            for (lonIndex = 1; lonIndex < numLonVertices - 1; lonIndex += 1) {
                // Exterior Vertex rounded down to even index.
                vertexIndex = (lonIndex & ~1) + latIndex * numLonVertices;
                indices[index++] = vertexIndex;

                // Interior vertex.
                vertexIndex = lonIndex + (latIndex + 1) * numLonVertices;
                indices[index++] = vertexIndex;
            }

            // Corner vertex.
            lonIndex = numLonVertices - 1;
            vertexIndex = lonIndex + latIndex * numLonVertices;
            indices[index++] = vertexIndex;

            this.indicesLoresSouthOffset = indices.length - numIndices;
            this.indicesLoresSouth = new Uint16Array(indices.slice(this.indicesLoresSouthOffset));
            this.numIndicesLoresSouth = numIndices;

            // West border.
            numIndices = 2 * numLatVertices - 2;
            lonIndex = 0;

            // Corner vertex.
            latIndex = numLatVertices - 1;
            vertexIndex = lonIndex + latIndex * numLonVertices;
            indices[index++] = vertexIndex;

            for (latIndex = numLatVertices - 2; latIndex > 0; latIndex -= 1) {
                // Exterior Vertex rounded up to even index.
                vertexIndex = lonIndex + ((latIndex + 1) & ~1) * numLonVertices;
                indices[index++] = vertexIndex;

                // Interior vertex.
                vertexIndex = (lonIndex + 1) + latIndex * numLonVertices;
                indices[index++] = vertexIndex;
            }

            // Corner vertex.
            latIndex = 0;
            vertexIndex = lonIndex + latIndex * numLonVertices;
            indices[index++] = vertexIndex;

            this.indicesLoresWestOffset = indices.length - numIndices;
            this.indicesLoresWest = new Uint16Array(indices.slice(this.indicesLoresWestOffset));
            this.numIndicesLoresWest = numIndices;

            // East border.
            numIndices = 2 * numLatVertices - 2;
            lonIndex = numLonVertices - 1;

            // Corner vertex.
            latIndex = 0;
            vertexIndex = lonIndex + latIndex * numLonVertices;
            indices[index++] = vertexIndex;

            for (latIndex = 1; latIndex < numLatVertices - 1; latIndex += 1) {
                // Exterior vertex rounded down to even index.
                vertexIndex = lonIndex + (latIndex & ~1) * numLonVertices;
                indices[index++] = vertexIndex;

                // Interior vertex.
                vertexIndex = (lonIndex - 1) + latIndex * numLonVertices;
                indices[index++] = vertexIndex;
            }

            // Corner vertex.
            latIndex = numLatVertices - 1;
            vertexIndex = lonIndex + latIndex * numLonVertices;
            indices[index++] = vertexIndex;

            this.indicesLoresEastOffset = indices.length - numIndices;
            this.indicesLoresEast = new Uint16Array(indices.slice(this.indicesLoresEastOffset));
            this.numIndicesLoresEast = numIndices;

            var wireframeIndices = this.buildWireframeIndices(tileWidth, tileHeight);
            var outlineIndices = this.buildOutlineIndices(tileWidth, tileHeight);

            indices = indices.concat(wireframeIndices);
            this.wireframeIndicesOffset = indices.length - this.numWireframeIndices;

            indices = indices.concat(outlineIndices);
            this.outlineIndicesOffset = indices.length - this.numOutlineIndices;

            this.indices = new Uint16Array(indices);
        };

        Tessellator.prototype.buildWireframeIndices = function (tileWidth, tileHeight) {
            // The wireframe representation draws the vertices that appear on the surface.

            // The number of vertices in each dimension is 1 more than the number of cells.
            var numLatVertices = tileHeight + 1;
            var numLonVertices = tileWidth + 1;

            // Allocate an array to hold the computed indices.
            var numIndices = 2 * tileWidth * numLatVertices + 2 * tileHeight * numLonVertices;
            var indices = [];

            var rowStride = numLonVertices;

            var index = 0,
                lonIndex,
                latIndex,
                vertexIndex;

            // Add a line between each row to define the horizontal cell outlines.
            for (latIndex = 0; latIndex < numLatVertices; latIndex += 1) {
                for (lonIndex = 0; lonIndex < tileWidth; lonIndex += 1) {
                    vertexIndex = lonIndex + latIndex * rowStride;
                    indices[index] = vertexIndex;
                    indices[index + 1] = (vertexIndex + 1);
                    index += 2
                }
            }

            // Add a line between each column to define the vertical cell outlines.
            for (lonIndex = 0; lonIndex < numLonVertices; lonIndex += 1) {
                for (latIndex = 0; latIndex < tileHeight; latIndex += 1) {
                    vertexIndex = lonIndex + latIndex * rowStride;
                    indices[index] = vertexIndex;
                    indices[index + 1] = (vertexIndex + rowStride);
                    index += 2;
                }
            }

            this.numWireframeIndices = numIndices;
            return indices;
        };

        Tessellator.prototype.buildOutlineIndices = function (tileWidth, tileHeight) {
            // The outline representation traces the tile's outer edge on the surface.

            // The number of vertices in each dimension is 1 more than the number of cells.
            var numLatVertices = tileHeight + 1;
            var numLonVertices = tileWidth + 1;

            // Allocate an array to hold the computed indices.
            var numIndices = 2 * (numLatVertices - 2) + 2 * numLonVertices + 1;
            var indices = [];

            var rowStride = numLatVertices;

            var index = 0,
                lonIndex,
                latIndex,
                vertexIndex;

            // Bottom row, starting at the left and going right.
            latIndex = 0;
            for (lonIndex = 0; lonIndex < numLonVertices; lonIndex += 1) {
                vertexIndex = lonIndex + latIndex * numLonVertices;
                indices[index] = vertexIndex;
                index += 1;
            }

            // Right column, starting at the bottom and going up.
            lonIndex = numLonVertices - 1;
            for (latIndex = 1; latIndex < numLatVertices; latIndex += 1) {
                vertexIndex = lonIndex + latIndex * numLonVertices;
                indices[index] = vertexIndex;
                index += 1
            }

            // Top row, starting on the right and going to the left.
            latIndex = numLatVertices - 1;
            for (lonIndex = numLonVertices - 1; lonIndex >= 0; lonIndex -= 1) {
                vertexIndex = lonIndex + latIndex * numLonVertices;
                indices[index] = vertexIndex;
                index += 1
            }

            // Leftmost column, starting at the top and going down.
            lonIndex = 0;
            for (latIndex = numLatVertices - 1; latIndex >= 0; latIndex -= 1) {
                vertexIndex = lonIndex + latIndex * numLonVertices;
                indices[index] = vertexIndex;
                index += 1
            }

            this.numOutlineIndices = numIndices;
            return indices;
        };

        Tessellator.prototype.cacheSharedGeometryVBOs = function (dc) {
            var gl = dc.currentGlContext,
                gpuResourceCache = dc.gpuResourceCache;

            var texCoordVbo = gpuResourceCache.resourceForKey(this.texCoordVboCacheKey);
            if (!texCoordVbo) {
                texCoordVbo = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, texCoordVbo);
                gl.bufferData(gl.ARRAY_BUFFER, this.texCoords, gl.STATIC_DRAW);
                dc.frameStatistics.incrementVboLoadCount(1);
                gpuResourceCache.putResource(this.texCoordVboCacheKey, texCoordVbo, this.texCoords.length * 4 / 2);
            }

            var indicesVbo = gpuResourceCache.resourceForKey(this.indicesVboCacheKey);
            if (!indicesVbo) {
                indicesVbo = gl.createBuffer();
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indicesVbo);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW);
                dc.frameStatistics.incrementVboLoadCount(1);
                gpuResourceCache.putResource(this.indicesVboCacheKey, indicesVbo, this.indices.length * 2);
            }
        };

        return Tessellator;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports AtmosphereLayer
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(1),
        __webpack_require__(81),
        __webpack_require__(31),
        __webpack_require__(0),
        __webpack_require__(5),
        __webpack_require__(58),
        __webpack_require__(3),
        __webpack_require__(82),
        __webpack_require__(2),
        __webpack_require__(28)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
              GroundProgram,
              Layer,
              Logger,
              Matrix,
              Matrix3,
              Sector,
              SkyProgram,
              Vec3,
              WWUtil) {
        "use strict";

        /**
         * Constructs a layer showing the Earth's atmosphere.
         * @alias AtmosphereLayer
         * @constructor
         * @classdesc Provides a layer showing the Earth's atmosphere.
         * @param {URL} nightImageSource optional url for the night texture.
         * @augments Layer
         */
        var AtmosphereLayer = function (nightImageSource) {
            Layer.call(this, "Atmosphere");

            // The atmosphere layer is not pickable.
            this.pickEnabled = false;

            //Documented in defineProperties below.
            this._nightImageSource = nightImageSource ||
                WorldWind.configuration.baseUrl + 'images/dnb_land_ocean_ice_2012.png';

            //Documented in defineProperties below.
            this._lightLocation = null;

            //Internal use only.
            //The light direction in cartesian space, computed form the lightLocation or defaults to the eyePoint.
            this._activeLightDirection = new Vec3(0, 0, 0);

            this._fullSphereSector = Sector.FULL_SPHERE;

            //Internal use only. Intentionally not documented.
            this._skyData = {};

            //Internal use only. The number of longitudinal points in the grid for the sky geometry.
            this._skyWidth = 128;

            //Internal use only. The number of latitudinal points in the grid for the sky geometry.
            this._skyHeight = 128;

            //Internal use only. Number of indices for the sky geometry.
            this._numIndices = 0;

            //Internal use only. Texture coordinate matrix used for the night texture.
            this._texMatrix = Matrix3.fromIdentity();

            //Internal use only. The night texture.
            this._activeTexture = null;
        };

        AtmosphereLayer.prototype = Object.create(Layer.prototype);

        Object.defineProperties(AtmosphereLayer.prototype, {

            /**
             * The geographic location of the light (sun).
             * @memberof AtmosphereLayer.prototype
             * @type {Position}
             */
            lightLocation: {
                get: function () {
                    return this._lightLocation;
                },
                set: function (value) {
                    this._lightLocation = value;
                }
            },

            /**
             * Url for the night texture.
             * @memberof AtmosphereLayer.prototype
             * @type {URL}
             */
            nightImageSource: {
                get: function () {
                    return this._nightImageSource;
                },
                set: function (value) {
                    this._nightImageSource = value;
                }
            }

        });

        // Documented in superclass.
        AtmosphereLayer.prototype.doRender = function (dc) {
            if (dc.globe.is2D()) {
                return;
            }

            this.determineLightDirection(dc);
            this.drawSky(dc);
            this.drawGround(dc);
        };

        // Internal. Intentionally not documented.
        AtmosphereLayer.prototype.applySkyVertices = function (dc) {
            var gl = dc.currentGlContext,
                program = dc.currentProgram,
                skyData = this._skyData,
                skyPoints, vboId;

            if (!skyData.verticesVboCacheKey) {
                skyData.verticesVboCacheKey = dc.gpuResourceCache.generateCacheKey();
            }

            vboId = dc.gpuResourceCache.resourceForKey(skyData.verticesVboCacheKey);
            
            if (!vboId) {
                skyPoints = this.assembleVertexPoints(dc, this._skyHeight, this._skyWidth, program.getAltitude());
                
                vboId = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, vboId);
                gl.bufferData(gl.ARRAY_BUFFER, skyPoints, gl.STATIC_DRAW);
                gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);
                
                dc.gpuResourceCache.putResource(skyData.verticesVboCacheKey, vboId,
                    skyPoints.length * 4);
                dc.frameStatistics.incrementVboLoadCount(1);
            }
            else {
                gl.bindBuffer(gl.ARRAY_BUFFER, vboId);
                gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);
            }

        };

        // Internal. Intentionally not documented.
        AtmosphereLayer.prototype.applySkyIndices = function (dc) {
            var gl = dc.currentGlContext,
                skyData = this._skyData,
                skyIndices, vboId;

            if (!skyData.indicesVboCacheKey) {
                skyData.indicesVboCacheKey = dc.gpuResourceCache.generateCacheKey();
            }

            vboId = dc.gpuResourceCache.resourceForKey(skyData.indicesVboCacheKey);
            
            if (!vboId) {
                skyIndices = this.assembleTriStripIndices(this._skyWidth, this._skyHeight);
                
                vboId = gl.createBuffer();
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vboId);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, skyIndices, gl.STATIC_DRAW);
                
                dc.frameStatistics.incrementVboLoadCount(1);
                dc.gpuResourceCache.putResource(skyData.indicesVboCacheKey, vboId, skyIndices.length * 2);
            }
            else {
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vboId);
            }

        };

        // Internal. Intentionally not documented.
        AtmosphereLayer.prototype.drawSky = function (dc) {
            var gl = dc.currentGlContext,
                program = dc.findAndBindProgram(SkyProgram);

            program.loadGlobeRadius(gl, dc.globe.equatorialRadius);

            program.loadEyePoint(gl, dc.navigatorState.eyePoint);

            program.loadVertexOrigin(gl, Vec3.ZERO);

            program.loadModelviewProjection(gl, dc.navigatorState.modelviewProjection);

            program.loadLightDirection(gl, this._activeLightDirection);

            program.setScale(gl);

            this.applySkyVertices(dc);
            this.applySkyIndices(dc);

            gl.depthMask(false);
            gl.frontFace(gl.CW);
            gl.enableVertexAttribArray(0);
            gl.drawElements(gl.TRIANGLE_STRIP, this._numIndices, gl.UNSIGNED_SHORT, 0);

            gl.depthMask(true);
            gl.frontFace(gl.CCW);
            gl.disableVertexAttribArray(0);
        };

        // Internal. Intentionally not documented.
        AtmosphereLayer.prototype.drawGround = function (dc) {
            var gl = dc.currentGlContext,
                program = dc.findAndBindProgram(GroundProgram),
                terrain = dc.terrain,
                textureBound;

            program.loadGlobeRadius(gl, dc.globe.equatorialRadius);

            program.loadEyePoint(gl, dc.navigatorState.eyePoint);

            program.loadLightDirection(gl, this._activeLightDirection);

            program.setScale(gl);

            // Use this layer's night image when the light location is different than the eye location.
            if (this.nightImageSource && this.lightLocation) {
                
                this._activeTexture = dc.gpuResourceCache.resourceForKey(this.nightImageSource);
                
                if (!this._activeTexture) {
                    this._activeTexture = dc.gpuResourceCache.retrieveTexture(gl, this.nightImageSource);
                }
                
                textureBound = this._activeTexture && this._activeTexture.bind(dc);
            }

            terrain.beginRendering(dc);

            for (var idx = 0, len = terrain.surfaceGeometry.length; idx < len; idx++) {
                var currentTile = terrain.surfaceGeometry[idx];
                
                // Use the vertex origin for the terrain tile.
                var terrainOrigin = currentTile.referencePoint;
                program.loadVertexOrigin(gl, terrainOrigin);

                // Use a tex coord matrix that registers the night texture correctly on each terrain.
                if (textureBound) {
                    this._texMatrix.setToUnitYFlip();
                    this._texMatrix.multiplyByTileTransform(currentTile.sector, this._fullSphereSector);
                    program.loadTexMatrix(gl, this._texMatrix);
                }

                terrain.beginRenderingTile(dc, currentTile);

                // Draw the tile, multiplying the current fragment color by the program's secondary color.
                program.loadFragMode(gl, program.FRAGMODE_GROUND_SECONDARY);
                gl.blendFunc(gl.DST_COLOR, gl.ZERO);
                terrain.renderTile(dc, currentTile);

                // Draw the terrain as triangles, adding the current fragment color to the program's primary color.
                var fragMode = textureBound ?
                    program.FRAGMODE_GROUND_PRIMARY_TEX_BLEND : program.FRAGMODE_GROUND_PRIMARY;
                program.loadFragMode(gl, fragMode);
                gl.blendFunc(gl.ONE, gl.ONE);
                terrain.renderTile(dc, currentTile);

                terrain.endRenderingTile(dc, currentTile);
            }

            // Restore the default World Wind OpenGL state.
            terrain.endRendering(dc);
            gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);

            // Clear references to Gpu resources.
            this._activeTexture = null;
        };

        // Internal. Intentionally not documented.
        AtmosphereLayer.prototype.assembleVertexPoints = function (dc, numLat, numLon, altitude) {
            var count = numLat * numLon;
            var altitudes = new Array(count);
            WWUtil.fillArray(altitudes, altitude);
            var result = new Float32Array(count * 3);

            return dc.globe.computePointsForGrid(this._fullSphereSector, numLat, numLon, altitudes, Vec3.ZERO, result);
        };

        // Internal. Intentionally not documented.
        AtmosphereLayer.prototype.assembleTriStripIndices = function (numLat, numLon) {
            var result = [];
            var vertex = 0;

            for (var latIndex = 0; latIndex < numLat - 1; latIndex++) {
                // Create a triangle strip joining each adjacent column of vertices, starting in the bottom left corner and
                // proceeding to the right. The first vertex starts with the left row of vertices and moves right to create
                // a counterclockwise winding order.
                for (var lonIndex = 0; lonIndex < numLon; lonIndex++) {
                    vertex = lonIndex + latIndex * numLon;
                    result.push(vertex + numLon);
                    result.push(vertex);
                }

                // Insert indices to create 2 degenerate triangles:
                // - one for the end of the current row, and
                // - one for the beginning of the next row
                if (latIndex < numLat - 2) {
                    result.push(vertex);
                    result.push((latIndex + 2) * numLon);
                }
            }

            this._numIndices = result.length;
            
            return new Uint16Array(result);
        };

        // Internal. Intentionally not documented.
        AtmosphereLayer.prototype.determineLightDirection = function (dc) {
            if (this.lightLocation != null) {
                dc.globe.computePointFromLocation(this.lightLocation.latitude, this.lightLocation.longitude,
                    this._activeLightDirection);
            }
            else {
                this._activeLightDirection.copy(dc.navigatorState.eyePoint);
            }
            this._activeLightDirection.normalize();
        };

        return AtmosphereLayer;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports RenderableLayer
 * @version $Id: RenderableLayer.js 3334 2015-07-22 19:15:43Z tgaskins $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(1),
        __webpack_require__(31),
        __webpack_require__(0)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
              Layer,
              Logger) {
        "use strict";

        /**
         * Constructs a layer that contains shapes and other renderables.
         * @alias RenderableLayer
         * @constructor
         * @augments Layer
         * @classdesc Provides a layer that contains shapes and other renderables.
         * @param {String} displayName This layer's display name.
         */
        var RenderableLayer = function (displayName) {
            Layer.call(this, displayName);

            /**
             * The array of renderables;
             * @type {Array}
             * @readonly
             */
            this.renderables = [];
        };

        RenderableLayer.prototype = Object.create(Layer.prototype);

        /**
         * Adds a renderable to this layer.
         * @param {Renderable} renderable The renderable to add.
         * @throws {ArgumentError} If the specified renderable is null or undefined.
         */
        RenderableLayer.prototype.addRenderable = function (renderable) {
            if (!renderable) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "RenderableLayer", "addRenderable",
                    "missingRenderable"));
            }

            this.renderables.push(renderable);
        };

        /**
         * Adds an array of renderables to this layer.
         * @param {Renderable[]} renderables The renderables to add.
         * @throws {ArgumentError} If the specified renderables array is null or undefined.
         */
        RenderableLayer.prototype.addRenderables = function (renderables) {
            if (!renderables) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "RenderableLayer", "addRenderables",
                    "The renderables array is null or undefined."));
            }

            for (var i = 0, len = renderables.length; i < len; i++) {
                this.addRenderable(renderables[i]);
            }
        };

        /**
         * Removes a renderable from this layer.
         * @param {Renderable} renderable The renderable to remove.
         */
        RenderableLayer.prototype.removeRenderable = function (renderable) {
            var index = this.renderables.indexOf(renderable);
            if (index >= 0) {
                this.renderables.splice(index, 1);
            }
        };

        /**
         * Removes all renderables from this layer. Does not call dispose on those renderables.
         */
        RenderableLayer.prototype.removeAllRenderables = function () {
            this.renderables = [];
        };

        // Documented in superclass.
        RenderableLayer.prototype.doRender = function (dc) {
            var numOrderedRenderablesAtStart = dc.orderedRenderables.length;

            for (var i = 0, len = this.renderables.length; i < len; i++) {
                try {
                    this.renderables[i].render(dc);
                } catch (e) {
                    Logger.logMessage(Logger.LEVEL_SEVERE, "RenderableLayer", "doRender",
                        "Error while rendering shape " + this.renderables[i].displayName + ".\n" + e.toString());
                    // Keep going. Render the rest of the shapes.
                }
            }

            if (dc.orderedRenderables.length > numOrderedRenderablesAtStart) {
                this.inCurrentFrame = true;
            }
        };

        return RenderableLayer;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports LookAtNavigator
 * @version $Id: LookAtNavigator.js 3321 2015-07-16 21:34:58Z dcollins $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(6),
        __webpack_require__(59),
        __webpack_require__(24),
        __webpack_require__(19),
        __webpack_require__(13),
        __webpack_require__(7),
        __webpack_require__(0),
        __webpack_require__(5),
        __webpack_require__(71),
        __webpack_require__(37),
        __webpack_require__(60),
        __webpack_require__(10),
        __webpack_require__(61),
        __webpack_require__(62),
        __webpack_require__(14),
        __webpack_require__(2),
        __webpack_require__(4)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Angle,
              DragRecognizer,
              Frustum,
              GestureRecognizer,
              Line,
              Location,
              Logger,
              Matrix,
              Navigator,
              PanRecognizer,
              PinchRecognizer,
              Position,
              RotationRecognizer,
              TiltRecognizer,
              Vec2,
              Vec3,
              WWMath) {
        "use strict";

        /**
         * Constructs a look-at navigator.
         * @alias LookAtNavigator
         * @constructor
         * @augments Navigator
         * @classdesc Represents a navigator that enables the user to pan, zoom and tilt the globe.
         * This navigator automatically responds to user-input events and gestures.
         * @param {WorldWindow} worldWindow The world window to associate with this navigator.
         */
        var LookAtNavigator = function (worldWindow) {
            Navigator.call(this, worldWindow);

            // Prevent the browser's default actions in response to mouse and touch events, which interfere with
            // navigation. Register these event listeners  before any others to ensure that they're called last.
            function preventDefaultListener(event) {
                event.preventDefault();
            }
            worldWindow.addEventListener("mousedown", preventDefaultListener);
            worldWindow.addEventListener("touchstart", preventDefaultListener);
            worldWindow.addEventListener("contextmenu", preventDefaultListener);
            worldWindow.addEventListener("wheel", preventDefaultListener);

            // Prevent the browser's default actions in response to to pointer events, which interfere with navigation.
            // This CSS style property is configured here to ensure that it's set for all applications.
            if (window.PointerEvent) {
                worldWindow.canvas.style.setProperty("touch-action", "none");
            }

            /**
             * The geographic location at the center of the viewport.
             * @type {Location}
             */
            this.lookAtLocation = new Location(30, -110);

            /**
             * The distance from this navigator's eye point to its look-at location.
             * @type {Number}
             * @default 10,000 kilometers
             */
            this.range = 10e6; // TODO: Compute initial range to fit globe in viewport.

            // Development testing only. Set this to false to suppress default navigator limits on 2D globes.
            this.enable2DLimits = true;

            var thisNavigator = this;

            // Intentionally not documented.
            this.primaryDragRecognizer = new DragRecognizer(worldWindow, function (recognizer) {
                thisNavigator.handlePanOrDrag(recognizer);
            });

            // Intentionally not documented.
            this.secondaryDragRecognizer = new DragRecognizer(worldWindow, function (recognizer) {
                thisNavigator.handleSecondaryDrag(recognizer);
            });
            this.secondaryDragRecognizer.button = 2; // secondary mouse button

            // Intentionally not documented.
            this.panRecognizer = new PanRecognizer(worldWindow, function (recognizer) {
                thisNavigator.handlePanOrDrag(recognizer);
            });

            // Intentionally not documented.
            this.pinchRecognizer = new PinchRecognizer(worldWindow, function (recognizer) {
                thisNavigator.handlePinch(recognizer);
            });

            // Intentionally not documented.
            this.rotationRecognizer = new RotationRecognizer(worldWindow, function (recognizer) {
                thisNavigator.handleRotation(recognizer);
            });

            // Intentionally not documented.
            this.tiltRecognizer = new TiltRecognizer(worldWindow, function (recognizer) {
                thisNavigator.handleTilt(recognizer);
            });

            // Register wheel event listeners on the WorldWindow's canvas.
            worldWindow.addEventListener("wheel", function (event) {
                thisNavigator.handleWheelEvent(event);
            });

            // Establish the dependencies between gesture recognizers. The pan, pinch and rotate gesture may recognize
            // simultaneously with each other.
            this.panRecognizer.recognizeSimultaneouslyWith(this.pinchRecognizer);
            this.panRecognizer.recognizeSimultaneouslyWith(this.rotationRecognizer);
            this.pinchRecognizer.recognizeSimultaneouslyWith(this.rotationRecognizer);

            // Since the tilt gesture is a subset of the pan gesture, pan will typically recognize before tilt,
            // effectively suppressing tilt. Establish a dependency between the other touch gestures and tilt to provide
            // tilt an opportunity to recognize.
            this.panRecognizer.requireRecognizerToFail(this.tiltRecognizer);
            this.pinchRecognizer.requireRecognizerToFail(this.tiltRecognizer);
            this.rotationRecognizer.requireRecognizerToFail(this.tiltRecognizer);

            // Intentionally not documented.
            this.beginPoint = new Vec2(0, 0);
            this.lastPoint = new Vec2(0, 0);
            this.beginHeading = 0;
            this.beginTilt = 0;
            this.beginRange = 0;
            this.lastRotation = 0;
        };

        LookAtNavigator.prototype = Object.create(Navigator.prototype);

        // Documented in superclass.
        LookAtNavigator.prototype.currentState = function () {
            this.applyLimits();

            var globe = this.worldWindow.globe,
                lookAtPosition = new Position(this.lookAtLocation.latitude, this.lookAtLocation.longitude, 0),
                modelview = Matrix.fromIdentity();
            modelview.multiplyByLookAtModelview(lookAtPosition, this.range, this.heading, this.tilt, this.roll, globe);

            return this.currentStateForModelview(modelview);
        };

        // Intentionally not documented.
        LookAtNavigator.prototype.handlePanOrDrag = function (recognizer) {
            if (this.worldWindow.globe.is2D()) {
                this.handlePanOrDrag2D(recognizer);
            } else {
                this.handlePanOrDrag3D(recognizer);
            }
        };

        // Intentionally not documented.
        LookAtNavigator.prototype.handlePanOrDrag3D = function (recognizer) {
            var state = recognizer.state,
                tx = recognizer.translationX,
                ty = recognizer.translationY;

            if (state == WorldWind.BEGAN) {
                this.lastPoint.set(0, 0);
            } else if (state == WorldWind.CHANGED) {
                // Convert the translation from screen coordinates to arc degrees. Use this navigator's range as a
                // metric for converting screen pixels to meters, and use the globe's radius for converting from meters
                // to arc degrees.
                var canvas = this.worldWindow.canvas,
                    globe = this.worldWindow.globe,
                    globeRadius = WWMath.max(globe.equatorialRadius, globe.polarRadius),
                    distance = WWMath.max(1, this.range),
                    metersPerPixel = WWMath.perspectivePixelSize(canvas.clientWidth, canvas.clientHeight, distance),
                    forwardMeters = (ty - this.lastPoint[1]) * metersPerPixel,
                    sideMeters = -(tx - this.lastPoint[0]) * metersPerPixel,
                    forwardDegrees = (forwardMeters / globeRadius) * Angle.RADIANS_TO_DEGREES,
                    sideDegrees = (sideMeters / globeRadius) * Angle.RADIANS_TO_DEGREES;

                // Apply the change in latitude and longitude to this navigator, relative to the current heading.
                var sinHeading = Math.sin(this.heading * Angle.DEGREES_TO_RADIANS),
                    cosHeading = Math.cos(this.heading * Angle.DEGREES_TO_RADIANS);

                this.lookAtLocation.latitude += forwardDegrees * cosHeading - sideDegrees * sinHeading;
                this.lookAtLocation.longitude += forwardDegrees * sinHeading + sideDegrees * cosHeading;
                this.lastPoint.set(tx, ty);
                this.applyLimits();
                this.worldWindow.redraw();
            }
        };

        // Intentionally not documented.
        LookAtNavigator.prototype.handlePanOrDrag2D = function (recognizer) {
            var state = recognizer.state,
                x = recognizer.clientX,
                y = recognizer.clientY,
                tx = recognizer.translationX,
                ty = recognizer.translationY;

            if (state == WorldWind.BEGAN) {
                this.beginPoint.set(x, y);
                this.lastPoint.set(x, y);
            } else if (state == WorldWind.CHANGED) {
                var x1 = this.lastPoint[0],
                    y1 = this.lastPoint[1],
                    x2 = this.beginPoint[0] + tx,
                    y2 = this.beginPoint[1] + ty;
                this.lastPoint.set(x2, y2);

                var navState = this.currentState(),
                    globe = this.worldWindow.globe,
                    ray = navState.rayFromScreenPoint(this.worldWindow.canvasCoordinates(x1, y1)),
                    point1 = new Vec3(0, 0, 0),
                    point2 = new Vec3(0, 0, 0),
                    origin = new Vec3(0, 0, 0);
                if (!globe.intersectsLine(ray, point1)) {
                    return;
                }

                ray = navState.rayFromScreenPoint(this.worldWindow.canvasCoordinates(x2, y2));
                if (!globe.intersectsLine(ray, point2)) {
                    return;
                }

                // Transform the original navigator state's modelview matrix to account for the gesture's change.
                var modelview = Matrix.fromIdentity();
                modelview.copy(navState.modelview);
                modelview.multiplyByTranslation(point2[0] - point1[0], point2[1] - point1[1], point2[2] - point1[2]);

                // Compute the globe point at the screen center from the perspective of the transformed navigator state.
                modelview.extractEyePoint(ray.origin);
                modelview.extractForwardVector(ray.direction);
                if (!globe.intersectsLine(ray, origin)) {
                    return;
                }

                // Convert the transformed modelview matrix to a set of navigator properties, then apply those
                // properties to this navigator.
                var params = modelview.extractViewingParameters(origin, this.roll, globe, {});
                this.lookAtLocation.copy(params.origin);
                this.range = params.range;
                this.heading = params.heading;
                this.tilt = params.tilt;
                this.roll = params.roll;
                this.applyLimits();
                this.worldWindow.redraw();
            }
        };

        // Intentionally not documented.
        LookAtNavigator.prototype.handleSecondaryDrag = function (recognizer) {
            var state = recognizer.state,
                tx = recognizer.translationX,
                ty = recognizer.translationY;

            if (state == WorldWind.BEGAN) {
                this.beginHeading = this.heading;
                this.beginTilt = this.tilt;
            } else if (state == WorldWind.CHANGED) {
                // Compute the current translation from screen coordinates to degrees. Use the canvas dimensions as a
                // metric for converting the gesture translation to a fraction of an angle.
                var headingDegrees = 180 * tx / this.worldWindow.canvas.clientWidth,
                    tiltDegrees = 90 * ty / this.worldWindow.canvas.clientHeight;

                // Apply the change in heading and tilt to this navigator's corresponding properties.
                this.heading = this.beginHeading + headingDegrees;
                this.tilt = this.beginTilt + tiltDegrees;
                this.applyLimits();
                this.worldWindow.redraw();
            }
        };

        // Intentionally not documented.
        LookAtNavigator.prototype.handlePinch = function (recognizer) {
            var state = recognizer.state,
                scale = recognizer.scale;

            if (state == WorldWind.BEGAN) {
                this.beginRange = this.range;
            } else if (state == WorldWind.CHANGED) {
                if (scale != 0) {
                    // Apply the change in pinch scale to this navigator's range, relative to the range when the gesture
                    // began.
                    this.range = this.beginRange / scale;
                    this.applyLimits();
                    this.worldWindow.redraw();
                }
            }
        };

        // Intentionally not documented.
        LookAtNavigator.prototype.handleRotation = function (recognizer) {
            var state = recognizer.state,
                rotation = recognizer.rotation;

            if (state == WorldWind.BEGAN) {
                this.lastRotation = 0;
            } else if (state == WorldWind.CHANGED) {
                // Apply the change in gesture rotation to this navigator's current heading. We apply relative to the
                // current heading rather than the heading when the gesture began in order to work simultaneously with
                // pan operations that also modify the current heading.
                this.heading -= rotation - this.lastRotation;
                this.lastRotation = rotation;
                this.applyLimits();
                this.worldWindow.redraw();
            }
        };

        // Intentionally not documented.
        LookAtNavigator.prototype.handleTilt = function (recognizer) {
            var state = recognizer.state,
                ty = recognizer.translationY;

            if (state == WorldWind.BEGAN) {
                this.beginTilt = this.tilt;
            } else if (state == WorldWind.CHANGED) {
                // Compute the gesture translation from screen coordinates to degrees. Use the canvas dimensions as a
                // metric for converting the translation to a fraction of an angle.
                var tiltDegrees = -90 * ty / this.worldWindow.canvas.clientHeight;
                // Apply the change in heading and tilt to this navigator's corresponding properties.
                this.tilt = this.beginTilt + tiltDegrees;
                this.applyLimits();
                this.worldWindow.redraw();
            }
        };

        // Intentionally not documented.
        LookAtNavigator.prototype.handleWheelEvent = function (event) {
            // Normalize the wheel delta based on the wheel delta mode. This produces a roughly consistent delta across
            // browsers and input devices.
            var normalizedDelta;
            if (event.deltaMode == WheelEvent.DOM_DELTA_PIXEL) {
                normalizedDelta = event.deltaY;
            } else if (event.deltaMode == WheelEvent.DOM_DELTA_LINE) {
                normalizedDelta = event.deltaY * 40;
            } else if (event.deltaMode == WheelEvent.DOM_DELTA_PAGE) {
                normalizedDelta = event.deltaY * 400;
            }

            // Compute a zoom scale factor by adding a fraction of the normalized delta to 1. When multiplied by the
            // navigator's range, this has the effect of zooming out or zooming in depending on whether the delta is
            // positive or negative, respectfully.
            var scale = 1 + (normalizedDelta / 1000);

            // Apply the scale to this navigator's properties.
            this.range *= scale;
            this.applyLimits();
            this.worldWindow.redraw();
        };

        // Intentionally not documented.
        LookAtNavigator.prototype.applyLimits = function () {
            // Clamp latitude to between -90 and +90, and normalize longitude to between -180 and +180.
            this.lookAtLocation.latitude = WWMath.clamp(this.lookAtLocation.latitude, -90, 90);
            this.lookAtLocation.longitude = Angle.normalizedDegreesLongitude(this.lookAtLocation.longitude);

            // Clamp range to values greater than 1 in order to prevent degenerating to a first-person navigator when
            // range is zero.
            this.range = WWMath.clamp(this.range, 1, Number.MAX_VALUE);

            // Normalize heading to between -180 and +180.
            this.heading = Angle.normalizedDegrees(this.heading);

            // Clamp tilt to between 0 and +90 to prevent the viewer from going upside down.
            this.tilt = WWMath.clamp(this.tilt, 0, 90);

            // Normalize heading to between -180 and +180.
            this.roll = Angle.normalizedDegrees(this.roll);

            // Apply 2D limits when the globe is 2D.
            if (this.worldWindow.globe.is2D() && this.enable2DLimits) {
                // Clamp range to prevent more than 360 degrees of visible longitude. Assumes a 45 degree horizontal
                // field of view.
                var maxRange = 2 * Math.PI * this.worldWindow.globe.equatorialRadius;
                this.range = WWMath.clamp(this.range, 1, maxRange);

                // Force tilt to 0 when in 2D mode to keep the viewer looking straight down.
                this.tilt = 0;
            }
        };

        return LookAtNavigator;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports Navigator
 * @version $Id: Navigator.js 3298 2015-07-06 17:28:33Z dcollins $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(1),
        __webpack_require__(0),
        __webpack_require__(5),
        __webpack_require__(20),
        __webpack_require__(10),
        __webpack_require__(17),
        __webpack_require__(2),
        __webpack_require__(4)], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
              Logger,
              Matrix,
              NavigatorState,
              Position,
              UnsupportedOperationError,
              Vec3,
              WWMath) {
        "use strict";

        /**
         * Constructs a base navigator.
         * @alias Navigator
         * @constructor
         * @classdesc Provides an abstract base class for navigators. This class is not meant to be instantiated
         * directly. See {@Link LookAtNavigator} for a concrete navigator.
         * @param {WorldWindow} worldWindow The world window to associate with this navigator.
         */
        var Navigator = function (worldWindow) {
            if (!worldWindow) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Navigator", "constructor", "missingWorldWindow"));
            }

            /**
             * The {@link WorldWindow} associated with this navigator.
             * @type {WorldWindow}
             * @readonly
             */
            this.worldWindow = worldWindow;

            /**
             * This navigator's heading, in degrees clockwise from north.
             * @type {Number}
             * @default 0
             */
            this.heading = 0;

            /**
             * This navigator's tilt, in degrees.
             * @type {Number}
             * @default 0
             */
            this.tilt = 0;

            /**
             * This navigator's roll, in degrees.
             * @type {Number}
             * @default 0
             */
            this.roll = 0;

            // Intentionally not documented.
            this.nearDistance = 1;

            // Intentionally not documented.
            this.farDistance = 10e6;
        };

        /**
         * Returns the current state of this navigator. Subclasses must override this method.
         * @returns {NavigatorState} The current state of this navigator.
         */
        Navigator.prototype.currentState = function () {
            throw new UnsupportedOperationError(
                Logger.logMessage(Logger.LEVEL_SEVERE, "Navigator", "currentState", "abstractInvocation"));
        };

        /**
         * Returns the current navigator state for a specified model-view matrix.
         * This method is meant to be called only by subclasses;
         * applications should not call this method.
         * @protected
         * @param {Matrix} modelviewMatrix The modelview matrix.
         * @returns {NavigatorState} The current navigator state.
         * @throws {ArgumentError} If the specified matrix is null or undefined.
         */
        Navigator.prototype.currentStateForModelview = function (modelviewMatrix) {
            if (!modelviewMatrix) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "Navigator", "currentStateForModelview", "missingMatrix"));
            }

            var globe = this.worldWindow.globe,
                globeRadius = WWMath.max(globe.equatorialRadius, globe.polarRadius),
                eyePoint = modelviewMatrix.extractEyePoint(new Vec3(0, 0, 0)),
                eyePos = globe.computePositionFromPoint(eyePoint[0], eyePoint[1], eyePoint[2], new Position(0, 0, 0)),
                viewport = this.worldWindow.viewport,
                viewDepthBits = this.worldWindow.depthBits,
                distanceToSurface,
                maxNearDistance,
                projectionMatrix = Matrix.fromIdentity();

            // Compute the far clip distance based on the current eye altitude. This must be done after computing the
            // modelview matrix and before computing the near clip distance. The far clip distance depends on the
            // modelview matrix, and the near clip distance depends on the far clip distance.
            this.farDistance = WWMath.horizonDistanceForGlobeRadius(globeRadius, eyePos.altitude);
            if (this.farDistance < 1e3)
                this.farDistance = 1e3;

            // Compute the near clip distance in order to achieve a desired depth resolution at the far clip distance.
            // This computed distance is limited such that it does not intersect the terrain when possible and is never
            // less than a predetermined minimum (usually one). The computed near distance automatically scales with the
            // resolution of the WebGL depth buffer.
            this.nearDistance = WWMath.perspectiveNearDistanceForFarDistance(this.farDistance, 10, viewDepthBits);

            // Prevent the near clip plane from intersecting the terrain.
            distanceToSurface = eyePos.altitude - globe.elevationAtLocation(eyePos.latitude, eyePos.longitude);
            if (distanceToSurface > 0) {
                maxNearDistance = WWMath.perspectiveNearDistance(viewport.width, viewport.height, distanceToSurface);
                if (this.nearDistance > maxNearDistance)
                    this.nearDistance = maxNearDistance;
            }

            if (this.nearDistance < 1)
                this.nearDistance = 1;

            // Compute the current projection matrix based on this navigator's perspective properties and the current
            // WebGL viewport.
            projectionMatrix.setToPerspectiveProjection(viewport.width, viewport.height, this.nearDistance, this.farDistance);

            return new NavigatorState(modelviewMatrix, projectionMatrix, viewport, this.heading, this.tilt);
        };

        return Navigator;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports ProjectionEquirectangular
 * @version $Id: ProjectionEquirectangular.js 2821 2015-02-20 16:59:27Z dcollins $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(6),
        __webpack_require__(1),
        __webpack_require__(43),
        __webpack_require__(0),
        __webpack_require__(2)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Angle,
              ArgumentError,
              GeographicProjection,
              Logger,
              Vec3) {
        "use strict";

        /**
         * Constructs an Equirectangular geographic projection, also known as Equidistant Cylindrical, Plate Carree and
         * Rectangular. The projected globe is spherical, not ellipsoidal.
         * @alias ProjectionEquirectangular
         * @constructor
         * @augments GeographicProjection
         * @classdesc Represents an equirectangular geographic projection.
         */
        var ProjectionEquirectangular = function () {

            GeographicProjection.call(this, "Equirectangular", true, null);
        };

        ProjectionEquirectangular.prototype = Object.create(GeographicProjection.prototype);

        Object.defineProperties(ProjectionEquirectangular.prototype, {
            /**
             * A string identifying this projection's current state. Used to compare states during rendering to
             * determine whether globe-state dependent cached values must be updated. Applications typically do not
             * interact with this property.
             * @memberof ProjectionEquirectangular.prototype
             * @readonly
             * @type {String}
             */
            stateKey: {
                get: function () {
                    return "projection equirectangular ";
                }
            }
        });

        // Documented in base class.
        ProjectionEquirectangular.prototype.geographicToCartesian = function (globe, latitude, longitude, elevation,
                                                                              offset, result) {
            if (!globe) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "ProjectionEquirectangular",
                    "geographicToCartesian", "missingGlobe"));
            }

            if (!result) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "ProjectionEquirectangular",
                    "geographicToCartesian", "missingResult"));
            }

            result[0] = globe.equatorialRadius * longitude * Angle.DEGREES_TO_RADIANS + (offset ? offset[0] : 0);
            result[1] = globe.equatorialRadius * latitude * Angle.DEGREES_TO_RADIANS;
            result[2] = elevation;

            return result;
        };

        // Documented in base class.
        ProjectionEquirectangular.prototype.geographicToCartesianGrid = function (globe, sector, numLat, numLon,
                                                                                  elevations, referencePoint,
                                                                                  offset, result) {
            if (!globe) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "ProjectionEquirectangular",
                    "geographicToCartesianGrid", "missingGlobe"));
            }

            if (!sector) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "ProjectionEquirectangular",
                    "geographicToCartesianGrid", "missingSector"));
            }

            if (!elevations || elevations.length < numLat * numLon) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "ProjectionEquirectangular",
                    "geographicToCartesianGrid",
                    "The specified elevations array is null, undefined or insufficient length"));
            }

            if (!result) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "ProjectionEquirectangular",
                    "geographicToCartesianGrid", "missingResult"));
            }

            var eqr = globe.equatorialRadius,
                minLat = sector.minLatitude * Angle.DEGREES_TO_RADIANS,
                maxLat = sector.maxLatitude * Angle.DEGREES_TO_RADIANS,
                minLon = sector.minLongitude * Angle.DEGREES_TO_RADIANS,
                maxLon = sector.maxLongitude * Angle.DEGREES_TO_RADIANS,
                deltaLat = (maxLat - minLat) / (numLat > 1 ? numLat - 1 : 1),
                deltaLon = (maxLon - minLon) / (numLon > 1 ? numLon - 1 : 1),
                refPoint = referencePoint ? referencePoint : new Vec3(0, 0, 0),
                offsetX = offset ? offset[0] : 0,
                latIndex, lonIndex,
                elevIndex = 0, resultIndex = 0,
                lat, lon, y;

            // Iterate over the latitude and longitude coordinates in the specified sector, computing the Cartesian
            // point corresponding to each latitude and longitude.
            for (latIndex = 0, lat = minLat; latIndex < numLat; latIndex++, lat += deltaLat) {
                if (latIndex === numLat - 1) {
                    lat = maxLat; // explicitly set the last lat to the max latitude to ensure alignment
                }

                // Latitude is constant for each row. Values that are a function of latitude can be computed once per row.
                y = eqr * lat - refPoint[1];

                for (lonIndex = 0, lon = minLon; lonIndex < numLon; lonIndex++, lon += deltaLon) {
                    if (lonIndex === numLon - 1) {
                        lon = maxLon; // explicitly set the last lon to the max longitude to ensure alignment
                    }

                    result[resultIndex++] = eqr * lon - refPoint[0] + offsetX;
                    result[resultIndex++] = y;
                    result[resultIndex++] = elevations[elevIndex++] - refPoint[2];
                }
            }

            return result;
        };

        // Documented in base class.
        ProjectionEquirectangular.prototype.cartesianToGeographic = function (globe, x, y, z, offset, result) {
            if (!globe) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "ProjectionEquirectangular",
                    "cartesianToGeographic", "missingGlobe"));
            }

            if (!result) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "ProjectionEquirectangular",
                    "cartesianToGeographic", "missingResult"));
            }

            result.latitude = (y / globe.equatorialRadius) * Angle.RADIANS_TO_DEGREES;
            result.longitude = ((x - (offset ? offset[0] : 0)) / globe.equatorialRadius) * Angle.RADIANS_TO_DEGREES;
            result.altitude = z;

            return result;
        };

        return ProjectionEquirectangular;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2015 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports ProjectionWgs84
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(6),
        __webpack_require__(1),
        __webpack_require__(43),
        __webpack_require__(0),
        __webpack_require__(10),
        __webpack_require__(2),
        __webpack_require__(4)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Angle,
              ArgumentError,
              GeographicProjection,
              Logger,
              Position,
              Vec3,
              WWMath) {
        "use strict";

        /**
         * Constructs a WGS84 ellipsoid
         * @alias ProjectionWgs84
         * @constructor
         * @augments GeographicProjection
         * @classdesc Represents a WGS84 ellipsoid.
         */
        var ProjectionWgs84 = function () {

            GeographicProjection.call(this, "WGS84", false, null);

            this.is2D = false;

            this.scratchPosition = new Position(0, 0, 0);
        };

        ProjectionWgs84.prototype = Object.create(GeographicProjection.prototype);

        Object.defineProperties(ProjectionWgs84.prototype, {
            /**
             * A string identifying this projection's current state. Used to compare states during rendering to
             * determine whether globe-state dependent cached values must be updated. Applications typically do not
             * interact with this property.
             * @memberof ProjectionEquirectangular.prototype
             * @readonly
             * @type {String}
             */
            stateKey: {
                get: function () {
                    return "projection wgs84 ";
                }
            }
        });

        // Documented in base class.
        ProjectionWgs84.prototype.geographicToCartesian = function (globe, latitude, longitude, altitude, offset,
                                                                    result) {
            if (!globe) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "ProjectionWgs84",
                    "geographicToCartesian", "missingGlobe"));
            }

            var cosLat = Math.cos(latitude * Angle.DEGREES_TO_RADIANS),
                sinLat = Math.sin(latitude * Angle.DEGREES_TO_RADIANS),
                cosLon = Math.cos(longitude * Angle.DEGREES_TO_RADIANS),
                sinLon = Math.sin(longitude * Angle.DEGREES_TO_RADIANS),
                rpm = globe.equatorialRadius / Math.sqrt(1.0 - globe.eccentricitySquared * sinLat * sinLat);

            result[0] = (rpm + altitude) * cosLat * sinLon;
            result[1] = (rpm * (1.0 - globe.eccentricitySquared) + altitude) * sinLat;
            result[2] = (rpm + altitude) * cosLat * cosLon;

            return result;
        };

        // Documented in base class.
        ProjectionWgs84.prototype.geographicToCartesianGrid = function (globe, sector, numLat, numLon, elevations,
                                                                        referencePoint, offset, result) {
            if (!globe) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "ProjectionWgs84",
                    "geographicToCartesianGrid", "missingGlobe"));
            }

            var minLat = sector.minLatitude * Angle.DEGREES_TO_RADIANS,
                maxLat = sector.maxLatitude * Angle.DEGREES_TO_RADIANS,
                minLon = sector.minLongitude * Angle.DEGREES_TO_RADIANS,
                maxLon = sector.maxLongitude * Angle.DEGREES_TO_RADIANS,
                deltaLat = (maxLat - minLat) / (numLat > 1 ? numLat - 1 : 1),
                deltaLon = (maxLon - minLon) / (numLon > 1 ? numLon - 1 : 1),
                refCenter = referencePoint ? referencePoint : new Vec3(0, 0, 0),
                latIndex, lonIndex,
                elevIndex = 0, resultIndex = 0,
                lat, lon, rpm, elev,
                cosLat, sinLat,
                cosLon = new Float64Array(numLon), sinLon = new Float64Array(numLon);

            // Compute and save values that are a function of each unique longitude value in the specified sector. This
            // eliminates the need to re-compute these values for each column of constant longitude.
            for (lonIndex = 0, lon = minLon; lonIndex < numLon; lonIndex++, lon += deltaLon) {
                if (lonIndex === numLon - 1) {
                    lon = maxLon; // explicitly set the last lon to the max longitude to ensure alignment
                }

                cosLon[lonIndex] = Math.cos(lon);
                sinLon[lonIndex] = Math.sin(lon);
            }

            // Iterate over the latitude and longitude coordinates in the specified sector, computing the Cartesian
            // point corresponding to each latitude and longitude.
            for (latIndex = 0, lat = minLat; latIndex < numLat; latIndex++, lat += deltaLat) {
                if (latIndex === numLat - 1) {
                    lat = maxLat; // explicitly set the last lat to the max longitude to ensure alignment
                }

                // Latitude is constant for each row. Values that are a function of latitude can be computed once per row.
                cosLat = Math.cos(lat);
                sinLat = Math.sin(lat);
                rpm = globe.equatorialRadius / Math.sqrt(1.0 - globe.eccentricitySquared * sinLat * sinLat);

                for (lonIndex = 0; lonIndex < numLon; lonIndex++) {
                    elev = elevations[elevIndex++];
                    result[resultIndex++] = (rpm + elev) * cosLat * sinLon[lonIndex] - refCenter[0];
                    result[resultIndex++] = (rpm * (1.0 - globe.eccentricitySquared) + elev) * sinLat - refCenter[1];
                    result[resultIndex++] = (rpm + elev) * cosLat * cosLon[lonIndex] - refCenter[2];
                }
            }

            return result;
        };

        // Documented in base class.
        ProjectionWgs84.prototype.cartesianToGeographic = function (globe, x, y, z, offset, result) {
            if (!globe) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "ProjectionWgs84",
                    "cartesianToGeographic", "missingGlobe"));
            }

            // According to H. Vermeille, "An analytical method to transform geocentric into geodetic coordinates"
            // http://www.springerlink.com/content/3t6837t27t351227/fulltext.pdf
            // Journal of Geodesy, accepted 10/2010, not yet published
            var X = z,
                Y = x,
                Z = y,
                XXpYY = X * X + Y * Y,
                sqrtXXpYY = Math.sqrt(XXpYY),
                a = globe.equatorialRadius,
                ra2 = 1 / (a * a),
                e2 = globe.eccentricitySquared,
                e4 = e2 * e2,
                p = XXpYY * ra2,
                q = Z * Z * (1 - e2) * ra2,
                r = (p + q - e4) / 6,
                h,
                phi,
                u,
                evoluteBorderTest = 8 * r * r * r + e4 * p * q,
                rad1,
                rad2,
                rad3,
                atan,
                v,
                w,
                k,
                D,
                sqrtDDpZZ,
                e,
                lambda,
                s2;

            if (evoluteBorderTest > 0 || q != 0) {
                if (evoluteBorderTest > 0) {
                    // Step 2: general case
                    rad1 = Math.sqrt(evoluteBorderTest);
                    rad2 = Math.sqrt(e4 * p * q);

                    // 10*e2 is my arbitrary decision of what Vermeille means by "near... the cusps of the evolute".
                    if (evoluteBorderTest > 10 * e2) {
                        rad3 = WWMath.cbrt((rad1 + rad2) * (rad1 + rad2));
                        u = r + 0.5 * rad3 + 2 * r * r / rad3;
                    }
                    else {
                        u = r + 0.5 * WWMath.cbrt((rad1 + rad2) * (rad1 + rad2))
                            + 0.5 * WWMath.cbrt((rad1 - rad2) * (rad1 - rad2));
                    }
                }
                else {
                    // Step 3: near evolute
                    rad1 = Math.sqrt(-evoluteBorderTest);
                    rad2 = Math.sqrt(-8 * r * r * r);
                    rad3 = Math.sqrt(e4 * p * q);
                    atan = 2 * Math.atan2(rad3, rad1 + rad2) / 3;

                    u = -4 * r * Math.sin(atan) * Math.cos(Math.PI / 6 + atan);
                }

                v = Math.sqrt(u * u + e4 * q);
                w = e2 * (u + v - q) / (2 * v);
                k = (u + v) / (Math.sqrt(w * w + u + v) + w);
                D = k * sqrtXXpYY / (k + e2);
                sqrtDDpZZ = Math.sqrt(D * D + Z * Z);

                h = (k + e2 - 1) * sqrtDDpZZ / k;
                phi = 2 * Math.atan2(Z, sqrtDDpZZ + D);
            }
            else {
                // Step 4: singular disk
                rad1 = Math.sqrt(1 - e2);
                rad2 = Math.sqrt(e2 - p);
                e = Math.sqrt(e2);

                h = -a * rad1 * rad2 / e;
                phi = rad2 / (e * rad2 + rad1 * Math.sqrt(p));
            }

            // Compute lambda
            s2 = Math.sqrt(2);
            if ((s2 - 1) * Y < sqrtXXpYY + X) {
                // case 1 - -135deg < lambda < 135deg
                lambda = 2 * Math.atan2(Y, sqrtXXpYY + X);
            }
            else if (sqrtXXpYY + Y < (s2 + 1) * X) {
                // case 2 - -225deg < lambda < 45deg
                lambda = -Math.PI * 0.5 + 2 * Math.atan2(X, sqrtXXpYY - Y);
            }
            else {
                // if (sqrtXXpYY-Y<(s2=1)*X) {  // is the test, if needed, but it's not
                // case 3: - -45deg < lambda < 225deg
                lambda = Math.PI * 0.5 - 2 * Math.atan2(X, sqrtXXpYY + Y);
            }

            result.latitude = Angle.RADIANS_TO_DEGREES * phi;
            result.longitude = Angle.RADIANS_TO_DEGREES * lambda;
            result.altitude = h;

            return result;
        };

        ProjectionWgs84.prototype.northTangentAtLocation = function (globe, latitude, longitude, result) {
            // The north-pointing tangent is derived by rotating the vector (0, 1, 0) about the Y-axis by longitude degrees,
            // then rotating it about the X-axis by -latitude degrees. The latitude angle must be inverted because latitude
            // is a clockwise rotation about the X-axis, and standard rotation matrices assume counter-clockwise rotation.
            // The combined rotation can be represented by a combining two rotation matrices Rlat, and Rlon, then
            // transforming the vector (0, 1, 0) by the combined transform:
            //
            // NorthTangent = (Rlon * Rlat) * (0, 1, 0)
            //
            // This computation can be simplified and encoded inline by making two observations:
            // - The vector's X and Z coordinates are always 0, and its Y coordinate is always 1.
            // - Inverting the latitude rotation angle is equivalent to inverting sinLat. We know this by the
            //  trigonometric identities cos(-x) = cos(x), and sin(-x) = -sin(x).

            var cosLat = Math.cos(latitude * Angle.DEGREES_TO_RADIANS),
                cosLon = Math.cos(longitude * Angle.DEGREES_TO_RADIANS),
                sinLat = Math.sin(latitude * Angle.DEGREES_TO_RADIANS),
                sinLon = Math.sin(longitude * Angle.DEGREES_TO_RADIANS);

            result[0] = -sinLat * sinLon;
            result[1] = cosLat;
            result[2] = -sinLat * cosLon;

            return result;
        };

        ProjectionWgs84.prototype.northTangentAtPoint = function (globe, x, y, z, offset, result) {
            this.cartesianToGeographic(globe, x, y, z, Vec3.ZERO, this.scratchPosition);

            return this.northTangentAtLocation(globe, this.scratchPosition.latitude, this.scratchPosition.longitude, result);
        };

        ProjectionWgs84.prototype.surfaceNormalAtPoint = function (globe, x, y, z, result) {
            if (!globe) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "ProjectionWgs84",
                    "surfaceNormalAtPoint", "missingGlobe"));
            }

            var eSquared = globe.equatorialRadius * globe.equatorialRadius,
                polSquared = globe.polarRadius * globe.polarRadius;

            result[0] = x / eSquared;
            result[1] = y / polSquared;
            result[2] = z / eSquared;

            return result.normalize();
        };

        return ProjectionWgs84;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2015 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports FramebufferTile
 * @version $Id: FramebufferTile.js 3345 2015-07-28 20:28:35Z dcollins $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(1),
        __webpack_require__(45),
        __webpack_require__(0),
        __webpack_require__(5),
        __webpack_require__(9),
        __webpack_require__(32)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
              FramebufferTexture,
              Logger,
              Matrix,
              Rectangle,
              TextureTile) {
        "use strict";

        /**
         * Constructs a framebuffer tile.
         * @alias FramebufferTile
         * @constructor
         * @augments TextureTile
         * @classdesc Represents a WebGL framebuffer applied to a portion of a globe's terrain. The framebuffer's width
         * and height in pixels are equal to this tile's [tileWidth]{@link FramebufferTile#tileWidth} and
         * [tileHeight]{@link FramebufferTile#tileHeight}, respectively. The framebuffer can be made active by calling
         * [bindFramebuffer]{@link FramebufferTile#bindFramebuffer}. Color fragments written to this
         * tile's framebuffer can then be drawn on the terrain surface using a
         * [SurfaceTileRenderer]{@link SurfaceTileRenderer}.
         * <p>
         * This class is meant to be used internally. Applications typically do not interact with this class.
         * @param {Sector} sector The sector this tile covers.
         * @param {Level} level The level this tile is associated with.
         * @param {Number} row This tile's row in the associated level.
         * @param {Number} column This tile's column in the associated level.
         * @param {String} cacheKey A string uniquely identifying this tile relative to other tiles.
         * @throws {ArgumentError} If the specified sector or level is null or undefined, the row or column arguments
         * are less than zero, or the cache name is null, undefined or empty.
         */
        var FramebufferTile = function (sector, level, row, column, cacheKey) {
            if (!cacheKey || (cacheKey.length < 1)) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "FramebufferTile", "constructor",
                        "The specified cache name is null, undefined or zero length."));
            }

            TextureTile.call(this, sector, level, row, column); // args are checked in the superclass' constructor

            // Assign the cacheKey as the gpuCacheKey (inherited from TextureTile).
            this.gpuCacheKey = cacheKey;

            // Internal. Intentionally not documented.
            this.textureTransform = Matrix.fromIdentity().setToUnitYFlip();

            // Internal. Intentionally not documented.
            this.mustClear = true;
        };

        FramebufferTile.prototype = Object.create(TextureTile.prototype);

        /**
         * Causes this tile to clear any color fragments written to its off-screen framebuffer.
         * @param dc The current draw context.
         */
        FramebufferTile.prototype.clearFramebuffer = function (dc) {
            this.mustClear = true;
        };

        /**
         * Causes this tile's off-screen framebuffer as the current WebGL framebuffer. WebGL operations that affect the
         * framebuffer now affect this tile's framebuffer, rather than the default WebGL framebuffer.
         * Color fragments are written to this tile's WebGL texture, which can be made active by calling
         * [SurfaceTile.bind]{@link SurfaceTile#bind}.
         *
         * @param {DrawContext} dc The current draw context.
         * @returns {Boolean} true if the framebuffer was bound successfully, otherwise false.
         */
        FramebufferTile.prototype.bindFramebuffer = function (dc) {
            var framebuffer = dc.gpuResourceCache.resourceForKey(this.gpuCacheKey);

            if (!framebuffer) {
                framebuffer = this.createFramebuffer(dc);
            }

            dc.bindFramebuffer(framebuffer);

            if (this.mustClear) {
                this.doClearFramebuffer(dc);
                this.mustClear = false;
            }

            return true;
        };

        // Internal. Intentionally not documented.
        FramebufferTile.prototype.createFramebuffer = function (dc) {
            var framebuffer = new FramebufferTexture(dc.currentGlContext, this.tileWidth, this.tileHeight, false);
            dc.gpuResourceCache.putResource(this.gpuCacheKey, framebuffer, framebuffer.size);

            return framebuffer;
        };

        // Internal. Intentionally not documented.
        FramebufferTile.prototype.doClearFramebuffer = function (dc) {
            var gl = dc.currentGlContext;
            gl.clearColor(0, 0, 0, 0);
            gl.clear(gl.COLOR_BUFFER_BIT);
        };

        /**
         * Applies the appropriate texture transform to display this tile's WebGL texture.
         * @param {DrawContext} dc The current draw context.
         * @param {Matrix} matrix The matrix to apply the transform to.
         */
        FramebufferTile.prototype.applyInternalTransform = function (dc, matrix) {
            matrix.multiplyMatrix(this.textureTransform);
        };

        return FramebufferTile;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2015 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports FramebufferTileController
 * @version $Id: FramebufferTileController.js 3130 2015-05-29 18:20:15Z dcollins $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(1),
        __webpack_require__(74),
        __webpack_require__(27),
        __webpack_require__(7),
        __webpack_require__(0),
        __webpack_require__(16),
        __webpack_require__(3),
        __webpack_require__(12)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
              FramebufferTile,
              LevelSet,
              Location,
              Logger,
              MemoryCache,
              Sector,
              Tile) {
        "use strict";

        /**
         * Constructs a framebuffer tile controller.
         * @alias FramebufferTileController
         * @constructor
         * @classdesc Provides access to a multi-resolution WebGL framebuffer arranged as adjacent tiles in a pyramid.
         * World Wind shapes use this class internally to draw on the terrain surface. Applications typically do not
         * interact with this class.
         */
        var FramebufferTileController = function () {

            /**
             * The width in pixels of framebuffers associated with this controller's tiles.
             * @type {Number}
             * @readonly
             */
            this.tileWidth = 256;

            /**
             * The height in pixels of framebuffers associated with this controller's tiles.
             * @type {Number}
             * @readonly
             */
            this.tileHeight = 256;

            /**
             * Controls the level of detail switching for this controller. The next highest resolution level is
             * used when an image's texel size is greater than this number of pixels.
             * @type {Number}
             * @default 1.75
             */
            this.detailControl = 1.75;

            // Internal. Intentionally not documented.
            this.levels = new LevelSet(Sector.FULL_SPHERE, new Location(45, 45), 16, this.tileWidth, this.tileHeight);

            // Internal. Intentionally not documented.
            this.topLevelTiles = [];

            // Internal. Intentionally not documented.
            this.currentTiles = [];

            // Internal. Intentionally not documented.
            this.currentTimestamp = null;

            // Internal. Intentionally not documented.
            this.currentGlobeStateKey = null;

            // Internal. Intentionally not documented.
            this.tileCache = new MemoryCache(500000, 400000);

            // Internal. Intentionally not documented.
            this.key = "FramebufferTileController " + ++FramebufferTileController.keyPool;
        };

        // Internal. Intentionally not documented.
        FramebufferTileController.keyPool = 0; // source of unique ids

        /**
         * Returns a set of multi-resolution [FramebufferTile]{@link FramebufferTile} instances appropriate for the
         * current draw context that overlap a specified sector.
         * @param {DrawContext} dc The current draw context.
         * @param {Sector} sector The geographic region of interest.
         * @returns {Array} The set of multi-resolution framebuffer tiles that overlap the sector.
         * @throws {ArgumentError} If the specified sector is null.
         */
        FramebufferTileController.prototype.selectTiles = function (dc, sector) {
            if (!sector) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "FramebufferTileController",
                    "selectTiles", "missingSector"));
            }

            // Assemble a set of global tiles appropriate for the draw context.
            this.assembleTiles(dc);

            // Collect the tiles that overlap the specified sector and mark them as selected.
            var tiles = [];
            for (var i = 0, len = this.currentTiles.length; i < len; i++) {
                var tile = this.currentTiles[i];
                if (tile.sector.overlaps(sector)) {
                    tile.selected = true;
                    tiles.push(tile);
                }
            }

            return tiles;
        };

        /**
         * Draws this multi-resolution framebuffer on the terrain surface then clears the framebuffer. This has no
         * effect if the framebuffer is unchanged since the last call to render.
         * @param {DrawContext} dc The current draw context.
         */
        FramebufferTileController.prototype.render = function (dc) {
            // Exit immediately if there are no framebuffer tiles. This can happen when there ar eno surface shapes in
            // the scene, for example.
            if (this.currentTiles.length == 0) {
                return;
            }

            // Collect the tiles that have changed since the last call to render.
            var tiles = [];
            for (var i = 0, len = this.currentTiles.length; i < len; i++) {
                var tile = this.currentTiles[i];
                if (tile.selected) {
                    tiles.push(tile);
                }
            }

            // Draw the changed tiles on the terrain surface.
            dc.surfaceTileRenderer.renderTiles(dc, tiles, 1);

            // Clear the changed tile's WebGL framebuffers.
            var gl = dc.currentGlContext,
                framebuffer = dc.currentFramebuffer;
            try {
                gl.clearColor(0, 0, 0, 0);
                for (i = 0, len = tiles.length; i < len; i++) {
                    tile = tiles[i];
                    tile.selected = false;
                    tile.bindFramebuffer(dc);
                    gl.clear(gl.COLOR_BUFFER_BIT);
                }
            } finally {
                dc.bindFramebuffer(framebuffer);
            }
        };

        // Internal. Intentionally not documented.
        FramebufferTileController.prototype.assembleTiles = function (dc) {
            var timestamp = dc.timestamp,
                globeStateKey = dc.globeStateKey;

            if (this.currentTimestamp != timestamp ||
                this.currentGlobeStateKey != globeStateKey) {

                this.doAssembleTiles(dc);

                this.currentTimestamp = timestamp;
                this.currentGlobeStateKey = globeStateKey;
            }
        };

        // Internal. Intentionally not documented.
        FramebufferTileController.prototype.doAssembleTiles = function (dc) {
            this.currentTiles = [];

            if (!dc.terrain) {
                return;
            }

            if (this.topLevelTiles.length == 0) {
                this.createTopLevelTiles();
            }

            for (var i = 0, len = this.topLevelTiles.length; i < len; i++) {
                var tile = this.topLevelTiles[i];
                tile.update(dc);

                if (this.isTileVisible(dc, tile)) {
                    this.addTileOrDescendants(dc, tile);
                }
            }
        };

        // Internal. Intentionally not documented.
        FramebufferTileController.prototype.createTile = function (sector, level, row, column) {
            var tileKey = this.key + " " + level.levelNumber + "." + row + "." + column;
            return new FramebufferTile(sector, level, row, column, tileKey);
        };

        // Internal. Intentionally not documented.
        FramebufferTileController.prototype.createTopLevelTiles = function () {
            Tile.createTilesForLevel(this.levels.firstLevel(), this, this.topLevelTiles);
        };

        // Internal. Intentionally not documented.
        FramebufferTileController.prototype.addTileOrDescendants = function (dc, tile) {
            if (this.tileMeetsRenderingCriteria(dc, tile)) {
                this.addTile(tile);
                return;
            }

            var subTiles = tile.subdivideToCache(tile.level.nextLevel(), this, this.tileCache);
            for (var i = 0, len = subTiles.length; i < len; i++) {
                var child = subTiles[i];
                child.update(dc);

                if (this.isTileVisible(dc, child)) {
                    this.addTileOrDescendants(dc, child);
                }
            }
        };

        // Internal. Intentionally not documented.
        FramebufferTileController.prototype.addTile = function (tile) {
            this.currentTiles.push(tile);
        };

        // Internal. Intentionally not documented.
        FramebufferTileController.prototype.isTileVisible = function (dc, tile) {
            if (dc.globe.projectionLimits && !tile.sector.overlaps(dc.globe.projectionLimits)) {
                return false;
            }

            if (dc.pickingMode) {
                return tile.extent.intersectsFrustum(dc.pickFrustum);
            }

            return tile.extent.intersectsFrustum(dc.navigatorState.frustumInModelCoordinates);
        };

        // Internal. Intentionally not documented.
        FramebufferTileController.prototype.tileMeetsRenderingCriteria = function (dc, tile) {
            var s = this.detailControl;
            if (tile.sector.minLatitude >= 75 || tile.sector.maxLatitude <= -75) {
                s *= 1.2;
            }

            return tile.level.isLastLevel() || !tile.mustSubdivide(dc, s);
        };

        return FramebufferTileController;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2015 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports ScreenCreditController
 * @version $Id: ScreenCreditController.js 3345 2015-07-28 20:28:35Z dcollins $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(1),
        __webpack_require__(49),
        __webpack_require__(8),
        __webpack_require__(86),
        __webpack_require__(0),
        __webpack_require__(5),
        __webpack_require__(88),
        __webpack_require__(21),
        __webpack_require__(46),
        __webpack_require__(2),
        __webpack_require__(4)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
              BasicTextureProgram,
              Color,
              Font,
              Logger,
              Matrix,
              Offset,
              PickedObject,
              Renderable,
              Vec3,
              WWMath) {
        "use strict";

        /**
         * Constructs a screen credit controller.
         * @alias ScreenCreditController
         * @constructor
         * @classdesc Collects and displays screen credits.
         */
        var ScreenCreditController = function () {
            // Internal. Intentionally not documented.
            this.imageUrls = [];

            // Internal. Intentionally not documented.
            this.stringCredits = [];

            // Internal. Intentionally not documented.
            this.imageCreditSize = 64;

            // Internal. Intentionally not documented.
            this.margin = 5;

            // Internal. Intentionally not documented.
            this.opacity = 0.5;

            // Internal. Intentionally not documented.
            this.creditFont = new Font(14);
        };

        // Internal use only. Intentionally not documented.
        ScreenCreditController.scratchMatrix = Matrix.fromIdentity(); // scratch variable
        ScreenCreditController.imageTransform = Matrix.fromIdentity(); // scratch variable
        ScreenCreditController.texCoordMatrix = Matrix.fromIdentity(); // scratch variable

        /**
         * Clears all credits from this controller.
         */
        ScreenCreditController.prototype.clear = function () {
            this.imageUrls = [];
            this.stringCredits = [];
        };

        /**
         * Adds an image credit to this controller.
         * @param {String} imageUrl The URL of the image to display in the credits area.
         * @throws {ArgumentError} If the specified URL is null or undefined.
         */
        ScreenCreditController.prototype.addImageCredit = function (imageUrl) {
            if (!imageUrl) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "ScreenCreditController", "addImageCredit", "missingUrl"));
            }

            if (this.imageUrls.indexOf(imageUrl) === -1) {
                this.imageUrls.push(imageUrl);
            }
        };

        /**
         * Adds a string credit to this controller.
         * @param {String} stringCredit The string to display in the credits area.
         * @param (Color} color The color with which to draw the string.
         * @throws {ArgumentError} If either the specified string or color is null or undefined.
         */
        ScreenCreditController.prototype.addStringCredit = function (stringCredit, color) {
            if (!stringCredit) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "ScreenCreditController", "addStringCredit", "missingText"));
            }

            if (!color) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "ScreenCreditController", "addStringCredit", "missingColor"));
            }

            if (this.stringCredits.indexOf(stringCredit) === -1) {
                this.stringCredits.push({
                    text: stringCredit,
                    color: color || Color.WHITE
                });
            }
        };

        // Internal use only. Intentionally not documented.
        ScreenCreditController.prototype.drawCredits = function (dc) {
            // Check to see if there's anything to draw.
            if ((this.imageUrls.length === 0 && this.stringCredits.length === 0)) {
                return;
            }

            // Picking not provided.
            if (dc.pickingMode) {
                return;
            }

            // Want to draw only once per frame.
            if (dc.timestamp == this.lastFrameTimestamp) {
                return;
            }
            this.lastFrameTimestamp = dc.timestamp;

            this.beginDrawingCredits(dc);

            // Draw the image credits in a row along the bottom of the window from right to left.
            var imageX = dc.navigatorState.viewport.width - (this.margin + this.imageCreditSize),
                imageHeight, maxImageHeight = 0;

            for (var i = 0; i < this.imageUrls.length; i++) {
                imageHeight = this.drawImageCredit(dc, this.imageUrls[i], imageX, this.margin);
                if (imageHeight > 0) {
                    imageX -= (this.margin + this.imageCreditSize);
                    maxImageHeight = WWMath.max(imageHeight, maxImageHeight);
                }
            }

            // Draw the string credits above the image credits and progressing from bottom to top.
            var stringY = maxImageHeight + this.margin;
            for (var j = 0; j < this.stringCredits.length; j++) {
                this.drawStringCredit(dc, this.stringCredits[j], stringY);
                stringY += this.margin + 15; // margin + string height
            }

            this.endDrawingCredits(dc);
        };

        // Internal use only. Intentionally not documented.
        ScreenCreditController.prototype.beginDrawingCredits = function (dc) {
            var gl = dc.currentGlContext,
                program;

            dc.findAndBindProgram(BasicTextureProgram);

            // Configure GL to use the draw context's unit quad VBOs for both model coordinates and texture coordinates.
            // Most browsers can share the same buffer for vertex and texture coordinates, but Internet Explorer requires
            // that they be in separate buffers, so the code below uses the 3D buffer for vertex coords and the 2D
            // buffer for texture coords.
            program = dc.currentProgram;
            gl.bindBuffer(gl.ARRAY_BUFFER, dc.unitQuadBuffer3());
            gl.vertexAttribPointer(program.vertexPointLocation, 3, gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ARRAY_BUFFER, dc.unitQuadBuffer());
            gl.vertexAttribPointer(program.vertexTexCoordLocation, 2, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(program.vertexPointLocation);
            gl.enableVertexAttribArray(program.vertexTexCoordLocation);

            // Tell the program which texture unit to use.
            program.loadTextureUnit(gl, gl.TEXTURE0);
            program.loadModulateColor(gl, false);

            // Turn off depth testing.
            // tag, 6/17/15: It's not clear why this call was here. It was carried over from WWJ.
            //gl.disable(WebGLRenderingContext.DEPTH_TEST);
        };

        // Internal use only. Intentionally not documented.
        ScreenCreditController.prototype.endDrawingCredits = function (dc) {
            var gl = dc.currentGlContext,
                program = dc.currentProgram;

            // Clear the vertex attribute state.
            gl.disableVertexAttribArray(program.vertexPointLocation);
            gl.disableVertexAttribArray(program.vertexTexCoordLocation);

            // Clear GL bindings.
            gl.bindBuffer(gl.ARRAY_BUFFER, null);
            gl.bindTexture(gl.TEXTURE_2D, null);

            // Re-enable depth testing.
            gl.enable(gl.DEPTH_TEST);
        };

        // Internal use only. Intentionally not documented.
        ScreenCreditController.prototype.drawImageCredit = function (dc, creditUrl, x, y) {
            var imageWidth, imageHeight, scale, activeTexture, gl, program;

            activeTexture = dc.gpuResourceCache.resourceForKey(creditUrl);
            if (!activeTexture) {
                dc.gpuResourceCache.retrieveTexture(dc.currentGlContext, creditUrl);
                return 0;
            }

            // Scale the image to fit within a constrained size.
            imageWidth = activeTexture.imageWidth;
            imageHeight = activeTexture.imageHeight;
            if (imageWidth <= this.imageCreditSize && this.imageHeight <= this.imageCreditSize) {
                scale = 1;
            } else if (imageWidth >= imageHeight) {
                scale = this.imageCreditSize / imageWidth;
            } else {
                scale = this.imageCreditSize / imageHeight;
            }

            ScreenCreditController.imageTransform.setTranslation(x, y, 0);
            ScreenCreditController.imageTransform.setScale(scale * imageWidth, scale * imageHeight, 1);

            gl = dc.currentGlContext;
            program = dc.currentProgram;

            // Compute and specify the MVP matrix.
            ScreenCreditController.scratchMatrix.copy(dc.screenProjection);
            ScreenCreditController.scratchMatrix.multiplyMatrix(ScreenCreditController.imageTransform);
            program.loadModelviewProjection(gl, ScreenCreditController.scratchMatrix);

            program.loadTextureEnabled(gl, true);
            program.loadColor(gl, Color.WHITE);
            program.loadOpacity(gl, this.opacity);

            ScreenCreditController.texCoordMatrix.setToIdentity();
            ScreenCreditController.texCoordMatrix.multiplyByTextureTransform(activeTexture);
            program.loadTextureMatrix(gl, ScreenCreditController.texCoordMatrix);

            if (activeTexture.bind(dc)) { // returns false if active texture cannot be bound
                // Draw the image quad.
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            }

            return imageHeight;
        };

        // Internal use only. Intentionally not documented.
        ScreenCreditController.prototype.drawStringCredit = function (dc, credit, y) {
            var imageWidth, imageHeight, activeTexture, textureKey, gl, program, x;

            textureKey = credit.text + this.creditFont.toString();
            activeTexture = dc.gpuResourceCache.resourceForKey(textureKey);
            if (!activeTexture) {
                activeTexture = dc.textSupport.createTexture(dc, credit.text, this.creditFont, false);
                dc.gpuResourceCache.putResource(textureKey, activeTexture, activeTexture.size);
            }

            imageWidth = activeTexture.imageWidth;
            imageHeight = activeTexture.imageHeight;

            x = dc.navigatorState.viewport.width - (imageWidth + this.margin);
            ScreenCreditController.imageTransform.setTranslation(x, y, 0);
            ScreenCreditController.imageTransform.setScale(imageWidth, imageHeight, 1);

            gl = dc.currentGlContext;
            program = dc.currentProgram;

            // Compute and specify the MVP matrix.
            ScreenCreditController.scratchMatrix.copy(dc.screenProjection);
            ScreenCreditController.scratchMatrix.multiplyMatrix(ScreenCreditController.imageTransform);
            program.loadModelviewProjection(gl, ScreenCreditController.scratchMatrix);

            program.loadTextureEnabled(gl, true);
            program.loadColor(gl, credit.color);
            program.loadOpacity(gl, this.opacity);

            ScreenCreditController.texCoordMatrix.setToIdentity();
            ScreenCreditController.texCoordMatrix.multiplyByTextureTransform(activeTexture);
            program.loadTextureMatrix(gl, ScreenCreditController.texCoordMatrix);

            if (activeTexture.bind(dc)) { // returns false if active texture cannot be bound
                // Draw the image quad.
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            }

            return true;
        };

        return ScreenCreditController;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports SurfaceTile
 * @version $Id: SurfaceTile.js 2941 2015-03-30 21:11:43Z tgaskins $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(1),
        __webpack_require__(0),
        __webpack_require__(5),
        __webpack_require__(3),
        __webpack_require__(17)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
              Logger,
              Matrix,
              Sector,
              UnsupportedOperationError) {
        "use strict";

        /**
         * Constructs a surface tile for a specified sector.
         * @alias SurfaceTile
         * @constructor
         * @classdesc Defines an abstract base class for imagery to be rendered on terrain. Applications typically
         * do not interact with this class.
         * @param {Sector} sector The sector of this surface tile.
         * @throws {ArgumentError} If the specified sector is null or undefined.
         */
        var SurfaceTile = function (sector) {
            if (!sector) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "SurfaceTile", "constructor",
                    "missingSector"));
            }

            /**
             * The sector spanned by this surface tile.
             * @type {Sector}
             */
            this.sector = sector;
        };

        /**
         * Causes this surface tile to be active, typically by binding the tile's texture in WebGL.
         * Subclasses must override this function.
         * @param {DrawContext} dc The current draw context.
         * @returns {Boolean} true if the resource was successfully bound, otherwise false.
         */
        SurfaceTile.prototype.bind = function (dc) {
            throw new UnsupportedOperationError(
                Logger.logMessage(Logger.LEVEL_SEVERE, "SurfaceTile", "bind", "abstractInvocation"));
        };

        /**
         * Applies this surface tile's internal transform, typically a texture transform to align the associated
         * resource with the terrain.
         * Subclasses must override this function.
         * @param {DrawContext} dc The current draw context.
         * @param {Matrix} matrix The transform to apply.
         */
        SurfaceTile.prototype.applyInternalTransform = function (dc, matrix) {
            throw new UnsupportedOperationError(
                Logger.logMessage(Logger.LEVEL_SEVERE, "SurfaceTile", "applyInternalTransform", "abstractInvocation"));
        };

        return SurfaceTile;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports SurfaceTileRenderer
 * @version $Id: SurfaceTileRenderer.js 3345 2015-07-28 20:28:35Z dcollins $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(1),
        __webpack_require__(0),
        __webpack_require__(5),
        __webpack_require__(50),
        __webpack_require__(83)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
              Logger,
              Matrix,
              SurfaceShapeTile,
              SurfaceTileRendererProgram) {
        "use strict";

        /**
         * Constructs a new surface tile renderer.
         * @alias SurfaceTileRenderer
         * @constructor
         * @classdesc This class is responsible for rendering imagery onto the terrain.
         * It is meant to be used internally. Applications typically do not interact with this class.
         */
        var SurfaceTileRenderer = function () {

            // Scratch values to avoid constantly recreating these matrices.
            this.texMaskMatrix = Matrix.fromIdentity();
            this.texSamplerMatrix = Matrix.fromIdentity();

            // Internal. Intentionally not documented.
            this.isSurfaceShapeTileRendering = false;
        };

        /**
         * Render a specified collection of surface tiles.
         * @param {DrawContext} dc The current draw context.
         * @param {SurfaceTile[]} surfaceTiles The surface tiles to render.
         * @param {Number} opacity The opacity at which to draw the surface tiles.
         * @param {Boolean} tilesHaveOpacity If true, incoming tiles each have their own opacity property and
         * it's value is applied when the tile is drawn.
         * @throws {ArgumentError} If the specified surface tiles array is null or undefined.
         */
        SurfaceTileRenderer.prototype.renderTiles = function (dc, surfaceTiles, opacity, tilesHaveOpacity) {
            if (!surfaceTiles) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "SurfaceTileRenderer", "renderTiles",
                        "Specified surface tiles array is null or undefined."));
            }

            if (surfaceTiles.length < 1)
                return;

            var terrain = dc.terrain,
                gl = dc.currentGlContext,
                tileCount = 0,// for frame statistics,
                program,
                terrainTile,
                terrainTileSector,
                surfaceTile,
                currentTileOpacity = 1;

            if (!terrain)
                return;

            this.isSurfaceShapeTileRendering = surfaceTiles[0] instanceof SurfaceShapeTile;

            opacity *= dc.surfaceOpacity;

            // For each terrain tile, render it for each overlapping surface tile.
            program = this.beginRendering(dc, opacity);
            terrain.beginRendering(dc);
            try {
                for (var i = 0, ttLen = terrain.surfaceGeometry.length; i < ttLen; i++) {
                    terrainTile = terrain.surfaceGeometry[i];
                    terrainTileSector = terrainTile.sector;

                    terrain.beginRenderingTile(dc, terrainTile);
                    try {
                        // Render the terrain tile for each overlapping surface tile.
                        for (var j = 0, stLen = surfaceTiles.length; j < stLen; j++) {
                            surfaceTile = surfaceTiles[j];
                            if (surfaceTile.sector.overlaps(terrainTileSector)) {
                                if (surfaceTile.bind(dc)) {
                                    if (dc.pickingMode) {
                                        if (surfaceTile.pickColor) {
                                            program.loadColor(gl, surfaceTile.pickColor);
                                        } else {
                                            // Surface shape tiles don't use a pick color. Pick colors are encoded into
                                            // the colors of the individual shapes drawn into the tile.
                                        }
                                    } else {
                                        if (tilesHaveOpacity && surfaceTile.opacity != currentTileOpacity) {
                                            program.loadOpacity(gl, opacity * surfaceTile.opacity);
                                            currentTileOpacity = surfaceTile.opacity;
                                        }
                                    }

                                    this.applyTileState(dc, terrainTile, surfaceTile);
                                    terrain.renderTile(dc, terrainTile);
                                    ++tileCount;
                                }
                            }
                        }
                    }
                    catch (e) {
                        console.log(e);
                    }
                    finally {
                        terrain.endRenderingTile(dc, terrainTile);
                    }
                }
            }
            catch (e) {
                console.log(e);
            }
            finally {
                terrain.endRendering(dc);
                this.endRendering(dc);
                dc.frameStatistics.incrementRenderedTileCount(tileCount);
            }
        };

        // Intentionally not documented.
        SurfaceTileRenderer.prototype.beginRendering = function (dc, opacity) {
            var gl = dc.currentGlContext,
                program = dc.findAndBindProgram(SurfaceTileRendererProgram);
            program.loadTexSampler(gl, gl.TEXTURE0);

            if (dc.pickingMode && !this.isSurfaceShapeTileRendering) {
                program.loadModulateColor(gl, true);
            } else {
                program.loadModulateColor(gl, false);
                program.loadOpacity(gl, opacity);
            }

            return program;
        };

        // Intentionally not documented.
        SurfaceTileRenderer.prototype.endRendering = function (dc) {
            var gl = dc.currentGlContext;
            gl.bindTexture(gl.TEXTURE_2D, null);
        };

        // Intentionally not documented.
        SurfaceTileRenderer.prototype.applyTileState = function (dc, terrainTile, surfaceTile) {
            // Sets up the texture transform and mask that applies the texture tile to the terrain tile.
            var gl = dc.currentGlContext,
                program = dc.currentProgram,
                terrainSector = terrainTile.sector,
                terrainDeltaLat = terrainSector.deltaLatitude(),
                terrainDeltaLon = terrainSector.deltaLongitude(),
                surfaceSector = surfaceTile.sector,
                rawSurfaceDeltaLat = surfaceSector.deltaLatitude(),
                rawSurfaceDeltaLon = surfaceSector.deltaLongitude(),
                surfaceDeltaLat = rawSurfaceDeltaLat > 0 ? rawSurfaceDeltaLat : 1,
                surfaceDeltaLon = rawSurfaceDeltaLon > 0 ? rawSurfaceDeltaLon : 1,
                sScale = terrainDeltaLon / surfaceDeltaLon,
                tScale = terrainDeltaLat / surfaceDeltaLat,
                sTrans = -(surfaceSector.minLongitude - terrainSector.minLongitude) / surfaceDeltaLon,
                tTrans = -(surfaceSector.minLatitude - terrainSector.minLatitude) / surfaceDeltaLat;

            this.texMaskMatrix.set(
                sScale, 0, 0, sTrans,
                0, tScale, 0, tTrans,
                0, 0, 1, 0,
                0, 0, 0, 1
            );

            this.texSamplerMatrix.setToUnitYFlip();
            surfaceTile.applyInternalTransform(dc, this.texSamplerMatrix);
            this.texSamplerMatrix.multiplyMatrix(this.texMaskMatrix);

            program.loadTexSamplerMatrix(gl, this.texSamplerMatrix);
            program.loadTexMaskMatrix(gl, this.texMaskMatrix);
        };

        return SurfaceTileRenderer;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports TextSupport
 * @version $Id: TextSupport.js 3302 2015-07-06 22:20:36Z dcollins $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(1),
        __webpack_require__(49),
        __webpack_require__(8),
        __webpack_require__(0),
        __webpack_require__(5),
        __webpack_require__(25),
        __webpack_require__(14)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
              BasicTextureProgram,
              Color,
              Logger,
              Matrix,
              Texture,
              Vec2) {
        "use strict";

        /**
         * Constructs a TextSupport instance.
         * @alias TextSupport
         * @constructor
         * @classdesc Provides methods useful for displaying text. An instance of this class is attached to the
         * World Window {@link DrawContext} and is not intended to be used independently of that. Applications typically do
         * not create instances of this class.
         */
        var TextSupport = function () {

            // Internal use only. Intentionally not documented.
            this.canvas2D = document.createElement("canvas");

            // Internal use only. Intentionally not documented.
            this.ctx2D = this.canvas2D.getContext("2d");

            // Internal use only. Intentionally not documented.
            this.lineSpacing = 0.15; // fraction of font size

            // Internal use only. Intentionally not documented.
            this.strokeStyle = "rgba(0, 0, 0, " + 0.5 + ")";

            // Internal use only. Intentionally not documented.
            this.strokeWidth = 4;
        };

        /**
         * Returns the width and height of a specified text string upon applying a specified font and optional outline.
         * @param {string} text The text string.
         * @param {Font} font The font to apply when drawing the text.
         * @param {Boolean} outline Indicates whether the text includes an outline, which increases its width and height.
         * @returns {Vec2} A vector indicating the text's width and height, respectively, in pixels.
         */
        TextSupport.prototype.textSize = function (text, font, outline) {
            if (text.length === 0) {
                return new Vec2(0, 0);
            }

            this.ctx2D.font = font.fontString;

            var lines = text.split("\n"),
                height = lines.length * (font.size * (1 + this.lineSpacing)),
                maxWidth = 0;

            for (var i = 0; i < lines.length; i++) {
                maxWidth = Math.max(maxWidth, this.ctx2D.measureText(lines[i]).width);
            }

            if (outline) {
                maxWidth += this.strokeWidth;
                height += this.strokeWidth;
            }

            return new Vec2(maxWidth, height);
        };

        /**
         * Creates a texture for a specified text string, a specified font and an optional outline.
         * @param {DrawContext} dc The current draw context.
         * @param {String} text The text string.
         * @param {Font} font The font to use.
         * @param {Boolean} outline Indicates whether the text is drawn with a thin black outline.
         * @returns {Texture} A texture for the specified text string and font.
         */
        TextSupport.prototype.createTexture = function (dc, text, font, outline) {
            var gl = dc.currentGlContext,
                ctx2D = this.ctx2D,
                canvas2D = this.canvas2D,
                textSize = this.textSize(text, font, outline),
                lines = text.split("\n"),
                strokeOffset = outline ? this.strokeWidth / 2 : 0,
                pixelScale = dc.pixelScale,
                x, y;

            canvas2D.width = Math.ceil(textSize[0]) * pixelScale;
            canvas2D.height = Math.ceil(textSize[1]) * pixelScale;

            ctx2D.scale(pixelScale, pixelScale);
            ctx2D.font = font.fontString;
            ctx2D.textBaseline = "top";
            ctx2D.textAlign = font.horizontalAlignment;
            ctx2D.fillStyle = Color.WHITE.toHexString(false);
            ctx2D.strokeStyle = this.strokeStyle;
            ctx2D.lineWidth = this.strokeWidth;
            ctx2D.lineCap = "round";
            ctx2D.lineJoin = "round";

            if (font.horizontalAlignment === "left") {
                ctx2D.translate(strokeOffset, 0);
            } else if (font.horizontalAlignment === "right") {
                ctx2D.translate(textSize[0] - strokeOffset, 0);
            } else {
                ctx2D.translate(textSize[0] / 2, 0);
            }

            for (var i = 0; i < lines.length; i++) {
                if (outline) {
                    ctx2D.strokeText(lines[i], 0, 0);
                }
                ctx2D.fillText(lines[i], 0, 0);
                ctx2D.translate(0, font.size * (1 + this.lineSpacing) + strokeOffset);
            }

            return new Texture(gl, canvas2D);
        };

        /**
         * Calculates maximum line height based on a font
         * @param {Font} font The font to use.
         * @returns {Vec2} A vector indicating the text's width and height, respectively, in pixels based on the passed font.
         */
        TextSupport.prototype.getMaxLineHeight = function(font)
        {
            // Check underscore + capital E with acute accent
            return this.textSize("_\u00c9", font, 0)[1];
        };

        /**
         * Wraps the text based on width and height using new linew delimiter
         * @param {String} text The text to wrap.
         * @param {Number} width The width in pixels.
         * @param {Number} height The height in pixels.
         * @param {Font} font The font to use.
         * @returns {String} The wrapped text.
         */
        TextSupport.prototype.wrap = function(text, width, height, font)
        {
            if (!text) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.WARNING, "TextSupport", "wrap", "missing text"));
            }

            var i;

            var lines = text.split("\n");
            var wrappedText = "";

            // Wrap each line
            for (i = 0; i < lines.length; i++)
            {
                lines[i] = this.wrapLine(lines[i], width, font);
            }
            // Concatenate all lines in one string with new line separators
            // between lines - not at the end
            // Checks for height limit.
            var currentHeight = 0;
            var heightExceeded = false;
            var maxLineHeight = this.getMaxLineHeight(font);
            for (i = 0; i < lines.length && !heightExceeded; i++)
            {
                var subLines = lines[i].split("\n");
                for (var j = 0; j < subLines.length && !heightExceeded; j++)
                {
                    if (height <= 0 || currentHeight + maxLineHeight <= height)
                    {
                        wrappedText += subLines[j];
                        currentHeight += maxLineHeight + this.lineSpacing;
                        if (j < subLines.length - 1) {
                            wrappedText += '\n';
                        }
                    }
                    else
                    {
                        heightExceeded = true;
                    }
                }

                if (i < lines.length - 1 && !heightExceeded) {
                    wrappedText += '\n';
                }
            }
            // Add continuation string if text truncated
            if (heightExceeded)
            {
                if (wrappedText.length > 0) {
                    wrappedText = wrappedText.substring(0, wrappedText.length - 1);
                }

                wrappedText += "...";
            }

            return wrappedText;
        };

        /**
         * Wraps a line of text based on width and height
         * @param {String} text The text to wrap.
         * @param {Number} width The width in pixels.
         * @param {Font} font The font to use.
         * @returns {String} The wrapped text.
         */
        TextSupport.prototype.wrapLine = function(text, width, font)
        {
            var wrappedText = "";

            // Single line - trim leading and trailing spaces
            var source = text.trim();
            var lineBounds = this.textSize(source, font, 0);
            if (lineBounds[0] > width)
            {
                // Split single line to fit preferred width
                var line = "";
                var start = 0;
                var end = source.indexOf(' ', start + 1);
                while (start < source.length)
                {
                    if (end == -1) {
                        end = source.length;   // last word
                    }

                    // Extract a 'word' which is in fact a space and a word
                    var word = source.substring(start, end);
                    var linePlusWord = line + word;
                    if (this.textSize(linePlusWord, font, 0)[0] <= width)
                    {
                        // Keep adding to the current line
                        line += word;
                    }
                    else
                    {
                        // Width exceeded
                        if (line.length != 0)
                        {
                            // Finish current line and start new one
                            wrappedText += line;
                            wrappedText += '\n';
                            line = "";
                            line += word.trim();  // get read of leading space(s)
                        }
                        else
                        {
                            // Line is empty, force at least one word
                            line += word.trim();
                        }
                    }
                    // Move forward in source string
                    start = end;
                    if (start < source.length - 1)
                    {
                        end = source.indexOf(' ', start + 1);
                    }
                }
                // Gather last line
                wrappedText += line;
            }
            else
            {
                // Line doesn't need to be wrapped
                wrappedText += source;
            }

            return wrappedText;
        };

        return TextSupport;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports GpuShader
 * @version $Id: GpuShader.js 2906 2015-03-17 18:45:22Z tgaskins $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(1),
        __webpack_require__(0)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
              Logger) {
        "use strict";

        /**
         * Constructs a GPU shader of a specified type with specified GLSL source code.
         *
         * @alias GpuShader
         * @constructor
         * @classdesc
         * Represents an OpenGL shading language (GLSL) shader and provides methods for compiling and disposing
         * of them.
         *
         * @param {WebGLRenderingContext} gl The current WebGL context.
         * @param {Number} shaderType The type of shader, either WebGLRenderingContext.VERTEX_SHADER
         * or WebGLRenderingContext.FRAGMENT_SHADER.
         * @param {String} shaderSource The shader's source code.
         * @throws {ArgumentError} If the shader type is unrecognized, the shader source is null or undefined or shader
         * compilation fails. If the compilation fails the error thrown contains any compilation messages.
         */
        var GpuShader = function (gl, shaderType, shaderSource) {
            if (!(shaderType === gl.VERTEX_SHADER
                || shaderType === gl.FRAGMENT_SHADER)) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "GpuShader", "constructor",
                    "The specified shader type is unrecognized."));
            }

            if (!shaderSource) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "GpuShader", "constructor",
                    "The specified shader source is null or undefined."));
            }

            var shader = gl.createShader(shaderType);
            if (!shader) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "GpuShader", "constructor",
                    "Unable to create shader of type " +
                    (shaderType == gl.VERTEX_SHADER ? "VERTEX_SHADER." : "FRAGMENT_SHADER.")));
            }

            if (!this.compile(gl, shader, shaderType, shaderSource)) {
                var infoLog = gl.getShaderInfoLog(shader);

                gl.deleteShader(shader);

                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "GpuShader", "constructor",
                    "Unable to compile shader: " + infoLog));
            }

            this.shaderId = shader;
        };

        /**
         * Compiles the source code for this shader. This method is not meant to be invoked by applications. It is
         * invoked internally as needed.
         * @param {WebGLRenderingContext} gl The current WebGL rendering context.
         * @param {WebGLShader} shaderId The shader ID.
         * @param {Number} shaderType The type of shader, either WebGLRenderingContext.VERTEX_SHADER
         * or WebGLRenderingContext.FRAGMENT_SHADER.
         * @param {String} shaderSource The shader's source code.
         * @returns {boolean} <code>true</code> if the shader compiled successfully, otherwise <code>false</code>.
         */
        GpuShader.prototype.compile = function (gl, shaderId, shaderType, shaderSource) {
            gl.shaderSource(shaderId, shaderSource);
            gl.compileShader(shaderId);

            return gl.getShaderParameter(shaderId, gl.COMPILE_STATUS);
        };

        /**
         * Releases this shader's WebGL shader.
         * @param {WebGLRenderingContext} gl The current WebGL rendering context.
         */
        GpuShader.prototype.dispose = function (gl) {
            if (this.shaderId) {
                gl.deleteShader(this.shaderId);
                delete this.shaderId;
            }
        };

        return GpuShader;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports GroundProgram
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(47)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (AtmosphereProgram) {
        "use strict";

        /**
         * Constructs a new program.
         * Initializes, compiles and links this GLSL program with the source code for its vertex and fragment shaders.
         * <p>
         * This method creates WebGL shaders for the program's shader sources and attaches them to a new GLSL program.
         * This method then compiles the shaders and then links the program if compilation is successful. Use the bind
         * method to make the program current during rendering.
         *
         * @alias GroundProgram
         * @constructor
         * @augments AtmosphereProgram
         * @classdesc GroundProgram is a GLSL program that draws the ground component of the atmosphere.
         * @param {WebGLRenderingContext} gl The current WebGL context.
         * @throws {ArgumentError} If the shaders cannot be compiled, or linking of
         * the compiled shaders into a program fails.
         */
        var GroundProgram = function (gl) {
            var vertexShaderSource =
                    'precision mediump int;\n' +

                    'const int FRAGMODE_GROUND_PRIMARY_TEX_BLEND = 4;\n' +
                    'const int SAMPLE_COUNT = 2;\n' +
                    'const float SAMPLES = 2.0;\n' +

                    'const float PI = 3.141592653589;\n' +
                    'const float Kr = 0.0025;\n' +
                    'const float Kr4PI = Kr * 4.0 * PI;\n' +
                    'const float Km = 0.0015;\n' +
                    'const float Km4PI = Km * 4.0 * PI;\n' +
                    'const float ESun = 15.0;\n' +
                    'const float KmESun = Km * ESun;\n' +
                    'const float KrESun = Kr * ESun;\n' +
                    'const vec3 invWavelength = vec3(5.60204474633241, 9.473284437923038, 19.643802610477206);\n' +
                    'const float rayleighScaleDepth = 0.25;\n' +

                    'uniform int fragMode;\n' +
                    'uniform mat4 mvpMatrix;\n' +
                    'uniform mat3 texCoordMatrix;\n' +
                    'uniform vec3 vertexOrigin;\n' +
                    'uniform vec3 eyePoint;\n' +
                    'uniform float eyeMagnitude;\n' + /* The eye point's magnitude */
                    'uniform float eyeMagnitude2;\n' + /* eyeMagnitude^2 */
                    'uniform vec3 lightDirection;\n' + /* The direction vector to the light source */
                    'uniform float atmosphereRadius;\n' + /* The outer (atmosphere) radius */
                    'uniform float atmosphereRadius2;\n' + /* atmosphereRadius^2 */
                    'uniform float globeRadius;\n' + /* The inner (planetary) radius */
                    'uniform float scale;\n' + /* 1 / (atmosphereRadius - globeRadius) */
                    'uniform float scaleDepth;\n' + /* The scale depth (i.e. the altitude at which
                     the atmosphere's average density is found) */
                    'uniform float scaleOverScaleDepth;\n' + /* fScale / fScaleDepth */

                    'attribute vec4 vertexPoint;\n' +
                    'attribute vec2 vertexTexCoord;\n' +

                    'varying vec3 primaryColor;\n' +
                    'varying vec3 secondaryColor;\n' +
                    'varying vec2 texCoord;\n' +

                    'float scaleFunc(float cos) {\n' +
                    '    float x = 1.0 - cos;\n' +
                    '    return scaleDepth * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\n' +
                    '}\n' +

                    'void sampleGround() {\n' +
                    /* Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the
                     atmosphere) */
                    '    vec3 point = vertexPoint.xyz + vertexOrigin;\n' +
                    '    vec3 ray = point - eyePoint;\n' +
                    '    float far = length(ray);\n' +
                    '    ray /= far;\n' +

                    '    vec3 start;\n' +
                    '    if (eyeMagnitude < atmosphereRadius) {\n' +
                    '        start = eyePoint;\n' +
                    '    } else {\n' +
                    /* Calculate the closest intersection of the ray with the outer atmosphere (which is the near point of the ray
                     passing through the atmosphere) */
                    '        float B = 2.0 * dot(eyePoint, ray);\n' +
                    '        float C = eyeMagnitude2 - atmosphereRadius2;\n' +
                    '        float det = max(0.0, B*B - 4.0 * C);\n' +
                    '        float near = 0.5 * (-B - sqrt(det));\n' +

                    /* Calculate the ray's starting point, then calculate its scattering offset */
                    '        start = eyePoint + ray * near;\n' +
                    '        far -= near;\n' +
                    '}\n' +

                    '    float depth = exp((globeRadius - atmosphereRadius) / scaleDepth);\n' +
                    '    float eyeAngle = dot(-ray, point) / length(point);\n' +
                    '    float lightAngle = dot(lightDirection, point) / length(point);\n' +
                    '    float eyeScale = scaleFunc(eyeAngle);\n' +
                    '    float lightScale = scaleFunc(lightAngle);\n' +
                    '    float eyeOffset = depth*eyeScale;\n' +
                    '    float temp = (lightScale + eyeScale);\n' +

                    /* Initialize the scattering loop variables */
                    '    float sampleLength = far / SAMPLES;\n' +
                    '    float scaledLength = sampleLength * scale;\n' +
                    '    vec3 sampleRay = ray * sampleLength;\n' +
                    '    vec3 samplePoint = start + sampleRay * 0.5;\n' +

                    /* Now loop through the sample rays */
                    '    vec3 frontColor = vec3(0.0, 0.0, 0.0);\n' +
                    '    vec3 attenuate = vec3(0.0, 0.0, 0.0);\n' +
                    '    for(int i=0; i<SAMPLE_COUNT; i++)\n' +
                    '    {\n' +
                    '        float height = length(samplePoint);\n' +
                    '        float depth = exp(scaleOverScaleDepth * (globeRadius - height));\n' +
                    '        float scatter = depth*temp - eyeOffset;\n' +
                    '        attenuate = exp(-scatter * (invWavelength * Kr4PI + Km4PI));\n' +
                    '        frontColor += attenuate * (depth * scaledLength);\n' +
                    '        samplePoint += sampleRay;\n' +
                    '    }\n' +

                    '    primaryColor = frontColor * (invWavelength * KrESun + KmESun);\n' +
                    '    secondaryColor = attenuate;\n' + /* Calculate the attenuation factor for the ground */
                    '}\n' +

                    'void main()\n ' +
                    '{\n' +
                    '    sampleGround();\n' +
                    /* Transform the vertex point by the modelview-projection matrix */
                    '    gl_Position = mvpMatrix * vertexPoint;\n' +
                    '    if (fragMode == FRAGMODE_GROUND_PRIMARY_TEX_BLEND) {\n' +
                    /* Transform the vertex texture coordinate by the tex coord matrix */
                    '        texCoord = (texCoordMatrix * vec3(vertexTexCoord, 1.0)).st;\n' +
                    '    }\n' +
                    '}',
                fragmentShaderSource =
                    'precision mediump float;\n' +
                    'precision mediump int;\n' +

                    'const int FRAGMODE_GROUND_PRIMARY = 2;\n' +
                    'const int FRAGMODE_GROUND_SECONDARY = 3;\n' +
                    'const int FRAGMODE_GROUND_PRIMARY_TEX_BLEND = 4;\n' +

                    'uniform int fragMode;\n' +
                    'uniform sampler2D texSampler;\n' +

                    'varying vec3 primaryColor;\n' +
                    'varying vec3 secondaryColor;\n' +
                    'varying vec2 texCoord;\n' +

                    'void main (void)\n' +
                    '{\n' +
                    '    if (fragMode == FRAGMODE_GROUND_PRIMARY) {\n' +
                    '        gl_FragColor = vec4(primaryColor, 1.0);\n' +
                    '    } else if (fragMode == FRAGMODE_GROUND_SECONDARY) {\n' +
                    '        gl_FragColor = vec4(secondaryColor, 1.0);\n' +
                    '    } else if (fragMode == FRAGMODE_GROUND_PRIMARY_TEX_BLEND) {\n' +
                    '        vec4 texColor = texture2D(texSampler, texCoord);\n' +
                    '        gl_FragColor = vec4(primaryColor + texColor.rgb * (1.0 - secondaryColor), 1.0);\n' +
                    '    }\n' +
                    '}';

            // Call to the superclass, which performs shader program compiling and linking.
            AtmosphereProgram.call(this, gl, vertexShaderSource, fragmentShaderSource, ["vertexPoint", "vertexTexCoord"]);
        };

        /**
         * A string that uniquely identifies this program.
         * @type {string}
         * @readonly
         */
        GroundProgram.key = "WorldWindGroundProgram";

        // Inherit from AtmosphereProgram.
        GroundProgram.prototype = Object.create(AtmosphereProgram.prototype);

        return GroundProgram;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));




/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports SkyProgram
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(47)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (AtmosphereProgram) {
        "use strict";

        /**
         * Constructs a new program.
         * Initializes, compiles and links this GLSL program with the source code for its vertex and fragment shaders.
         * <p>
         * This method creates WebGL shaders for the program's shader sources and attaches them to a new GLSL program.
         * This method then compiles the shaders and then links the program if compilation is successful. Use the bind
         * method to make the program current during rendering.
         *
         * @alias SkyProgram
         * @constructor
         * @augments AtmosphereProgram
         * @classdesc SkyProgram is a GLSL program that draws the sky component of the atmosphere.
         * @param {WebGLRenderingContext} gl The current WebGL context.
         * @throws {ArgumentError} If the shaders cannot be compiled, or linking of
         * the compiled shaders into a program fails.
         */
        var  SkyProgram = function (gl) {
            var vertexShaderSource =
                    'precision mediump int;\n' +

                    'const int SAMPLE_COUNT = 2;\n' +
                    'const float SAMPLES = 2.0;\n' +

                    'const float PI = 3.141592653589;\n' +
                    'const float Kr = 0.0025;\n' +
                    'const float Kr4PI = Kr * 4.0 * PI;\n' +
                    'const float Km = 0.0015;\n' +
                    'const float Km4PI = Km * 4.0 * PI;\n' +
                    'const float ESun = 15.0;\n' +
                    'const float KmESun = Km * ESun;\n' +
                    'const float KrESun = Kr * ESun;\n' +
                    'const vec3 invWavelength = vec3(5.60204474633241, 9.473284437923038, 19.643802610477206);\n' +
                    'const float rayleighScaleDepth = 0.25;\n' +

                    'uniform mat4 mvpMatrix;\n' +
                    'uniform vec3 vertexOrigin;\n' +
                    'uniform vec3 eyePoint;\n' +
                    'uniform float eyeMagnitude;\n' +        /* The eye point's magnitude */
                    'uniform float eyeMagnitude2;\n' +       /* eyeMagnitude^2 */
                    'uniform mediump vec3 lightDirection;\n' +       /* The direction vector to the light source */
                    'uniform float atmosphereRadius;\n' +    /* The outer (atmosphere) radius */
                    'uniform float atmosphereRadius2;\n' +   /* atmosphereRadius^2 */
                    'uniform float globeRadius;\n' +         /* The inner (planetary) radius */
                    'uniform float scale;\n' +               /* 1 / (atmosphereRadius - globeRadius) */
                    'uniform float scaleDepth;\n' +          /* The scale depth (i.e. the altitude at which the
                     atmosphere's average density is found) */
                    'uniform float scaleOverScaleDepth;\n' + /* fScale / fScaleDepth */

                    'attribute vec4 vertexPoint;\n' +

                    'varying vec3 primaryColor;\n' +
                    'varying vec3 secondaryColor;\n' +
                    'varying vec3 direction;\n' +

                    'float scaleFunc(float cos)\n' +
                    '{\n' +
                    '    float x = 1.0 - cos;\n' +
                    '    return scaleDepth * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\n' +
                    '}\n' +

                    'void sampleSky() {\n' +
                        /* Get the ray from the camera to the vertex and its length (which is the far point of
                         the ray passing through the atmosphere) */
                    '    vec3 point = vertexPoint.xyz + vertexOrigin;\n' +
                    '    vec3 ray = point - eyePoint;\n' +
                    '    float far = length(ray);\n' +
                    '    ray /= far;\n' +

                    '    vec3 start;\n' +
                    '    float startOffset;\n' +

                    '    if (eyeMagnitude < atmosphereRadius) {\n' +
                        /* Calculate the ray's starting point, then calculate its scattering offset */
                    '        start = eyePoint;\n' +
                    '        float height = length(start);\n' +
                    '        float depth = exp(scaleOverScaleDepth * (globeRadius - eyeMagnitude));\n' +
                    '        float startAngle = dot(ray, start) / height;\n' +
                    '        startOffset = depth*scaleFunc(startAngle);\n' +
                    '    } else {\n' +
                        /* Calculate the closest intersection of the ray with the outer atmosphere (which is the near
                         point of the ray passing through the atmosphere) */
                    '        float B = 2.0 * dot(eyePoint, ray);\n' +
                    '        float C = eyeMagnitude2 - atmosphereRadius2;\n' +
                    '        float det = max(0.0, B*B - 4.0 * C);\n' +
                    '        float near = 0.5 * (-B - sqrt(det));\n' +

                        /* Calculate the ray's starting point, then calculate its scattering offset */
                    '        start = eyePoint + ray * near;\n' +
                    '        far -= near;\n' +
                    '        float startAngle = dot(ray, start) / atmosphereRadius;\n' +
                    '        float startDepth = exp(-1.0 / scaleDepth);\n' +
                    '        startOffset = startDepth*scaleFunc(startAngle);\n' +
                    '    }\n' +

                        /* Initialize the scattering loop variables */
                    '    float sampleLength = far / SAMPLES;\n' +
                    '    float scaledLength = sampleLength * scale;\n' +
                    '    vec3 sampleRay = ray * sampleLength;\n' +
                    '    vec3 samplePoint = start + sampleRay * 0.5;\n' +

                        /* Now loop through the sample rays */
                    '    vec3 frontColor = vec3(0.0, 0.0, 0.0);\n' +
                    '    for(int i=0; i<SAMPLE_COUNT; i++)\n' +
                    '    {\n' +
                    '       float height = length(samplePoint);\n' +
                    '       float depth = exp(scaleOverScaleDepth * (globeRadius - height));\n' +
                    '       float lightAngle = dot(lightDirection, samplePoint) / height;\n' +
                    '       float cameraAngle = dot(ray, samplePoint) / height;\n' +
                    '       float scatter = (startOffset + depth*(scaleFunc(lightAngle) - scaleFunc(cameraAngle)));\n'+
                    '       vec3 attenuate = exp(-scatter * (invWavelength * Kr4PI + Km4PI));\n' +
                    '       frontColor += attenuate * (depth * scaledLength);\n' +
                    '       samplePoint += sampleRay;\n' +
                    '    }\n' +

                        /* Finally, scale the Mie and Rayleigh colors and set up the varying variables for the fragment
                         shader */
                    '    primaryColor = frontColor * (invWavelength * KrESun);\n' +
                    '    secondaryColor = frontColor * KmESun;\n' +
                    '    direction = eyePoint - point;\n' +
                    '}\n' +

                    'void main()\n' +
                    '{\n' +
                    '    sampleSky();\n' +

                        /* Transform the vertex point by the modelview-projection matrix */
                    '    gl_Position = mvpMatrix * vertexPoint;\n' +

                        /* fix horizon clipping */
                    '    gl_Position.z = gl_Position.w - 0.00001;\n' +
                    '}',
                fragmentShaderSource =
                    '#ifdef GL_FRAGMENT_PRECISION_HIGH\n'+
                    'precision highp float;\n'+
                    '#else\n'+
                    'precision mediump float;\n'+
                    '#endif\n'+

                    'const float g = -0.95;\n' +
                    'const float g2 = g * g;\n' +
                        
                    'uniform mediump vec3 lightDirection;\n' +

                    'varying vec3 primaryColor;\n' +
                    'varying vec3 secondaryColor;\n' +
                    'varying vec3 direction;\n' +

                    'void main (void)\n' +
                    '{\n' +
                    '    float cos = dot(lightDirection, direction) / length(direction);\n' +
                    '    float rayleighPhase = 0.75 * (1.0 + cos * cos);\n' +
                    '    float miePhase = 1.5 * ((1.0 - g2) / (2.0 + g2)) * (1.0 + cos*cos) / ' +
                    '        pow(1.0 + g2 - 2.0*g*cos, 1.5);\n' +
                    '    const float exposure = 2.0;\n' +
                    '    vec3 color = primaryColor * rayleighPhase + secondaryColor * miePhase;\n' +
                    '    color = vec3(1.0) - exp(-exposure * color);\n' +
                    '    gl_FragColor = vec4(color, color.b);\n' +
                    '}';

            // Call to the superclass, which performs shader program compiling and linking.
            AtmosphereProgram.call(this, gl, vertexShaderSource, fragmentShaderSource, ["vertexPoint"]);
        };

        /**
         * A string that uniquely identifies this program.
         * @type {string}
         * @readonly
         */
        SkyProgram.key = "WorldWindSkyProgram";

        // Inherit from AtmosphereProgram.
        SkyProgram.prototype = Object.create(AtmosphereProgram.prototype);

        return SkyProgram;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));





/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports SurfaceTileRendererProgram
 * @version $Id: SurfaceTileRendererProgram.js 3327 2015-07-21 19:03:39Z dcollins $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(1),
        __webpack_require__(8),
        __webpack_require__(11),
        __webpack_require__(0)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
              Color,
              GpuProgram,
              Logger) {
        "use strict";

        /**
         * Constructs a new surface-tile-renderer program.
         * Initializes, compiles and links this GLSL program with the source code for its vertex and fragment shaders.
         * <p>
         * This method creates WebGL shaders for the program's shader sources and attaches them to a new GLSL program. This
         * method then compiles the shaders and links the program if compilation is successful. Use the bind method to make the
         * program current during rendering.
         *
         * @alias SurfaceTileRendererProgram
         * @constructor
         * @augments GpuProgram
         * @classdesc A GLSL program that draws textured geometry on the globe's terrain.
         * Application's typically do not interact with this class.
         * @param {WebGLRenderingContext} gl The current WebGL context.
         */
        var SurfaceTileRendererProgram = function (gl) {
            var vertexShaderSource =
                    'attribute vec4 vertexPoint;\n' +
                    'attribute vec4 vertexTexCoord;\n' +
                    'uniform mat4 mvpMatrix;\n' +
                    'uniform mat4 texSamplerMatrix;\n' +
                    'uniform mat4 texMaskMatrix;\n' +
                    'varying vec2 texSamplerCoord;\n' +
                    'varying vec2 texMaskCoord;\n' +
                    'void main() {\n' +
                    'gl_Position = mvpMatrix * vertexPoint;\n' +
                        /* Transform the vertex texture coordinate into sampler texture coordinates. */
                    'texSamplerCoord = (texSamplerMatrix * vertexTexCoord).st;\n' +
                        /* Transform the vertex texture coordinate into mask texture coordinates. */
                    'texMaskCoord = (texMaskMatrix * vertexTexCoord).st;\n' +
                    '}',
                fragmentShaderSource =
                    'precision mediump float;\n' +
                        /* Uniform sampler indicating the texture 2D unit (0, 1, 2, etc.) to use when sampling texture color. */
                    'uniform sampler2D texSampler;\n' +
                    'uniform float opacity;\n' +
                    'uniform vec4 color;\n' +
                    'uniform bool modulateColor;\n' +
                    'varying vec2 texSamplerCoord;\n' +
                    'varying vec2 texMaskCoord;\n' +
                        /*
                         * Returns true when the texture coordinate samples texels outside the texture image.
                         */
                    'bool isInsideTextureImage(const vec2 coord) {\n' +
                    '    return coord.x >= 0.0 && coord.x <= 1.0 && coord.y >= 0.0 && coord.y <= 1.0;\n' +
                    '}\n' +
                        /*
                         * OpenGL ES Shading Language v1.00 fragment shader for SurfaceTileRendererProgram. Writes the value of the texture 2D
                         * object bound to texSampler at the current transformed texture coordinate, multiplied by the uniform opacity. Writes
                         * transparent black (0, 0, 0, 0) if the transformed texture coordinate indicates a texel outside of the texture data's
                         * standard range of [0,1].
                         */
                    'void main(void) {\n' +
                        'float mask = float(isInsideTextureImage(texMaskCoord));' +
                    'if (modulateColor) {\n' +
                    '    gl_FragColor = color * mask * floor(texture2D(texSampler, texSamplerCoord).a + 0.5);\n' +
                    '} else {\n' +
                        /* Return either the sampled texture2D color multiplied by opacity or transparent black. */
                    '    gl_FragColor = texture2D(texSampler, texSamplerCoord) * mask * opacity;\n' +
                    '}\n' +
                    '}';

            // Call to the superclass, which performs shader program compiling and linking.
            GpuProgram.call(this, gl, vertexShaderSource, fragmentShaderSource);

            // Capture the attribute and uniform locations.

            /**
             * This program's vertex point location.
             * @type {Number}
             * @readonly
             */
            this.vertexPointLocation = this.attributeLocation(gl, "vertexPoint");

            /**
             * This program's texture coordinate location.
             * @type {Number}
             * @readonly
             */
            this.vertexTexCoordLocation = this.attributeLocation(gl, "vertexTexCoord");

            /**
             * This program's modelview-projection matrix location.
             * @type {WebGLUniformLocation}
             * @readonly
             */
            this.mvpMatrixLocation = this.uniformLocation(gl, "mvpMatrix");

            /**
             * The WebGL location for this program's 'color' uniform.
             * @type {WebGLUniformLocation}
             * @readonly
             */
            this.colorLocation = this.uniformLocation(gl, "color");

            /**
             * The WebGL location for this program's 'modulateColor' uniform.
             * @type {WebGLUniformLocation}
             * @readonly
             */
            this.modulateColorLocation = this.uniformLocation(gl, "modulateColor");

            // The rest of these are strictly internal and intentionally not documented.
            this.texSamplerMatrixLocation = this.uniformLocation(gl, "texSamplerMatrix");
            this.texMaskMatrixLocation = this.uniformLocation(gl, "texMaskMatrix");
            this.texSamplerLocation = this.uniformLocation(gl, "texSampler");
            this.opacityLocation = this.uniformLocation(gl, "opacity");

            /**
             * The WebGL location for this program's 'vertexTexCoord' attribute.
             * @type {Number}
             * @readonly
             */
            this.vertexPointLocation = -1;
        };

        /**
         * A string that uniquely identifies this program.
         * @type {string}
         * @readonly
         */
        SurfaceTileRendererProgram.key = "WorldWindGpuSurfaceTileRenderingProgram";

        SurfaceTileRendererProgram.prototype = Object.create(GpuProgram.prototype);

        /**
         * Loads the specified matrix as the value of this program's 'mvpMatrix' uniform variable.
         *
         * @param {WebGLRenderingContext} gl The current WebGL context.
         * @param {Matrix} matrix The matrix to load.
         * @throws {ArgumentError} If the specified matrix is null or undefined.
         */
        SurfaceTileRendererProgram.prototype.loadModelviewProjection = function (gl, matrix) {
            if (!matrix) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "SurfaceTileRendererProgram", "loadModelviewProjection",
                        "missingMatrix"));
            }

            this.loadUniformMatrix(gl, matrix, this.mvpMatrixLocation);
        };

        /**
         * Loads the specified matrix as the value of this program's 'texSamplerMatrix' uniform variable.
         *
         * @param {WebGLRenderingContext} gl The current WebGL context.
         * @param {Matrix} matrix The matrix to load.
         * @throws {ArgumentError} If the specified matrix is null or undefined.
         */
        SurfaceTileRendererProgram.prototype.loadTexSamplerMatrix = function (gl, matrix) {
            if (!matrix) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "SurfaceTileRendererProgram", "loadTexSamplerMatrix",
                        "missingMatrix"));
            }

            this.loadUniformMatrix(gl, matrix, this.texSamplerMatrixLocation);
        };

        /**
         * Loads the specified matrix as the value of this program's 'texMaskMatrix' uniform variable.
         *
         * @param {WebGLRenderingContext} gl The current WebGL context.
         * @param {Matrix} matrix The matrix to load.
         * @throws {ArgumentError} If the specified matrix is null or undefined.
         */
        SurfaceTileRendererProgram.prototype.loadTexMaskMatrix = function (gl, matrix) {
            if (!matrix) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "SurfaceTileRendererProgram", "loadTexMaskMatrix",
                        "missingMatrix"));
            }

            this.loadUniformMatrix(gl, matrix, this.texMaskMatrixLocation);
        };

        /**
         * Loads the specified texture unit ID as the value of this program's 'texSampler' uniform variable.
         * The specified unit ID must be one of the GL_TEXTUREi WebGL enumerations, where i ranges from 0 to
         * GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1.
         *
         * @param {WebGLRenderingContext} gl The current WebGL context.
         * @param {Number} unit The unit ID to load.
         */
        SurfaceTileRendererProgram.prototype.loadTexSampler = function (gl, unit) {
            gl.uniform1i(this.texSamplerLocation, unit - WebGLRenderingContext.TEXTURE0);
        };

        /**
         * Loads the specified value as the value of this program's 'opacity' uniform variable.
         *
         * @param {WebGLRenderingContext} gl The current WebGL context.
         * @param {Number} opacity The opacity to load.
         */
        SurfaceTileRendererProgram.prototype.loadOpacity = function (gl, opacity) {
            gl.uniform1f(this.opacityLocation, opacity);
        };

        /**
         * Loads the specified color as the value of this program's 'color' uniform variable.
         *
         * @param {WebGLRenderingContext} gl The current WebGL context.
         * @param {Color} color The color to load.
         * @throws {ArgumentError} If the specified color is null or undefined.
         */
        SurfaceTileRendererProgram.prototype.loadColor = function (gl, color) {
            if (!color) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "SurfaceTileRendererProgram", "loadColor", "missingColor"));
            }

            this.loadUniformColor(gl, color, this.colorLocation);
        };

        /**
         * Loads the specified boolean as the value of this program's 'modulateColor' uniform variable. When this
         * value is true the color uniform of this shader is
         * multiplied by the rounded alpha component of the texture color at each fragment. This causes the color
         * to be either fully opaque or fully transparent depending on the value of the texture color's alpha value.
         * This is used during picking to replace opaque or mostly opaque texture colors with the pick color, and
         * to make all other texture colors transparent.
         * @param {WebGLRenderingContext} gl The current WebGL context.
         * @param {Boolean} enable <code>true</code> to enable modulation, <code>false</code> to disable modulation.
         */
        SurfaceTileRendererProgram.prototype.loadModulateColor = function (gl, enable) {
            gl.uniform1i(this.modulateColorLocation, enable ? 1 : 0);
        };

        return SurfaceTileRendererProgram;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports ShapeAttributes
 * @version $Id: ShapeAttributes.js 3270 2015-06-26 01:09:56Z tgaskins $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(8),
        __webpack_require__(54)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Color,
              ImageSource) {
        "use strict";

        /**
         * Constructs a shape attributes bundle, optionally specifying a prototype set of attributes. Not all shapes
         * use all the properties in the bundle. See the documentation of a specific shape to determine the properties
         * it does use.
         * @alias ShapeAttributes
         * @constructor
         * @classdesc Holds attributes applied to World Wind shapes.
         * @param {ShapeAttributes} attributes An attribute bundle whose properties are used to initially populate
         * the constructed attributes bundle. May be null, in which case the constructed attributes bundle is populated
         * with default attributes.
         */
        var ShapeAttributes = function (attributes) {

            // All these are documented with their property accessors below.
            this._drawInterior = attributes ? attributes._drawInterior : true;
            this._drawOutline = attributes ? attributes._drawOutline : true;
            this._enableLighting = attributes ? attributes._enableLighting : false;
            this._interiorColor = attributes ? attributes._interiorColor : Color.WHITE;
            this._outlineColor = attributes ? attributes._outlineColor : Color.RED;
            this._outlineWidth = attributes ? attributes._outlineWidth : 1.0;
            this._outlineStippleFactor = attributes ? attributes._outlineStippleFactor : 0;
            this._outlineStipplePattern = attributes ? attributes._outlineStipplePattern : 0xF0F0;
            this._imageSource = attributes ? attributes._imageSource : null;
            this._depthTest = attributes ? attributes._depthTest : true;
            this._drawVerticals = attributes ? attributes._drawVerticals : false;
            this._applyLighting = attributes ? attributes._applyLighting : false;

            /**
             * Indicates whether this object's state key is invalid. Subclasses must set this value to true when their
             * attributes change. The state key will be automatically computed the next time it's requested. This flag
             * will be set to false when that occurs.
             * @type {Boolean}
             * @protected
             */
            this.stateKeyInvalid = true;
        };

        /**
         * Computes the state key for this attributes object. Subclasses that define additional attributes must
         * override this method, call it from that method, and append the state of their attributes to its
         * return value.
         * @returns {String} The state key for this object.
         * @protected
         */
        ShapeAttributes.prototype.computeStateKey = function () {
            return "di " + this._drawInterior +
                  " do " + this._drawOutline +
                  " el " + this._enableLighting +
                  " ic " + this._interiorColor.toHexString(true) +
                  " oc " + this._outlineColor.toHexString(true) +
                  " ow " + this._outlineWidth +
                  " osf " + this._outlineStippleFactor +
                  " osp " + this._outlineStipplePattern +
                  " is " + (this._imageSource ?
                        (this.imageSource instanceof ImageSource ? this.imageSource.key : this.imageSource) : "null") +
                  " dt " + this._depthTest +
                  " dv " + this._drawVerticals +
                  " li " + this._applyLighting;
        };

        Object.defineProperties(ShapeAttributes.prototype, {
            /**
             * A string identifying the state of this attributes object. The string encodes the current values of all
             * this object's properties. It's typically used to validate cached representations of shapes associated
             * with this attributes object.
             * @type {String}
             * @readonly
             * @memberof ShapeAttributes.prototype
             */
            stateKey: {
                get: function () {
                    if (this.stateKeyInvalid) {
                        this._stateKey = this.computeStateKey();
                        this.stateKeyInvalid = false;
                    }
                    return this._stateKey;
                }
            },

            /**
             * Indicates whether the interior of the associated shape is drawn.
             * @type {Boolean}
             * @default true
             * @memberof ShapeAttributes.prototype
             */
            drawInterior: {
                get: function () {
                    return this._drawInterior;
                },
                set: function (value) {
                    this._drawInterior = value;
                    this.stateKeyInvalid = true;
                }
            },

            /**
             * Indicates whether the outline of the associated shape is drawn
             * @type {Boolean}
             * @default true
             * @memberof ShapeAttributes.prototype
             */
            drawOutline: {
                get: function () {
                    return this._drawOutline;
                },
                set: function (value) {
                    this._drawOutline = value;
                    this.stateKeyInvalid = true;
                }
            },

            /**
             * Indicates whether lighting is applied to the associated shape.
             * @type {Boolean}
             * @default false
             * @memberof ShapeAttributes.prototype
             */
            enableLighting: {
                get: function () {
                    return this._enableLighting;
                },
                set: function (value) {
                    this._enableLighting = value;
                    this.stateKeyInvalid = true;
                }
            },

            /**
             * Indicates the associated shape's interior color and opacity.
             * @type {Color}
             * @default Opaque white (red = 1, green = 1, blue = 1, alpha = 1)
             * @memberof ShapeAttributes.prototype
             */
            interiorColor: {
                get: function () {
                    return this._interiorColor;
                },
                set: function (value) {
                    this._interiorColor = value;
                    this.stateKeyInvalid = true;
                }
            },

            /**
             * Indicates the associated shape's outline color and opacity.
             * @type {Color}
             * @default Opaque red (red = 1, green = 0, blue = 0, alpha = 1)
             * @memberof ShapeAttributes.prototype
             */
            outlineColor: {
                get: function () {
                    return this._outlineColor;
                },
                set: function (value) {
                    this._outlineColor = value;
                    this.stateKeyInvalid = true;
                }
            },

            /**
             * Indicates the associated shape's outline width.
             * @type {Number}
             * @default 1.0
             * @memberof ShapeAttributes.prototype
             */
            outlineWidth: {
                get: function () {
                    return this._outlineWidth;
                },
                set: function (value) {
                    this._outlineWidth = value;
                    this.stateKeyInvalid = true;
                }
            },

            /**
             * Indicates the associated shape's outline stipple pattern. Specifies a number whose lower 16 bits
             * define a pattern of which pixels in the outline are rendered and which are suppressed. Each bit
             * corresponds to a pixel in the shape's outline, and the pattern repeats after every n*16 pixels, where
             * n is the [stipple factor]{@link ShapeAttributes#outlineStippleFactor}. For example, if the outline
             * stipple factor is 3, each bit in the stipple pattern is repeated three times before using the next bit.
             * <p>
             * To disable outline stippling, either specify a stipple factor of 0 or specify a stipple pattern of
             * all 1 bits, i.e., 0xFFFF.
             * @type {Number}
             * @default 0xF0F0
             * @memberof ShapeAttributes.prototype
             */
            outlineStipplePattern: {
                get: function () {
                    return this._outlineStipplePattern;
                },
                set: function (value) {
                    this._outlineStipplePattern = value;
                    this.stateKeyInvalid = true;
                }
            },

            /**
             * Indicates the associated shape's outline stipple factor. Specifies the number of times each bit in the
             * outline stipple pattern is repeated before the next bit is used. For example, if the outline stipple
             * factor is 3, each bit is repeated three times before using the next bit. The specified factor must be
             * either 0 or an integer greater than 0. A stipple factor of 0 indicates no stippling.
             * @type {Number}
             * @default 0
             * @memberof ShapeAttributes.prototype
             */
            outlineStippleFactor: {
                get: function () {
                    return this._outlineStippleFactor;
                },
                set: function (value) {
                    this._outlineStippleFactor = value;
                    this.stateKeyInvalid = true;
                }
            },

            /**
             * Indicates the associated shape's image source. May be null, in which case no image is
             * applied to the shape.
             * @type {String|ImageSource}
             * @memberof ShapeAttributes.prototype
             * @default null
             */
            imageSource: {
                get: function () {
                    return this._imageSource;
                },
                set: function (value) {
                    this._imageSource = value;
                    this.stateKeyInvalid = true;
                }
            },

            /**
             * Indicates whether the shape should be depth-tested against other objects in the scene. If true,
             * the shape may be occluded by terrain and other objects in certain viewing situations. If false,
             * the shape will not be occluded by terrain and other objects.
             * @type {Boolean}
             * @default true
             * @memberof ShapeAttributes.prototype
             */
            depthTest: {
                get: function () {
                    return this._depthTest;
                },
                set: function (value) {
                    this._depthTest = value;
                    this.stateKeyInvalid = true;
                }
            },

            /**
             * Indicates whether this shape should draw vertical lines extending from its specified positions to the
             * ground.
             * @type {Boolean}
             * @default false
             * @memberof ShapeAttributes.prototype
             */
            drawVerticals: {
                get: function () {
                    return this._drawVerticals;
                },
                set: function (value) {
                    this._drawVerticals = value;
                    this.stateKeyInvalid = true;
                }
            },

            /**
             * Indicates whether lighting is applied to the shape.
             * @type {Boolean}
             * @default false
             * @memberof ShapeAttributes.prototype
             */
            applyLighting: {
                get: function () {
                    return this._applyLighting;
                },
                set: function (value) {
                    this._applyLighting = value;
                    this.stateKeyInvalid = true;
                }
            }
        });

        return ShapeAttributes;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
;

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports SurfaceImage
 * @version $Id: SurfaceImage.js 3023 2015-04-15 20:24:17Z tgaskins $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(1),
        __webpack_require__(0),
        __webpack_require__(21),
        __webpack_require__(77)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
              Logger,
              PickedObject,
              SurfaceTile) {
        "use strict";

        /**
         * Constructs a surface image shape for a specified sector and image path.
         * @alias SurfaceImage
         * @constructor
         * @augments SurfaceTile
         * @classdesc Represents an image drawn on the terrain.
         * @param {Sector} sector The sector spanned by this surface image.
         * @param {String|ImageSource} imageSource The image source of the image to draw on the terrain.
         * May be either a string identifying the URL of the image, or an {@link ImageSource} object identifying a
         * dynamically created image.
         * @throws {ArgumentError} If either the specified sector or image source is null or undefined.
         */
        var SurfaceImage = function (sector, imageSource) {
            if (!sector) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "SurfaceImage", "constructor",
                    "missingSector"));
            }

            if (!imageSource) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "SurfaceImage", "constructor",
                    "missingImage"));
            }

            SurfaceTile.call(this, sector);

            /**
             * Indicates whether this surface image is drawn.
             * @type {boolean}
             * @default true
             */
            this.enabled = true;

            /**
             * The path to the image.
             * @type {String}
             */
            this._imageSource = imageSource;

            /**
             * This surface image's opacity. When this surface image is drawn, the actual opacity is the product of
             * this opacity and the opacity of the layer containing this surface image.
             * @type {number}
             */
            this.opacity = 1;

            /**
             * This surface image's display name;
             * @type {string}
             */
            this.displayName = "Surface Image";

            // Internal. Indicates whether the image needs to be updated in the GPU resource cache.
            this.imageSourceWasUpdated = true;
        };

        SurfaceImage.prototype = Object.create(SurfaceTile.prototype);

        Object.defineProperties(SurfaceImage.prototype, {
            /**
             * The source of the image to display.
             * May be either a string identifying the URL of the image, or an {@link ImageSource} object identifying a
             * dynamically created image.
             * @type {String|ImageSource}
             * @default null
             * @memberof SurfaceImage.prototype
             */
            imageSource: {
                get: function () {
                    return this._imageSource;
                },
                set: function (imageSource) {
                    if (!imageSource) {
                        throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "SurfaceImage", "imageSource",
                            "missingImage"));
                    }

                    this._imageSource = imageSource;
                    this.imageSourceWasUpdated = true;
                }
            }
        });

        SurfaceImage.prototype.bind = function (dc) {
            var texture = dc.gpuResourceCache.resourceForKey(this._imageSource);
            if (texture && !this.imageSourceWasUpdated) {
                return texture.bind(dc);
            } else {
                texture = dc.gpuResourceCache.retrieveTexture(dc.currentGlContext, this._imageSource);
                this.imageSourceWasUpdated = false;
                if (texture) {
                    return texture.bind(dc);
                }
            }
        };

        SurfaceImage.prototype.applyInternalTransform = function (dc, matrix) {
            // No need to apply the transform.
        };

        /**
         * Displays this surface image. Called by the layer containing this surface image.
         * @param {DrawContext} dc The current draw context.
         */
        SurfaceImage.prototype.render = function (dc) {
            if (!this.enabled || !this.sector.overlaps(dc.terrain.sector)) {
                return;
            }

            if (dc.pickingMode) {
                this.pickColor = dc.uniquePickColor();
            }

            dc.surfaceTileRenderer.renderTiles(dc, [this], this.opacity * dc.currentLayer.opacity);

            if (dc.pickingMode) {
                var po = new PickedObject(this.pickColor.clone(), this.pickDelegate ? this.pickDelegate : this,
                    null, this.layer, false);
                dc.resolvePick(po);
            }

            dc.currentLayer.inCurrentFrame = true;
        };

        return SurfaceImage;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2015 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports Font
 * @version $Id: Font.js 2660 2015-01-20 19:20:11Z danm $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(1),
        __webpack_require__(8),
        __webpack_require__(0)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
              Color,
              Logger) {
        "use strict";

        /**
         * Construct a font descriptor. See the individual attribute descriptions below for possible parameter values.
         * @param {Number} size The size of font.
         * @param {String} style The style of the font.
         * @param {String} variant The variant of the font.
         * @param {String} weight The weight of the font.
         * @param {String} family The family of the font.
         * @param {String} horizontalAlignment The vertical alignment of the font.
         * @alias Font
         * @constructor
         * @classdesc Holds attributes controlling the style, size and other attributes of {@link Text} shapes and
         * the textual features of {@link Placemark} and other shapes. The values used for these attributes are those
         * defined by the [CSS Font property]{@link http://www.w3schools.com/cssref/pr_font_font.asp}.
         */
        var Font = function (size, style, variant, weight, family, horizontalAlignment) {
            /*
             * All properties of Font are intended to be private and must be accessed via public getters and setters.
             */

            if (!size) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "Font", "constructor",
                    "missingSize"));
            }
            else if (size <= 0) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "Font", "constructor",
                    "invalidSize"));
            }
            else {
                this._size = size;
            }

            this.style = style || "normal";
            this.variant = variant || "normal";
            this.weight = weight || "normal";
            this.family = family || "sans-serif";
            this.horizontalAlignment = horizontalAlignment || "center";
        };

        Object.defineProperties(Font.prototype, {
            /**
             * The font size.
             * @memberof Font.prototype
             * @type Number
             */
            size: {
                get: function () {
                    return this._size;
                },
                set: function (value) {
                    this._fontString = null;
                    this._size = value;
                }
            },
            /**
             * The font style.
             * See [CSS font-style]{@link http://www.w3schools.com/cssref/pr_font_font-style.asp} for defined values.
             * @memberof Font.prototype
             * @type {String}
             * @default "normal"
             */
            style: {
                get: function () {
                    return this._style;
                },
                set: function (value) {
                    this._fontString = null;
                    this._style = value;
                }
            },
            /**
             * The font variant.
             * See [CSS font-variant]{@link http://www.w3schools.com/cssref/pr_font_font-variant.asp} for defined values.
             * @memberof Font.prototype
             * @type {String}
             * @default "normal"
             */
            variant: {
                get: function () {
                    return this._variant;
                },
                set: function (value) {
                    this._fontString = null;
                    this._variant = value;
                }
            },
            /**
             * The font weight.
             * See [CSS font-weight]{@link http://www.w3schools.com/cssref/pr_font_weight.asp} for defined values.
             * @memberof Font.prototype
             * @type {String}
             * @default "normal"
             */
            weight: {
                get: function () {
                    return this._weight;
                },
                set: function (value) {
                    this._fontString = null;
                    this._weight = value;
                }
            },
            /**
             * The font family.
             * See [CSS font-family]{@link http://www.w3schools.com/cssref/pr_font_font-family.asp} for defined values.
             * @memberof Font.prototype
             * @type {String}
             * @default "sans-serif"
             */
            family: {
                get: function () {
                    return this._family;
                },
                set: function (value) {
                    this._fontString = null;
                    this._family = value;
                }
            },
            /**
             * The horizontal alignment of the font.
             * Recognized values are "left", "center" and "right".
             * @memberof Font.prototype
             * @type {String}
             * @default "center"
             */
            horizontalAlignment: {
                get: function () {
                    return this._horizontalAlignment;
                },
                set: function (value) {
                    this._toString = null;
                    this._horizontalAlignment = value;
                }
            },

            /**
             * A string representing this font's style, weight, size and family properties, suitable for
             * passing directly to a 2D canvas context.
             * @memberof Font.prototype
             */
            fontString: {
                get: function () {
                    if (!this._fontString) {
                        this._fontString =
                            this._style + " " +
                            this.variant + " " +
                            this._weight + " " +
                            this._size.toString() + "px " +
                            this._family;
                    }
                    return this._fontString;
                }
            }
        });

        /**
         * Returns a string representation of this object.
         * @returns {String} A string representation of this object.
         */
        Font.prototype.toString = function () {
            if (!this._toString || !this._fontString) {
                this._toString = this.fontString + " " + this.horizontalAlignment;
            }
            return this._toString;
        };

        return Font;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports GoToAnimator
 * @version $Id: GoToAnimator.js 3164 2015-06-09 15:35:14Z tgaskins $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(7),
        __webpack_require__(0),
        __webpack_require__(10),
        __webpack_require__(2)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Location,
              Logger,
              Position,
              Vec3) {
        "use strict";

        /**
         * Constructs a GoTo animator.
         * @alias GoToAnimator
         * @constructor
         * @classdesc Incrementally and smoothly moves a {@link Navigator} to a specified position.
         * @param {WorldWindow} worldWindow The World Window in which to perform the animation.
         * @throws {ArgumentError} If the specified World Window is null or undefined.
         */
        var GoToAnimator = function (worldWindow) {
            if (!worldWindow) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "GoToAnimator", "constructor",
                    "missingWorldWindow"));
            }

            /**
             * The World Window associated with this animator.
             * @type {WorldWindow}
             * @readonly
             */
            this.wwd = worldWindow;

            /**
             * The frequency in milliseconds at which to animate the position change.
             * @type {Number}
             * @default 20
             */
            this.animationFrequency = 20;

            /**
             * The animation's duration, in milliseconds. When the distance is short, less than twice the viewport
             * size, the travel time is reduced proportionally to the distance to travel. It therefore takes less
             * time to move shorter distances.
             * @type {Number}
             * @default 3000
             */
            this.travelTime = 3000;

            /**
             * Indicates whether the current or most recent animation has been cancelled. Use the cancel() function
             * to cancel an animation.
             * @type {Boolean}
             * @default false
             * @readonly
             */
            this.cancelled = false;
        };

        // Stop the current animation.
        GoToAnimator.prototype.cancel = function () {
            this.cancelled = true;
        };

        /**
         * Moves the navigator to a specified location or position.
         * @param {Location | Position} position The location or position to move the navigator to. If this
         * argument contains an "altitude" property, as {@link Position} does, the end point of the navigation is
         * at the specified altitude. Otherwise the end point is at the current altitude of the navigator.
         * @param {Function} completionCallback If not null or undefined, specifies a function to call when the
         * animation completes. The completion callback is called with a single argument, this animator.
         * @throws {ArgumentError} If the specified location or position is null or undefined.
         */
        GoToAnimator.prototype.goTo = function (position, completionCallback) {
            if (!position) {
                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "GoToAnimator", "goTo",
                    "missingPosition"));
            }

            this.completionCallback = completionCallback;

            // Reset the cancellation flag.
            this.cancelled = false;

            // Capture the target position and determine its altitude.
            this.targetPosition = new Position(position.latitude, position.longitude,
                position.altitude || this.wwd.navigator.range);

            // Capture the start position and start time.
            this.startPosition = new Position(
                this.wwd.navigator.lookAtLocation.latitude,
                this.wwd.navigator.lookAtLocation.longitude,
                this.wwd.navigator.range);
            this.startTime = Date.now();

            // Determination of the pan and range velocities requires the distance to be travelled.
            var animationDuration = this.travelTime,
                panDistance = Location.greatCircleDistance(this.startPosition, this.targetPosition),
                rangeDistance;

            // Determine how high we need to go to give the user context. The max altitude computed is approximately
            // that needed to fit the start and end positions in the same viewport assuming a 45 degree field of view.
            var pA = this.wwd.globe.computePointFromLocation(
                    this.startPosition.latitude, this.startPosition.longitude, new Vec3(0, 0, 0)),
                pB = this.wwd.globe.computePointFromLocation(
                    this.targetPosition.latitude, this.targetPosition.longitude, new Vec3(0, 0, 0));
            this.maxAltitude = pA.distanceTo(pB);

            // Determine an approximate viewport size in radians in order to determine whether we actually change
            // the range as we pan to the new location. We don't want to change the range if the distance between
            // the start and target positions is small relative to the current viewport.
            var viewportSize = this.wwd.navigator.currentState().pixelSizeAtDistance(this.startPosition.altitude)
                * this.wwd.canvas.clientWidth / this.wwd.globe.equatorialRadius;

            if (panDistance <= 2 * viewportSize) {
                // Start and target positions are close, so don't back out.
                this.maxAltitude = this.startPosition.altitude;
            }

            // We need to capture the time the max altitude is reached in order to begin decreasing the range
            // midway through the animation. If we're already above the max altitude, then that time is now since
            // we don't back out if the current altitude is above the computed max altitude.
            this.maxAltitudeReachedTime = this.maxAltitude <= this.wwd.navigator.range ? Date.now() : null;

            // Compute the total range to travel since we need that to compute the range velocity.
            // Note that the range velocity and pan velocity are computed so that the respective animations, which
            // operate independently, finish at the same time.
            if (this.maxAltitude > this.startPosition.altitude) {
                rangeDistance = Math.max(0, this.maxAltitude - this.startPosition.altitude);
                rangeDistance += Math.abs(this.targetPosition.altitude - this.maxAltitude);
            } else {
                rangeDistance = Math.abs(this.targetPosition.altitude - this.startPosition.altitude);
            }

            // Determine which distance governs the animation duration.
            var animationDistance = Math.max(panDistance, rangeDistance / this.wwd.globe.equatorialRadius);
            if (animationDistance === 0) {
                return; // current and target positions are the same
            }

            if (animationDistance < 2 * viewportSize) {
                // Start and target positions are close, so reduce the travel time based on the
                // distance to travel relative to the viewport size.
                animationDuration = Math.min((animationDistance / viewportSize) * this.travelTime, this.travelTime);
            }

            // Don't let the animation duration go to 0.
            animationDuration = Math.max(1, animationDuration);

            // Determine the pan velocity, in radians per millisecond.
            this.panVelocity = panDistance / animationDuration;

            // Determine the range velocity, in meters per millisecond.
            this.rangeVelocity = rangeDistance / animationDuration; // meters per millisecond

            // Set up the animation timer.
            var thisAnimator = this;
            var timerCallback = function () {
                if (thisAnimator.cancelled) {
                    if (thisAnimator.completionCallback) {
                        thisAnimator.completionCallback(thisAnimator);
                    }
                    return;
                }

                if (thisAnimator.update()) {
                    setTimeout(timerCallback, thisAnimator.animationFrequency);
                } else if (thisAnimator.completionCallback) {
                    thisAnimator.completionCallback(thisAnimator);
                }
            };
            setTimeout(timerCallback, this.animationFrequency); // invoke it the first time
        };

        // Intentionally not documented.
        GoToAnimator.prototype.update = function () {
            // This is the timer callback function. It invokes the range animator and the pan animator.

            var currentPosition = new Position(
                this.wwd.navigator.lookAtLocation.latitude,
                this.wwd.navigator.lookAtLocation.longitude,
                this.wwd.navigator.range);

            var continueAnimation = this.updateRange(currentPosition);
            continueAnimation = this.updateLocation(currentPosition) || continueAnimation;

            this.wwd.redraw();

            return continueAnimation;
        };

        // Intentionally not documented.
        GoToAnimator.prototype.updateRange = function (currentPosition) {
            // This function animates the range.
            var continueAnimation = false,
                nextRange, elapsedTime;

            // If we haven't reached the maximum altitude, then step-wise increase it. Otherwise step-wise change
            // the range towards the target altitude.
            if (!this.maxAltitudeReachedTime) {
                elapsedTime = Date.now() - this.startTime;
                nextRange = Math.min(this.startPosition.altitude + this.rangeVelocity * elapsedTime, this.maxAltitude);
                // We're done if we get withing 1 meter of the desired range.
                if (Math.abs(this.wwd.navigator.range - nextRange) < 1) {
                    this.maxAltitudeReachedTime = Date.now();
                }
                this.wwd.navigator.range = nextRange;
                continueAnimation = true;
            } else {
                elapsedTime = Date.now() - this.maxAltitudeReachedTime;
                if (this.maxAltitude > this.targetPosition.altitude) {
                    nextRange = this.maxAltitude - (this.rangeVelocity * elapsedTime);
                    nextRange = Math.max(nextRange, this.targetPosition.altitude);
                } else {
                    nextRange = this.maxAltitude + (this.rangeVelocity * elapsedTime);
                    nextRange = Math.min(nextRange, this.targetPosition.altitude);
                }
                this.wwd.navigator.range = nextRange;
                // We're done if we get withing 1 meter of the desired range.
                continueAnimation = Math.abs(this.wwd.navigator.range - this.targetPosition.altitude) > 1;
            }

            return continueAnimation;
        };

        // Intentionally not documented.
        GoToAnimator.prototype.updateLocation = function (currentPosition) {
            // This function animates the pan to the desired location.
            var elapsedTime = Date.now() - this.startTime,
                distanceTravelled = Location.greatCircleDistance(this.startPosition, currentPosition),
                distanceRemaining = Location.greatCircleDistance(currentPosition, this.targetPosition),
                azimuthToTarget = Location.greatCircleAzimuth(currentPosition, this.targetPosition),
                distanceForNow = this.panVelocity * elapsedTime,
                nextDistance = Math.min(distanceForNow - distanceTravelled, distanceRemaining),
                nextLocation = Location.greatCircleLocation(currentPosition, azimuthToTarget, nextDistance,
                    new Location(0, 0)),
                locationReached = false;

            this.wwd.navigator.lookAtLocation.latitude = nextLocation.latitude;
            this.wwd.navigator.lookAtLocation.longitude = nextLocation.longitude;

            // We're done if we're within a meter of the desired location.
            if (nextDistance < 1 / this.wwd.globe.equatorialRadius) {
                locationReached = true;
            }

            return !locationReached;
        };

        return GoToAnimator;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports Offset
 * @version $Id: Offset.js 2958 2015-04-01 23:25:29Z tgaskins $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(14)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Vec2) {
        "use strict";

        /**
         * Constructs an offset instance given specified units and offsets.
         * @alias Offset
         * @constructor
         * @classdesc Specifies an offset relative to a rectangle. Used by [Placemark]{@link Placemark} and
         * other shapes.
         * @param {String} xUnits The type of units specified for the X dimension. May be one of the following:
         * <ul>
         *     <li>[WorldWind.OFFSET_FRACTION]{@link WorldWind#OFFSET_FRACTION}</li>
         *     <li>[WorldWind.OFFSET_INSET_PIXELS]{@link WorldWind#OFFSET_INSET_PIXELS}</li>
         *     <li>[WorldWind.OFFSET_PIXELS]{@link WorldWind#OFFSET_PIXELS}</li>
         * </ul>
         * @param {Number} x The offset in the X dimension.
         * @param {String} yUnits The type of units specified for the Y dimension, assuming a lower-left Y origin.
         * May be one of the following:
         * <ul>
         *     <li>[WorldWind.OFFSET_FRACTION]{@link WorldWind#OFFSET_FRACTION}</li>
         *     <li>[WorldWind.OFFSET_INSET_PIXELS]{@link WorldWind#OFFSET_INSET_PIXELS}</li>
         *     <li>[WorldWind.OFFSET_PIXELS]{@link WorldWind#OFFSET_PIXELS}</li>
         * </ul>
         * @param {Number} y The offset in the Y dimension.
         */
        var Offset = function (xUnits, x, yUnits, y) {

            /**
             * The offset in the X dimension, interpreted according to this instance's xUnits argument.
             * @type {Number}
             */
            this.x = x;

            /**
             * The offset in the Y dimension, interpreted according to this instance's yUnits argument.
             * @type {Number}
             */
            this.y = y;

            /**
             * The units of this instance's X offset. See this class' constructor description for a list of the
             * possible values.
             * @type {String}
             */
            this.xUnits = xUnits;

            /**
             * The units of this instance's Y offset. See this class' constructor description for a list of the
             * possible values.
             * @type {String}
             */
            this.yUnits = yUnits;
        };

        /**
         * Creates a new copy of this offset with identical property values.
         * @returns {Offset} A new offset instance with its property values the same as this one's.
         */
        Offset.prototype.clone = function () {
            return new Offset(this.xUnits, this.x, this.yUnits, this.y);
        };

        /**
         * Returns this offset's absolute X and Y coordinates in pixels for a rectangle of a specified size in pixels.
         * The returned offset is in pixels relative to the rectangle's origin, and is defined in the coordinate
         * system used by the caller.
         * @param {Number} width The rectangle's width in pixels.
         * @param {Number} height The rectangles height in pixels.
         * @returns {Vec2} The computed offset relative to the rectangle's origin.
         */
        Offset.prototype.offsetForSize = function (width, height) {
            var x, y;

            if (this.xUnits == WorldWind.OFFSET_FRACTION) {
                x = width * this.x;
            } else if (this.xUnits == WorldWind.OFFSET_INSET_PIXELS) {
                x = width - this.x;
            } else { // default to OFFSET_PIXELS
                x = this.x;
            }

            if (this.yUnits == WorldWind.OFFSET_FRACTION) {
                y = height * this.y;
            } else if (this.yUnits == WorldWind.OFFSET_INSET_PIXELS) {
                y = height - this.y;
            } else { // default to OFFSET_PIXELS
                y = this.y;
            }

            return new Vec2(x, y);
        };

        /**
         * Returns a string representation of this object.
         * @returns {String} A string representation of this object.
         */
        Offset.prototype.toString = function () {
            return this.xUnits + " " + this.x + " " + this.yUnits + " " + this.y;
        };

        return Offset;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Copyright (C) 2014 United States Government as represented by the Administrator of the
 * National Aeronautics and Space Administration. All Rights Reserved.
 */
/**
 * @exports WmsUrlBuilder
 * @version $Id: WmsUrlBuilder.js 3362 2015-07-31 19:29:12Z tgaskins $
 */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(1),
        __webpack_require__(0)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
              Logger) {
        "use strict";

        /**
         * Constructs a WMS URL builder.
         * @alias WmsUrlBuilder
         * @constructor
         * @classdesc Provides a factory to create URLs for WMS Get Map requests.
         * @param {String} serviceAddress The address of the WMS server.
         * @param {String} layerNames The comma-separated list of names of the layers to retrieve.
         * @param {String} styleNames The comma-separated list of names of the styles to retrieve. May be null.
         * @param {String} wmsVersion The version of the WMS server. May be null, in which case version 1.3.0 is
         * assumed.
         * @param {String} timeString The time parameter included in GetMap requests.
         * May be null, in which case no time parameter is included in the request.
         * @throws {ArgumentError} If the service address or layer names are null or empty.
         *
         */
        var WmsUrlBuilder = function (serviceAddress, layerNames, styleNames, wmsVersion, timeString) {
            if (!serviceAddress || (serviceAddress.length === 0)) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "WmsUrlBuilder", "constructor",
                        "The WMS service address is missing."));
            }

            if (!layerNames || (layerNames.length === 0)) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "WmsUrlBuilder", "constructor",
                        "The WMS layer names are not specified."));
            }

            /**
             * The address of the WMS server.
             * @type {String}
             */
            this.serviceAddress = serviceAddress;

            /**
             * The comma-separated list of layer names to retrieve.
             * @type {String}
             */
            this.layerNames = layerNames;

            /**
             * The comma-separated list of style names to retrieve.
             * @type {String}
             */
            this.styleNames = styleNames ? styleNames : "";

            /**
             * Indicates whether the layer should be requested with transparency.
             * @type {Boolean}
             * @default true
             */
            this.transparent = true;

            /**
             * The WMS version to specify when requesting resources.
             * @type {String}
             * @default 1.3.0
             */
            this.wmsVersion = (wmsVersion && wmsVersion.length > 0) ? wmsVersion : "1.3.0";
            this.isWms130OrGreater = this.wmsVersion >= "1.3.0";

            /**
             * The coordinate reference system to use when requesting layers.
             * @type {String}
             * @default EPSG:4326
             */
            this.crs = "EPSG:4326";

            /**
             * The time parameter included in GetMap requests. If null, no time parameter is included in the requests.
             * @type {String}
             */
            this.timeString = timeString;
        };

        /**
         * Creates the URL string for a WMS Get Map request.
         * @param {Tile} tile The tile for which to create the URL.
         * @param {String} imageFormat The image format to request.
         * @throws {ArgumentError} If the specified tile or image format are null or undefined.
         */
        WmsUrlBuilder.prototype.urlForTile = function (tile, imageFormat) {
            if (!tile) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "WmsUrlBuilder", "urlForTile", "missingTile"));
            }

            if (!imageFormat) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "WmsUrlBuilder", "urlForTile",
                        "The image format is null or undefined."));
            }

            var sector = tile.sector;

            var sb = WmsUrlBuilder.fixGetMapString(this.serviceAddress);

            if (sb.search(/service=wms/i) < 0) {
                sb = sb + "service=WMS";
            }

            sb = sb + "&request=GetMap";
            sb = sb + "&version=" + this.wmsVersion;
            sb = sb + "&transparent=" + (this.transparent ? "TRUE" : "FALSE");
            sb = sb + "&layers=" + this.layerNames;
            sb = sb + "&styles=" + this.styleNames;
            sb = sb + "&format=" + imageFormat;
            sb = sb + "&width=" + tile.tileWidth;
            sb = sb + "&height=" + tile.tileHeight;

            if (this.timeString) {
                sb = sb + "&time=" + this.timeString;
            }

            if (this.isWms130OrGreater) {
                sb = sb + "&crs=" + this.crs;
                sb = sb + "&bbox=";
                if (this.crs === "CRS:84") {
                    sb = sb + sector.minLongitude + "," + sector.minLatitude + ",";
                    sb = sb + sector.maxLongitude+ "," + sector.maxLatitude;
                } else {
                    sb = sb + sector.minLatitude + "," + sector.minLongitude + ",";
                    sb = sb + sector.maxLatitude+ "," + sector.maxLongitude;
                }
            } else {
                sb = sb + "&srs=" + this.crs;
                sb = sb + "&bbox=";
                sb = sb + sector.minLongitude + "," + sector.minLatitude + ",";
                sb = sb + sector.maxLongitude+ "," + sector.maxLatitude;
            }

            sb = sb.replace(" ", "%20");

            return sb;
        };

        // Intentionally not documented.
        WmsUrlBuilder.fixGetMapString = function (serviceAddress) {
            if (!serviceAddress) {
                throw new ArgumentError(
                    Logger.logMessage(Logger.LEVEL_SEVERE, "WmsUrlBuilder", "fixGetMapString",
                        "The specified service address is null or undefined."));
            }

            var index = serviceAddress.indexOf("?");

            if (index < 0) { // if string contains no question mark
                serviceAddress = serviceAddress + "?"; // add one
            } else if (index !== serviceAddress.length - 1) { // else if question mark not at end of string
                index = serviceAddress.search(/&$/);
                if (index < 0) {
                    serviceAddress = serviceAddress + "&"; // add a parameter separator
                }
            }

            return serviceAddress;
        };

        return WmsUrlBuilder;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(55);
__webpack_require__(34);
__webpack_require__(56);

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

var RenderableLayer = __webpack_require__(69);
var Sector = __webpack_require__(3);
var SurfaceImage = __webpack_require__(85);

var SingleImageLayer = function (src) {
    RenderableLayer.call(this, "Single image layer");
    this.addRenderable(new SurfaceImage(Sector.FULL_SPHERE, src));
    this.minActiveAltitude = 0; // 3e6;
};

SingleImageLayer.prototype = Object.create(RenderableLayer.prototype);

module.exports = SingleImageLayer;

/***/ })
/******/ ]);