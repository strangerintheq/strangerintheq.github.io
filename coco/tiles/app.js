/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	window.devMode = false;

	__webpack_require__(1);

	// html user interface
	__webpack_require__(2);

	// globe viewer engine
	__webpack_require__(40);

	// ww polygon dependency
	window.libtess = __webpack_require__(254);

	// qt integration
	window.QWebChannel = __webpack_require__(255);

	// shared event system
	window.Events = __webpack_require__(5);


/***/ }),
/* 1 */
/***/ (function(module, exports) {

	
	var prev = ['-256 -500 2048 2048', 'M1536 640v-128q0 -53 -32.5 -90.5t-84.5 -37.5h-704l293\
	            -294q38 -36 38 -90t-38 -90l-75 -76q-37 -37 -90 -37q-52 0 -91 37l-651 652q-37\
	             37 -37 90q0 52 37 91l651 650q38 38 91 38q52 0 90 -38l75 -74q38 -38 38 -91t-38\
	              -91l-293 -293h704q52 0 84.5 -37.5 t32.5 -90.5z'];

	var next = ['-256 -500 2048 2048', 'M1472 576q0 -54 -37 -91l-651 -651q-39 -37 -91\
	            -37q-51 0 -90 37l-75 75q-38 38 -38 91t38 91l293 293h-704q-52 0 -84.5\
	             37.5t-32.5 90.5v128q0 53 32.5 90.5t84.5 37.5h704l-293 294q-38 36 -38\
	              90t38 90l75 75q38 38 90 38q53 0 91 -38l651 -651q37 -35 37 -90z'];

	var rotate = ['-256 -400 2048 2048', 'M1536 640q0 -156 -61 -298t-164 -245t-245 -164t-298 -61q-172 0 -327 72.5t-264 204.5q-7 10 -6.5 22.5t8.5 20.5l137 138q10 9 25 9q16 -2 23 -12q73 -95 179 -147t225 -52q104 0 198.5 40.5t163.5 109.5t109.5 163.5t40.5 198.5t-40.5 198.5t-109.5 163.5 t-163.5 109.5t-198.5 40.5q-98 0 -188 -35.5t-160 -101.5l137 -138q31 -30 14 -69q-17 -40 -59 -40h-448q-26 0 -45 19t-19 45v448q0 42 40 59q39 17 69 -14l130 -129q107 101 244.5 156.5t284.5 55.5q156 0 298 -61t245 -164t164 -245t61 -298z'];

	var move = ['-120 -400 2048 2048', 'M1792 640q0 -26 -19 -45l-256 -256q-19 -19 -45 -19t-45 19t-19 45v128h-384v-384h128q26 0 45 -19t19 -45t-19 -45l-256 -256q-19 -19 -45 -19t-45 19l-256 256q-19 19 -19 45t19 45t45 19h128v384h-384v-128q0 -26 -19 -45t-45 -19t-45 19l-256 256q-19 19 -19 45 t19 45l256 256q19 19 45 19t45 -19t19 -45v-128h384v384h-128q-26 0 -45 19t-19 45t19 45l256 256q19 19 45 19t45 -19l256 -256q19 -19 19 -45t-19 -45t-45 -19h-128v-384h384v128q0 26 19 45t45 19t45 -19l256 -256q19 -19 19 -45z'];

	var magic = ['-256 -500 2048 2048', 'M1190 955l293 293l-107 107l-293 -293zM1637 1248q0 -27 -18 -45l-1286 -1286q-18 -18 -45 -18t-45 18l-198 198q-18 18 -18 45t18 45l1286 1286q18 18 45 18t45 -18l198 -198q18 -18 18 -45zM286 1438l98 -30l-98 -30l-30 -98l-30 98l-98 30l98 30l30 98zM636 1276 l196 -60l-196 -60l-60 -196l-60 196l-196 60l196 60l60 196zM1566 798l98 -30l-98 -30l-30 -98l-30 98l-98 30l98 30l30 98zM926 1438l98 -30l-98 -30l-30 -98l-30 98l-98 30l98 30l30 98z'];

	var pencil = ['-300 -400 2048 2048', 'M363 0l91 91l-235 235l-91 -91v-107h128v-128h107zM886\
	    928q0 22 -22 22q-10 0 -17 -7l-542 -542q-7 -7 -7 -17q0 -22 22 -22q10 0 17 7l542 542q7 7 7\
	    17zM832 1120l416 -416l-832 -832h-416v416zM1515 1024q0 -53 -37 -90l-166 -166l-416 416l166\
	    165q36 38 90 38 q53 0 91 -38l235 -234q37 -39 37 -91z'];

	var gear = ['-2 -1 18 18', 'M14,8.77 L14,7.17 L12.06,6.53 L11.61,5.44 L12.49,3.6 L11.36,2.47\
	    L9.55,3.38 L8.46,2.93 L7.77,1.01 L6.17,1.01 L5.54,2.95 L4.43,3.4\
	    L2.59,2.52 L1.46,3.65 L2.37,5.46 L1.92,6.55 L0,7.23 L0,8.82 L1.94,9.46\
	    L2.39,10.55 L1.51,12.39 L2.64,13.52 L4.45,12.61 L5.54,13.06 L6.23,14.98\
	    L7.82,14.98 L8.45,13.04 L9.56,12.59 L11.4,13.47 L12.53,12.34 L11.61,10.53\
	    L12.08,9.44 L14,8.75 L14,8.77 Z M7,11 C5.34,11 4,9.66 4,8 C4,6.34 5.34,5 7,5\
	    C8.66,5 10,6.34 10,8 C10,9.66 8.66,11 7,11 L7,11 Z'];

	var wizard = ['3 3 90 90', 'M32.8,18l-2.9,11.5L18.2,32l8.5,8.3l-3.6,11.3l11.4-3.2l8,8.8l1.5-6l-8.9-9\
	    c0.8-3.2,3.8-6.3,6.9-6.9l9.1,9.1l5.9-1.3l-8.5-8.3l3.6-11.3l-11.4,3.2L32.8,18z M52.4,45.8l-6.9,6.9L70.9,78\
	    c3.4-0.8,6.2-3.3,6.9-6.9L52.4,45.8z'];

	var look = ['-100 -100 1200 1200', 'M990,500c0,13.3-3.3,23.3-10,36.7c-50,83.3-120,150-206.7,200c-86.7,50-176.7,76.7-273.3,76.7c-96.7,0-186.7-26.7-273.3-76.7C140,686.7,73.3,620,20,536.7C13.3,523.3,10,510,10,500c0-13.3,3.3-23.3,10-36.7c50-83.3,120-150,206.7-200c86.7-50,176.7-76.7,273.3-76.7c96.7,0,186.7,26.7,273.3,76.7c86.7,50,153.3,116.7,206.7,200C986.7,476.7,990,486.7,990,500z M920,500c-56.7-86.7-123.3-150-206.7-193.3c23.3,36.7,33.3,80,33.3,123.3c0,66.7-23.3,123.3-73.3,173.3C626.7,650,566.7,676.7,500,676.7c-66.7,0-123.3-23.3-173.3-73.3C280,556.7,253.3,496.7,253.3,430c0-43.3,10-83.3,33.3-123.3C203.3,350,133.3,413.3,80,500c50,73.3,110,133.3,183.3,176.7c73.3,43.3,153.3,66.7,236.7,66.7c86.7,0,163.3-23.3,236.7-66.7C810,633.3,870,573.3,920,500z M520,310c6.7-6.7,6.7-10,6.7-20c0-6.7-3.3-13.3-6.7-20c-6.7-6.7-10-6.7-20-6.7c-46.7,0-83.3,16.7-116.7,50c-33.3,33.3-50,70-50,116.7c0,6.7,3.3,13.3,6.7,20c6.7,6.7,10,6.7,20,6.7c6.7,0,13.3-3.3,20-6.7c6.7-6.7,6.7-10,6.7-20c0-30,10-56.7,33.3-80c23.3-23.3,50-33.3,80-33.3C506.7,316.7,513.3,313.3,520,310z'];

	var icons = {
	    magic: create.bind(null, magic),
	    prev: create.bind(null, prev),
	    next: create.bind(null, next),
	    rotate: create.bind(null, rotate),
	    move: create.bind(null, move),
	    pencil: create.bind(null, pencil),
	    look: create.bind(null, look),
	    gear: create.bind(null, gear),
	    wizard: create.bind(null, wizard)
	};
	module.exports = icons;

	window.SvgIcons = icons;

	function create(icon) {
	    return svg(path(icon[1]), icon[0]);
	}

	function svg(content, viewBox) {
	    return '<svg viewBox="' + (viewBox || "0 0 100 100") + '">' + content + '</svg>'
	}

	function path(d, width, stroke) {
	    return '<path stroke-width="' + (width || 1) + '" stroke="' + (stroke || 'white') +'" fill="white" d="' + d + '"/>';
	}

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(3);
	__webpack_require__(7);

	__webpack_require__(19);
	__webpack_require__(20);
	__webpack_require__(21);
	__webpack_require__(22);
	__webpack_require__(23);
	__webpack_require__(24);
	__webpack_require__(25);
	//require("./gui/OnScreenLogger");
	__webpack_require__(26);
	__webpack_require__(27);
	__webpack_require__(38);
	__webpack_require__(39);

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

	var dom = __webpack_require__(4);
	var Events = __webpack_require__(5);

	var buttons = dom.select('#buttons');
	var style = buttons.currentStyle || window.getComputedStyle(buttons);
	var pad = parseInt(style.marginTop.substring(0, style.marginTop.length - 2));
	var countLeft = 0;
	var countRight = 0;

	Events.listen(Events.CREATE_BUTTON, createButton);

	function createButton(cfg) {

	    var button = dom.div('button')
	        .click(cfg.click ? cfg.click : buttonClicked)
	        .appendTo(buttons);

	    button.oncontextmenu = function() {
	        return false;
	    };

	    button.id = cfg.id;

	    if(cfg.align === 'right') {
	        button.style.right = pad + countRight++ * 50 + 'px';
	    } else {
	        button.style.left = pad + countLeft++ * 50 + 'px';
	    }

	    if (cfg.title) {
	        button.title = cfg.title;
	    }

	    if (cfg.html) {
	        button.innerHTML = cfg.html;
	    }

	    if (cfg.icon) {
	        button.style.backgroundImage = 'url(' + cfg.icon + ')';
	        button.style.backgroundSize= 'cover';
	        button.style.backgroundPosition = 'center';
	    }

	    function buttonClicked() {
	        cfg.event && Events.post(cfg.event, cfg.data);
	    }
	}

/***/ }),
/* 4 */
/***/ (function(module, exports) {

	
	module.exports = {

	    div: function(className) {
	        return html("div", className);
	    },
	    span: function(className) {
	        return html("span", className);
	    },
	    input: function(className) {
	        return html("input", className);
	    },
	    img: function(src, className) {
	        return html('img', className, {src: src ? src : ''});
	    },

	    svg: function(attributes) {
	        return svg('svg', attributes);
	    },
	    path: function(attributes) {
	        return svg('path', attributes);
	    },

	    circle: function(attributes) {
	        return svg('circle', attributes);
	    },

	    select: function(selector, doc) {
	        return extend((doc || document).querySelector(selector));
	    },

	    all: function(selector, doc) {
	        return Array.prototype.slice.call((doc || document).querySelectorAll(selector)).map(function(element) {
	            return extend(element);
	        });
	    }
	};

	function svg(name, attributes) {
	    var svgElement = create(name, "http://www.w3.org/2000/svg");
	    return assignAttributes(svgElement, attributes);
	}

	function html(name, classes, attributes) {
	    var htmlElement = create(name);
	    assignAttributes(attributes);
	    return assignClasses(htmlElement, classes);
	}

	function create(name, namespace) {
	    return extend(
	        namespace ?
	            document.createElementNS(namespace, name) :
	            document.createElement(name)
	    );
	}

	function extend(element) {

	    element.append = function(child) {
	        element.appendChild(child.domElement ? child.domElement: child);
	        return element;
	    };

	    element.appendTo = function(parent) {
	        parent.appendChild(element);
	        return element;
	    };

	    element.setClass = function(className, isAdd) {
	        element.classList[isAdd ? 'add' : 'remove'](className);
	        return element;
	    };

	    element.val = propertyFunction(element, 'value');
	    element.change = propertyFunction(element, 'oninput');
	    element.html = propertyFunction(element, 'innerHTML');

	    element.top = styleFunction(element, 'top');
	    element.left = styleFunction(element, 'left');

	    element.over = listenerFunction(element, 'mouseover');
	    element.out = listenerFunction(element, 'mouseout');
	    element.click = listenerFunction(element, 'click');

	    return element;
	}


	function assignClasses(element, classes) {
	    if (classes) {
	        element.className = classes.toString();
	    }
	    return element;
	}

	function assignAttributes(element, attributes) {
	    if (attributes) {
	        for (var attr in attributes) {
	            if (attributes.hasOwnProperty(attr)) {
	                element.setAttribute(attr, attributes[attr])
	            }
	        }
	    }
	    return element;
	}


	function styleFunction(element, parameter) {
	    return function(value) {
	        element.style[parameter] = value;
	        return element;
	    };
	}


	function propertyFunction(element, propertyName) {
	    return function (value) {
	        if (value) {
	            element[propertyName] = value;
	        }
	        return element;
	    }
	}

	function listenerFunction(element, parameter) {
	    return function(listener) {
	        element.addEventListener(parameter, listener);
	        return element;
	    };
	}


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

	var EventSystem = __webpack_require__(6);

	module.exports = {
	    SHOW_PROPERTIES_FORM: 'show-properties-form',
	    ON_SCREEN_LOG: 'on-screen-log',
	    SHOW_WIZARD: 'show-wizard',
	    WIZARD_RESULT: 'wizard-result',

	    DELETE_MODE: 'delete-mode',
	    BLOCK_NAVIGATION: 'block-navigation',
	    SHOW_CONTEXT_MENU: 'show-context-menu',
	    START_DRAWING: 'start-drawing',
	    END_DRAWING: 'end-drawing',
	    SET_DRAW_MODE: 'set-draw-mode',
	    DRAW_MODE_CHANGED: 'draw-mode-changed',

	    CHANGE_SPACE: 'change-space', // {skybox: 'images/skybox/one'} or 'stars'
	    WAIT: 'wait',
	    TOOLTIP: 'tooltip', // {x: 200, y: 200, text: 'Текст сообщения'} or null for hiding

	    // navigator event listeners
	    NAVIGATOR_STATE_CHANGED: 'navigator-state-changed',
	    LOCATION_CHANGED: 'location-changed',
	    OBJECT_MOUSE_OVER: 'object-mouse-over',
	    OBJECT_MOUSE_CLICK: 'object-mouse-click',

	    // user objects manipulations
	    CREATE_LAYER: 'create-layer',
	    CLEAR_LAYER: 'clear-layer',
	    HAS_LAYER: 'has-layer',
	    SET_LAYER_PROPERTY: 'set-layer-property',

	    GET_LAYER_CONTENTS: 'get-layer-contents',
	    DESTROY_LAYER: 'destroy-layer',
	    CREATE_GEO_JSON_OBJECT: 'create-geo-json-object',
	    CREATE_MODEL: 'create-model',
	    CREATE_ELLIPSE: 'create-ellipse',
	    CREATE_TEXT: 'create-text',
	    CREATE_BILLBOARD: 'create-billboard',

	    // create ui
	    CREATE_FORM: 'create-form',
	    CREATE_BUTTON: 'create-button',
	    CREATE_BASE_LAYER_PICKER: 'create-base-layer-picker',
	    DESTROY_BASE_LAYER_PICKER: 'destroy-base-layer-picker',
	    GET_MAPS_KEYS : 'get-maps-keys',
	    GET_ELEVATIONS_KEYS :  'get-elevations-keys',
	    SET_ACTIVE_MAP : 'set-active-map',
	    SET_ACTIVE_ELEVATION: 'set-active-elevation',

	    // controls actions
	    CONTROLS: 'controls',
	    ROTATE_TO: 'rotate-to',
	    SET_LOCATION: 'set-location',

	    // without argument
	    REDRAW: 'redraw',

	    // null = toggle action
	    SWITCH_GLOBE: 'switch-globe', // null, true, false
	    SWITCH_ATMOSPHERE: 'switch-atmosphere', // null, true, false
	    SWITCH_ATMOSPHERE_GROUND: 'switch-atmosphere-ground', // null, true, false
	    SWITCH_ATMOSPHERE_NIGHT: 'switch-atmosphere-night', // null, true, false
	    SWITCH_COMPASS: 'switch-compass-gl', // null, true, false
	    SWITCH_COMPASS_SVG: 'switch-compass-svg', // null, true, false
	    SWITCH_CONTROLS: 'switch-controls', // null, true, false
	    SWITCH_2D_PROJECTION: 'switch-2d-projection', // null, "mercator", "equirectangular"

	    EDIT_OBJECT: 'edit-object', // 123456
	    DESTROY_OBJECT: 'destroy-object', // 123456
	    SEARCH_OBJECT: 'search-object', //123456
	    GET_OBJECT: 'get-object', // 123456
	    GET_OBJECT_GEOMETRY: 'get-object-geometry', // 123456
	    GET_OBJECT_PROPERTIES: 'get-object-properties', // 123456
	    GET_OBJECT_PROPERTY: 'get-object-property', // {id: 123456, property: 'customProperty'},
	    SET_OBJECT_PROPERTIES: 'set-object-properties', // {id: 123456, properties: {customProperty: 'custom value'}},
	    SET_OBJECT_GEOMETRY: 'set-object-geometry',

	    // form actions
	    SHOW_FORM: 'show-form',
	    HIDE_FORM: 'hide-form',
	    TOGGLE_FORM: 'toggle-form',
	    FORM_BUTTON_GROUP_STATE_CHANGED: 'form-button-group-state-changed',

	    // tile map events
	    CHANGE_MAP: 'change-map',
	    CHANGE_ELEVATION_MODEL:  'change-elevation-model',
	    GET_OGC_LAYERS: 'get-ogc-layers',

	    // internal events
	    _CHANGE_ELEVATION_MODEL: 'inner-change-elevation-model',
	    _CREATE_GROUND_MAP_LAYER: 'inner-create-ground-map-layer',
	    _DESTROY_GROUND_MAP_LAYER: 'inner-destroy-ground-map-layer',

	    _CREATE_WMS_MAP_LAYER: 'inner-create-wms-map-layer',
	    _CREATE_WMTS_MAP_LAYER: 'inner-create-wmts-map-layer',
	    _CREATE_TILE_MAP_LAYER: 'inner-create-tile-map-layer',

	    _DESTROY_MAP_LAYER: 'inner-destroy-map-layer',

	    _REQUEST_PICK: 'inner-request-pick', // mouse event as argument

	    _ADD_LAYER: 'inner-add-layer', // layer reference
	    _REMOVE_LAYER: 'inner-remove-layer', // layer reference
	    _INSERT_LAYER: 'inner-insert-layer', // {index: 0, layer: layer}

	    _EDIT_OBJECT: 'inner-edit-object',
	    _BLOCK_NAVIGATOR_EVENTS_LISTENERS: 'inner-block-navigator-events-listeners',
	    _BLOCK_TILE_LOADING: 'inner-block-tile-loading',

	    _DISTANCE_FIELD_SETTINGS: 'inner-distance-fields-settings',
	    _ANCHOR_POINTS_COUNT: 'inner-anchor-points-count',
	    _FORCE_END_DRAWING: 'inner-force-end-drawing',
	    _GET_LAYER: 'inner-get-layer',
	    _SHOW_SEARCH_RESULT: 'inner-show-search-result',
	    _HIGHLIGHT_FOUND: 'inner-highlight-found'
	};

	module.exports.post = EventSystem.post;
	module.exports.listen = EventSystem.listen;

/***/ }),
/* 6 */
/***/ (function(module, exports) {

	var listeners = {};

	module.exports = {
	    post: post,
	    listen: listen
	};

	function post(name, event) {
	    var result = [];
	    if (listeners[name]) {
	        listeners[name].forEach(function (listener) {
	            try {
	                result.push(listener(event));
	            } catch (e) {
	                console.error(e);
	            }
	        });
	    }
	    return result.length === 1 ? result[0] : result;
	}

	function listen(name, listener) {
	    if (!listeners[name]) {
	        listeners[name] = [];
	    }
	    listeners[name].push(listener);
	}


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

	var Form = __webpack_require__(8);
	var Events = __webpack_require__(5);

	Events.listen(Events.CREATE_FORM, createForm);

	function createForm(cfg) {

	    var form = Form(cfg.id, cfg.title);
	    loadFromConfig('width', 400);
	    loadFromConfig('height', 300);
	    loadFromConfig('left');
	    loadFromConfig('bottom');
	    loadFromConfig('top');
	    loadFromConfig('right');

	    if (cfg.close) {
	        form.addCloseButton();
	    } else if (cfg.minimize) {
	        form.addMinimizeButton();
	    }

	    if (cfg.resize) {
	        form.addResize();
	    }

	    if (cfg.contents) {
	        cfg.contents.forEach(addElement);
	    }

	    if (cfg.visible) {
	        form.show();
	    }

	    form.appendTo(document.body);

	    return form;

	    function addElement(element) {
	        if (element.type === 'button') form.addButton(element);
	        if (element.type === 'field') form.addField(element);
	        if (element.type === 'html') form.addHtml(element);
	        if (element.type === 'combobox') form.addCombobox(element);
	        if (element.type === 'tree') form.addTree(element);
	        if (element.type === 'checklist') form.addChecklist(element);
	        if (element.type === 'slider') form.addSlider(element);
	    }

	    function loadFromConfig(property, defaultValue) {
	        var value = cfg[property];
	        value = value ? value : defaultValue;
	        if (value) form.style[property] = value + "px";
	    }
	}




/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

	var dom = __webpack_require__(4);
	var Field = __webpack_require__(9);
	var Events = __webpack_require__(5);
	var ComboBox = __webpack_require__(10);
	var Checklist = __webpack_require__(12);
	var Tree = __webpack_require__(13);
	var FormButton = __webpack_require__(15);
	var Slider = __webpack_require__(16);
	var Input = __webpack_require__(17);
	var Area = __webpack_require__(18);
	module.exports = function(id, title) {

	    var form = dom.div('form');

	    form.oncontextmenu = function() {
	        return false;
	    };

	    if (typeof title === 'string') {
	        title = dom.div('form-title')
	            .html(title)
	            .appendTo(form);
	    } else if (title) {
	        form.append(title)
	    }

	    var fields = {};
	    form.fields = fields;

	    var content = dom.div('form-content').appendTo(form);
	    if (!title) {
	        content.style.top = 0;
	    }
	    form.add = function(element) {
	        content.append(element);
	        return form;
	    };

	    form.addField = function(config, namespace) {
	        var field = Field(config);
	        form.add(field);
	        if (!config.path) {
	            return form;
	        }
	        namespace = namespace || 'default';
	        if (!fields[namespace]) {
	            fields[namespace] = [];
	        }
	        fields[namespace].push(field);
	        return form;
	    };

	    form.addTree = function (element) {
	        form.add(Tree(element.config, element.data, element.select, element.height));
	    };

	    form.addCombobox = function (element) {
	        form.add(ComboBox(element.title, element.values, element.width));
	    };

	    form.addInput = function (element) {
	        var input = Input(element.title, element.value);
	        form.add(input);
	        return input;
	    };

	    form.addTextArea = function (element) {
	        element = element || {};
	        var area = Area(
	            element.title || '',
	            element.value || '',
	            element.width || 100,
	            element.height || 50
	        );
	        form.add(area);
	        return area;
	    };

	    form.addChecklist = function (element) {
	        form.add(Checklist(element.title, element.values, element.width));
	    };

	    form.addHtml = function (element) {
	        form.add(dom.div().html(element.html));
	    };

	    form.addButton = function (config) {
	        var button = FormButton.create(config);
	        form.add(button);
	        return button;
	    };

	    form.addSlider = function(config) {
	        form.add(Slider(config));
	        form.add(dom.div('stub50'));
	    };

	    form.addFields = function (configs, namespace) {
	        configs.forEach(function(config) {
	            form.addField(config, namespace);
	        });
	    };

	    form.render = function(data, namespace) {
	        namespace = namespace || 'default';
	        if (fields[namespace]) {
	            fields[namespace].forEach(function(f) {
	                f.render(data);
	            });
	        }
	        return form;
	    };

	    form.getField = function(path, namespace) {
	        namespace = namespace || 'default';
	        return fields[namespace].filter(function(field) {
	            return path === field.cfg.path;
	        })[0];
	    };
	    form.hasMinimazeButton = false;
	    form.addMinimizeButton = function(component){
	        form.classList.add('form-transition');
	        form.hasMinimazeButton = true;
	        var minimize = dom.div('form-top-button').click(function() {
	            form.oldLeft = form.offsetLeft;
	            form.style.left = (dom.all('.form-minimized').length * 160) + 10 + 'px';
	            form.classList.add('form-minimized');
	            minimize.classList.add('hidden');
	            if (component) {
	                component.classList.add('hidden');
	            }
	        }).appendTo(form).append(createMinimizeSvg());

	        if (title) {
	            title.click(function() {

	                if (!form.classList.contains('form-minimized')) {
	                    return;
	                }
	                form.classList.remove('form-minimized');
	                minimize.classList.remove('hidden');
	                if (component) {
	                    component.classList.remove('hidden');
	                }
	                dom.all('.form-minimized').forEach(function(f) {
	                    if (f.offsetLeft > form.offsetLeft) {
	                        var l = f.offsetLeft - 160;
	                        f.style.left = l + 'px';
	                    }
	                });
	                form.style.left = form.oldLeft + 'px';
	            });
	        }
	        return form;
	    };

	    form.addCloseButton = function() {
	        dom.div('form-top-button')
	            .click(form.hide)
	            .appendTo(form)
	            .append(createCloseSvg());
	        return form;
	    };

	    form.addResize = function() {
	        var resise = dom.div('form-resize')
	            .appendTo(form)
	            .append(createResizeSvg());
	        resise.addEventListener('mousedown', startResize);
	        resise.addEventListener('touchstart', startResize);
	        return form;
	    };

	    form.show = function(x,y) {
	        bringToFront();
	        x && (form.style.left = x+'px');
	        y && (form.style.top = y+'px');
	        form.classList.add('visible');
	        return form;
	    };
	    form.hide = function() {
	        form.classList.remove('visible');
	        return form;
	    };
	    form.toggle = function() {
	        return form.classList.contains('visible') ? form.hide() : form.show();
	    };

	    form.clear = function() {
	        content.innerHTML = "";
	        return form;
	    };

	    form.id = "form-" + id;

	    Events.listen(Events.SHOW_FORM, function (formId) {
	        if ("form-" + formId === form.id) form.show();
	    });
	    Events.listen(Events.HIDE_FORM, function (formId) {
	        if ("form-" + formId === form.id) form.hide();
	    });
	    Events.listen(Events.TOGGLE_FORM, function (formId) {
	        if ("form-" + formId === form.id) form.toggle();
	    });

	    var initX, initY, mousePressX, mousePressY;
	    var padding = 10;

	    if (title) {
	        title.addEventListener('mousedown', startDrag);
	        title.addEventListener('touchstart', startDrag);

	        window.addEventListener('resize', function() {
	            adjustLeft(form.offsetLeft);
	            adjustBottom(window.innerHeight - form.offsetTop - form.offsetHeight);
	        });
	    }
	    form.click(bringToFront);
	    return form;

	    function bringToFront() {
	        dom.all('.form').forEach(function (f) {
	            f.style.zIndex = 100;
	        });
	        form.style.zIndex = 1000;
	    }

	    function startResize(event) {
	        bringToFront();

	        initX = form.offsetWidth;
	        initY = form.offsetHeight;

	        form.classList.remove('form-transition');

	        mousePressX = event.clientX || event.touches[0].clientX;
	        mousePressY = event.clientY || event.touches[0].clientY;

	        window.addEventListener('mousemove', resizeElement);
	        window.addEventListener('touchmove', resizeElement);

	        window.addEventListener('mouseup', mouseUp.bind(null, resizeElement));
	        window.addEventListener('touchend', mouseUp.bind(null, resizeElement));

	        if (form.style.bottom){
	            form.style.top = form.offsetTop + 'px';
	            form.style.removeProperty('bottom');
	        }
	    }

	    function startDrag(event) {
	        bringToFront();

	        if (form.classList.contains('form-minimized')){
	            return;
	        }

	        initX = form.offsetLeft;
	        initY = form.offsetTop;

	        form.classList.remove('form-transition');

	        mousePressX = event.clientX || event.touches[0].clientX;
	        mousePressY = event.clientY || event.touches[0].clientY;

	        window.addEventListener('mousemove', repositionElement);
	        window.addEventListener('touchmove', repositionElement);

	        window.addEventListener('mouseup', mouseUp.bind(null, repositionElement));
	        window.addEventListener('touchend', mouseUp.bind(null, repositionElement));
	    }

	    function mouseUp(func) {
	        window.removeEventListener('mousemove', func);
	        window.removeEventListener('touchmove', func);
	        form.hasMinimazeButton && form.classList.add('form-transition');
	    }

	    function adjustLeft(left) {
	        var maxLeft = window.innerWidth - padding - form.offsetWidth;
	        left = left > maxLeft ? maxLeft : left;
	        left = left < padding ? padding : left;
	        form.style.left = left + 'px';
	    }

	    function adjustBottom(bottom) {
	        var maxBottom = window.innerHeight - padding - form.offsetHeight;
	        bottom = bottom > maxBottom ? maxBottom : bottom;
	        bottom = bottom < padding ? padding : bottom;
	        form.style.bottom = bottom + 'px';
	        form.style.removeProperty('top');
	    }

	    function repositionElement(event) {
	        var clientX = event.clientX || event.touches[0].clientX;
	        var clientY = event.clientY || event.touches[0].clientY;
	        adjustLeft(initX + clientX - mousePressX);
	        adjustBottom(window.innerHeight - (initY + clientY - mousePressY) - form.offsetHeight);
	    }

	    function resizeElement(event) {
	        var clientX = event.clientX || event.touches[0].clientX;
	        var clientY = event.clientY || event.touches[0].clientY;
	        form.style.height = (initY + clientY - mousePressY) + 'px';
	        form.style.width = (initX + clientX - mousePressX) + 'px';
	    }
	};

	function createMinimizeSvg() {
	    return svg().append(path("M5,15 H16"));
	}

	function createCloseSvg() {
	    return svg().append(path("M5,5 L16,16 M5,16 L16,5"));
	}
	function createResizeSvg() {
	    return svg().append(path("M4,19 L19,4 M8,19 L19,8 M12,19 L19,12", 1.2));
	}
	function path(d, width){
	    return dom.path({
	        d: d,
	        stroke: "lightgray",
	        "stroke-width": width || 3
	    });
	}

	function svg() {
	    return dom.svg({
	        width: 21,
	        height: 21,
	        viewbox: "0 0 25 25"
	    });
	}

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

	var dom = __webpack_require__(4);
	var Events = __webpack_require__(5);

	module.exports = createField;
	module.exports.cfg = createConfig;

	function createField(cfg) {

	    var field = dom.div('form-field');

	    field.cfg = cfg;

	    if (!cfg.custom) {
	        cfg.custom = {};
	    }

	    dom.div('form-field-title')
	        .html(cfg.title + ':')
	        .appendTo(field);

	    var value = dom.div('form-field-value')
	        .appendTo(field);

	    field.set = function(text) {
	        value.html(text);
	    };

	    field.render = function(data) {
	        var val = cfg.custom.provider ?
	            cfg.custom.provider(data) :
	            deepValue(data, cfg.path);

	        if (cfg.custom.renderer) {
	            cfg.custom.renderer(val, value, data);
	        } else if (null != val) {
	            if (typeof val == 'number'){
	                val = val.toFixed(6);
	            }
	            value.innerHTML = val;
	        }
	    };

	    if (cfg.listen) {
	        Events.listen(cfg.listen, function (data) {
	            field.render(data);
	        })
	    }

	    if (cfg.custom.style) {
	        for (var property in cfg.custom.style) {
	            if (cfg.custom.style.hasOwnProperty(property)) {
	                field.style[property] = cfg.custom.style[property];
	            }
	        }
	    }

	    return field;
	}

	function deepValue(obj, path) {
	    try {
	        path = path.split('.');
	        for (var i = 0; i < path.length; i++) {
	            obj = obj[path[i]];
	        }
	        return obj;
	    } catch (e) {
	        return null;
	    }
	}

	function createConfig(title, path, style) {

	    var cfg = {
	        title: title,
	        path: path,
	        custom: {
	            style: style
	        }
	    };

	    cfg.style = createCustom('style');
	    cfg.provider = createCustom('provider');
	    cfg.renderer = createCustom('renderer');
	    cfg.onclick = createCustom('onclick');

	    return cfg;

	    function createCustom(property) {
	        return function(value) {
	            cfg.custom[property] = value;
	            return cfg;
	        };
	    }
	}


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

	var Events = __webpack_require__(5);
	var dom = __webpack_require__(4);
	var Dropdown = __webpack_require__(11);

	module.exports = function (placeholderText, values, width) {
	    var cb = new DropDown5(placeholderText, values, width);
	    return cb.dd;
	};

	function DropDown5(placeholderText, values, width) {
	    var dd = Dropdown('wrapper-dropdown-5', placeholderText, width);

	    this.dd = dd;
	    this.opts = values.map(createvalueItem);
	    this.val = '';
	    this.index = -1;

	    function createvalueItem(value) {
	        var span = document.createElement('span');
	        span.innerHTML = value.text;

	        if (value.selected) {
	           assignValue();
	        }

	        var li = document.createElement('li');
	        li.appendChild(span);
	        li.onclick = function () {
	            assignValue();
	            Events.post(value.post, value.data);
	        };

	        dd.ul.appendChild(li);

	        return li;

	        function assignValue() {
	            dd.placeholder.innerHTML = value.text;
	        }
	    }
	}




/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

	var dom = __webpack_require__(4);
	var instanceCount = 0;

	module.exports = function (style, placeholderText, width) {

	    var ul = document.createElement('ul');
	    ul.classList.add('dropdown');

	    var placeholder = dom.span().html(placeholderText);

	    var dropdown = dom.div(style)
	        .append(placeholder).append(ul);

	    dropdown.style.width = (width || 100) + 'px';
	    dropdown.tabIndex = instanceCount++;
	    dropdown.placeholder = placeholder;
	    dropdown.ul = ul;

	    dropdown.onblur = deactivate;

	    window.addEventListener('click', deactivate, false);

	    dropdown.onclick = function (event) {
	        dropdown.classList.toggle('active');
	        event.stopPropagation();
	        return false;
	    };

	    function deactivate() {
	        dropdown.classList.remove('active');
	    }
	    return dropdown;
	};

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

	var Dropdown = __webpack_require__(11);
	var Events = __webpack_require__(5);
	var dom = __webpack_require__(4);

	module.exports = function (placeholderText, values, width) {
	    var cb = new DropDown4(placeholderText, values, width);
	    return cb.dd;
	};

	/**
	    <div id="dd" class="wrapper-dropdown-4">
	        To do
	        <ul class="dropdown">
	            <li><input type="checkbox" id="el-1" name="el-1" value="donut"><label for="el-1">task 1</label></li>
	            <li><input type="checkbox" id="el-2" name="el-2" value="neighbour"><label for="el-2">task 2</label></li>
	            <li><input type="checkbox" id="el-3" name="el-3" value="T-rex"><label for="el-3">task 3</label></li>
	        </ul>
	    </div>
	 */

	function DropDown4(placeholderText, values, width) {

	    var self = this;
	    var dd = Dropdown('wrapper-dropdown-4', placeholderText, width);
	    this.dd = dd;
	    this.opts = values.map(createvalueItem);
	    this.val = [];
	    this.index = [];

	    function createvalueItem(value, index) {
	        var id = 'checklist-element-' + Math.random().toString(36).substr(2, 10);

	        var label = document.createElement('label');
	        label.for = id;
	        label.innerHTML = value.text;

	        var checkbox = document.createElement('input');
	        checkbox.type = 'checkbox';
	        checkbox.value = value.text;
	        checkbox.id = id;
	        checkbox.name = id;

	        var li = document.createElement('li');
	        li.appendChild(checkbox);
	        li.appendChild(label);

	        dd.ul.appendChild(li);

	        label.onclick = function () {
	            var val = checkbox.value;
	            arrayLoop(val, self.val) !== -1 ? self.val.splice(arrayLoop(val, self.val), 1) : self.val.push(val);
	            arrayLoop(index, self.index) !== -1 ? self.index.splice(arrayLoop(index, self.index), 1) : self.index.push(index);
	        };

	        return li;
	    }
	}

	function arrayLoop(elem, array, i) {
	    var len = array.length;
	    i = i ? i < 0 ? Math.max(0, len + i) : i : 0;
	    for (; i < len; i++) {
	        // Skip accessing in sparse arrays
	        if (i in array && array[i] === elem) {
	            return i;
	        }
	    }
	    return -1;
	}



/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

	var dom = __webpack_require__(4);
	var scroll = __webpack_require__(14);

	module.exports = function(config, data, onSelect, maxHeight) {
	    var tree = dom.div('tree');
	    // var header = dom.div('tree-header').appendTo(tree);
	    var body = dom.div('tree-body');
	    
	    traverse(data, addNode);
	    
	    if (maxHeight) {
	        var scroller = scroll(body, config.width, maxHeight).appendTo(tree);
	    } else {
	        body.appendTo(tree);
	    }

	    tree.update = function() {
	        if (scroller) {
	            scroller.update();
	        }
	    };

	    tree.update();

	    return tree;
	    
	    function addNode(object, parent) {

	        var expanderIcon = dom.path({
	            d: "M15,5 V25 M5,15 H25",
	            stroke: 'white',
	            strokeWidth: 2
	        });

	        var expander = dom.svg({width: 30, height: 30})
	            .append(expanderIcon)
	            .click(expandNode);

	        var nodeText = dom.span('tree-node-text')
	            .html(object[config.property])
	            .click(selectNode);

	        object.treeNode = dom.div('tree-node')
	            .append(dom.span('tree-node-expander').append(expander))
	            .append(nodeText)
	            .appendTo(parent.treeNode ? parent.treeNode : body);

	        object.treeNode.expander = expander;

	        expander.style.opacity = 0;

	        if (parent.treeNode) {
	            parent.treeNode.expander.style.opacity = 1;
	        }


	        function expandNode() {
	            object.treeNode.classList.toggle('collapsed');
	        }

	        function selectNode() {
	            onSelect(object);
	        }
	    }
	};

	function traverse(parent, func) {
	    if (!parent.children) {
	        return;
	    }
	    parent.children.forEach(function (child) {
	        func.apply(this, [child, parent]);
	        traverse(child, func);
	    });
	}


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

	const dom = __webpack_require__(4);

	module.exports = createScroll;

	function createScroll(content, width, height) {
	    var start;

	    var scroll = dom.div('scroll-container');
	    var viewport = dom.div('viewport').append(content).appendTo(scroll);
	    var track = dom.div('track').appendTo(scroll);
	    var knob = dom.div('knob').appendTo(track);

	    resize(scroll, width, height);
	    resize(viewport, width, height);
	    resize(track, null, height);

	    scroll.addEventListener('mousewheel', onWheel);
	    knob.addEventListener('mousedown', onMouseDown);

	    scroll.update = updateKnob;

	    return scroll;

	    function onMouseMove(e) {

	        var pos = start + e.clientY;
	        var max = viewport.offsetHeight - knob.offsetHeight;

	        if (pos < 0) {
	            pos = 0;
	        }

	        if (pos > max) {
	            pos = max;
	        }

	        viewport.scrollTop = pos / k();
	        knob.style.top = pos + "px";
	    }

	    function onMouseDown(e) {
	        start = knob.offsetTop - e.clientY;
	        document.addEventListener('mousemove', onMouseMove);
	        document.addEventListener('mouseup', onMouseUp);
	        knob.parentNode.classList.add('active');
	    }

	    function onMouseUp() {
	        document.removeEventListener('mousemove', onMouseMove);
	        document.addEventListener('mouseup', onMouseUp);
	        knob.parentNode.classList.remove('active');
	    }

	    function updateKnob() {
	        const coef = k();
	        knob.style.top = viewport.scrollTop * coef + "px";
	        knob.style.height = (coef < 1 ? height * coef : 0) + "px";
	    }

	    function onWheel(e) {
	        var delta = e.deltaY;
	        viewport.scrollTop += delta / 2;
	        updateKnob();
	        e.preventDefault();
	    }

	    function k() {
	        return height / content.offsetHeight;
	    }
	}

	function resize(component, width, height) {
	    if (null != width) {
	        component.style.width = width + "px";
	    }
	    if (null != height) {
	        component.style.height = height + "px";
	    }
	}


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

	
	var dom = __webpack_require__(4);

	module.exports = {
	    create: function(config) {
	        var button;
	        var disabled = false;
	        if (config.image) {
	            var image = dom.img();
	            image.src = config.image;
	            button = dom.div('form-button-image').append(image)
	                .append(dom.span('form-button-image--text').html(config.title));
	        } else {
	            button = dom.div('form-button').html(config.title);
	        }

	        config.tooltip && button.setAttribute('title', config.tooltip);
	        config.width && (button.style.width = config.width + 'px');
	        config.height && (button.style.height = config.height + 'px');

	        if (config.group) {
	            Events.listen(Events.FORM_BUTTON_GROUP_STATE_CHANGED, function (state) {
	               if (state.group === config.group) {
	                   button.setClass('active', state.title === config.title);
	               }
	            });
	        }

	        if (config.post || config.action) {
	            button.click(function () {

	                if (disabled) return;

	                if (config.post && !button.classList.contains('active')) {
	                    Events.post(config.post, config.data);
	                }

	                if (config.action) {
	                    config.action();
	                }

	                if (config.group) {
	                    Events.post(Events.FORM_BUTTON_GROUP_STATE_CHANGED, {
	                        group: config.group,
	                        title: config.title
	                    });
	                }
	            });
	        }

	        button.setDisabled = function (disable) {
	            disabled = disable;
	            button.setClass('disabled', disable);
	            button.style.pointerEvents = disable ? 'none' : 'all';
	            return button;
	        };

	        button.setVisible = function (isVisible) {
	            button.setClass('hidden', !isVisible);
	            return button;
	        };

	        return button;
	    }
	};


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

	var dom = __webpack_require__(4);

	var knobSize = 30;
	var range = 100;

	module.exports = function(cfg) {
	    var coordinate;
	    var newValue;

	    var value = cfg ? cfg.value ? cfg.value * range : 0 : 0;
	    var property = cfg.vertical ? 'clientY' : 'clientX';

	    var slider = dom.div('slider');
	    slider.style.width = (cfg.vertical ? knobSize : cfg.size) + 'px';
	    slider.style.height = (cfg.vertical ? cfg.size : knobSize) + 'px';

	    var k = (cfg.size - knobSize) / range;

	    cfg.style && slider.classList.add(cfg.style);

	    var knob = dom.div('slider-knob').appendTo(slider);
	    knob.addEventListener('mousedown', down);
	    render();

	    slider.setValue = function(val) {
	        value = val * range;
	        newValue = val * range;
	        render();
	    };

	    return slider;

	    function down(e) {
	        coordinate = e[property];
	        window.addEventListener('mousemove', move);
	        window.addEventListener('mouseup', up);
	    }

	    function move(e) {
	        const delta = (e[property] - coordinate) / k;
	        newValue = value + delta * (cfg.invert ? -1 : 1);
	        if (newValue < 0) newValue = 0;
	        if (newValue > range) newValue = range;
	        render();
	        if (cfg && typeof cfg.callback === 'function') {
	            cfg.callback(newValue / 100);
	        }
	    }

	    function up() {
	        window.removeEventListener('mousemove', move);
	        window.removeEventListener('mouseup', up);
	        value = newValue;
	        coordinate = null;
	    }

	    function render() {
	        var val = coordinate ? newValue : value;
	        var prop = cfg.vertical ?
	            cfg.invert ? 'bottom' : 'top' :
	            cfg.invert ? 'right' : 'left';
	        knob.style[prop] = val * k + 'px';
	        knob.html(renderValue(val));
	    }


	    function renderValue(val) {
	        var number = val/range;
	        if (cfg.renderValue) {
	            cfg.renderValue(number);
	        }
	        return (number).toFixed(2).toString();
	    }
	};

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

	var dom = __webpack_require__(4);

	module.exports = function(name, value) {
	    var title = dom.div('form-input-title').html(name);
	    var input = dom.input('form-input');
	    input.value = value || '';
	    var field = dom.div('form-input-container').append(title).append(input);
	    field.setValue = function (val) {
	        input.value = val;
	    };
	    field.getValue = function () {
	        return input.value;
	    };
	    return field;
	};

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

	var dom = __webpack_require__(4);

	module.exports = function(name, value, width, height) {
	    var title = dom.div('form-textarea-title').html(name);
	    var ta = document.createElement('textarea');
	    ta.value = value || '';
	    ta.style.width = width + 'px';
	    ta.style.height = height + 'px';
	    var field = dom.div('form-textarea-container').append(title).append(ta);
	    field.setValue = function (val) {
	        ta.value = val;
	    };
	    field.getValue = function () {
	        return ta.value;
	    };
	    field.setTitle = function (text) {
	        title.html(text)
	    };
	    return field;
	};

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

	var Dom = __webpack_require__(4);
	var Events = __webpack_require__(5);

	var target = Dom.div('target').appendTo(document.body);

	Dom.svg({
	    viewBox: "0 0 100 100",
	    width: 50,
	    height: 50
	}).append(Dom.circle({
	    r: 30,
	    cx: 50,
	    cy: 50,
	    stroke: "wheat",
	    "stroke-width": 3,
	    fill: "none"
	})).append(Dom.path({
	    stroke: "wheat",
	    "stroke-width": 3,
	    d: "M50,10 L50,20 M50,80 L50,90 M10,50 L20,50 M80,50 L90,50"
	})).appendTo(target);

	Events.listen(Events.NAVIGATOR_STATE_CHANGED, navigatorStateChanged);
	Events.listen(Events.LOCATION_CHANGED, navigatorStateChanged);

	var hideInterval;

	function navigatorStateChanged() {
	    target.classList.add('visible');
	    if (hideInterval) {
	        clearInterval(hideInterval);
	    }
	    hideInterval = setInterval(function() {
	        target.classList.remove('visible');
	    }, 250);
	}

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

	var Events = __webpack_require__(5);
	var dom = __webpack_require__(4);

	var x = 0;
	var z = 0;

	var gray = 'rgba(255, 255, 255, 0.7)';
	var red = 'rgba(255, 0, 0, 0.7)';
	var none = 'none';
	var svg = dom.svg({
	    viewbox: '0 0 100 100', width: 100, height: 100
	}).append(dom.circle({
	    cx: 50, cy: 50, r: 45, stroke: gray, fill: none, 'stroke-width': 3
	})).append(dom.path({
	    d: 'M50,10 L37,50 L63,50 Z', stroke: none, 'fill': red
	})).append(dom.path({
	    d: 'M50,10 L37,50 L50,90 L63,50 Z', stroke: gray, fill: none, 'stroke-width': 3
	})).click(function() {
	    window.engine.navigator.tilt = 0;
	    window.engine.navigator.heading = 0;
	});

	var compass = dom.div('overlay-compass hidden').append(svg).appendTo(document.body);

	Events.listen(Events.SWITCH_COMPASS_SVG, function(state) {
	    compass.setClass('hidden', state == null ? !compass.classList.contains('hidden') : state);
	});

	compass.oncontextmenu = function() {
	    return false;
	};

	Events.listen(Events.NAVIGATOR_STATE_CHANGED, function(state) {
	    state.tilt !== undefined && (x = state.tilt);
	    state.heading !== undefined && (z = -state.heading);
	    x = x > 70 ? 70 : x;
	    update();
	});

	function update(){
	    svg.style.transform = 'rotateX(' + x + 'deg) rotateZ(' + z + 'deg)';
	}


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

	var Events = __webpack_require__(5);
	var Dom = __webpack_require__(4);
	var SvgIcons = __webpack_require__(1);

	var WIZARD_FORM_ID = 'wizard';
	var descriptionSize = 60;
	var circleSize = 30;
	var txtFieldHeight = 27;

	var currentStep;
	var wizardConfig;
	var pointsCount;
	var wizardIsActive;
	var isDrawing;

	var wizard = Events.post(Events.CREATE_FORM, {
	    id: WIZARD_FORM_ID,
	    width: 220,
	    height: 400,
	    left: 55,
	    bottom: 155,
	    title: 'Нанесение знака',
	    visible: false
	});

	wizard.style.transition = '0 !important';

	var btnSize = 40;
	var prevButton = wizard.addButton({
	    action: function () {
	        reconfigureAndStartEditIfRuleSwitched(currentStep - 1);
	    },
	    tooltip: 'Предыдущее правило', title: SvgIcons.prev(), width: btnSize, height: btnSize});

	var nextButton = wizard.addButton({
	    action: function () {
	        reconfigureAndStartEditIfRuleSwitched(currentStep + 1);
	    },
	    tooltip: 'Следующее правило', title: SvgIcons.next(), width: btnSize, height: btnSize});

	var rotateButton = wizard.addButton({
	    action: function () {
	        Events.post(Events.SET_DRAW_MODE, 'rotate');
	        rotateButton.setVisible(false);
	        moveButton.setVisible(true);
	    },
	    tooltip: 'Включить режим поворота', title: SvgIcons.rotate(), width: btnSize, height: btnSize});

	var moveButton = wizard.addButton({
	    action: function () {
	        Events.post(Events.SET_DRAW_MODE, 'move');
	        moveButton.setVisible(false);
	        rotateButton.setVisible(true);
	    },
	    tooltip: 'Выключить режим поворота', title: SvgIcons.move(), width: btnSize, height: btnSize})
	    .setVisible(false);


	var drawButton = wizard.addButton({
	    action: function () {
	        Events.post(Events.SET_DRAW_MODE, 'draw');
	        drawButton.setVisible(false);
	        lookButton.setVisible(true);
	    },
	    tooltip: 'Приостановить нанесение', title: SvgIcons.look(), width: btnSize, height: btnSize});

	var lookButton = wizard.addButton({
	    action: function () {
	        Events.post(Events.SET_DRAW_MODE, 'draw');
	        lookButton.setVisible(false);
	        drawButton.setVisible(true);
	    },
	    tooltip: 'Продолжить нанесение', title: SvgIcons.pencil(), width: btnSize, height: btnSize});


	var cancelButton = wizard.addButton({
	    action: closeWizard.bind(null, true),
	    tooltip: 'Отменить нанесение знака', title: 'Отмена', width: 90});

	var finishButton = wizard.addButton({
	    action: closeWizard.bind(null),
	    tooltip: 'Закончить нанесение знака', title: 'Нанести', width: 90});

	function closeWizard(cancel) {
	    Events.post(Events._FORCE_END_DRAWING);
	    Events.post(Events.HIDE_FORM, WIZARD_FORM_ID);
	    wizardIsActive = false;
	    cancel && (wizardConfig.cancelled = true);
	    Events.post(Events.WIZARD_RESULT, wizardConfig);
	    Events.post(Events.CLEAR_LAYER, 'editor');
	}

	Events.listen(Events._ANCHOR_POINTS_COUNT, function (count) {
	    if (!wizardIsActive) return;
	    pointsCount = count;
	    var rule = wizardConfig.rules[currentStep];
	    rule.finished = rule.min <= count;
	    reconfigure();
	    Events.post(Events.REDRAW);
	});

	Events.listen(Events.END_DRAWING, function (source) {
	    isDrawing = false;
	    if (!wizardIsActive) return;
	    wizardConfig.rules[currentStep].result = source;
	    reconfigure();
	    Events.post(Events.REDRAW);
	});

	function isRulesFullyFilled() {
	    var filled = true;
	    !wizardConfig.rules.forEach(function (rule) {
	        filled &= rule.finished;
	    });
	    return filled;
	}
	function reconfigure() {
	    var currentRule = wizardConfig.rules[currentStep];

	    wizard.clear();
	    wizard.add(createIndicator());
	    wizard.add(prevButton.setDisabled(currentStep === 0));
	    wizard.add(nextButton.setDisabled(currentStep === wizardConfig.rules.length - 1));
	    wizard.add(rotateButton.setVisible(true).setDisabled(currentRule.max === 1 || !isDrawing));
	    wizard.add(moveButton.setVisible(false));
	    wizard.add(drawButton.setVisible(true).setDisabled(!isDrawing));
	    wizard.add(lookButton.setVisible(false));
	    wizard.add(cancelButton);
	    wizard.add(finishButton.setDisabled(!isRulesFullyFilled()));

	    if (currentRule.text) {
	        currentRule.text.forEach(function (txt, i) {
	            var textField = Dom.input('wizard-point-text');
	            textField.setAttribute('type', 'text');
	            textField.style.top = (90 + circleSize * currentStep + i*txtFieldHeight) + 'px';
	            textField.style.left = '50px';
	            textField.style.width = '150px';
	            textField.style.height = '20px';
	            textField.style.backgroundColor = 'rgba(128,128,128,0.5)';
	            textField.placeholder = txt.title;
	            txt.value && (textField.value = txt.value);
	            textField.onkeyup = function () {
	                txt.value = textField.value;
	            };
	            wizard.add(textField);
	        });
	    }

	    var textFieldCount = currentRule.text ? currentRule.text.length : 0;
	    wizard.style.height = (wizardConfig.rules.length * 30 + 195 + textFieldCount*txtFieldHeight) + 'px';
	}

	function reconfigureAndStartEditIfRuleSwitched(next) {
	    Events.post(Events._FORCE_END_DRAWING);
	    currentStep = next;
	    var needReconfigure = true;

	    if (currentStep < 0) {
	        currentStep = 0;
	        needReconfigure = false;
	    } else if (currentStep === wizardConfig.rules.length) {
	        currentStep = wizardConfig.rules.length - 1;
	        needReconfigure = false;
	    }

	    if (needReconfigure){
	        pointsCount = 0;
	        reconfigure();
	        setTimeout(startEdit, 10);
	    }
	}

	function createIndicator() {
	    var len = wizardConfig.rules.length;
	    var half = circleSize / 2;
	    var currentRule = wizardConfig.rules[currentStep];
	    var textFieldCount = currentRule.text ? currentRule.text.length : 0;
	    var total = len * circleSize + descriptionSize + textFieldCount * txtFieldHeight;
	    var indicator = Dom.svg({
	        viewbox: '0 0 200 ' + total,
	        width: 200,
	        height: total
	    });
	    var linePoint;
	    for (var i = 0; i < len; i++) {
	        var y = circleSize*i + half + (i > currentStep ? descriptionSize + textFieldCount * txtFieldHeight: 0);
	        var r = half*0.7;
	        var isCurrentStep = i === currentStep;
	        var rule = wizardConfig.rules[i];
	        var href = isCurrentStep ? null : i + 1;

	        !rule.finished && indicator.append(text(half, y, i + 1, 'white', true));
	        indicator.append(circle(half, y, r, rule.finished, href));
	        rule.finished && indicator.append(text(half, y, i + 1, 'black', true));

	        indicator.append(text(circleSize + 10, y, rule.name, isCurrentStep ? 'wheat' : 'white', false, href));
	        if (isCurrentStep) {
	            if (rule.description) {
	                var words = rule.description.split(" ");
	                var s1 = "";
	                var s2 = "";
	                words.forEach(function(word) {
	                    if (s1.length + word.length + 1 < 25) {
	                        s1 += " " + word;
	                    }  else {
	                        s2 += " " + word;
	                    }
	                });

	                s1.length && indicator.append(text(circleSize + 15, y + 20, s1, 'white'));
	                s2.length && indicator.append(text(circleSize + 15, y + 40, s2, 'white'));
	            }
	            // indicator.append(text(circleSize + 15, y + 40, 'Минимум точек: ' + rule.min, 'white'));
	            // indicator.append(text(circleSize + 15, y + 60, 'Максимум точек: ' + rule.min, 'white'));
	            for (var j = 0; j < rule.min; j++) {
	                indicator.append(circle(circleSize + 20 + j*15, y + 60, 5, j<pointsCount));
	            }
	            if (!rule.max || rule.max > rule.min) {
	                indicator.append(cross(circleSize + 20 + rule.min*15, y + 60, 5, rule.min + 1 <= pointsCount));
	            }
	        }

	        linePoint && indicator.append(line(half, linePoint, y - r));
	        linePoint = y + r;
	    }
	    return indicator;
	}

	function line(x, y1, y2) {
	    return Dom.path({
	        d: 'M ' + x + ',' + y1 + ' L ' + x + ',' + y2,
	        stroke: 'white', 'stroke-width': 2
	    })
	}

	function text(x, y, text, color, center, href) {
	    var el = document.createElementNS("http://www.w3.org/2000/svg", 'text');
	    el.innerHTML = text;
	    el.setAttribute('x', x);
	    el.setAttribute('y', y);
	    el.setAttribute('fill', color);
	    el.setAttribute('cursor', 'default');
	    el.setAttribute('alignment-baseline', 'central');
	    href && el.setAttribute('cursor', 'pointer');
	    href && (el.onclick = onclick.bind(null, href));
	    center && el.setAttribute('text-anchor', 'middle');
	    return el;
	}

	function onclick(i) {
	    reconfigureAndStartEditIfRuleSwitched(i - 1);
	}

	function cross(x, y, s, fill, href) {
	    var attributes = {
	        d: M(0, -s) + L(0, s) + M (-s, 0) + L(s, 0),
	        fill: fill ? 'wheat' : 'none',
	        stroke: fill ? 'wheat': 'white',
	        'stroke-width': 2
	    };
	    href && (attributes.cursor = 'pointer');
	    var circle = Dom.path(attributes);
	    href && (circle.onclick = onclick.bind(null, href));
	    return circle;

	    function pt(dx, dy) {
	        return (x + dx) + ',' + (y + dy);
	    }

	    function M(dx, dy) {
	       return 'M' + pt(dx, dy);
	    }

	    function L(dx, dy) {
	        return 'L' + pt(dx, dy);
	    }
	}

	function circle(x, y, r, fill, href) {
	    var attributes = {
	        r: r, cx: x, cy: y,
	        fill: fill ? 'wheat' : 'none',
	        stroke: fill ? 'wheat': 'white',
	        'stroke-width': 2
	    };

	    href && (attributes.cursor = 'pointer');
	    var circle = Dom.circle(attributes);
	    href && (circle.onclick = onclick.bind(null, href));
	    return circle;
	}


	var types = {};
	//! Подпись
	types.LABEL = "Point";
	//! Точечный знак
	types.POINT = "Point";
	//! Линейный знак
	types.LINE = "LineString";
	//! Площадной знак
	types.AREA = "Polygon";
	//! Формуляр
	types.FORMULAR = "Point";
	//! Разранлиния
	types.DEMARK_LINE = "LineString";
	//! Позиционный район
	types.POSITION_AREA = "Polygon";
	//! Полоса
	types.STRIP = "LineString";
	//! Заградительный огонь
	types.DEFENSIVE_FIRE = "LineString";
	//! Зона видимости
	types.OBSERVATION_AREA = "Polygon";
	//! Таблица
	types.TABLE = "Point";
	//! Направление удара
	types.THRUST = "Point";
	//! Флагшок
	types.FLAG_STAFF = "Point";
	//! Выноска
	types.LEADER = "Point";
	//! Соединительная линия
	types.LINK_LINE = "LineString";

	function getGeometryTypeByRuleType(type) {
	    return types.hasOwnProperty(type) ? types[type] : type;
	}

	function startEdit() {

	    var l = Events.post(Events._GET_LAYER, 'editor');
	    l && l.renderables.forEach(function (r) {
	        if (r.source.properties.ruleIndex === currentStep) {
	            l.removeRenderable(r)
	        }
	    });

	    var rule = wizardConfig.rules[currentStep];
	    if (rule.result) {
	        Events.post(Events.EDIT_OBJECT, {object: {source: rule.result}});
	    } else {
	        Events.post(Events.START_DRAWING, {
	            type: 'Feature',
	            geometry: {
	                type: getGeometryTypeByRuleType(rule.type)
	            },
	            properties: {
	                layer: 'editor', id: wizardConfig.id,
	                ruleType: rule.type, ruleIndex: currentStep,
	                api: 'coco',
	                text: '', width: 10, height: 10
	            }
	        });
	    }
	    Events.post(Events.REDRAW);
	    isDrawing = true;
	    reconfigure();
	}

	Events.listen(Events.SHOW_WIZARD, function(config) {
	    wizardConfig = config;
	    wizardIsActive = true;
	    currentStep = 0;
	    pointsCount = 0;
	    Events.post(Events.SHOW_FORM, WIZARD_FORM_ID);
	    startEdit();
	});


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

	var Events = __webpack_require__(5);
	var Dom = __webpack_require__(4);

	var tooltip = Dom.select('.tooltip');

	Events.listen(Events.TOOLTIP, function (text) {
	    tooltip.setClass('visible', !!text).html(text ? text.split(' ').join('&nbsp;') : '');
	    window[!!text ? 'addEventListener': 'removeEventListener']('mousemove', listener);
	});

	function listener(event) {
	    tooltip.style.left = (event.x + 15) + 'px';
	    tooltip.style.top = (event.y - 5) + 'px';
	}

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

	var Events = __webpack_require__(5);
	var Dom = __webpack_require__(4);

	var waiting = Dom.select('.waiting');

	Events.listen(Events.WAIT, function (state) {
	    waiting.setClass('visible', !!state);
	});



/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

	var events = __webpack_require__(5);
	var dom = __webpack_require__(4);

	var controls = dom.select('#compass');

	controls.oncontextmenu = function() {
	    return false;
	};

	var size = 160;
	var half = size/2;

	var startY, startAngle, dragType;

	var knobs = {
	    heading: initKnob('heading'),
	    tilt: initKnob('tilt'),
	    zoom: initKnob('range')
	};

	var svg = dom.select('#controls-svg');

	module.exports = svg;

	dom.all('path.arrow').forEach(initArrow);

	// dom.select('#controls-globe').click(function() {
	//     //events.post(events.ROTATE_TO, {heading: 0, tilt: 0})
	// });

	events.listen(events.SWITCH_CONTROLS, function (state) {
	    if (typeof state !== "boolean") {
	        controls.classList.toggle('visible');
	    } else if (state) {
	        controls.classList.add('visible');
	    } else {
	        controls.classList.remove('visible');
	    }
	});

	events.listen(events.NAVIGATOR_STATE_CHANGED, function(state) {

	    if (dragType) { // prevents handling of navigator changes when dragging
	        return;
	    }

	    if (null != state.heading) {
	        setHeading(-state.heading);
	    }

	    if (null != state.tilt) {
	        setTilt(state.tilt/90 * size - half);
	    }

	    if (null != state.range) {
	        var z = (1e5 + state.range)/20e6 * size - half
	        if (Math.abs(z) > half) {
	            z = Math.sign(z) * half;
	        }
	        setZoom(z);
	    }
	});

	function send(value, id) {
	    events.post(events.CONTROLS, {
	        parameter: id ? id : dragType,
	        value: value
	    });
	}

	function onMouseMove(e) {

	    if (dragType == 'heading') {
	        var angle = startAngle + mouseAngle(e);
	        setHeading(angle);
	        send(-angle);
	        return;
	    }

	    var y = startY + mouseY(e);
	    if (Math.abs(y) > half) {
	        y = Math.sign(y) * half;
	    }

	    if (dragType == 'tilt') {
	        setTilt(y);
	        send((y + half)/size*90); //
	        return;
	    }

	    if (dragType == 'range') {
	        setZoom(y);
	        send(1e5 + (y + half)/size*20e6); //
	    }
	}

	function onMouseDown(e) {
	    dragType = getId(this.id);

	    if (dragType == 'heading') {
	        startAngle = headingKnobCurrentAngle() - mouseAngle(e);
	    } else {
	        startY = knobCurrentY(this) - mouseY(e);
	    }

	    document.addEventListener('mousemove', onMouseMove);
	    document.addEventListener('mouseup', onMouseUp);
	    document.addEventListener('touchmove', onMouseMove);
	    document.addEventListener('touchend', onMouseUp);
	}

	function knobCurrentY(knob) {
	    return parseFloat(knob.getAttribute('transform').split(/\(|\)/)[1].split(' ')[1]);
	}

	function headingKnobCurrentAngle() {
	    return parseFloat(knobs.heading.parentNode.getAttribute('transform').split(/\(|\)/)[1]);
	}

	function setHeading(deg) {
	    knobs.heading.parentNode.setAttribute('transform', 'rotate(' + deg + ')');
	}

	function setZoom(value) {
	    knobs.zoom.setAttribute('transform', 'translate(100 ' + value + ')');
	}

	function setTilt(value) {
	    knobs.tilt.setAttribute('transform', 'translate(-100 ' + value + ')');
	}

	function initKnob(type) {
	    var knob = dom.select('#controls-' + type + '-knob');
	    knob.addEventListener('mousedown', onMouseDown);
	    knob.addEventListener('touchstart', onMouseDown);
	    return knob;
	}

	function mouseAngle(e) {
	    return rad2deg(Math.PI - Math.atan2(mouseX(e), mouseY(e)));
	}

	function mouseY(e) {
	    return (e.clientY || e.touches[0].clientY) - getOffset(svg.parentNode, 'offsetTop') - svg.clientHeight / 2;
	}

	function mouseX(e) {
	    return (e.clientX || e.touches[0].clientX)- getOffset(svg.parentNode, 'offsetLeft') - svg.clientWidth / 2;
	}

	function rad2deg(rad) {
	    return rad / Math.PI * 180;
	}

	function deg2rad(deg) {
	    return deg / 180 * Math.PI;
	}

	function onMouseUp() {
	    dragType = null;
	    document.removeEventListener('mousemove', onMouseMove);
	    document.removeEventListener('mouseup', onMouseUp);
	    document.removeEventListener('touchmove', onMouseMove);
	    document.removeEventListener('touchend', onMouseUp);
	}

	function getOffset(elem, offsetParam) {
	    var offset = elem[offsetParam];
	    if (elem.offsetParent) {
	        offset += getOffset(elem.offsetParent, offsetParam);
	    }
	    return offset;
	}

	function initArrow(arrow) {

	    const id = getId(arrow.id);

	    arrow.addEventListener('mousedown', activate);
	    arrow.addEventListener('touchstart', activate);

	    function deactivate() {
	        document.removeEventListener('mouseup', deactivate);
	        document.removeEventListener('touchend', deactivate);
	        send(false, id)
	    }

	    function activate() {
	        document.addEventListener('mouseup', deactivate);
	        document.addEventListener('touchend', deactivate);
	        send(true, id);
	    }

	}

	function getId(id) {
	    return id.split('-')[1];
	}


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

	var Events = __webpack_require__(5);
	var Dom = __webpack_require__(4);

	var context = Dom.select('.context');

	context.oncontextmenu = function() {
	    return false;
	};

	window.addEventListener('resize', function () {
	    context.classList.remove('visible');
	});

	Events.listen(Events.SHOW_CONTEXT_MENU, function (description) {
	    if (description) {
	        context.innerHTML = '';
	        context.style.left = description.x + 'px';
	        context.style.top = description.y + 'px';
	        description.items.forEach(addItem);
	        context.classList.add('visible');
	    } else {
	        context.classList.remove('visible');
	    }
	});

	function addItem(item) {
	    Dom.div('context-menu-item')
	        .click(item.func)
	        .html(item.text)
	        .appendTo(context);
	}



/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

	var dom = __webpack_require__(4);
	var Events = __webpack_require__(5);

	var PICKER_FORM_ID = 'layers';
	var PICKER_BUTTON_ID = 'show-blp';
	var MAPS_KEYS = [];
	var ELEVATIONS_KEYS = [];
	var BLP_SCHEMA = {};


	Events.listen(Events.CREATE_BASE_LAYER_PICKER, createBaseLayerPicker);

	Events.listen(Events.DESTROY_BASE_LAYER_PICKER, destroyBaseLayerPicker);

	Events.listen(Events.GET_MAPS_KEYS, getMapsKeys);

	Events.listen(Events.GET_ELEVATIONS_KEYS, getElevationsKeys);

	Events.listen(Events.SET_ACTIVE_MAP, setActiveMapByKey);

	Events.listen(Events.SET_ACTIVE_ELEVATION, setActiveElevationByKey);


	function getMapsKeys() {
	    return  MAPS_KEYS;
	}
	function getElevationsKeys() {
	    return  ELEVATIONS_KEYS;
	}

	function setActiveElevationByKey(key) {
	    if (!BLP_SCHEMA || !BLP_SCHEMA.elevations || !BLP_SCHEMA.elevations.buttons)
	        return;

	    var data = BLP_SCHEMA.elevations.buttons[key];
	    if (data) {
	        Events.post(Events.CHANGE_ELEVATION_MODEL, data.data);
	        Events.post(Events.FORM_BUTTON_GROUP_STATE_CHANGED, {group: 'elevations', title: data.title});
	    }

	}

	function setActiveMapByKey(key) {
	     if (!BLP_SCHEMA || !BLP_SCHEMA.maps || !BLP_SCHEMA.maps.buttons)
	        return;

	    var data = BLP_SCHEMA.maps.buttons[key];
	    if (data){
	        Events.post(Events.CHANGE_MAP, data.data);
	        Events.post(Events.FORM_BUTTON_GROUP_STATE_CHANGED, {group: 'maps',title: data.title});
	    }
	}

	var queriesMaps = {
	    bing: {
	        title : 'Bing',
	        icon : 'images/layers/bingAerial.png',
	        default: true,
	        data : {
	           ground: 'images/ground/vesat.2048x1024.jpg',
	           patternUrl: "https://t{s}.ssl.ak.dynamic.tiles.virtualearth.net/comp/ch/{q}?mkt=ru-RU&it=A,G,RL&shading=hill&n=z&og=154&c4w=1"
	        }
	    },
	    osm: {
	        title : 'Open Street Map',
	        icon : 'images/layers/openStreetMap.png',
	        data : {
	           patternUrl: "http://tile.openstreetmap.org/{z}/{x}/{y}.png"
	        }
	    },
	    twoGis: {
	        title : '2 GIS',
	        icon : 'images/layers/twoGisMap.png',
	        data : {
	           patternUrl: 'http://tile3.maps.2gis.com/tiles?x={x}&y={y}&z={z}&v=36'
	        }
	    },
	    panorama: {
	        title : 'Panorama',
	        icon : 'images/layers/worldMap.png',
	        data : {
	          type: 'wmts', layers: [11], detail: 1.2,
	          patternUrl: 'http://gisserver.info/GISWebServiceSE/service.php'
	        }
	    },
	    wmts: {
	        title : 'Example WMTS',
	       // icon : "bmap-64x64.png",
	        data : {
	           type: 'wmts', layers: [0, 1],
	           patternUrl: 'https://tiles.geoservice.dlr.de/service/wmts'
	        }
	    },
	    hybrid: {
	        title : 'Hybrid',
	        icon : 'images/layers/googleHyb.png',
	        data : {
	           ground: 'images/ground/sat.2048x1024.jpg',
	           patternUrl: 'http://213.170.107.10:8080/tile/?dataset=sat,Both&z={z}&x={x}&y={y}&suffix=.jpg'
	        }
	    }
	};

	var queriesElevs = {
	    none: {
	        title: 'Без рельефа',
	        default: true,
	        //icon : 'bmap-64x64.png',
	        data: {
	            type: 'none'
	        }
	    },
	    rest: {
	        title: 'Базовый',
	        icon: 'images/layers/elevationLocal.png',
	        data: {
	            type: 'rest',
	            url: '*'
	        }
	    },
	    wcs: {
	        title: 'SRTM WCS',
	        //icon : 'bmap-64x64.png',
	        data: {
	            type: 'wcs',
	            url: '*'
	        }
	    },
	    wms: {
	        title: 'SRTM WMS',
	        //icon : 'bmap-64x64.png',
	        data: {
	            type: 'wms',
	            url: '*'
	        }
	    }
	};

	var defaultMapPicker = {
	    maps : {
	        title : "Карты",
	        buttons : queriesMaps,
	    },
	    elevations: {
	        title : "Рельеф",
	        buttons : queriesElevs,
	    }
	}

	function loadJSON(url, callback) {
	    var xobj = new XMLHttpRequest();
	    xobj.overrideMimeType("application/json");
	    xobj.open('GET', url, true);
	    xobj.onreadystatechange = function () {
	        if (xobj.readyState == 4 && (xobj.status == "200" ||  xobj.status == "0")) {
	            callback(xobj.responseText);
	        }
	    };
	    xobj.send(null);
	}

	function getFirstProp(jsonObj){
	    for(var key in jsonObj) {
	        if(jsonObj.hasOwnProperty(key)) {
	            return jsonObj[key];
	        }
	    }
	    return null;
	}

	function destroyBaseLayerPicker() {
	    var btn = dom.select('#' + PICKER_BUTTON_ID);
	    btn.parentNode.removeChild(btn);
	};

	function fillBaseLayerPickerFromObject(mapPicker){
	    BLP_SCHEMA = mapPicker;

	    if (!mapPicker)
	        return;

	    MAPS_KEYS = [];
	    ELEVATIONS_KEYS = [];

	    var layerPickerFormContent = [];
	    var defaultMapKey;
	    var defaultElevKey;

	    var count = 0;

	    if (mapPicker.maps) {
	        addTitle(mapPicker.maps.title);
	        for (var key in mapPicker.maps.buttons) {
	            var obj = mapPicker.maps.buttons[key];
	            if (typeof(obj) === 'object' && obj.data){
	               MAPS_KEYS.push(key);
	               addMapButton((obj.icon) || 'images/layers/bmap-64x64.png', obj.title, obj.data);
	               if (obj.default == true) {
	                   defaultMapKey = key;
	               }
	            }
	            count++;
	        }
	    }


	    if (mapPicker.elevations) {
	        addTitle(mapPicker.elevations.title);
	        for (var key in mapPicker.elevations.buttons) {
	            var obj = mapPicker.elevations.buttons[key];
	            if (typeof(obj) === 'object' && obj.data){
	                ELEVATIONS_KEYS.push(key);
	                addElevationButton((obj.icon) || 'images/layers/bmap-64x64.png', obj.title, obj.data);
	                if (obj.default == true) {
	                    defaultElevKey = key;
	                }
	            }
	            count++;
	        }
	    }

	    Events.post(Events.CREATE_FORM, {
	        id: PICKER_FORM_ID,
	        width: 315,
	        height: 100 + Math.ceil(count/4) * 92,
	        right: 5,
	        top: 55,
	        contents: layerPickerFormContent
	    });

	    function addTitle(text) {
	        layerPickerFormContent.push({
	            type: 'html',
	            html: '<div style="' +
	            'cursor: default;' +
	            'height: 40px;' +
	            'line-height: 40px;' +
	            'font-size: 25px;' +
	            'text-align: center;' +
	            'color: khaki">' + text + '</div>'
	        });
	    }

	    function addMapButton(image, title, data) {
	        addButton('maps', image, title, Events.CHANGE_MAP, data);
	    }

	    function addElevationButton(image, title, data) {
	        addButton('elevations', image, title, Events.CHANGE_ELEVATION_MODEL, data);
	    }

	    function addButton(group, image, title, post, data) {
	        layerPickerFormContent.push({
	            type: 'button',
	            group: group, title: title,
	            image: image,
	            post: post, data: data,
	            action: hideLayerPicker
	        });
	    }


	    // если не назначен по умолчанию то устанавливаем активным первый попавшийся
	    if (!defaultMapKey && MAPS_KEYS.length > 0) {
	        defaultMapKey =  MAPS_KEYS[0];
	    }

	    if (!defaultElevKey && ELEVATIONS_KEYS.length > 0) {
	        defaultElevKey = ELEVATIONS_KEYS[0];
	    }

	    // После создания формы применяем стиль для подсветки активной карты или высоты
	    if (defaultMapKey){
	        setActiveMapByKey(defaultMapKey);
	    }
	    if (defaultElevKey) {
	        setActiveElevationByKey(defaultElevKey);
	    }
	}

	function createBaseLayerPicker(mapPickerData) {

	    Events.post(Events.CREATE_BUTTON, {
	        align: 'right',
	        icon: 'images/layers/map-ico.png',
	        event: Events.TOGGLE_FORM,
	        data: PICKER_FORM_ID,
	        id: PICKER_BUTTON_ID
	    });


	    if (typeof(mapPickerData) === 'object') {
	        fillBaseLayerPickerFromObject(mapPickerData);
	    } else  if (typeof(mapPickerData) === 'string') {
	        loadJSON(mapPickerData, function(response) {
	             var actual = JSON.parse(response)
	             if (actual.maps || actual.elevations)
	               fillBaseLayerPickerFromObject(actual);
	        });
	    } else {
	        fillBaseLayerPickerFromObject(defaultMapPicker);
	    }
	};

	function hideLayerPicker(){
	    Events.post(Events.HIDE_FORM, PICKER_FORM_ID);
	};

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

	var Location = __webpack_require__(28);
	var Events = __webpack_require__(5);
	var Dom = __webpack_require__(4);

	Events.listen(Events.NAVIGATOR_STATE_CHANGED, redraw);
	Events.listen(Events.LOCATION_CHANGED, redraw);

	var widget = Dom.div('scale-widget').appendTo(document.body);
	var text = Dom.div('text').appendTo(widget);
	var svg = Dom.svg({viewBox:'0 0 200 30', width: 200, height: 20, fill: 'none'}).appendTo(widget);
	var path = Dom.path({stroke: 'wheat', "stroke-width": 2.5}).appendTo(svg);
	var size = 200;
	var length = 0;

	function pick(x, y) {
	    var pickPoint = window.engine.canvasCoordinates(x, y);
	    var picked = window.engine.pick(pickPoint).objects;
	    for (var i = 0; i < picked.length; i++) {
	        if (picked[i].isTerrain) return picked[i].position;
	    }
	}

	function measure10pxDistance() {
	    var probe = 30;
	    var yOffset = 2;
	    var c = window.engine.canvas;
	    var left = c.clientWidth / 2 - probe / 2;
	    var right = left + probe;
	    var y = c.clientHeight / 2 - yOffset;
	    var p1 = pick(left, y);
	    var p2 = pick(right, y);
	    var d = Location.greatCircleDistance(p1, p2);
	    console.log(111200*360*d/Math.PI);
	    return d;
	}

	function redraw(){
	    var dc = window.engine.drawContext;
	    if (dc.pickingMode) return;
	    if (!dc.navigatorState) return;
	    // measure10pxDistance();
	    var lookAt = engine.navigator.lookAtLocation;
	    var elevation = engine.globe.elevationAtLocation(lookAt.latitude, lookAt.longitude);
	    var pt = [0,0,0];
	    engine.globe.computePointFromPosition(lookAt.latitude, lookAt.longitude, elevation, pt);
	    var distance = dc.navigatorState.eyePoint.distanceTo(pt);
	    var pixelSize = dc.navigatorState.pixelSizeAtDistance(distance);
	    var base = 1000;
	    var len = calcLen();
	    while (len > size) {
	        base /= has5() ? 5 : 2;
	        calcLen();
	    }
	    while (len < size / 5) {
	        base *= has5() ? 2 : 5;
	        calcLen();
	    }
	    len = Math.floor(len);
	    if (length !== len) {
	        length = len;
	        var s = (size-length)/2;
	        var e = s + length;
	        path.setAttribute('d', 'M' + s + ',20 L' + s + ',30 L' + e + ',30 L' + e + ',20 M100,30 L100,20');
	        text.html(base > 500 ? (base/1000) + ' км' : base + ' м');
	    }

	    function calcLen(){
	        return len = base / pixelSize;
	    }

	    function has5() {
	        return base.toString().indexOf('5') > -1;
	    }
	}

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports Location
	 * @version $Id: Location.js 3116 2015-05-27 01:30:07Z tgaskins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(29),
	        __webpack_require__(30),
	        __webpack_require__(32),
	        __webpack_require__(33),
	        __webpack_require__(35),
	        __webpack_require__(36)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Angle,
	              ArgumentError,
	              Logger,
	              Plane,
	              Vec3,
	              WWMath) {
	        "use strict";

	        /**
	         * Constructs a location from a specified latitude and longitude in degrees.
	         * @alias Location
	         * @constructor
	         * @classdesc Represents a latitude, longitude pair in degrees.
	         * @param {Number} latitude The latitude in degrees.
	         * @param {Number} longitude The longitude in degrees.
	         */
	        var Location = function (latitude, longitude) {
	            /**
	             * The latitude in degrees.
	             * @type {Number}
	             */
	            this.latitude = latitude;
	            /**
	             * The longitude in degrees.
	             * @type {Number}
	             */
	            this.longitude = longitude;
	        };

	        /**
	         * A Location with latitude and longitude both 0.
	         * @constant
	         * @type {Location}
	         */
	        Location.ZERO = new Location(0, 0);

	        /**
	         * Creates a location from angles specified in radians.
	         * @param {Number} latitudeRadians The latitude in radians.
	         * @param {Number} longitudeRadians The longitude in radians
	         * @returns {Location} The new location with latitude and longitude in degrees.
	         */
	        Location.fromRadians = function (latitudeRadians, longitudeRadians) {
	            return new Location(latitudeRadians * Angle.RADIANS_TO_DEGREES, longitudeRadians * Angle.RADIANS_TO_DEGREES);
	        };

	        /**
	         * Copies this location to the latitude and longitude of a specified location.
	         * @param {Location} location The location to copy.
	         * @returns {Location} This location, set to the values of the specified location.
	         * @throws {ArgumentError} If the specified location is null or undefined.
	         */
	        Location.prototype.copy = function (location) {
	            if (!location) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Location", "copy", "missingLocation"));
	            }

	            this.latitude = location.latitude;
	            this.longitude = location.longitude;

	            return this;
	        };

	        /**
	         * Sets this location to the latitude and longitude.
	         * @param {number} latitude The latitude to set.
	         * @param {number} longitude The longitude to set.
	         * @returns {Location} This location, set to the values of the specified location.
	         * @throws {ArgumentError} If the specified location is null or undefined.
	         */
	        Location.prototype.set = function (latitude, longitude) {
	            this.latitude = latitude;
	            this.longitude = longitude;

	            return this;
	        };

	        /**
	         * Indicates whether this location is equal to a specified location.
	         * @param {Location} location The location to compare this one to.
	         * @returns {boolean} <code>true</code> if this location is equal to the specified location, otherwise
	         * <code>false</code>.
	         */
	        Location.prototype.equals = function (location) {
	            return location
	                && location.latitude === this.latitude && location.longitude === this.longitude;
	        };

	        /**
	         * Compute a location along a path at a specified distance between two specified locations.
	         * @param {String} pathType The type of path to assume. Recognized values are
	         * [WorldWind.GREAT_CIRCLE]{@link WorldWind#GREAT_CIRCLE},
	         * [WorldWind.RHUMB_LINE]{@link WorldWind#RHUMB_LINE} and
	         * [WorldWind.LINEAR]{@link WorldWind#LINEAR}.
	         * If the path type is not recognized then WorldWind.LINEAR is used.
	         * @param {Number} amount The fraction of the path between the two locations at which to compute the new
	         * location. This number should be between 0 and 1. If not, it is clamped to the nearest of those values.
	         * @param {Location} location1 The starting location.
	         * @param {Location} location2 The ending location.
	         * @param {Location} result A Location in which to return the result.
	         * @returns {Location} The specified result location.
	         * @throws {ArgumentError} If either specified location or the result argument is null or undefined.
	         */
	        Location.interpolateAlongPath = function (pathType, amount, location1, location2, result) {
	            if (!location1 || !location2) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Location", "interpolateAlongPath", "missingLocation"));
	            }

	            if (!result) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Location", "interpolateAlongPath", "missingResult"));
	            }

	            if (pathType === WorldWind.GREAT_CIRCLE) {
	                return this.interpolateGreatCircle(amount, location1, location2, result);
	            } else if (pathType && pathType === WorldWind.RHUMB_LINE) {
	                return this.interpolateRhumb(amount, location1, location2, result);
	            } else {
	                return this.interpolateLinear(amount, location1, location2, result);
	            }
	        };

	        /**
	         * Compute a location along a great circle path at a specified distance between two specified locations.
	         * @param {Number} amount The fraction of the path between the two locations at which to compute the new
	         * location. This number should be between 0 and 1. If not, it is clamped to the nearest of those values.
	         * This function uses a spherical model, not elliptical.
	         * @param {Location} location1 The starting location.
	         * @param {Location} location2 The ending location.
	         * @param {Location} result A Location in which to return the result.
	         * @returns {Location} The specified result location.
	         * @throws {ArgumentError} If either specified location or the result argument is null or undefined.
	         */
	        Location.interpolateGreatCircle = function (amount, location1, location2, result) {
	            if (!location1 || !location2) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Location", "interpolateGreatCircle", "missingLocation"));
	            }
	            if (!result) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Location", "interpolateGreatCircle", "missingResult"));
	            }

	            if (location1.equals(location2)) {
	                result.latitude = location1.latitude;
	                result.longitude = location1.longitude;
	                return result;
	            }

	            var t = WWMath.clamp(amount, 0, 1),
	                azimuthDegrees = this.greatCircleAzimuth(location1, location2),
	                distanceRadians = this.greatCircleDistance(location1, location2);

	            return this.greatCircleLocation(location1, azimuthDegrees, t * distanceRadians, result);
	        };

	        /**
	         * Computes the azimuth angle (clockwise from North) that points from the first location to the second location.
	         * This angle can be used as the starting azimuth for a great circle arc that begins at the first location, and
	         * passes through the second location.
	         * This function uses a spherical model, not elliptical.
	         * @param {Location} location1 The starting location.
	         * @param {Location} location2 The ending location.
	         * @returns {Number} The computed azimuth, in degrees.
	         * @throws {ArgumentError} If either specified location is null or undefined.
	         */
	        Location.greatCircleAzimuth = function (location1, location2) {
	            if (!location1 || !location2) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Location", "greatCircleAzimuth", "missingLocation"));
	            }

	            var lat1 = location1.latitude * Angle.DEGREES_TO_RADIANS,
	                lat2 = location2.latitude * Angle.DEGREES_TO_RADIANS,
	                lon1 = location1.longitude * Angle.DEGREES_TO_RADIANS,
	                lon2 = location2.longitude * Angle.DEGREES_TO_RADIANS,
	                x,
	                y,
	                azimuthRadians;

	            if (lat1 == lat2 && lon1 == lon2) {
	                return 0;
	            }

	            if (lon1 == lon2) {
	                return lat1 > lat2 ? 180 : 0;
	            }

	            // Taken from "Map Projections - A Working Manual", page 30, equation 5-4b.
	            // The atan2() function is used in place of the traditional atan(y/x) to simplify the case when x == 0.
	            y = Math.cos(lat2) * Math.sin(lon2 - lon1);
	            x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);
	            azimuthRadians = Math.atan2(y, x);

	            return isNaN(azimuthRadians) ? 0 : azimuthRadians * Angle.RADIANS_TO_DEGREES;
	        };

	        /**
	         * Computes the great circle angular distance between two locations. The return value gives the distance as the
	         * angle between the two positions. In radians, this angle is the arc length of the segment between the two
	         * positions. To compute a distance in meters from this value, multiply the return value by the radius of the
	         * globe.
	         * This function uses a spherical model, not elliptical.
	         *
	         * @param {Location} location1 The starting location.
	         * @param {Location} location2 The ending location.
	         * @returns {Number} The computed distance, in radians.
	         * @throws {ArgumentError} If either specified location is null or undefined.
	         */
	        Location.greatCircleDistance = function (location1, location2) {
	            if (!location1 || !location2) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Location", "greatCircleDistance", "missingLocation"));
	            }

	            var lat1Radians = location1.latitude * Angle.DEGREES_TO_RADIANS,
	                lat2Radians = location2.latitude * Angle.DEGREES_TO_RADIANS,
	                lon1Radians = location1.longitude * Angle.DEGREES_TO_RADIANS,
	                lon2Radians = location2.longitude * Angle.DEGREES_TO_RADIANS,
	                a,
	                b,
	                c,
	                distanceRadians;

	            if (lat1Radians == lat2Radians && lon1Radians == lon2Radians) {
	                return 0;
	            }

	            // "Haversine formula," taken from https://en.wikipedia.org/wiki/Great-circle_distance#Formul.C3.A6
	            a = Math.sin((lat2Radians - lat1Radians) / 2.0);
	            b = Math.sin((lon2Radians - lon1Radians) / 2.0);
	            c = a * a + Math.cos(lat1Radians) * Math.cos(lat2Radians) * b * b;
	            distanceRadians = 2.0 * Math.asin(Math.sqrt(c));

	            return isNaN(distanceRadians) ? 0 : distanceRadians;
	        };

	        /**
	         * Computes the location on a great circle path corresponding to a given starting location, azimuth, and
	         * arc distance.
	         * This function uses a spherical model, not elliptical.
	         *
	         * @param {Location} location The starting location.
	         * @param {Number} greatCircleAzimuthDegrees The azimuth in degrees.
	         * @param {Number} pathLengthRadians The radian distance along the path at which to compute the end location.
	         * @param {Location} result A Location in which to return the result.
	         * @returns {Location} The specified result location.
	         * @throws {ArgumentError} If the specified location or the result argument is null or undefined.
	         */
	        Location.greatCircleLocation = function (location, greatCircleAzimuthDegrees, pathLengthRadians, result) {
	            if (!location) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Location", "greatCircleLocation", "missingLocation"));
	            }
	            if (!result) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Location", "greatCircleLocation", "missingResult"));
	            }

	            if (pathLengthRadians == 0) {
	                result.latitude = location.latitude;
	                result.longitude = location.longitude;
	                return result;
	            }

	            var latRadians = location.latitude * Angle.DEGREES_TO_RADIANS,
	                lonRadians = location.longitude * Angle.DEGREES_TO_RADIANS,
	                azimuthRadians = greatCircleAzimuthDegrees * Angle.DEGREES_TO_RADIANS,
	                endLatRadians,
	                endLonRadians;

	            // Taken from "Map Projections - A Working Manual", page 31, equation 5-5 and 5-6.
	            endLatRadians = Math.asin(Math.sin(latRadians) * Math.cos(pathLengthRadians) +
	                Math.cos(latRadians) * Math.sin(pathLengthRadians) * Math.cos(azimuthRadians));
	            endLonRadians = lonRadians + Math.atan2(
	                Math.sin(pathLengthRadians) * Math.sin(azimuthRadians),
	                Math.cos(latRadians) * Math.cos(pathLengthRadians) -
	                Math.sin(latRadians) * Math.sin(pathLengthRadians) * Math.cos(azimuthRadians));

	            if (isNaN(endLatRadians) || isNaN(endLonRadians)) {
	                result.latitude = location.latitude;
	                result.longitude = location.longitude;
	            } else {
	                result.latitude = Angle.normalizedDegreesLatitude(endLatRadians * Angle.RADIANS_TO_DEGREES);
	                result.longitude = Angle.normalizedDegreesLongitude(endLonRadians * Angle.RADIANS_TO_DEGREES);
	            }

	            return result;
	        };

	        /**
	         * Compute a location along a rhumb path at a specified distance between two specified locations.
	         * This function uses a spherical model, not elliptical.
	         * @param {Number} amount The fraction of the path between the two locations at which to compute the new
	         * location. This number should be between 0 and 1. If not, it is clamped to the nearest of those values.
	         * @param {Location} location1 The starting location.
	         * @param {Location} location2 The ending location.
	         * @param {Location} result A Location in which to return the result.
	         * @returns {Location} The specified result location.
	         * @throws {ArgumentError} If either specified location or the result argument is null or undefined.
	         */
	        Location.interpolateRhumb = function (amount, location1, location2, result) {
	            if (!location1 || !location2) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Location", "interpolateRhumb", "missingLocation"));
	            }
	            if (!result) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Location", "interpolateRhumb", "missingResult"));
	            }

	            if (location1.equals(location2)) {
	                result.latitude = location1.latitude;
	                result.longitude = location1.longitude;
	                return result;
	            }

	            var t = WWMath.clamp(amount, 0, 1),
	                azimuthDegrees = this.rhumbAzimuth(location1, location2),
	                distanceRadians = this.rhumbDistance(location1, location2);

	            return this.rhumbLocation(location1, azimuthDegrees, t * distanceRadians, result);
	        };

	        /**
	         * Computes the azimuth angle (clockwise from North) that points from the first location to the second location.
	         * This angle can be used as the azimuth for a rhumb arc that begins at the first location, and
	         * passes through the second location.
	         * This function uses a spherical model, not elliptical.
	         * @param {Location} location1 The starting location.
	         * @param {Location} location2 The ending location.
	         * @returns {Number} The computed azimuth, in degrees.
	         * @throws {ArgumentError} If either specified location is null or undefined.
	         */
	        Location.rhumbAzimuth = function (location1, location2) {
	            if (!location1 || !location2) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Location", "rhumbAzimuth", "missingLocation"));
	            }

	            var lat1 = location1.latitude * Angle.DEGREES_TO_RADIANS,
	                lat2 = location2.latitude * Angle.DEGREES_TO_RADIANS,
	                lon1 = location1.longitude * Angle.DEGREES_TO_RADIANS,
	                lon2 = location2.longitude * Angle.DEGREES_TO_RADIANS,
	                dLon,
	                dPhi,
	                azimuthRadians;

	            if (lat1 == lat2 && lon1 == lon2) {
	                return 0;
	            }

	            dLon = lon2 - lon1;
	            dPhi = Math.log(Math.tan(lat2 / 2.0 + Math.PI / 4) / Math.tan(lat1 / 2.0 + Math.PI / 4));

	            // If lonChange over 180 take shorter rhumb across 180 meridian.
	            if (WWMath.fabs(dLon) > Math.PI) {
	                dLon = dLon > 0 ? -(2 * Math.PI - dLon) : (2 * Math.PI + dLon);
	            }

	            azimuthRadians = Math.atan2(dLon, dPhi);

	            return isNaN(azimuthRadians) ? 0 : azimuthRadians * Angle.RADIANS_TO_DEGREES;
	        };

	        /**
	         * Computes the rhumb angular distance between two locations. The return value gives the distance as the
	         * angle between the two positions in radians. This angle is the arc length of the segment between the two
	         * positions. To compute a distance in meters from this value, multiply the return value by the radius of the
	         * globe.
	         * This function uses a spherical model, not elliptical.
	         *
	         * @param {Location} location1 The starting location.
	         * @param {Location} location2 The ending location.
	         * @returns {Number} The computed distance, in radians.
	         * @throws {ArgumentError} If either specified location is null or undefined.
	         */
	        Location.rhumbDistance = function (location1, location2) {
	            if (!location1 || !location2) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Location", "rhumbDistance", "missingLocation"));
	            }

	            var lat1 = location1.latitude * Angle.DEGREES_TO_RADIANS,
	                lat2 = location2.latitude * Angle.DEGREES_TO_RADIANS,
	                lon1 = location1.longitude * Angle.DEGREES_TO_RADIANS,
	                lon2 = location2.longitude * Angle.DEGREES_TO_RADIANS,
	                dLat,
	                dLon,
	                dPhi,
	                q,
	                distanceRadians;

	            if (lat1 == lat2 && lon1 == lon2) {
	                return 0;
	            }

	            dLat = lat2 - lat1;
	            dLon = lon2 - lon1;
	            dPhi = Math.log(Math.tan(lat2 / 2.0 + Math.PI / 4) / Math.tan(lat1 / 2.0 + Math.PI / 4));
	            q = dLat / dPhi;

	            if (isNaN(dPhi) || isNaN(q)) {
	                q = Math.cos(lat1);
	            }

	            // If lonChange over 180 take shorter rhumb across 180 meridian.
	            if (WWMath.fabs(dLon) > Math.PI) {
	                dLon = dLon > 0 ? -(2 * Math.PI - dLon) : (2 * Math.PI + dLon);
	            }

	            distanceRadians = Math.sqrt(dLat * dLat + q * q * dLon * dLon);

	            return isNaN(distanceRadians) ? 0 : distanceRadians;
	        };

	        /**
	         * Computes the location on a rhumb arc with the given starting location, azimuth, and arc distance.
	         * This function uses a spherical model, not elliptical.
	         *
	         * @param {Location} location The starting location.
	         * @param {Number} azimuthDegrees The azimuth in degrees.
	         * @param {Number} pathLengthRadians The radian distance along the path at which to compute the location.
	         * @param {Location} result A Location in which to return the result.
	         * @returns {Location} The specified result location.
	         * @throws {ArgumentError} If the specified location or the result argument is null or undefined.
	         */
	        Location.rhumbLocation = function (location, azimuthDegrees, pathLengthRadians, result) {
	            if (!location) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Location", "rhumbLocation", "missingLocation"));
	            }
	            if (!result) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Location", "rhumbLocation", "missingResult"));
	            }

	            if (pathLengthRadians == 0) {
	                result.latitude = location.latitude;
	                result.longitude = location.longitude;
	                return result;
	            }

	            var latRadians = location.latitude * Angle.DEGREES_TO_RADIANS,
	                lonRadians = location.longitude * Angle.DEGREES_TO_RADIANS,
	                azimuthRadians = azimuthDegrees * Angle.DEGREES_TO_RADIANS,
	                endLatRadians = latRadians + pathLengthRadians * Math.cos(azimuthRadians),
	                dPhi = Math.log(Math.tan(endLatRadians / 2 + Math.PI / 4) / Math.tan(latRadians / 2 + Math.PI / 4)),
	                q = (endLatRadians - latRadians) / dPhi,
	                dLon,
	                endLonRadians;

	            if (isNaN(dPhi) || isNaN(q) || !isFinite(q)) {
	                q = Math.cos(latRadians);
	            }

	            dLon = pathLengthRadians * Math.sin(azimuthRadians) / q;

	            // Handle latitude passing over either pole.
	            if (WWMath.fabs(endLatRadians) > Math.PI / 2)
	            {
	                endLatRadians = endLatRadians > 0 ? Math.PI - endLatRadians : -Math.PI - endLatRadians;
	            }

	            endLonRadians = WWMath.fmod(lonRadians + dLon + Math.PI, 2 * Math.PI) - Math.PI;

	            if (isNaN(endLatRadians) || isNaN(endLonRadians)) {
	                result.latitude = location.latitude;
	                result.longitude = location.longitude;
	            } else {
	                result.latitude = Angle.normalizedDegreesLatitude(endLatRadians * Angle.RADIANS_TO_DEGREES);
	                result.longitude = Angle.normalizedDegreesLongitude(endLonRadians * Angle.RADIANS_TO_DEGREES);
	            }

	            return result;
	        };

	        /**
	         * Compute a location along a linear path at a specified distance between two specified locations.
	         * @param {Number} amount The fraction of the path between the two locations at which to compute the new
	         * location. This number should be between 0 and 1. If not, it is clamped to the nearest of those values.
	         * @param {Location} location1 The starting location.
	         * @param {Location} location2 The ending location.
	         * @param {Location} result A Location in which to return the result.
	         * @returns {Location} The specified result location.
	         * @throws {ArgumentError} If either specified location or the result argument is null or undefined.
	         */
	        Location.interpolateLinear = function (amount, location1, location2, result) {
	            if (!location1 || !location2) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Location", "interpolateLinear", "missingLocation"));
	            }
	            if (!result) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Location", "interpolateLinear", "missingResult"));
	            }

	            if (location1.equals(location2)) {
	                result.latitude = location1.latitude;
	                result.longitude = location1.longitude;
	                return result;
	            }

	            var t = WWMath.clamp(amount, 0, 1),
	                azimuthDegrees = this.linearAzimuth(location1, location2),
	                distanceRadians = this.linearDistance(location1, location2);

	            return this.linearLocation(location1, azimuthDegrees, t * distanceRadians, result);
	        };

	        /**
	         * Computes the azimuth angle (clockwise from North) that points from the first location to the second location.
	         * This angle can be used as the azimuth for a linear arc that begins at the first location, and
	         * passes through the second location.
	         * @param {Location} location1 The starting location.
	         * @param {Location} location2 The ending location.
	         * @returns {Number} The computed azimuth, in degrees.
	         * @throws {ArgumentError} If either specified location is null or undefined.
	         */
	        Location.linearAzimuth = function (location1, location2) {
	            if (!location1 || !location2) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Location", "linearAzimuth", "missingLocation"));
	            }

	            var lat1 = location1.latitude * Angle.DEGREES_TO_RADIANS,
	                lat2 = location2.latitude * Angle.DEGREES_TO_RADIANS,
	                lon1 = location1.longitude * Angle.DEGREES_TO_RADIANS,
	                lon2 = location2.longitude * Angle.DEGREES_TO_RADIANS,
	                dLon,
	                dPhi,
	                azimuthRadians;

	            if (lat1 == lat2 && lon1 == lon2) {
	                return 0;
	            }

	            dLon = lon2 - lon1;
	            dPhi = lat2 - lat1;

	            // If longitude change is over 180 take shorter path across 180 meridian.
	            if (WWMath.fabs(dLon) > Math.PI) {
	                dLon = dLon > 0 ? -(2 * Math.PI - dLon) : (2 * Math.PI + dLon);
	            }

	            azimuthRadians = Math.atan2(dLon, dPhi);

	            return isNaN(azimuthRadians) ? 0 : azimuthRadians * Angle.RADIANS_TO_DEGREES;
	        };

	        /**
	         * Computes the linear angular distance between two locations. The return value gives the distance as the
	         * angle between the two positions in radians. This angle is the arc length of the segment between the two
	         * positions. To compute a distance in meters from this value, multiply the return value by the radius of the
	         * globe.
	         *
	         * @param {Location} location1 The starting location.
	         * @param {Location} location2 The ending location.
	         * @returns {Number} The computed distance, in radians.
	         * @throws {ArgumentError} If either specified location is null or undefined.
	         */
	        Location.linearDistance = function (location1, location2) {
	            if (!location1 || !location2) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Location", "linearDistance", "missingLocation"));
	            }

	            var lat1 = location1.latitude * Angle.DEGREES_TO_RADIANS,
	                lat2 = location2.latitude * Angle.DEGREES_TO_RADIANS,
	                lon1 = location1.longitude * Angle.DEGREES_TO_RADIANS,
	                lon2 = location2.longitude * Angle.DEGREES_TO_RADIANS,
	                dLat,
	                dLon,
	                distanceRadians;

	            if (lat1 == lat2 && lon1 == lon2) {
	                return 0;
	            }

	            dLat = lat2 - lat1;
	            dLon = lon2 - lon1;

	            // If lonChange over 180 take shorter path across 180 meridian.
	            if (WWMath.fabs(dLon) > Math.PI) {
	                dLon = dLon > 0 ? -(2 * Math.PI - dLon) : (2 * Math.PI + dLon);
	            }

	            distanceRadians = Math.sqrt(dLat * dLat + dLon * dLon);

	            return isNaN(distanceRadians) ? 0 : distanceRadians;
	        };

	        /**
	         * Computes the location on a linear path with the given starting location, azimuth, and arc distance.
	         *
	         * @param {Location} location The starting location.
	         * @param {Number} azimuthDegrees The azimuth in degrees.
	         * @param {Number} pathLengthRadians The radian distance along the path at which to compute the location.
	         * @param {Location} result A Location in which to return the result.
	         * @returns {Location} The specified result location.
	         * @throws {ArgumentError} If the specified location or the result argument is null or undefined.
	         */
	        Location.linearLocation = function (location, azimuthDegrees, pathLengthRadians, result) {
	            if (!location) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Location", "linearLocation", "missingLocation"));
	            }
	            if (!result) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Location", "linearLocation", "missingResult"));
	            }

	            if (pathLengthRadians == 0) {
	                result.latitude = location.latitude;
	                result.longitude = location.longitude;
	                return result;
	            }

	            var latRadians = location.latitude * Angle.DEGREES_TO_RADIANS,
	                lonRadians = location.longitude * Angle.DEGREES_TO_RADIANS,
	                azimuthRadians = azimuthDegrees * Angle.DEGREES_TO_RADIANS,
	                endLatRadians = latRadians + pathLengthRadians * Math.cos(azimuthRadians),
	                endLonRadians;

	            // Handle latitude passing over either pole.
	            if (WWMath.fabs(endLatRadians) > Math.PI / 2)
	            {
	                endLatRadians = endLatRadians > 0 ? Math.PI - endLatRadians : -Math.PI - endLatRadians;
	            }

	            endLonRadians =
	                WWMath.fmod(lonRadians + pathLengthRadians * Math.sin(azimuthRadians) + Math.PI, 2 * Math.PI) - Math.PI;

	            if (isNaN(endLatRadians) || isNaN(endLonRadians)) {
	                result.latitude = location.latitude;
	                result.longitude = location.longitude;
	            } else {
	                result.latitude = Angle.normalizedDegreesLatitude(endLatRadians * Angle.RADIANS_TO_DEGREES);
	                result.longitude = Angle.normalizedDegreesLongitude(endLonRadians * Angle.RADIANS_TO_DEGREES);
	            }

	            return result;
	        };

	        /**
	         * Determine whether a list of locations crosses the dateline.
	         * @param {Location[]} locations The locations to test.
	         * @returns {boolean} True if the dateline is crossed, else false.
	         * @throws {ArgumentError} If the locations list is null.
	         */
	        Location.locationsCrossDateLine = function(locations) {
	            if (!locations) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Location", "locationsCrossDateline", "missingLocation"));
	            }

	            var pos = null;
	            for (var idx = 0, len = locations.length; idx < len; idx += 1) {
	                var posNext = locations[idx];

	                if (pos != null) {
	                    // A segment cross the line if end pos have different longitude signs
	                    // and are more than 180 degrees longitude apart
	                    if (WWMath.signum(pos.longitude) != WWMath.signum(posNext.longitude)) {
	                        var delta = Math.abs(pos.longitude - posNext.longitude);
	                        if (delta > 180 && delta < 360)
	                            return true;
	                    }
	                }
	                pos = posNext;
	            }

	            return false;
	        };

	        /**
	         * Returns two locations with the most extreme latitudes on the sequence of great circle arcs defined by each pair
	         * of locations in the specified iterable.
	         *
	         * @param {Location[]} locations The pairs of locations defining a sequence of great circle arcs.
	         *
	         * @return {Location[]} Two locations with the most extreme latitudes on the great circle arcs.
	         *
	         * @throws IllegalArgumentException if locations is null.
	         */
	        Location.greatCircleArcExtremeLocations = function(locations) {
	            if (!locations) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Location", "greatCircleArcExtremeLocations", "missingLocation"));
	            }

	            var minLatLocation = null;
	            var maxLatLocation = null;

	            var lastLocation = null;

	            for (var idx = 0, len = locations.length; idx < len; idx += 1) {
	                var location = locations[idx];

	                if (lastLocation != null) {
	                    var extremes = Location.greatCircleArcExtremeForTwoLocations(lastLocation, location);
	                    if (extremes == null) {
	                        continue;
	                    }

	                    if (minLatLocation == null || minLatLocation.latitude > extremes[0].latitude) {
	                        minLatLocation = extremes[0];
	                    }
	                    if (maxLatLocation == null || maxLatLocation.latitude < extremes[1].latitude) {
	                        maxLatLocation = extremes[1];
	                    }
	                }

	                lastLocation = location;
	            }

	            return [minLatLocation, maxLatLocation];
	        };

	        /**
	         * Returns two locations with the most extreme latitudes on the great circle arc defined by, and limited to, the two
	         * locations.
	         *
	         * @param {Location} begin Beginning location on the great circle arc.
	         * @param {Location} end   Ending location on the great circle arc.
	         *
	         * @return {Location[]} Two locations with the most extreme latitudes on the great circle arc.
	         *
	         * @throws {ArgumentError} If either begin or end are null.
	         */
	        Location.greatCircleArcExtremeForTwoLocations = function(begin, end) {
	            if (!begin || !end) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Location", "greatCircleArcExtremeForTwoLocations", "missingLocation"));
	            }

	            var idx, len, location; // Iteration variables.
	            var minLatLocation = null;
	            var maxLatLocation = null;
	            var minLat = 90;
	            var maxLat = -90;

	            // Compute the min and max latitude and associated locations from the arc endpoints.
	            var locations = [begin, end];
	            for (idx = 0, len = locations.length; idx < len; idx += 1) {
	                location = locations[idx];

	                if (minLat >= location.latitude) {
	                    minLat = location.latitude;
	                    minLatLocation = location;
	                }
	                if (maxLat <= location.latitude) {
	                    maxLat = location.latitude;
	                    maxLatLocation = location;
	                }
	            }
	            // The above could be written for greater clarity, simplicity, and speed:
	            // minLat = Math.min(begin.latitude, end.latitude);
	            // maxLat = Math.max(begin.latitude, end.latitude);
	            // minLatLocation = minLat == begin.latitude ? begin : end;
	            // maxLatLocation = maxLat == begin.latitude ? begin : end;

	            // Compute parameters for the great circle arc defined by begin and end. Then compute the locations of extreme
	            // latitude on entire the great circle which that arc is part of.
	            var greatArcAzimuth = Location.greatCircleAzimuth(begin, end);
	            var greatArcDistance = Location.greatCircleDistance(begin, end);
	            var greatCircleExtremes = Location.greatCircleExtremeLocationsUsingAzimuth(begin, greatArcAzimuth);

	            // Determine whether either of the extreme locations are inside the arc defined by begin and end. If so,
	            // adjust the min and max latitude accordingly.
	            for (idx = 0, len = greatCircleExtremes.length; idx < len; idx += 1) {
	                location = greatCircleExtremes[idx];

	                var az = Location.greatCircleAzimuth(begin, location);
	                var d = Location.greatCircleDistance(begin, location);

	                // The extreme location must be between the begin and end locations. Therefore its azimuth relative to
	                // the begin location should have the same signum, and its distance relative to the begin location should
	                // be between 0 and greatArcDistance, inclusive.
	                if (WWMath.signum(az) == WWMath.signum(greatArcAzimuth)) {
	                    if (d >= 0 && d <= greatArcDistance) {
	                        if (minLat >= location.latitude) {
	                            minLat = location.latitude;
	                            minLatLocation = location;
	                        }
	                        if (maxLat <= location.latitude) {
	                            maxLat = location.latitude;
	                            maxLatLocation = location;
	                        }
	                    }
	                }
	            }

	            return [minLatLocation, maxLatLocation];
	        };

	        /**
	         * Returns two locations with the most extreme latitudes on the great circle with the given starting location and
	         * azimuth.
	         *
	         * @param {Location} location Location on the great circle.
	         * @param {number} azimuth  Great circle azimuth angle (clockwise from North).
	         *
	         * @return {Location[]} Two locations where the great circle has its extreme latitudes.
	         *
	         * @throws {ArgumentError} If location is null.
	         */
	        Location.greatCircleExtremeLocationsUsingAzimuth = function(location, azimuth) {
	            if (!location) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Location", "greatCircleArcExtremeLocationsUsingAzimuth", "missingLocation"));
	            }

	            var lat0 = location.latitude;
	            var az = azimuth * Angle.DEGREES_TO_RADIANS;

	            // Derived by solving the function for longitude on a great circle against the desired longitude. We start
	            // with the equation in "Map Projections - A Working Manual", page 31, equation 5-5:
	            //
	            //     lat = asin( sin(lat0) * cos(C) + cos(lat0) * sin(C) * cos(Az) )
	            //
	            // Where (lat0, lon) are the starting coordinates, c is the angular distance along the great circle from the
	            // starting coordinate, and Az is the azimuth. All values are in radians. Solving for angular distance gives
	            // distance to the equator:
	            //
	            //     tan(C) = -tan(lat0) / cos(Az)
	            //
	            // The great circle is by definition centered about the Globe's origin. Therefore intersections with the
	            // equator will be antipodal (exactly 180 degrees opposite each other), as will be the extreme latitudes.
	            // By observing the symmetry of a great circle, it is also apparent that the extreme latitudes will be 90
	            // degrees from either intersection with the equator.
	            //
	            // d1 = c + 90
	            // d2 = c - 90

	            var tanDistance = -Math.tan(lat0) / Math.cos(az);
	            var distance = Math.atan(tanDistance);

	            var extremeDistance1 = distance + (Math.PI / 2.0);
	            var extremeDistance2 = distance - (Math.PI / 2.0);

	            return [
	                Location.greatCircleLocation(location, azimuth, extremeDistance1, new Location(0, 0)),
	                Location.greatCircleLocation(location, azimuth, extremeDistance2, new Location(0,0))
	            ];
	        };

	        /**
	         * Determine where a line between two positions crosses a given meridian. The intersection test is performed by
	         * intersecting a line in Cartesian space between the two positions with a plane through the meridian. Thus, it is
	         * most suitable for working with positions that are fairly close together as the calculation does not take into
	         * account great circle or rhumb paths.
	         *
	         * @param {Location} p1         First position.
	         * @param {Location} p2         Second position.
	         * @param {number} meridian     Longitude line to intersect with.
	         * @param {Globe} globe         Globe used to compute intersection.
	         *
	         * @return {number} latitude The intersection latitude along the meridian
	         *
	         * TODO: this code allocates 4 new Vec3 and 1 new Position; use scratch variables???
	         * TODO: Why not? Every location created would then allocated those variables as well, even if they aren't needed :(.
	         */
	        Location.intersectionWithMeridian = function(p1, p2, meridian, globe) {
	            // TODO: add support for 2D
	            //if (globe instanceof Globe2D)
	            //{
	            //    // y = mx + b case after normalizing negative angles.
	            //    double lon1 = p1.getLongitude().degrees < 0 ? p1.getLongitude().degrees + 360 : p1.getLongitude().degrees;
	            //    double lon2 = p2.getLongitude().degrees < 0 ? p2.getLongitude().degrees + 360 : p2.getLongitude().degrees;
	            //    if (lon1 == lon2)
	            //        return null;
	            //
	            //    double med = meridian.degrees < 0 ? meridian.degrees + 360 : meridian.degrees;
	            //    double slope = (p2.latitude.degrees - p1.latitude.degrees) / (lon2 - lon1);
	            //    double lat = p1.latitude.degrees + slope * (med - lon1);
	            //
	            //    return LatLon.fromDegrees(lat, meridian.degrees);
	            //}

	            var pt1 = globe.computePointFromLocation(p1.latitude, p1.longitude, new Vec3(0, 0, 0));
	            var pt2 = globe.computePointFromLocation(p2.latitude, p2.longitude, new Vec3(0, 0, 0));

	            // Compute a plane through the origin, North Pole, and the desired meridian.
	            var northPole = globe.computePointFromLocation(90, meridian, new Vec3(0, 0, 0));
	            var pointOnEquator = globe.computePointFromLocation(0, meridian, new Vec3(0, 0, 0));

	            var plane = Plane.fromPoints(northPole, pointOnEquator, Vec3.ZERO);

	            var intersectionPoint = new Vec3(0, 0, 0);
	            if (!plane.intersectsSegmentAt(pt1, pt2, intersectionPoint)) {
	                return null;
	            }

	            // TODO: unable to simply create a new Position(0, 0, 0)
	            var pos = new WorldWind.Position(0, 0, 0);
	            globe.computePositionFromPoint(intersectionPoint[0], intersectionPoint[1], intersectionPoint[2], pos);

	            return pos.latitude;
	        };

	        /**
	         * A bit mask indicating which if any pole is being referenced.
	         * This corresponds to Java WW's AVKey.NORTH and AVKey.SOUTH,
	         * although this encoding can capture both poles simultaneously, which was
	         * a 'to do' item in the Java implementation.
	         * @type {{NONE: number, NORTH: number, SOUTH: number}}
	         */
	        Location.poles = {
	            'NONE': 0,
	            'NORTH': 1,
	            'SOUTH': 2
	        };

	        return Location;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @version $Id: Angle.js 2914 2015-03-19 19:10:19Z tgaskins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    "use strict";
	    /**
	     * Provides constants and functions for working with angles.
	     * @exports Angle
	     */

	    var Angle = {
	        /**
	         * Conversion factor for degrees to radians.
	         * @constant
	         */
	        DEGREES_TO_RADIANS: Math.PI / 180.0,
	        /**
	         * Conversion factor for radians to degrees.
	         * @constant
	         */
	        RADIANS_TO_DEGREES: 180.0 / Math.PI,
	        /**
	         * 2 pi.
	         * @constant
	         */
	        TWO_PI: 2 * Math.PI,
	        /**
	         * pi / 2
	         * @constant
	         */
	        HALF_PI: Math.PI / 2,

	        /**
	         * Normalizes a specified value to be within the range of [-180, 180] degrees.
	         * @param {Number} degrees The value to normalize, in degrees.
	         * @returns {Number} The specified value normalized to [-180, 180] degrees.
	         */
	        normalizedDegrees: function (degrees) {
	            var angle = degrees % 360;

	            return angle > 180 ? angle - 360 : angle < -180 ? 360 + angle : angle;
	        },

	        /**
	         * Normalizes a specified value to be within the range of [-90, 90] degrees.
	         * @param {Number} degrees The value to normalize, in degrees.
	         * @returns {Number} The specified value normalized to the normal range of latitude.
	         */
	        normalizedDegreesLatitude: function (degrees) {
	            var lat = degrees % 180;

	            return lat > 90 ? 180 - lat : lat < -90 ? -180 - lat : lat;
	        },

	        /**
	         * Normalizes a specified value to be within the range of [-180, 180] degrees.
	         * @param {Number} degrees The value to normalize, in degrees.
	         * @returns {Number} The specified value normalized to the normal range of longitude.
	         */
	        normalizedDegreesLongitude: function (degrees) {
	            var lon = degrees % 360;

	            return lon > 180 ? lon - 360 : lon < -180 ? 360 + lon : lon;
	        },

	        /**
	         * Normalizes a specified value to be within the range of [-Pi, Pi] radians.
	         * @param {Number} radians The value to normalize, in radians.
	         * @returns {Number} The specified value normalized to [-Pi, Pi] radians.
	         */
	        normalizedRadians: function (radians) {
	            var angle = radians % this.TWO_PI;

	            return angle > Math.PI ? angle - this.TWO_PI : angle < -Math.PI ? this.TWO_PI + angle : angle;
	        },

	        /**
	         * Normalizes a specified value to be within the range of [-Pi/2, Pi/2] radians.
	         * @param {Number} radians The value to normalize, in radians.
	         * @returns {Number} The specified value normalized to the normal range of latitude.
	         */
	        normalizedRadiansLatitude: function (radians) {
	            var lat = radians % Math.PI;

	            return lat > this.HALF_PI ? Math.PI - lat : lat < -this.HALF_PI ? -Math.PI - lat : lat;
	        },

	        /**
	         * Normalizes a specified value to be within the range of [-Pi, Pi] radians.
	         * @param {Number} radians The value to normalize, in radians.
	         * @returns {Number} The specified value normalized to the normal range of longitude.
	         */
	        normalizedRadiansLongitude: function (radians) {
	            var lon = radians % this.TWO_PI;

	            return lon > Math.PI ? lon - this.TWO_PI : lon < -Math.PI ? this.TWO_PI + lon : lon;
	        },

	        /**
	         * Indicates whether a specified value is within the normal range of latitude, [-90, 90].
	         * @param {Number} degrees The value to test, in degrees.
	         * @returns {Boolean} true if the value is within the normal range of latitude, otherwise false.
	         */
	        isValidLatitude: function (degrees) {
	            return degrees >= -90 && degrees <= 90;
	        },

	        /**
	         * Indicates whether a specified value is within the normal range of longitude, [-180, 180].
	         * @param {Number} degrees The value to test, in degrees.
	         * @returns {boolean} true if the value is within the normal range of longitude, otherwise false.
	         */
	        isValidLongitude: function (degrees) {
	            return degrees >= -180 && degrees <= 180;
	        },

	        /**
	         * Returns a string representation of a specified value in degrees.
	         * @param {Number} degrees The value for which to compute the string.
	         * @returns {String} The computed string, which is a decimal degrees value followed by the degree symbol.
	         */
	        toString: function (degrees) {
	            return degrees.toString() + '\u00B0';
	        },

	        /**
	         * Returns a decimal degrees string representation of a specified value in degrees.
	         * @param {Number} degrees The value for which to compute the string.
	         * @returns {String} The computed string, which is a decimal degrees value followed by the degree symbol.
	         */
	        toDecimalDegreesString: function (degrees) {
	            return degrees.toString() + '\u00B0';
	        },

	        /**
	         * Returns a degrees-minutes-seconds string representation of a specified value in degrees.
	         * @param {Number} degrees The value for which to compute the string.
	         * @returns {String} The computed string in degrees, minutes and decimal seconds.
	         */
	        toDMSString: function (degrees) {
	            var sign,
	                temp,
	                d,
	                m,
	                s;

	            sign = degrees < 0 ? -1 : 1;
	            temp = sign * degrees;
	            d = Math.floor(temp);
	            temp = (temp - d) * 60;
	            m = Math.floor(temp);
	            temp = (temp - m) * 60;
	            s = Math.round(temp);

	            if (s == 60) {
	                m++;
	                s = 0;
	            }
	            if (m == 60) {
	                d++;
	                m = 0;
	            }

	            return (sign == -1 ? "-" : "") + d + "\u00B0" + " " + m + "\u2019" + " " + s + "\u201D";
	        },

	        /**
	         * Returns a degrees-minutes string representation of a specified value in degrees.
	         * @param {Number} degrees The value for which to compute the string.
	         * @returns {String} The computed string in degrees and decimal minutes.
	         */
	        toDMString: function (degrees) {
	            var sign,
	                temp,
	                d,
	                m,
	                s,
	                mf;

	            sign = degrees < 0 ? -1 : 1;
	            temp = sign * degrees;
	            d = Math.floor(temp);
	            temp = (temp - d) * 60;
	            m = Math.floor(temp);
	            temp = (temp - m) * 60;
	            s = Math.round(temp);

	            if (s == 60) {
	                m++;
	                s = 0;
	            }
	            if (m == 60) {
	                d++;
	                m = 0;
	            }

	            mf = s == 0 ? m : m + s / 60;

	            return (sign == -1 ? "-" : "") + d + "\u00B0" + " " + mf + "\u2019";
	        }
	    };

	    return Angle;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports ArgumentError
	 * @version $Id: ArgumentError.js 2631 2015-01-02 21:32:32Z tgaskins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(31)], __WEBPACK_AMD_DEFINE_RESULT__ = function (AbstractError) {
	        "use strict";

	        /**
	         * Constructs an argument error with a specified message.
	         * @alias ArgumentError
	         * @constructor
	         * @classdesc Represents an error associated with invalid function arguments.
	         * @augments AbstractError
	         * @param {String} message The message.
	         */
	        var ArgumentError = function (message) {
	            AbstractError.call(this, "ArgumentError", message);

	            var stack;
	            try {
	                //noinspection ExceptionCaughtLocallyJS
	                throw new Error();
	            } catch (e) {
	                stack = e.stack;
	            }
	            this.stack = stack;
	        };

	        ArgumentError.prototype = Object.create(AbstractError.prototype);

	        return ArgumentError;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports AbstractError
	 * @version $Id: AbstractError.js 2913 2015-03-19 19:01:18Z tgaskins $
	 */
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    "use strict";

	    /**
	     * Constructs an error with a specified name and message.
	     * @alias AbstractError
	     * @constructor
	     * @abstract
	     * @classdesc Provides an abstract base class for error classes. This class is not meant to be instantiated
	     * directly but used only by subclasses.
	     * @param {String} name The error's name.
	     * @param {String} message The message.
	     */
	    var AbstractError = function (name, message) {
	        this.name = name;
	        this.message = message;
	    };

	    /**
	     * Returns the message and stack trace associated with this error.
	     * @returns {String} The message and stack trace associated with this error.
	     */
	    AbstractError.prototype.toString = function () {
	        var str = this.name + ': ' + this.message;

	        if (this.stack) {
	            str += '\n' + this.stack.toString();
	        }

	        return str;
	    };

	    return AbstractError;

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @version $Id: Logger.js 3418 2015-08-22 00:17:05Z tgaskins $
	 */
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    "use strict";
	    /**
	     * Logs selected message types to the console.
	     * @exports Logger
	     */

	    var Logger = {
	        /**
	         * Log no messages.
	         * @constant
	         */
	        LEVEL_NONE: 0,
	        /**
	         * Log messages marked as severe.
	         * @constant
	         */
	        LEVEL_SEVERE: 1,
	        /**
	         * Log messages marked as warnings and messages marked as severe.
	         * @constant
	         */
	        LEVEL_WARNING: 2,
	        /**
	         * Log messages marked as information, messages marked as warnings and messages marked as severe.
	         * @constant
	         */
	        LEVEL_INFO: 3,

	        /**
	         * Set the logging level used by subsequent invocations of the logger.
	         * @param {Number} level The logging level, one of Logger.LEVEL_NONE, Logger.LEVEL_SEVERE, Logger.LEVEL_WARNING,
	         * or Logger.LEVEL_INFO.
	         */
	        setLoggingLevel: function (level) {
	            loggingLevel = level;
	        },

	        /**
	         * Indicates the current logging level.
	         * @returns {Number} The current logging level.
	         */
	        getLoggingLevel: function () {
	            return loggingLevel;
	        },

	        /**
	         * Logs a specified message at a specified level.
	         * @param {Number} level The logging level of the message. If the current logging level allows this message to be
	         * logged it is written to the console.
	         * @param {String} message The message to log. Nothing is logged if the message is null or undefined.
	         */
	        log: function (level, message) {
	            if (message && level > 0 && level <= loggingLevel) {
	                if (level === Logger.LEVEL_SEVERE) {
	                    console.error(message);
	                } else if (level === Logger.LEVEL_WARNING) {
	                    console.warn(message);
	                } else if (level === Logger.LEVEL_INFO) {
	                    console.info(message);
	                } else {
	                    console.log(message);
	                }
	            }
	        },

	        // Intentionally not documented.
	        makeMessage: function (className, functionName, message) {
	            var msg = this.messageTable[message] ? this.messageTable[message] : message;

	            return className + "." + functionName + ": " + msg;
	        },

	        // Intentionally not documented.
	        logMessage: function (level, className, functionName, message) {
	            var msg = this.makeMessage(className, functionName, message);
	            this.log(level, msg);

	            return msg;
	        },

	        // Intentionally not documented.
	        messageTable: { // KEEP THIS TABLE IN ALPHABETICAL ORDER
	            abstractInvocation: "The function called is abstract and must be overridden in a subclass.",
	            indexOutOfRange: "The specified index is out of range.",
	            invalidHeight: "The specified height is zero or negative.",
	            invalidWidth: "The specified width is zero or negative.",
	            invalidSize: "The specified size is zero or negative.",
	            missingAltitudeMode: "The specified altitude mode is null or undefined.",
	            missingAttributeName: "The specified DBase attribute file name is null or undefined.",
	            missingArray: "The specified array is null, undefined or of insufficient length.",
	            missingBoundaries: "The specified boundaries array is null or undefined.",
	            missingBuffer: "The specified buffer descriptor is null or undefined.",
	            missingColor: "The specified color is null or undefined.",
	            missingDc: "The specified draw context is null or undefined.",
	            missingDomElement: "The specified DOM element is null or undefined.",
	            missingEntry: "The specified entry is null or undefined.",
	            missingFont: "The specified font is null or undefined.",
	            missingFrustum: "The specified frustum is null or undefined.",
	            missingFunction: "The specified function is null or undefined.",
	            missingGlContext: "The specified WebGL rendering context is null or undefined.",
	            missingGlobe: "The specified globe is null or undefined.",
	            missingImage: "The specified image is null or undefined.",
	            missingIndices: "The specified indices array is null or undefined.",
	            missingKey: "The specified key is null or undefined.",
	            missingLevel: "The specified level is null or undefined.",
	            missingLine: "The specified line is null or undefined.",
	            missingList: "The specified list is null or undefined.",
	            missingListener: "The specified listener is null or undefined",
	            missingLocation: "The specified location is null or undefined.",
	            missingMatrix: "The specified matrix is null or undefined.",
	            missingNavigatorState: "The specified navigator state is null or undefined.",
	            missingOffset: "The specified offset is null or undefined.",
	            missingPath: "The specified path is null or undefined.",
	            missingPlacename: "The specified place name is null or undefined.",
	            missingPlane: "The specified plane is null or undefined.",
	            missingPoint: "The specified point is null or undefined.",
	            missingPoints: "The specified points array is null or undefined.",
	            missingPosition: "The specified position is null or undefined.",
	            missingPositions: "The specified positions array is null or undefined.",
	            missingProgram: "The specified program is null or undefined.",
	            missingProjection: "The specified projection is null or undefined.",
	            missingRectangle: "The specified rectangle is null or undefined.",
	            missingRenderable: "The specified renderable is null or undefined.",
	            missingResource: "The specified resource is null or undefined.",
	            missingResult: "The specified result variable is null or undefined.",
	            missingResults: "The specified results array is null or undefined.",
	            missingSector: "The specified sector is null or undefined.",
	            missingShapeType: "The specified shape type is null or undefined.",
	            missingSize: "The specified size is null or undefined.",
	            missingText: "The specified text is null or undefined.",
	            missingTexture: "The specified texture is null or undefined.",
	            missingTile: "The specified tile is null or undefined.",
	            missingType: "The specified type is null or undefined.",
	            missingUrl: "The specified URL is null or undefined",
	            missingVector: "The specified vector is null or undefined.",
	            missingVertex: "The specified vertex is null or undefined.",
	            missingViewport: "The specified viewport is null or undefined.",
	            missingWorldWindow: "The specified World Window is null or undefined.",
	            notYetImplemented: "This function is not yet implemented"
	        }
	    };

	    var loggingLevel = 1; // log severe messages by default

	    return Logger;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports Plane
	 * @version $Id: Plane.js 2935 2015-03-27 17:59:48Z tgaskins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(30),
	        __webpack_require__(34),
	        __webpack_require__(32),
	        __webpack_require__(35)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
	              Line,
	              Logger,
	              Vec3) {
	        "use strict";

	        /**
	         * Constructs a plane.
	         * This constructor does not normalize the components. It assumes that a unit normal vector is provided.
	         * @alias Plane
	         * @constructor
	         * @classdesc Represents a plane in Cartesian coordinates.
	         * The plane's X, Y and Z components indicate the plane's normal vector. The distance component
	         * indicates the plane's distance from the origin relative to its unit normal.
	         * The components are expected to be normalized.
	         * @param {Number} x The X coordinate of the plane's unit normal vector.
	         * @param {Number} y The Y coordinate of the plane's unit normal vector.
	         * @param {Number} z The Z coordinate of the plane's unit normal vector.
	         * @param {Number} distance The plane's distance from the origin.
	         */
	        var Plane = function (x, y, z, distance) {
	            /**
	             * The normal vector to the plane.
	             * @type {Vec3}
	             */
	            this.normal = new Vec3(x, y, z);

	            /**
	             * The plane's distance from the origin.
	             * @type {Number}
	             */
	            this.distance = distance;
	        };

	        /**
	         * Computes a plane that passes through the specified three points.
	         * The plane's normal is the cross product of the
	         * two vectors from pb to pa and pc to pa, respectively. The
	         * returned plane is undefined if any of the specified points are colinear.
	         *
	         * @param {Vec3} pa The first point.
	         * @param {Vec3} pb The second point.
	         * @param {Vec3} pc The third point.
	         *
	         * @return {Plane} A plane passing through the specified points.
	         *
	         * @throws {ArgumentError} if pa, pb, or pc is null or undefined.
	         */
	        Plane.fromPoints = function(pa, pb, pc) {
	            if (!pa || !pb || !pc) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Plane", "fromPoints", "missingVector"));
	            }

	            var vab = new Vec3(pb[0], pb[1], pb[2]);
	            vab.subtract(pa);
	            var vac = new Vec3(pc[0], pc[1], pc[2]);
	            vac.subtract(pa);
	            vab.cross(vac);
	            vab.normalize();
	            var d = -vab.dot(pa);

	            return new Plane(vab[0], vab[1], vab[2], d);
	        };

	        /**
	         * Computes the dot product of this plane's normal vector with a specified vector.
	         * Since the plane was defined with a unit normal vector, this function returns the distance of the vector from
	         * the plane.
	         * @param {Vec3} vector The vector to dot with this plane's normal vector.
	         * @returns {Number} The computed dot product.
	         * @throws {ArgumentError} If the specified vector is null or undefined.
	         */
	        Plane.prototype.dot = function (vector) {
	            if (!vector) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Plane", "dot", "missingVector"));
	            }

	            return this.normal.dot(vector) + this.distance;
	        };

	        /**
	         * Computes the distance between this plane and a point.
	         * @param {Vec3} point The point whose distance to compute.
	         * @returns {Number} The computed distance.
	         * @throws {ArgumentError} If the specified point is null or undefined.
	         */
	        Plane.prototype.distanceToPoint = function (point) {
	            return this.dot(point);
	        };

	        /**
	         * Transforms this plane by a specified matrix.
	         * @param {Matrix} matrix The matrix to apply to this plane.
	         * @returns {Plane} This plane transformed by the specified matrix.
	         * @throws {ArgumentError} If the specified matrix is null or undefined.
	         */
	        Plane.prototype.transformByMatrix = function (matrix){
	            if (!matrix) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Plane", "transformByMatrix", "missingMatrix"));
	            }

	            var x = matrix[0] * this.normal[0] + matrix[1] * this.normal[1] + matrix[2] * this.normal[2] + matrix[3] * this.distance,
	                y = matrix[4] * this.normal[0] + matrix[5] * this.normal[1] + matrix[6] * this.normal[2] + matrix[7] * this.distance,
	                z = matrix[8] * this.normal[0] + matrix[9] * this.normal[1] + matrix[10] * this.normal[2] + matrix[11] * this.distance,
	                distance = matrix[12] * this.normal[0] + matrix[13] * this.normal[1] + matrix[14] * this.normal[2] + matrix[15] * this.distance;

	            this.normal[0] = x;
	            this.normal[1] = y;
	            this.normal[2] = z;
	            this.distance = distance;
	            
	            return this;
	        };

	        /**
	         * Normalizes the components of this plane.
	         * @returns {Plane} This plane with its components normalized.
	         */
	        Plane.prototype.normalize = function () {
	            var magnitude = this.normal.magnitude();

	            if (magnitude === 0)
	                return this;

	            this.normal.divide(magnitude);
	            this.distance /= magnitude;

	            return this;
	        };

	        /**
	         * Determines whether a specified line segment intersects this plane.
	         *
	         * @param {Vec3} endPoint1 The first end point of the line segment.
	         * @param {Vec3} endPoint2 The second end point of the line segment.
	         * @returns {Boolean} true if the line segment intersects this plane, otherwise false.
	         */
	        Plane.prototype.intersectsSegment = function(endPoint1, endPoint2) {
	            var distance1 = this.dot(endPoint1),
	                distance2 = this.dot(endPoint2);

	            return distance1 * distance2 <= 0;
	        };

	        /**
	         * Computes the intersection point of this plane with a specified line segment.
	         *
	         * @param {Vec3} endPoint1 The first end point of the line segment.
	         * @param {Vec3} endPoint2 The second end point of the line segment.
	         * @param {Vec3} result A variable in which to return the intersection point of the line segment with this plane.
	         * @returns {Boolean} true If the line segment intersects this plane, otherwise false.
	         */
	        Plane.prototype.intersectsSegmentAt = function (endPoint1, endPoint2, result) {
	            // Compute the distance from the end-points.
	            var distance1 = this.dot(endPoint1),
	                distance2 = this.dot(endPoint2);

	            // If both points points lie on the plane, ...
	            if (distance1 === 0 && distance2 === 0) {
	                // Choose an arbitrary endpoint as the intersection.
	                result[0] = endPoint1[0];
	                result[1] = endPoint1[1];
	                result[2] = endPoint1[2];

	                return true;
	            }
	            else if (distance1 === distance2) {
	                // The intersection is undefined.
	                return false;
	            }

	            var weight1 = -distance1 / (distance2 - distance1),
	                weight2 = 1 - weight1;

	            result[0] = weight1 * endPoint1[0] + weight2 * endPoint2[0];
	            result[1] = weight1 * endPoint1[1] + weight2 * endPoint2[1];
	            result[2] = weight1 * endPoint1[2] + weight2 * endPoint2[2];

	            return distance1 * distance2 <= 0;
	        };

	        /**
	         * Determines whether two points are on the same side of this plane.
	         *
	         * @param {Vec3} pointA the first point.
	         * @param {Vec3} pointB the second point.
	         *
	         * @return {Number} -1 If both points are on the negative side of this plane, +1 if both points are on the
	         * positive side of this plane, 0 if the points are on opposite sides of this plane.
	         *
	         * @throws {ArgumentError} If either point is null or undefined.
	         */
	        Plane.prototype.onSameSide = function (pointA, pointB) {
	            if (!pointA || !pointB) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Plane", "onSameSide", "missingPoint"));
	            }

	            var da = this.distanceToPoint(pointA),
	                db = this.distanceToPoint(pointB);

	            if (da < 0 && db < 0)
	                return -1;

	            if (da > 0 && db > 0)
	                return 1;

	            return 0;
	        };

	        /**
	         * Clips a line segment to this plane.
	         * @param {Vec3} pointA The first line segment endpoint.
	         * @param {Vec3} pointB The second line segment endpoint.
	         *
	         * @returns {Vec3[]}  An array of two points both on the positive side of the plane. If the direction of the line formed by the
	         *         two points is positive with respect to this plane's normal vector, the first point in the array will be
	         *         the intersection point on the plane, and the second point will be the original segment end point. If the
	         *         direction of the line is negative with respect to this plane's normal vector, the first point in the
	         *         array will be the original segment's begin point, and the second point will be the intersection point on
	         *         the plane. If the segment does not intersect the plane, null is returned. If the segment is coincident
	         *         with the plane, the input points are returned, in their input order.
	         *
	         * @throws {ArgumentError} If either point is null or undefined.
	         */
	        Plane.prototype.clip = function (pointA, pointB) {
	            if (!pointA || !pointB) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Plane", "clip", "missingPoint"));
	            }

	            if (pointA.equals(pointB)) {
	                return null;
	            }

	            // Get the projection of the segment onto the plane.
	            var line = Line.fromSegment(pointA, pointB),
	                lDotV = this.normal.dot(line.direction),
	                lDotS, t, p;

	            // Are the line and plane parallel?
	            if (lDotV === 0) { // line and plane are parallel and may be coincident.
	                lDotS = this.dot(line.origin);
	                if (lDotS === 0) {
	                    return [pointA, pointB]; // line is coincident with the plane
	                } else {
	                    return null; // line is not coincident with the plane.
	                }
	            }

	            // Not parallel so the line intersects. But does the segment intersect?
	            t = -this.dot(line.origin) / lDotV; // lDotS / lDotV
	            if (t < 0 || t > 1) { // segment does not intersect
	                return null;
	            }

	            p = line.pointAt(t, new Vec3(0, 0, 0));
	            if (lDotV > 0) {
	                return [p, pointB];
	            } else {
	                return [pointA, p];
	            }
	        };

	        return Plane;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports Line
	 * @version $Id: Line.js 2935 2015-03-27 17:59:48Z tgaskins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(30),
	        __webpack_require__(32),
	        __webpack_require__(35)], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
	              Logger,
	              Vec3) {
	        "use strict";

	        /**
	         * Constructs a line from a specified origin and direction.
	         * @alias Line
	         * @constructor
	         * @classdesc Represents a line in Cartesian coordinates.
	         * @param {Vec3} origin The line's origin.
	         * @param {Vec3} direction The line's direction.
	         * @throws {ArgumentError} If either the origin or the direction are null or undefined.
	         */
	        var Line = function (origin, direction) {
	            if (!origin) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "Line", "constructor",
	                    "Origin is null or undefined."));
	            }

	            if (!direction) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "Line", "constructor",
	                    "Direction is null or undefined."));
	            }

	            /**
	             * This line's origin.
	             * @type {Vec3}
	             */
	            this.origin = origin;

	            /**
	             * This line's direction.
	             * @type {Vec3}
	             */
	            this.direction = direction;
	        };

	        /**
	         * Creates a line given two specified endpoints.
	         * @param {Vec3} pointA The first endpoint.
	         * @param {Vec3} pointB The second endpoint.
	         * @return {Line} The new line.
	         * @throws {ArgumentError} If either endpoint is null or undefined.
	         */
	        Line.fromSegment = function (pointA, pointB) {
	            if (!pointA || !pointB) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Line", "fromSegment", "missingPoint"));
	            }

	            var origin = new Vec3(pointA[0], pointA[1], pointA[2]),
	                direction = new Vec3(pointB[0] - pointA[0], pointB[1] - pointA[1], pointB[2] - pointA[2]);

	            return new Line(origin, direction);
	        };

	        /**
	         * Computes a Cartesian point a specified distance along this line.
	         * @param {Number} distance The distance from this line's origin at which to compute the point.
	         * @param {Vec3} result A pre-allocated {@Link Vec3} instance in which to return the computed point.
	         * @return {Vec3} The specified result argument containing the computed point.
	         * @throws {ArgumentError} If the specified result argument is null or undefined.
	         */
	        Line.prototype.pointAt = function (distance, result) {
	            if (!result) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "Line", "pointAt", "missingResult."));
	            }

	            result[0] = this.origin[0] + this.direction[0] * distance;
	            result[1] = this.origin[1] + this.direction[1] * distance;
	            result[2] = this.origin[2] + this.direction[2] * distance;

	            return result;
	        };

	        return Line;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @version $Id: Vec3.js 3001 2015-04-09 20:13:50Z tgaskins $
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(32),
	        __webpack_require__(30)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Logger,
	              ArgumentError) {
	        "use strict";

	        /**
	         * Constructs a three-component vector.
	         * @alias Vec3
	         * @classdesc Represents a three-component vector. Access the X component of the vector as v[0], the Y
	         * component as v[1] and the Z component as v[2].
	         * @augments Float64Array
	         * @param {Number} x X component of vector.
	         * @param {Number} y Y component of vector.
	         * @param {Number} z Z component of vector.
	         * @constructor
	         */
	        var Vec3 = function Vec3(x, y, z) {
	            this[0] = x;
	            this[1] = y;
	            this[2] = z;
	        };

	        // Vec3 extends Float64Array.
	        Vec3.prototype = new Float64Array(3);

	        /**
	         * A vector corresponding to the origin.
	         * @type {Vec3}
	         */
	        Vec3.ZERO = new Vec3(0, 0, 0);

	        /**
	         * Computes the average of a specified array of vectors.
	         * @param {Vec3[]} vectors The vectors whose average to compute.
	         * @param {Vec3} result A pre-allocated Vec3 in which to return the computed average.
	         * @returns {Vec3} The result argument set to the average of the specified array of vectors.
	         * @throws {ArgumentError} If the specified array of vectors is null, undefined or empty or the specified
	         * result argument is null or undefined.
	         */
	        Vec3.average = function (vectors, result) {
	            if (!vectors || vectors.length < 1) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Vec3", "average", "missingArray"));
	            }

	            if (!result) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Vec3", "average", "missingResult"));
	            }

	            var count = vectors.length,
	                vec;

	            result[0] = 0;
	            result[1] = 0;
	            result[2] = 0;

	            for (var i = 0, len = vectors.length; i < len; i++) {
	                vec = vectors[i];

	                result[0] += vec[0] / count;
	                result[1] += vec[1] / count;
	                result[2] += vec[2] / count;
	            }

	            return result;
	        };

	        /**
	         * Computes the average of a specified array of points packed into a single array.
	         * @param {Float32Array | Float64Array | Number[]} points The points whose average to compute.
	         * @param {Vec3} result A pre-allocated Vec3 in which to return the computed average.
	         * @returns {Vec3} The result argument set to the average of the specified array of points.
	         * @throws {ArgumentError} If the specified array of points is null, undefined or empty or the result argument
	         * is null or undefined.
	         */
	        Vec3.averageOfBuffer = function (points, result) {
	            if (!points || points.length < 1) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Vec3", "averageBuffer", "missingArray"));
	            }

	            if (!result) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Vec3", "averageBuffer", "missingResult"));
	            }

	            var count = points.length / 3;

	            result[0] = 0;
	            result[1] = 0;
	            result[2] = 0;

	            for (var i = 0; i < count; i++) {
	                result[0] += points[i * 3] / count;
	                result[1] += points[i * 3 + 1] / count;
	                result[2] += points[i * 3 + 2] / count;
	            }

	            return result;
	        };

	        /**
	         * Indicates whether three vectors are colinear.
	         * @param {Vec3} a The first vector.
	         * @param {Vec3} b The second vector.
	         * @param {Vec3} c The third vector.
	         * @returns {Boolean} true if the vectors are colinear, otherwise false.
	         * @throws {ArgumentError} If any of the specified vectors are null or undefined.
	         */
	        Vec3.areColinear = function (a, b, c) {
	            if (!a || !b || !c) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Vec3", "areColinear", "missingVector"));
	            }

	           var ab = new Vec3(a[0]-b[0],a[1]-b[1],a[2]-b[2]).normalize(),
	               bc = new Vec3(c[0]-b[0],c[1]-b[1],c[2]-b[2]).normalize();

	            // ab and bc are considered colinear if their dot product is near +/-1.
	            return Math.abs(ab.dot(bc)) > 0.999;
	        };

	        /**
	         * Computes the normal vector of a specified triangle.
	         *
	         * @param {Vec3} a The triangle's first vertex.
	         * @param {Vec3} b The triangle's second vertex.
	         * @param {Vec3} c The triangle's third vertex.
	         * @returns {Vec3} The triangle's unit-normal vector.
	         * @throws {ArgumentError} If any of the specified vectors are null or undefined.
	         */
	        Vec3.computeTriangleNormal = function (a, b, c) {
	            if (!a || !b || !c) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Vec3", "areColinear", "missingVector"));
	            }

	            var x = ((b[1] - a[1]) * (c[2] - a[2])) - ((b[2] - a[2]) * (c[1] - a[1])),
	                y = ((b[2] - a[2]) * (c[0] - a[0])) - ((b[0] - a[0]) * (c[2] - a[2])),
	                z = ((b[0] - a[0]) * (c[1] - a[1])) - ((b[1] - a[1]) * (c[0] - a[0])),
	                length = (x * x) + (y * y) + (z * z);

	            if (length === 0) {
	                return new Vec3(x, y, z);
	            }

	            length = Math.sqrt(length);

	            return new Vec3(x / length, y / length, z / length);
	        };

	        /**
	         * Finds three non-colinear points in an array of coordinates.
	         *
	         * @param {Number[]} coords The coordinates, in the order x0, y0, z0, x1, y1, z1, ...
	         * @param {Number} stride The number of numbers between successive points. 0 indicates that the points
	         * are arranged one immediately after the other, as would the value 3.
	         * @returns {Vec3[]} Three non-colinear points from the input array of coordinates, or null if three
	         * non-colinear points could not be found or the specified coordinates array is null, undefined or
	         * contains fewer than three points.
	         */
	        Vec3.findThreeIndependentVertices = function (coords, stride) {
	            var xstride = (stride && stride > 0) ? stride : 3;

	            if (!coords || coords.length < 3 * xstride) {
	                return null;
	            }

	            var a = new Vec3(coords[0], coords[1], coords[2]),
	                b = null,
	                c = null,
	                k = xstride;

	            for (; k < coords.length; k += xstride) {
	                b = new Vec3(coords[k], coords[k + 1], coords[k + 2]);
	                if (!(b[0] === a[0] && b[1] === a[1] && b[2] === a[2])) {
	                    break;
	                }
	                b = null;
	            }

	            if (!b) {
	                return null;
	            }

	            for (k += xstride; k < coords.length; k += xstride) {
	                c = new Vec3(coords[k], coords[k + 1], coords[k + 2]);

	                // if c is not coincident with a or b, and the vectors ab and bc are not colinear, break and
	                // return a, b, c.
	                if (!((c[0] === a[0] && c[1] === a[1] && c[2] === a[2])
	                    || (c[0] === b[0] && c[1] === b[1] && c[2] === b[2]))) {
	                    if (!Vec3.areColinear(a, b, c))
	                        break;
	                }

	                c = null;
	            }

	            return c ? [a, b, c] : null;
	        };

	        /**
	         * Computes a unit-normal vector for a buffer of coordinate triples. The normal vector is computed from the
	         * first three non-colinear points in the buffer.
	         *
	         * @param {Number[]} coords The coordinates, in the order x0, y0, z0, x1, y1, z1, ...
	         * @param {Number} stride The number of numbers between successive points. 0 indicates that the points
	         * are arranged one immediately after the other, as would the value 3.
	         * @returns {Vec3} The computed unit-length normal vector.
	         */
	        Vec3.computeBufferNormal = function (coords, stride) {
	            var vertices = Vec3.findThreeIndependentVertices(coords, stride);

	            return vertices ? Vec3.computeTriangleNormal(vertices[0], vertices[1], vertices[2]) : null;
	        };

	        /**
	         * Assigns the components of this vector.
	         * @param {Number} x The X component of the vector.
	         * @param {Number} y The Y component of the vector.
	         * @param {Number} z The Z component of the vector.
	         * @returns {Vec3} This vector with the specified components assigned.
	         */
	        Vec3.prototype.set = function (x, y, z) {
	            this[0] = x;
	            this[1] = y;
	            this[2] = z;

	            return this;
	        };

	        /**
	         * Copies the components of a specified vector to this vector.
	         * @param {Vec3} vector The vector to copy.
	         * @returns {Vec3} This vector set to the X, Y and Z values of the specified vector.
	         * @throws {ArgumentError} If the specified vector is null or undefined.
	         */
	        Vec3.prototype.copy = function (vector) {
	            if (!vector) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Vec3", "copy", "missingVector"));
	            }

	            this[0] = vector[0];
	            this[1] = vector[1];
	            this[2] = vector[2];

	            return this;
	        };

	        /**
	         * Indicates whether the components of this vector are identical to those of a specified vector.
	         * @param {Vec3} vector The vector to test.
	         * @returns {Boolean} true if the components of this vector are equal to those of the specified one,
	         * otherwise false.
	         */
	        Vec3.prototype.equals = function (vector) {
	            return this[0] === vector[0] && this[1] === vector[1] && this[2] === vector[2];
	        };

	        /**
	         * Adds a specified vector to this vector.
	         * @param {Vec3} addend The vector to add.
	         * @returns {Vec3} This vector after adding the specified vector to it.
	         * @throws {ArgumentError} If the addend is null or undefined.
	         */
	        Vec3.prototype.add = function (addend) {
	            if (!addend) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Vec3", "add", "missingVector"));
	            }

	            this[0] += addend[0];
	            this[1] += addend[1];
	            this[2] += addend[2];

	            return this;
	        };

	        /**
	         * Subtracts a specified vector from this vector.
	         * @param {Vec3} subtrahend The vector to subtract
	         * @returns {Vec3} This vector after subtracting the specified vector from it.
	         * @throws {ArgumentError} If the subtrahend is null or undefined.
	         */
	        Vec3.prototype.subtract = function (subtrahend) {
	            if (!subtrahend) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Vec3", "subtract", "missingVector"));
	            }

	            this[0] -= subtrahend[0];
	            this[1] -= subtrahend[1];
	            this[2] -= subtrahend[2];

	            return this;
	        };

	        /**
	         * Multiplies this vector by a scalar.
	         * @param {Number} scalar The scalar to multiply this vector by.
	         * @returns {Vec3} This vector multiplied by the specified scalar.
	         */
	        Vec3.prototype.multiply = function (scalar) {
	            this[0] *= scalar;
	            this[1] *= scalar;
	            this[2] *= scalar;

	            return this;
	        };

	        /**
	         * Divides this vector by a scalar.
	         * @param {Number} divisor The scalar to divide this vector by.
	         * @returns {Vec3} This vector divided by the specified scalar.
	         */
	        Vec3.prototype.divide = function (divisor) {
	            this[0] /= divisor;
	            this[1] /= divisor;
	            this[2] /= divisor;

	            return this;
	        };

	        /**
	         * Multiplies this vector by a 4x4 matrix. The multiplication is performed with an implicit W component of 1.
	         * The resultant W component of the product is then divided through the X, Y, and Z components.
	         *
	         * @param {Matrix} matrix The matrix to multiply this vector by.
	         * @returns {Vec3} This vector multiplied by the specified matrix.
	         * @throws ArgumentError If the specified matrix is null or undefined.
	         */
	        Vec3.prototype.multiplyByMatrix = function (matrix) {
	            if (!matrix) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Vec3", "multiplyByMatrix", "missingMatrix"));
	            }

	            var x = matrix[0] * this[0] + matrix[1] * this[1] + matrix[2] * this[2] + matrix[3],
	                y = matrix[4] * this[0] + matrix[5] * this[1] + matrix[6] * this[2] + matrix[7],
	                z = matrix[8] * this[0] + matrix[9] * this[1] + matrix[10] * this[2] + matrix[11],
	                w = matrix[12] * this[0] + matrix[13] * this[1] + matrix[14] * this[2] + matrix[15];

	            this[0] = x / w;
	            this[1] = y / w;
	            this[2] = z / w;

	            return this;
	        };

	        /**
	         * Mixes (interpolates) a specified vector with this vector, modifying this vector.
	         * @param {Vec3} vector The vector to mix with this one.
	         * @param {Number} weight The relative weight of this vector.
	         * @returns {Vec3} This vector modified to the mix of itself and the specified vector.
	         * @throws {ArgumentError} If the specified vector is null or undefined.
	         */
	        Vec3.prototype.mix = function (vector, weight) {
	            if (!vector) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Vec3", "mix", "missingVector"));
	            }

	            var w0 = 1 - weight,
	                w1 = weight;

	            this[0] = this[0] * w0 + vector[0] * w1;
	            this[1] = this[1] * w0 + vector[1] * w1;
	            this[2] = this[2] * w0 + vector[2] * w1;

	            return this;
	        };

	        /**
	         * Negates the components of this vector.
	         * @returns {Vec3} This vector, negated.
	         */
	        Vec3.prototype.negate = function () {
	            this[0] = -this[0];
	            this[1] = -this[1];
	            this[2] = -this[2];

	            return this;
	        };

	        /**
	         * Computes the scalar dot product of this vector and a specified vector.
	         * @param {Vec3} vector The vector to multiply.
	         * @returns {Number} The dot product of the two vectors.
	         * @throws {ArgumentError} If the specified vector is null or undefined.
	         */
	        Vec3.prototype.dot = function (vector) {
	            if (!vector) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Vec3", "dot", "missingVector"));
	            }

	            return this[0] * vector[0] +
	                this[1] * vector[1] +
	                this[2] * vector[2];
	        };

	        /**
	         * Computes the cross product of this vector and a specified vector, modifying this vector.
	         * @param {Vec3} vector The vector to cross with this vector.
	         * @returns {Vec3} This vector set to the cross product of itself and the specified vector.
	         * @throws {ArgumentError} If the specified vector is null or undefined.
	         */
	        Vec3.prototype.cross = function (vector) {
	            if (!vector) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Vec3", "cross", "missingVector"));
	            }

	            var x = this[1] * vector[2] - this[2] * vector[1],
	                y = this[2] * vector[0] - this[0] * vector[2],
	                z = this[0] * vector[1] - this[1] * vector[0];

	            this[0] = x;
	            this[1] = y;
	            this[2] = z;

	            return this;
	        };

	        /**
	         * Computes the squared magnitude of this vector.
	         * @returns {Number} The squared magnitude of this vector.
	         */
	        Vec3.prototype.magnitudeSquared = function () {
	            return this.dot(this);
	        };

	        /**
	         * Computes the magnitude of this vector.
	         * @returns {Number} The magnitude of this vector.
	         */
	        Vec3.prototype.magnitude = function () {
	            return Math.sqrt(this.magnitudeSquared());
	        };

	        /**
	         * Normalizes this vector to a unit vector.
	         * @returns {Vec3} This vector, normalized.
	         */
	        Vec3.prototype.normalize = function () {
	            var magnitude = this.magnitude(),
	                magnitudeInverse = 1 / magnitude;

	            this[0] *= magnitudeInverse;
	            this[1] *= magnitudeInverse;
	            this[2] *= magnitudeInverse;

	            return this;
	        };

	        /**
	         * Computes the squared distance from this vector to a specified vector.
	         * @param {Vec3} vector The vector to compute the distance to.
	         * @returns {Number} The squared distance between the vectors.
	         * @throws {ArgumentError} If the specified vector is null or undefined.
	         */
	        Vec3.prototype.distanceToSquared = function (vector) {
	            if (!vector) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Vec3", "distanceToSquared", "missingVector"));
	            }

	            var dx = this[0] - vector[0],
	                dy = this[1] - vector[1],
	                dz = this[2] - vector[2];

	            return dx * dx + dy * dy + dz * dz;
	        };

	        /**
	         * Computes the distance from this vector to another vector.
	         * @param {Vec3} vector The vector to compute the distance to.
	         * @returns {number} The distance between the vectors.
	         * @throws {ArgumentError} If the specified vector is null or undefined.
	         */
	        Vec3.prototype.distanceTo = function (vector) {
	            if (!vector) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Vec3", "distanceTo", "missingVector"));
	            }

	            return Math.sqrt(this.distanceToSquared(vector));
	        };

	        /**
	         * Swaps this vector with that vector. This vector's components are set to the values of the specified
	         * vector's components, and the specified vector's components are set to the values of this vector's components.
	         * @param {Vec3} that The vector to swap.
	         * @returns {Vec3} This vector set to the values of the specified vector.
	         */
	        Vec3.prototype.swap = function (that) {
	            var tmp = this[0];
	            this[0] = that[0];
	            that[0] = tmp;

	            tmp = this[1];
	            this[1] = that[1];
	            that[1] = tmp;

	            tmp = this[2];
	            this[2] = that[2];
	            that[2] = tmp;

	            return this;
	        };

	        /**
	         * Returns a string representation of this vector.
	         * @returns {String} A string representation of this vector, in the form "(x, y, z)".
	         */
	        Vec3.prototype.toString = function () {
	            return "(" + this[0] + ", " + this[1] + ", " + this[2] + ")";
	        };

	        return Vec3;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @version $Id: WWMath.js 3305 2015-07-07 21:55:51Z dcollins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(29),
	        __webpack_require__(30),
	        __webpack_require__(34),
	        __webpack_require__(32),
	        __webpack_require__(37),
	        __webpack_require__(35)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Angle,
	              ArgumentError,
	              Line,
	              Logger,
	              Rectangle,
	              Vec3) {
	        "use strict";
	        /**
	         * Provides math constants and functions.
	         * @exports WWMath
	         */
	        var WWMath = {

	            /**
	             * Returns a number within the range of a specified minimum and maximum.
	             * @param {Number} value The value to clamp.
	             * @param {Number} minimum The minimum value to return.
	             * @param {Number} maximum The maximum value to return.
	             * @returns {Number} The minimum value if the specified value is less than the minimum, the maximum value if
	             * the specified value is greater than the maximum, otherwise the value specified is returned.
	             */
	            clamp: function (value, minimum, maximum) {
	                return value < minimum ? minimum : value > maximum ? maximum : value;
	            },

	            /**
	             * Computes a number between two numbers.
	             * @param amount {Number} The relative distance between the numbers at which to compute the new number. This
	             * should normally be a number between 0 and 1 but whatever number is specified is applied.
	             * @param {Number} value1 The first number.
	             * @param {Number} value2 The second number.
	             * @returns {Number} the computed value.
	             */
	            interpolate: function (amount, value1, value2) {
	                return (1 - amount) * value1 + amount * value2;
	            },

	            /**
	             * Returns the cube root of a specified value.
	             * @param {Number} x The value whose cube root is computed.
	             * @returns {Number} The cube root of the specified number.
	             */
	            cbrt: function (x) {
	                // Use the built-in version if it exists. cbrt() is defined in ECMA6.
	                if (typeof Math.cbrt == 'function') {
	                    return Math.cbrt(x);
	                } else {
	                    return Math.pow(x, 1 / 3);
	                }
	            },

	            /**
	             * Computes the Cartesian intersection point of a specified line with an ellipsoid.
	             * @param {Line} line The line for which to compute the intersection.
	             * @param {Number} equatorialRadius The ellipsoid's major radius.
	             * @param {Number} polarRadius The ellipsoid's minor radius.
	             * @param {Vec3} result A pre-allocated Vec3 instance in which to return the computed point.
	             * @returns {boolean} true if the line intersects the ellipsoid, otherwise false
	             * @throws {ArgumentError} If the specified line or result is null or undefined.
	             */
	            computeEllipsoidalGlobeIntersection: function (line, equatorialRadius, polarRadius, result) {
	                if (!line) {
	                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath",
	                        "computeEllipsoidalGlobeIntersection", "missingLine"));
	                }

	                if (!result) {
	                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath",
	                        "computeEllipsoidalGlobeIntersection", "missingResult"));
	                }

	                // Taken from "Mathematics for 3D Game Programming and Computer Graphics, Second Edition", Section 5.2.3.
	                //
	                // Note that the parameter n from in equations 5.70 and 5.71 is omitted here. For an ellipsoidal globe this
	                // parameter is always 1, so its square and its product with any other value simplifies to the identity.

	                var vx = line.direction[0],
	                    vy = line.direction[1],
	                    vz = line.direction[2],
	                    sx = line.origin[0],
	                    sy = line.origin[1],
	                    sz = line.origin[2],
	                    m = equatorialRadius / polarRadius, // ratio of the x semi-axis length to the y semi-axis length
	                    m2 = m * m,
	                    r2 = equatorialRadius * equatorialRadius, // nominal radius squared
	                    a = vx * vx + m2 * vy * vy + vz * vz,
	                    b = 2 * (sx * vx + m2 * sy * vy + sz * vz),
	                    c = sx * sx + m2 * sy * sy + sz * sz - r2,
	                    d = b * b - 4 * a * c, // discriminant
	                    t;

	                if (d < 0) {
	                    return false;
	                }
	                else {
	                    t = (-b - Math.sqrt(d)) / (2 * a);
	                    result[0] = sx + vx * t;
	                    result[1] = sy + vy * t;
	                    result[2] = sz + vz * t;
	                    return true;
	                }
	            },

	            /**
	             * Computes the Cartesian intersection point of a specified line with a triangle.
	             * @param {Line} line The line for which to compute the intersection.
	             * @param {Vec3} vertex0 The triangle's first vertex.
	             * @param {Vec3} vertex1 The triangle's second vertex.
	             * @param {Vec3} vertex2 The triangle's third vertex.
	             * @param {Vec3} result A pre-allocated Vec3 instance in which to return the computed point.
	             * @returns {boolean} true if the line intersects the triangle, otherwise false
	             * @throws {ArgumentError} If the specified line, vertex or result is null or undefined.
	             */
	            computeTriangleIntersection: function (line, vertex0, vertex1, vertex2, result) {
	                if (!line) {
	                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath",
	                        "computeTriangleIntersection", "missingLine"));
	                }

	                if (!vertex0 || !vertex1 || !vertex2) {
	                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath",
	                        "computeTriangleIntersection", "missingVertex"));
	                }

	                if (!result) {
	                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath",
	                        "computeTriangleIntersection", "missingResult"));
	                }

	                // Taken from Moller and Trumbore
	                // https://www.cs.virginia.edu/~gfx/Courses/2003/ImageSynthesis/papers/Acceleration/Fast%20MinimumStorage%20RayTriangle%20Intersection.pdf

	                var vx = line.direction[0],
	                    vy = line.direction[1],
	                    vz = line.direction[2],
	                    sx = line.origin[0],
	                    sy = line.origin[1],
	                    sz = line.origin[2],
	                    EPSILON = 0.00001;

	                // find vectors for two edges sharing point a: vertex1 - vertex0 and vertex2 - vertex0
	                var edge1x = vertex1[0] - vertex0[0],
	                    edge1y = vertex1[1] - vertex0[1],
	                    edge1z = vertex1[2] - vertex0[2],
	                    edge2x = vertex2[0] - vertex0[0],
	                    edge2y = vertex2[1] - vertex0[1],
	                    edge2z = vertex2[2] - vertex0[2];

	                // Compute cross product of line direction and edge2
	                var px = (vy * edge2z) - (vz * edge2y),
	                    py = (vz * edge2x) - (vx * edge2z),
	                    pz = (vx * edge2y) - (vy * edge2x);

	                // Get determinant
	                var det = edge1x * px + edge1y * py + edge1z * pz; // edge1 dot p
	                if (det > -EPSILON && det < EPSILON) { // if det is near zero then ray lies in plane of triangle
	                    return false;
	                }

	                var inv_det = 1.0 / det;

	                // Compute distance for vertex A to ray origin: origin - vertex0
	                var tx = sx - vertex0[0],
	                    ty = sy - vertex0[1],
	                    tz = sz - vertex0[2];

	                // Calculate u parameter and test bounds: 1/det * t dot p
	                var u = inv_det * (tx * px + ty * py + tz * pz);
	                if (u < -EPSILON || u > 1 + EPSILON) {
	                    return false;
	                }

	                // Prepare to test v parameter: t cross edge1
	                var qx = (ty * edge1z) - (tz * edge1y),
	                    qy = (tz * edge1x) - (tx * edge1z),
	                    qz = (tx * edge1y) - (ty * edge1x);

	                // Calculate v parameter and test bounds: 1/det * dir dot q
	                var v = inv_det * (vx * qx + vy * qy + vz * qz);
	                if (v < -EPSILON || u + v > 1 + EPSILON) {
	                    return false;
	                }

	                // Calculate the point of intersection on the line: t = 1/det * edge2 dot q
	                var t = inv_det * (edge2x * qx + edge2y * qy + edge2z * qz);
	                if (t < 0) {
	                    return false;
	                } else {
	                    result[0] = sx + vx * t;
	                    result[1] = sy + vy * t;
	                    result[2] = sz + vz * t;
	                    return true;
	                }
	            },

	            computeIndexedTrianglesIntersection: function (line, points, indices, results) {
	                if (!line) {
	                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath",
	                        "computeIndexedTrianglesIntersection", "missingLine"));
	                }

	                if (!points) {
	                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath",
	                        "computeIndexedTrianglesIntersection", "missingPoints"));
	                }

	                if (!indices) {
	                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath",
	                        "computeIndexedTrianglesIntersection", "missingIndices"));
	                }

	                if (!results) {
	                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath",
	                        "computeIndexedTrianglesIntersection", "missingResults"));
	                }

	                var v0 = new Vec3(0, 0, 0),
	                    v1 = new Vec3(0, 0, 0),
	                    v2 = new Vec3(0, 0, 0),
	                    iPoint = new Vec3(0, 0, 0);

	                for (var i = 0, len = indices.length; i < len; i += 3) {
	                    var i0 = 3 * indices[i],
	                        i1 = 3 * indices[i + 1],
	                        i2 = 3 * indices[i + 2];

	                    v0[0] = points[i0];
	                    v0[1] = points[i0 + 1];
	                    v0[2] = points[i0 + 2];

	                    v1[0] = points[i1];
	                    v1[1] = points[i1 + 1];
	                    v1[2] = points[i1 + 2];

	                    v2[0] = points[i2];
	                    v2[1] = points[i2 + 1];
	                    v2[2] = points[i2 + 2];

	                    if (WWMath.computeTriangleIntersection(line, v0, v1, v2, iPoint)) {
	                        results.push(iPoint);
	                        iPoint = new Vec3(0, 0, 0);
	                    }
	                }

	                return results.length > 0;
	            },

	            /**
	             * Computes the Cartesian intersection points of a specified line with a triangle strip. The triangle strip
	             * is specified by a list of vertex points and a list of indices indicating the triangle strip tessellation
	             * of those vertices. The triangle strip indices are interpreted in the same manner as WebGL, where each
	             * index indicates a vertex position rather than an actual index into the points array (e.g. a triangle
	             * strip index of 1 indicates the XYZ tuple starting at array index 3). This is equivalent to calling
	             * computeTriangleIntersection for each individual triangle in the triangle strip, but is potentially much
	             * more efficient.
	             * @param {Line} line The line for which to compute the intersection.
	             * @param {Array} points The list of vertex points, organized as a list of tightly-packed XYZ tuples.
	             * @param {Array} indices The list of triangle strip indices, organized as a list of vertex positions.
	             * @param {Array} results A pre-allocated array instance in which to return the intersection points as
	             * {@link Vec3} instances.
	             * @throws {ArgumentError} If the specified line, points, indices or results is null or undefined.
	             */
	            computeTriStripIntersections: function (line, points, indices, results) {
	                if (!line) {
	                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath",
	                        "computeTriStripIntersections", "missingLine"));
	                }

	                if (!points) {
	                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath",
	                        "computeTriStripIntersections", "missingPoints"));
	                }

	                if (!indices) {
	                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath",
	                        "computeTriStripIntersections", "missingIndices"));
	                }

	                if (!results) {
	                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath",
	                        "computeTriStripIntersections", "missingResults"));
	                }

	                // Taken from Moller and Trumbore
	                // https://www.cs.virginia.edu/~gfx/Courses/2003/ImageSynthesis/papers/Acceleration/Fast%20MinimumStorage%20RayTriangle%20Intersection.pdf

	                // Adapted from the original ray-triangle intersection algorithm to optimize for ray-triangle strip
	                // intersection. We optimize by reusing constant terms, replacing use of Vec3 with inline primitives,
	                // and exploiting the triangle strip organization to reuse computations common to adjacent triangles.
	                // These optimizations reduce worst-case terrain picking performance by approximately 50% in Chrome on a
	                // 2010 iMac and a Nexus 9.

	                var vx = line.direction[0],
	                    vy = line.direction[1],
	                    vz = line.direction[2],
	                    sx = line.origin[0],
	                    sy = line.origin[1],
	                    sz = line.origin[2],
	                    vert0x, vert0y, vert0z,
	                    vert1x, vert1y, vert1z,
	                    vert2x, vert2y, vert2z,
	                    edge1x, edge1y, edge1z,
	                    edge2x, edge2y, edge2z,
	                    px, py, pz,
	                    tx, ty, tz,
	                    qx, qy, qz,
	                    u, v, t,
	                    det, inv_det,
	                    index,
	                    EPSILON = 0.00001;

	                // Get the triangle strip's first vertex.
	                index = 3 * indices[0];
	                vert1x = points[index++];
	                vert1y = points[index++];
	                vert1z = points[index];

	                // Get the triangle strip's second vertex.
	                index = 3 * indices[1];
	                vert2x = points[index++];
	                vert2y = points[index++];
	                vert2z = points[index];

	                // Compute the intersection of each triangle with the specified ray.
	                for (var i = 2, len = indices.length; i < len; i++) {
	                    // Move the last two vertices into the first two vertices. This takes advantage of the triangle
	                    // strip's structure and avoids redundant reads from points and indices. During the first
	                    // iteration this places the triangle strip's first three vertices in vert0, vert1 and vert2,
	                    // respectively.
	                    vert0x = vert1x;
	                    vert0y = vert1y;
	                    vert0z = vert1z;
	                    vert1x = vert2x;
	                    vert1y = vert2y;
	                    vert1z = vert2z;

	                    // Get the triangle strip's next vertex.
	                    index = 3 * indices[i];
	                    vert2x = points[index++];
	                    vert2y = points[index++];
	                    vert2z = points[index];

	                    // find vectors for two edges sharing point a: vert1 - vert0 and vert2 - vert0
	                    edge1x = vert1x - vert0x;
	                    edge1y = vert1y - vert0y;
	                    edge1z = vert1z - vert0z;
	                    edge2x = vert2x - vert0x;
	                    edge2y = vert2y - vert0y;
	                    edge2z = vert2z - vert0z;

	                    // Compute cross product of line direction and edge2
	                    px = (vy * edge2z) - (vz * edge2y);
	                    py = (vz * edge2x) - (vx * edge2z);
	                    pz = (vx * edge2y) - (vy * edge2x);

	                    // Get determinant
	                    det = edge1x * px + edge1y * py + edge1z * pz; // edge1 dot p
	                    if (det > -EPSILON && det < EPSILON) { // if det is near zero then ray lies in plane of triangle
	                        continue;
	                    }

	                    inv_det = 1.0 / det;

	                    // Compute distance for vertex A to ray origin: origin - vert0
	                    tx = sx - vert0x;
	                    ty = sy - vert0y;
	                    tz = sz - vert0z;

	                    // Calculate u parameter and test bounds: 1/det * t dot p
	                    u = inv_det * (tx * px + ty * py + tz * pz);
	                    if (u < -EPSILON || u > 1 + EPSILON) {
	                        continue;
	                    }

	                    // Prepare to test v parameter: tvec cross edge1
	                    qx = (ty * edge1z) - (tz * edge1y);
	                    qy = (tz * edge1x) - (tx * edge1z);
	                    qz = (tx * edge1y) - (ty * edge1x);

	                    // Calculate v parameter and test bounds: 1/det * dir dot q
	                    v = inv_det * (vx * qx + vy * qy + vz * qz);
	                    if (v < -EPSILON || u + v > 1 + EPSILON) {
	                        continue;
	                    }

	                    // Calculate the point of intersection on the line: t = 1/det * edge2 dot q
	                    t = inv_det * (edge2x * qx + edge2y * qy + edge2z * qz);
	                    if (t >= 0) {
	                        results.push(new Vec3(sx + vx * t, sy + vy * t, sz + vz * t));
	                    }
	                }
	            },

	            /**
	             * Computes the absolute value of a specified value.
	             * @param {Number} a The value whose absolute value to compute.
	             * @returns {Number} The absolute value of the specified number.
	             */
	            fabs: function (a) {
	                return a >= 0 ? a : -a;
	            },

	            /**
	             * Computes the floating-point modulus of a specified number.
	             * @param {Number} number The number whose modulus to compute.
	             * @param {Number} modulus The modulus.
	             * @returns {Number} The remainder after dividing the number by the modulus: number % modulus.
	             */
	            fmod: function (number, modulus) {
	                return modulus === 0 ? 0 : number - Math.floor(number / modulus) * modulus;
	            },

	            /**
	             * Returns the fractional part of a specified number
	             * @param {Number} number The number whose fractional part to compute.
	             * @returns {Number} The fractional part of the specified number: number - floor(number).
	             */
	            fract: function (number) {
	                return number - Math.floor(number);
	            },

	            /**
	             * Returns the integer modulus of a specified number. This differs from the % operator in that
	             * the result is always positive when the modulus is positive. For example -1 % 10 = -1,
	             * whereas mod(-1, 10) = 1.
	             * @param {Number} number The number whose modulus to compute.
	             * @param {Number} modulus The modulus.
	             * @returns {Number} The remainder after dividing the number by the modulus.
	             */
	            mod: function (number, modulus) {
	                return ((number % modulus) + modulus) % modulus;
	            },

	            /**
	             * Returns the maximum of two specified numbers.
	             * @param {Number} value1 The first value to compare.
	             * @param {Number} value2 The second value to compare.
	             * @returns {Number} The maximum of the two specified values.
	             */
	            max: function (value1, value2) {
	                return value1 > value2 ? value1 : value2;
	            },

	            /**
	             * Computes the axes of a local coordinate system on the specified globe, placing the resultant axes in the specified
	             * axis arguments.
	             *
	             * Upon return the specified axis arguments contain three orthogonal axes identifying the X, Y, and Z axes. Each
	             * axis has unit length.
	             *
	             * The local coordinate system is defined such that the Z axis maps to the globe's surface normal at the point, the
	             * Y axis maps to the north pointing tangent, and the X axis maps to the east pointing tangent.
	             *
	             * @param {Vec3} origin The local coordinate system origin, in model coordinates.
	             * @param {Globe} globe The globe the coordinate system is relative to.
	             * @param {Vec3} xAxisResult A pre-allocated Vec3 in which to return the computed X axis.
	             * @param {Vec3} yAxisResult A pre-allocated Vec3 in which to return the computed Y axis.
	             * @param {Vec3} zAxisResult A pre-allocated Vec3 in which to return the computed Z axis.
	             * @throws {ArgumentError} If any argument is null or undefined.
	             */
	            localCoordinateAxesAtPoint: function (origin, globe, xAxisResult, yAxisResult, zAxisResult) {
	                if (!origin) {
	                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath",
	                        "localCoordinateAxesAtPoint", "missingVector"));
	                }

	                if (!globe) {
	                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath",
	                        "localCoordinateAxesAtPoint", "missingGlobe"));
	                }

	                if (!xAxisResult || !yAxisResult || !zAxisResult) {
	                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath",
	                        "localCoordinateAxesAtPoint", "missingResult"));
	                }

	                var x = origin[0],
	                    y = origin[1],
	                    z = origin[2];

	                // Compute the z axis from the surface normal in model coordinates. This axis is used to determine the other two
	                // axes, and is the only constant in the computations below.
	                globe.surfaceNormalAtPoint(x, y, z, zAxisResult);

	                // Compute the y axis from the north pointing tangent in model coordinates. This axis is known to be orthogonal to
	                // the z axis, and is therefore used to compute the x axis.
	                globe.northTangentAtPoint(x, y, z, yAxisResult);

	                // Compute the x axis as the cross product of the y and z axes. This ensures that the x and z axes are orthogonal.
	                xAxisResult.set(yAxisResult[0], yAxisResult[1], yAxisResult[2]);
	                xAxisResult.cross(zAxisResult);
	                xAxisResult.normalize();

	                // Re-compute the y axis as the cross product of the z and x axes. This ensures that all three axes are orthogonal.
	                // Though the initial y axis computed above is likely to be very nearly orthogonal, we re-compute it using cross
	                // products to reduce the effect of floating point rounding errors caused by working with Earth sized coordinates.
	                yAxisResult.set(zAxisResult[0], zAxisResult[1], zAxisResult[2]);
	                yAxisResult.cross(xAxisResult);
	                yAxisResult.normalize();
	            },

	            /**
	             * Computes the distance to a globe's horizon from a viewer at a given altitude.
	             *
	             * Only the globe's ellipsoid is considered; terrain height is not incorporated. This returns zero if the radius is zero
	             * or if the altitude is less than or equal to zero.
	             *
	             * @param {Number} radius The globe's radius, in meters.
	             * @param {Number} altitude The viewer's altitude above the globe, in meters.
	             * @returns {Number} The distance to the horizon, in model coordinates.
	             * @throws {ArgumentError} If the specified globe radius is negative.
	             */
	            horizonDistanceForGlobeRadius: function (radius, altitude) {
	                if (radius < 0) {
	                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath",
	                        "horizontalDistanceForGlobeRadius", "The specified globe radius is negative."));
	                }

	                return (radius > 0 && altitude > 0) ? Math.sqrt(altitude * (2 * radius + altitude)) : 0;
	            },

	            /**
	             * Computes the near clip distance that corresponds to a specified far clip distance and resolution at the far clip
	             * plane.
	             *
	             * This computes a near clip distance appropriate for use in [perspectiveFrustumRect]{@link WWMath#perspectiveFrustumRectangle}
	             * and [setToPerspectiveProjection]{@link Matrix#setToPerspectiveProjection}. This returns zero if either the distance or the
	             * resolution are zero.
	             *
	             * @param {Number} farDistance The far clip distance, in meters.
	             * @param {Number} farResolution The depth resolution at the far clip plane, in meters.
	             * @param {Number} depthBits The number of bit-planes in the depth buffer.
	             * @returns {Number} The near clip distance, in meters.
	             * @throws {ArgumentError} If either the distance or resolution is negative, or if the depth bits is less
	             * than one.
	             */
	            perspectiveNearDistanceForFarDistance: function (farDistance, farResolution, depthBits) {
	                if (farDistance < 0) {
	                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath", "perspectiveNearDistanceForFarDistance",
	                        "The specified distance is negative."));
	                }

	                if (farResolution < 0) {
	                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath", "perspectiveNearDistanceForFarDistance",
	                        "The specified resolution is negative."));
	                }

	                if (depthBits < 1) {
	                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath", "perspectiveNearDistanceForFarDistance",
	                        "The specified depth bits is negative."));
	                }

	                var maxDepthValue = (1 << depthBits) - 1;

	                return farDistance / (maxDepthValue / (1 - farResolution / farDistance) - maxDepthValue + 1);
	            },

	            /**
	             * Computes the maximum near clip distance for a perspective projection that avoids clipping an object at a
	             * given distance from the eye point.
	             * <p/>
	             * This computes a near clip distance appropriate for use in perspectiveFrustumRect and
	             * Matrix.setToPerspectiveProjection. The given distance should specify the smallest distance between the
	             * eye and the object being viewed, but may be an approximation if an exact distance is not required.
	             *
	             * @param {Number} viewportWidth The viewport width, in screen coordinates.
	             * @param {Number} viewportHeight The viewport height, in screen coordinates.
	             * @param {Number} distanceToSurface The distance from the perspective eye point to the nearest object, in
	             * meters.
	             * @returns {Number} The maximum near clip distance, in meters.
	             * @throws {ArgumentError} If the specified width or height is less than or equal to zero, or if the
	             * specified distance is negative.
	             */
	            perspectiveNearDistance: function (viewportWidth, viewportHeight, distanceToSurface) {
	                if (viewportWidth <= 0) {
	                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath", "perspectiveNearDistance",
	                        "invalidWidth"));
	                }

	                if (viewportHeight <= 0) {
	                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath", "perspectiveNearDistance",
	                        "invalidHeight"));
	                }

	                if (distanceToSurface < 0) {
	                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath", "perspectiveNearDistance",
	                        "The specified distance is negative."));
	                }

	                // Compute the maximum near clip distance that avoids clipping an object at the specified distance from
	                // the eye. Since the furthest points on the near clip rectangle are the four corners, we compute a near
	                // distance that puts any one of these corners exactly at the given distance. The distance to one of the
	                // four corners can be expressed in terms of the near clip distance, given distance to a corner 'd',
	                // near distance 'n', and aspect ratio 'a':
	                //
	                // d*d = x*x + y*y + z*z
	                // d*d = (n*n/4 * a*a) + (n*n/4) + (n*n)
	                //
	                // Extracting 'n*n/4' from the right hand side gives:
	                //
	                // d*d = (n*n/4) * (a*a + 1 + 4)
	                // d*d = (n*n/4) * (a*a + 5)
	                //
	                // Finally, solving for 'n' gives:
	                //
	                // n*n = 4 * d*d / (a*a + 5)
	                // n = 2 * d / sqrt(a*a + 5)

	                // Assumes a 45 degree horizontal field of view.
	                var aspectRatio = viewportHeight / viewportWidth;

	                return 2 * distanceToSurface / Math.sqrt(aspectRatio * aspectRatio + 5);
	            },

	            /**
	             * Computes the coordinates of a rectangle carved out of a perspective projection's frustum at a given
	             * distance in model coordinates. This returns an empty rectangle if the specified distance is zero.
	             *
	             * @param {Number} viewportWidth The viewport width, in screen coordinates.
	             * @param {Number} viewportHeight The viewport height, in screen coordinates.
	             * @param {Number} distance The distance along the negative Z axis, in model coordinates.
	             * @returns {Rectangle} The frustum rectangle, in model coordinates.
	             * @throws {ArgumentError} If the specified width or height is less than or equal to zero, or if the
	             * specified distance is negative.
	             */
	            perspectiveFrustumRectangle: function (viewportWidth, viewportHeight, distance) {
	                if (viewportWidth <= 0) {
	                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath", "perspectiveFrustumRectangle",
	                        "invalidWidth"));
	                }

	                if (viewportHeight <= 0) {
	                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath", "perspectiveFrustumRectangle",
	                        "invalidHeight"));
	                }

	                if (distance < 0) {
	                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath", "perspectiveFrustumRectangle",
	                        "The specified distance is negative."));
	                }

	                // Assumes a 45 degree horizontal field of view.
	                var width = distance,
	                    height = distance * viewportHeight / viewportWidth;

	                return new Rectangle(-width / 2, -height / 2, width, height);
	            },

	            /**
	             * Computes the vertical size of a pixel in model coordinates at a given distance from the eye point in a
	             * perspective projection. This returns zero if the specified distance is zero. The returned size is
	             * undefined if the distance is less than zero.
	             * <p/>
	             * This method assumes the model of a screen composed of rectangular pixels, where pixel coordinates denote
	             * infinitely thin space between pixels. The units of the returned size are in model coordinates per pixel
	             * (usually meters per pixel).
	             *
	             * @param {Number} viewportWidth The viewport width, in screen coordinates.
	             * @param {Number} viewportHeight The viewport height, in screen coordinates.
	             * @param {Number} distance The distance from the perspective eye point at which to determine pixel size, in
	             * model coordinates.
	             * @returns {Number} The pixel size at the specified distance from the eye point, in model coordinates per
	             * pixel.
	             * @throws {ArgumentError} If the specified width or height is less than or equal to zero, or if the
	             * specified distance is negative.
	             */
	            perspectivePixelSize: function (viewportWidth, viewportHeight, distance) {
	                if (viewportWidth <= 0) {
	                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath", "perspectivePixelSize",
	                        "invalidWidth"));
	                }

	                if (viewportHeight <= 0) {
	                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath", "perspectivePixelSize",
	                        "invalidHeight"));
	                }

	                if (distance < 0) {
	                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath", "perspectivePixelSize",
	                        "The specified distance is negative."));
	                }

	                var frustumHeight = WWMath.perspectiveFrustumRectangle(viewportWidth, viewportHeight, distance).height;
	                return frustumHeight / viewportHeight;
	            },

	            /**
	             * Computes the bounding rectangle for a unit quadrilateral after applying a transformation matrix to that
	             * quadrilateral.
	             * @param {Matrix} transformMatrix The matrix to apply to the unit quadrilateral.
	             * @returns {Rectangle} The computed bounding rectangle.
	             */
	            boundingRectForUnitQuad: function (transformMatrix) {
	                if (!transformMatrix) {
	                    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "WWMath", "boundingRectForUnitQuad",
	                        "missingMatrix"));
	                }

	                var m = transformMatrix,
	                // transform of (0, 0)
	                    x1 = m[3],
	                    y1 = m[7],
	                // transform of (1, 0)
	                    x2 = m[0] + m[3],
	                    y2 = m[4] + m[7],
	                // transform of (0, 1)
	                    x3 = m[1] + m[3],
	                    y3 = m[5] + m[7],
	                // transform of (1, 1)
	                    x4 = m[0] + m[1] + m[3],
	                    y4 = m[4] + m[5] + m[7],
	                    minX = Math.min(Math.min(x1, x2), Math.min(x3, x4)),
	                    maxX = Math.max(Math.max(x1, x2), Math.max(x3, x4)),
	                    minY = Math.min(Math.min(y1, y2), Math.min(y3, y4)),
	                    maxY = Math.max(Math.max(y1, y2), Math.max(y3, y4));

	                return new Rectangle(minX, minY, maxX - minX, maxY - minY);
	            },

	            /**
	             * Indicates whether a specified value is a power of two.
	             * @param {Number} value The value to test.
	             * @returns {boolean} <code>true</code> if the specified value is a power of two,
	             * otherwise <code>false</code>.
	             */
	            isPowerOfTwo: function (value) {
	                return value != 0 && (value & (value - 1)) === 0;
	            },

	            /**
	             * Determine the sign of a number.
	             * @param {Number} value The value to determine the sign of.
	             * @returns {Number} 1, -1, or 0, depending on the sign of the value.
	             */
	            signum: function (value) {
	                return value > 0 ? 1 : value < 0 ? -1 : 0;
	            },

	            /**
	             * Calculates the Gudermannian inverse used to unproject Mercator projections.
	             * @param {Number} latitude The latitude in degrees.
	             * @returns {Number} The Gudermannian inverse for the specified latitude.
	             */
	            gudermannianInverse: function (latitude) {
	                return Math.log(Math.tan(Math.PI / 4 + (latitude * Angle.DEGREES_TO_RADIANS) / 2)) / Math.PI;
	            },

	            epsg3857ToEpsg4326: function (easting, northing) {
	                var r = 6.3781e6,
	                    latRadians = (Math.PI / 2) - 2 * Math.atan(Math.exp(-northing / r)),
	                    lonRadians = easting / r;

	                return [
	                    WWMath.clamp(latRadians * Angle.RADIANS_TO_DEGREES, -90, 90),
	                    WWMath.clamp(lonRadians * Angle.RADIANS_TO_DEGREES, -180, 180)
	                ];
	            },

	            /**
	             * Returns the value that is the nearest power of 2 less than or equal to the given value.
	             * @param {Number} value the reference value. The power of 2 returned is less than or equal to this value.
	             * @returns {Number} the value that is the nearest power of 2 less than or equal to the reference value
	             */
	            powerOfTwoFloor: function (value) {
	                var power = Math.floor(Math.log(value) / Math.log(2));
	                return Math.pow(2, power);
	            }
	        };

	        return WWMath;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports Rectangle
	 * @version $Id: Rectangle.js 3174 2015-06-10 19:36:49Z tgaskins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(32)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Logger) {
	        "use strict";

	        /**
	         * Constructs a rectangle with a specified origin and size.
	         * @alias Rectangle
	         * @constructor
	         * @classdesc Represents a rectangle in 2D Cartesian coordinates.
	         * @param {Number} x The X coordinate of the rectangle's origin.
	         * @param {Number} y The Y coordinate of the rectangle's origin.
	         * @param {Number} width The rectangle's width.
	         * @param {Number} height The rectangle's height.
	         */
	        var Rectangle = function (x, y, width, height) {

	            /**
	             * The X coordinate of this rectangle's origin.
	             * @type {Number}
	             */
	            this.x = x;

	            /**
	             * The Y coordinate of this rectangle's origin.
	             * @type {Number}
	             */
	            this.y = y;

	            /**
	             * This rectangle's width.
	             * @type {Number}
	             */
	            this.width = width;

	            /**
	             * This rectangle's height.
	             * @type {Number}
	             */
	            this.height = height;
	        };

	        /**
	         * Sets all this rectangle's properties.
	         * @param {Number} x The X coordinate of the rectangle's origin.
	         * @param {Number} y The Y coordinate of the rectangle's origin.
	         * @param {Number} width The rectangle's width.
	         * @param {Number} height The rectangle's height.
	         */
	        Rectangle.prototype.set = function(x, y, width, height) {
	            this.x = x;
	            this.y = y;
	            this.width = width;
	            this.height = height;
	        };

	        /**
	         * Returns the minimum X value of this rectangle.
	         * @returns {Number} The rectangle's minimum X value.
	         */
	        Rectangle.prototype.getMinX = function () {
	            return this.x;
	        };

	        /**
	         * Returns the minimum Y value of this rectangle.
	         * @returns {Number} The rectangle's minimum Y value.
	         */
	        Rectangle.prototype.getMinY = function () {
	            return this.y;
	        };

	        /**
	         * Returns the maximum X value of this rectangle.
	         * @returns {Number} The rectangle's maximum X value.
	         */
	        Rectangle.prototype.getMaxX = function () {
	            return this.x + this.width;
	        };

	        /**
	         * Returns the maximum Y value of this rectangle.
	         * @returns {Number} The rectangle's maximum Y value.
	         */
	        Rectangle.prototype.getMaxY = function () {
	            return this.y + this.height;
	        };

	        /**
	         * Indicates whether this rectangle contains a specified point.
	         * @param {Vec2} point The point to test.
	         * @returns {Boolean} true if this rectangle contains the specified point, otherwise false.
	         */
	        Rectangle.prototype.containsPoint = function (point) {
	            return point[0] >= this.x && point[0] <= (this.x + this.width)
	                && point[1] >= this.y && point[1] <= (this.y + this.height);
	        };
	        /**
	         *
	         * Indicates whether this rectangle intersects a specified one.
	         * @param {Rectangle} that The rectangle to test.
	         * @returns {Boolean} true if this triangle and the specified one intersect, otherwise false.
	         */
	        Rectangle.prototype.intersects = function (that) {
	            if ((that.x + that.width) < this.x)
	                return false;

	            if (that.x > (this.x + this.width))
	                return false;

	            if ((that.y + that.height) < this.y)
	                return false;

	            //noinspection RedundantIfStatementJS
	            if (that.y > (this.y + this.height))
	                return false;

	            return true;
	        };

	        /**
	         * Indicates whether this rectangle intersects any rectangle in a specified array of rectangles.
	         * @param {Rectangle[]} rectangles The rectangles to test intersection with.
	         * @returns {Boolean} true if this rectangle intersects any rectangle in the array, otherwise false.
	         */
	        Rectangle.prototype.intersectsRectangles = function (rectangles) {
	            if (rectangles) {
	                for (var i = 0; i < rectangles.length; i++){
	                    if (this.intersects(rectangles[i])) {
	                        return true;
	                    }
	                }
	            }

	            return false;
	        };

	        /**
	         * Returns a string representation of this object.
	         * @returns {String} A string representation of this object.
	         */
	        Rectangle.prototype.toString = function () {
	            return this.x + ", " + this.y + ", " + this.width + ", " + this.height;
	        };

	        return Rectangle;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

	var Events = __webpack_require__(5);
	var Dom = __webpack_require__(4);
	var FORM_ID = 'search-form';
	var SvgIcons = __webpack_require__(1);

	var searchForm;
	var resultsDisplay;
	var current;
	var searchResult;

	Events.listen(Events._SHOW_SEARCH_RESULT, function(result) {
	    searchResult = result;
	    // for (var i=0; i<22; i++){
	    //     searchResult.push(i*1234);
	    // }
	    current = 0;
	    ensureForm();
	    reconfigure();
	    Events.post(Events.SHOW_FORM, FORM_ID);
	});

	function fillResult() {
	    getRange(searchResult, current).forEach(function (id) {
	        var i = searchResult.indexOf(id);
	        var name = Dom.span('search-result-item').html(i + 1)
	            .click(choose.bind(null, i));
	        i === current && name.classList.add('active');
	        resultsDisplay.append(name);
	    });
	}

	function getRange(arr, index) {
	    var right = arr.slice(index + 1).reverse(); // reverse right part
	    var left = arr.slice(0, index); // left part
	    var range = [arr[index]];
	    while (range.length < 10) {
	        left.length && (range = [left.pop()].concat(range));
	        right.length && (range = range.concat([right.pop()]));
	        if (right.length === 0 && left.length === 0) break;
	    }
	    return range;
	}

	function reconfigure() {
	    resultsDisplay.innerHTML = '';
	    fillResult();
	    Events.post(Events._HIGHLIGHT_FOUND, current);
	}

	function choose(i) {
	    current = i;
	    reconfigure();
	}

	function next() {
	    current++;
	    var max = searchResult.length - 1;
	    current = current > max ? max : current;
	    reconfigure();
	}

	function prev() {
	    current--;
	    current = current < 0 ? 0 : current;
	    reconfigure()
	}

	function ensureForm() {
	    if (searchForm) return;

	    searchForm = Events.post(Events.CREATE_FORM, {
	        id: FORM_ID,
	        close: true,
	        hidden: true,
	        width: 400,
	        height: 90,
	        title: 'Результаты поиска',
	        left: window.innerWidth / 2 - 200,
	        bottom: 50
	    });

	    searchForm.addButton({
	        action: prev,
	        tooltip: 'Предыдущий',
	        title: SvgIcons.prev(),
	        width: 30, height: 30
	    });

	    resultsDisplay = Dom.div('search-result');

	    searchForm.add(resultsDisplay);

	    searchForm.addButton({
	        action: next,
	        tooltip: 'Следующий',
	        title: SvgIcons.next(),
	        width: 30, height: 30
	    });
	}



/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

	var Dom = __webpack_require__(4);
	var Events = __webpack_require__(5);

	var state = Dom.div('on-screen-state').appendTo(document.body);

	var components = [
	    component('latitude', 'Ш'),
	    component('longitude', 'Д')
	];

	Events.listen(Events.NAVIGATOR_STATE_CHANGED, changed);
	Events.listen(Events.LOCATION_CHANGED, changed);

	function changed(e) {
	    components.forEach(function (c) {
	        c.update(e);
	    });
	}

	function component(name, tilte) {
	    var c = Dom.div().appendTo(state);
	    c.style.display = 'inline-block';
	    c.style.width = '120px';
	    var value;
	    c.update = function (e) {
	        if (e[name] && e[name] !== value) {
	            value = e[name];
	            c.html(tilte + ': ' + value.toFixed(6));
	        }
	    };
	    return c;
	}

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

	
	// global constants here
	__webpack_require__(41);
	__webpack_require__(42);

	__webpack_require__(101);
	__webpack_require__(105);
	__webpack_require__(107);

	var Events = __webpack_require__(5);
	var WorldWindow = __webpack_require__(109);
	var ZeroElevationModel = __webpack_require__(119);

	var earth = new WorldWindow('canvas', new ZeroElevationModel());
	window.engine = earth;
	module.exports = earth;

	//earth.drawContext.currentGlContext.getExtension("OES_standard_derivatives");

	__webpack_require__(135)(earth);

	earth.redraw();

	Events.listen(Events.REDRAW, earth.redraw.bind(earth));


	//var oldDisableVertexAttribArray  = earth.drawContext.currentGlContext.disableVertexAttribArray;
	//
	//earth.drawContext.currentGlContext.disableVertexAttribArray = function(index) {
	//    console.error(index);
	//    oldDisableVertexAttribArray.call(this, index);
	//};

/***/ }),
/* 41 */
/***/ (function(module, exports) {

	// see original ../node_modules/web-world-wind/src/WorldWind
	// this global constants is used by whole web world wind engine
	WorldWind = {

	    /**
	     * Holds configuration parameters for World Wind. Applications may modify these parameters prior to creating
	     * their first World Wind objects. Configuration properties are:
	     * <ul>
	     *     <li><code>gpuCacheSize</code>: A Number indicating the size in bytes to allocate from GPU memory for
	     *     resources such as textures, GLSL programs and buffer objects. Default is 250e6 (250 MB).</li>
	     *     <li><code>baseUrl</code>: The URL of the directory containing the World Wind Library and its resources.</li>
	     * </ul>
	     * @type {{gpuCacheSize: number}}
	     */
	    configuration: {
	        gpuCacheSize: 250e6
	    },

	    /**
	     * The World Wind version number.
	     * @default "0.0.0"
	     * @constant
	     */
	    VERSION: "0.0.0",

	    /**
	     * Indicates an altitude mode relative to the globe's ellipsoid.
	     * @constant
	     */
	    ABSOLUTE: "absolute",

	    /**
	     * Indicates that a redraw callback has been called immediately after a redraw.
	     * @constant
	     */
	    AFTER_REDRAW: "afterRedraw",

	    /**
	     * Indicates that a redraw callback has been called immediately before a redraw.
	     * @constant
	     */
	    BEFORE_REDRAW: "beforeRedraw",

	    /**
	     * The BEGAN gesture recognizer state. Continuous gesture recognizers transition to this state from the
	     * POSSIBLE state when the gesture is first recognized.
	     * @constant
	     */
	    BEGAN: "began",

	    /**
	     * The CANCELLED gesture recognizer state. Continuous gesture recognizers may transition to this state from
	     * the BEGAN state or the CHANGED state when the touch events are cancelled.
	     * @constant
	     */
	    CANCELLED: "cancelled",

	    /**
	     * The CHANGED gesture recognizer state. Continuous gesture recognizers transition to this state from the
	     * BEGAN state or the CHANGED state, whenever an input event indicates a change in the gesture.
	     * @constant
	     */
	    CHANGED: "changed",

	    /**
	     * Indicates an altitude mode always on the terrain.
	     * @constant
	     */
	    CLAMP_TO_GROUND: "clampToGround",

	    /**
	     * The radius of Earth.
	     * @constant
	     */
	    EARTH_RADIUS: 6371e3,

	    /**
	     * Indicates the cardinal direction east.
	     * @constant
	     */
	    EAST: "east",

	    /**
	     * The ENDED gesture recognizer state. Continuous gesture recognizers transition to this state from either
	     * the BEGAN state or the CHANGED state when the current input no longer represents the gesture.
	     * @constant
	     */
	    ENDED: "ended",

	    /**
	     * The FAILED gesture recognizer state. Gesture recognizers transition to this state from the POSSIBLE state
	     * when the gesture cannot be recognized given the current input.
	     * @constant
	     */
	    FAILED: "failed",

	    /**
	     * Indicates a great circle path.
	     * @constant
	     */
	    GREAT_CIRCLE: "greatCircle",

	    /**
	     * Indicates a linear, straight line path.
	     * @constant
	     */
	    LINEAR: "linear",

	    /**
	     * Indicates a multi-point shape, typically within a shapefile.
	     */
	    MULTI_POINT: "multiPoint",

	    /**
	     * Indicates the cardinal direction north.
	     * @constant
	     */
	    NORTH: "north",

	    /**
	     * Indicates a null shape, typically within a shapefile.
	     * @constant
	     */
	    NULL: "null",

	    /**
	     * Indicates that the associated parameters are fractional values of the virtual rectangle's width or
	     * height in the range [0, 1], where 0 indicates the rectangle's origin and 1 indicates the corner
	     * opposite its origin.
	     * @constant
	     */
	    OFFSET_FRACTION: "fraction",

	    /**
	     * Indicates that the associated parameters are in units of pixels relative to the virtual rectangle's
	     * corner opposite its origin corner.
	     * @constant
	     */
	    OFFSET_INSET_PIXELS: "insetPixels",

	    /**
	     * Indicates that the associated parameters are in units of pixels relative to the virtual rectangle's
	     * origin.
	     * @constant
	     */
	    OFFSET_PIXELS: "pixels",

	    /**
	     * Indicates a point shape, typically within a shapefile.
	     */
	    POINT: "point",

	    /**
	     * Indicates a polyline shape, typically within a shapefile.
	     */
	    POLYLINE: "polyline",

	    /**
	     * Indicates a polygon shape, typically within a shapefile.
	     */
	    POLYGON: "polygon",

	    /**
	     * The POSSIBLE gesture recognizer state. Gesture recognizers in this state are idle when there is no input
	     * event to evaluate, or are evaluating input events to determine whether or not to transition into another
	     * state.
	     * @constant
	     */
	    POSSIBLE: "possible",

	    /**
	     * The RECOGNIZED gesture recognizer state. Discrete gesture recognizers transition to this state from the
	     * POSSIBLE state when the gesture is recognized.
	     * @constant
	     */
	    RECOGNIZED: "recognized",

	    /**
	     * The event name of World Wind redraw events.
	     */
	    REDRAW_EVENT_TYPE: "WorldWindRedraw",

	    /**
	     * Indicates that the related value is specified relative to the globe.
	     * @constant
	     */
	    RELATIVE_TO_GLOBE: "relativeToGlobe",

	    /**
	     * Indicates an altitude mode relative to the terrain.
	     * @constant
	     */
	    RELATIVE_TO_GROUND: "relativeToGround",

	    /**
	     * Indicates that the related value is specified relative to the plane of the screen.
	     * @constant
	     */
	    RELATIVE_TO_SCREEN: "relativeToScreen",

	    /**
	     * Indicates a rhumb path -- a path of constant bearing.
	     * @constant
	     */
	    RHUMB_LINE: "rhumbLine",

	    /**
	     * Indicates the cardinal direction south.
	     * @constant
	     */
	    SOUTH: "south",

	    /**
	     * Indicates the cardinal direction west.
	     * @constant
	     */
	    WEST: "west"
	};





/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(43);
	__webpack_require__(44);
	__webpack_require__(48);
	__webpack_require__(56);
	__webpack_require__(59);
	__webpack_require__(71);
	__webpack_require__(96);

/***/ }),
/* 43 */
/***/ (function(module, exports) {

	
	String.prototype.format = String.prototype.f = function() {
	    var args = arguments;
	    return this.replace(/\{(\d+)\}/g, function(m,n){
	        return args[n] ? args[n] : m;
	    });
	};




/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

	// compass
	window.WorldWind.Offset = __webpack_require__(45);

	// Location.js:882
	window.WorldWind.Position = __webpack_require__(47);



/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports Offset
	 * @version $Id: Offset.js 2958 2015-04-01 23:25:29Z tgaskins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(46)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Vec2) {
	        "use strict";

	        /**
	         * Constructs an offset instance given specified units and offsets.
	         * @alias Offset
	         * @constructor
	         * @classdesc Specifies an offset relative to a rectangle. Used by [Placemark]{@link Placemark} and
	         * other shapes.
	         * @param {String} xUnits The type of units specified for the X dimension. May be one of the following:
	         * <ul>
	         *     <li>[WorldWind.OFFSET_FRACTION]{@link WorldWind#OFFSET_FRACTION}</li>
	         *     <li>[WorldWind.OFFSET_INSET_PIXELS]{@link WorldWind#OFFSET_INSET_PIXELS}</li>
	         *     <li>[WorldWind.OFFSET_PIXELS]{@link WorldWind#OFFSET_PIXELS}</li>
	         * </ul>
	         * @param {Number} x The offset in the X dimension.
	         * @param {String} yUnits The type of units specified for the Y dimension, assuming a lower-left Y origin.
	         * May be one of the following:
	         * <ul>
	         *     <li>[WorldWind.OFFSET_FRACTION]{@link WorldWind#OFFSET_FRACTION}</li>
	         *     <li>[WorldWind.OFFSET_INSET_PIXELS]{@link WorldWind#OFFSET_INSET_PIXELS}</li>
	         *     <li>[WorldWind.OFFSET_PIXELS]{@link WorldWind#OFFSET_PIXELS}</li>
	         * </ul>
	         * @param {Number} y The offset in the Y dimension.
	         */
	        var Offset = function (xUnits, x, yUnits, y) {

	            /**
	             * The offset in the X dimension, interpreted according to this instance's xUnits argument.
	             * @type {Number}
	             */
	            this.x = x;

	            /**
	             * The offset in the Y dimension, interpreted according to this instance's yUnits argument.
	             * @type {Number}
	             */
	            this.y = y;

	            /**
	             * The units of this instance's X offset. See this class' constructor description for a list of the
	             * possible values.
	             * @type {String}
	             */
	            this.xUnits = xUnits;

	            /**
	             * The units of this instance's Y offset. See this class' constructor description for a list of the
	             * possible values.
	             * @type {String}
	             */
	            this.yUnits = yUnits;
	        };

	        /**
	         * Creates a new copy of this offset with identical property values.
	         * @returns {Offset} A new offset instance with its property values the same as this one's.
	         */
	        Offset.prototype.clone = function () {
	            return new Offset(this.xUnits, this.x, this.yUnits, this.y);
	        };

	        /**
	         * Returns this offset's absolute X and Y coordinates in pixels for a rectangle of a specified size in pixels.
	         * The returned offset is in pixels relative to the rectangle's origin, and is defined in the coordinate
	         * system used by the caller.
	         * @param {Number} width The rectangle's width in pixels.
	         * @param {Number} height The rectangles height in pixels.
	         * @returns {Vec2} The computed offset relative to the rectangle's origin.
	         */
	        Offset.prototype.offsetForSize = function (width, height) {
	            var x, y;

	            if (this.xUnits == WorldWind.OFFSET_FRACTION) {
	                x = width * this.x;
	            } else if (this.xUnits == WorldWind.OFFSET_INSET_PIXELS) {
	                x = width - this.x;
	            } else { // default to OFFSET_PIXELS
	                x = this.x;
	            }

	            if (this.yUnits == WorldWind.OFFSET_FRACTION) {
	                y = height * this.y;
	            } else if (this.yUnits == WorldWind.OFFSET_INSET_PIXELS) {
	                y = height - this.y;
	            } else { // default to OFFSET_PIXELS
	                y = this.y;
	            }

	            return new Vec2(x, y);
	        };

	        /**
	         * Returns a string representation of this object.
	         * @returns {String} A string representation of this object.
	         */
	        Offset.prototype.toString = function () {
	            return this.xUnits + " " + this.x + " " + this.yUnits + " " + this.y;
	        };

	        return Offset;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @version $Id: Vec2.js 2946 2015-03-31 20:37:33Z dcollins $
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(32),
	        __webpack_require__(30),
	        __webpack_require__(35)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Logger,
	              ArgumentError,
	              Vec3) {
	        "use strict";

	        /**
	         * Constructs a two-component vector.
	         * @alias Vec2
	         * @classdesc Represents a two-component vector. Access the X component of the vector as v[0] and the Y
	         * component as v[1].
	         * @augments Float64Array
	         * @param {Number} x X component of vector.
	         * @param {Number} y Y component of vector.
	         * @constructor
	         */
	        var Vec2 = function Vec2(x, y) {
	            this[0] = x;
	            this[1] = y;
	        };

	        // Vec2 inherits from Float64Array.
	        Vec2.prototype = new Float64Array(2);

	        /**
	         * Assigns the components of this vector.
	         * @param {Number} x The X component of the vector.
	         * @param {Number} y The Y component of the vector.
	         * @returns {Vec2} This vector with the specified components assigned.
	         */
	        Vec2.prototype.set = function (x, y) {
	            this[0] = x;
	            this[1] = y;

	            return this;
	        };

	        /**
	         * Copies the components of a specified vector to this vector.
	         * @param {Vec2} vector The vector to copy.
	         * @returns {Vec2} This vector set to the values of the specified vector.
	         * @throws {ArgumentError} If the specified vector is null or undefined.
	         */
	        Vec2.prototype.copy = function (vector) {
	            if (!vector) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Vec2", "copy", "missingVector"));
	            }

	            this[0] = vector[0];
	            this[1] = vector[1];

	            return this;
	        };

	        /**
	         * Indicates whether the X and Y components of this vector are identical to those of a specified vector.
	         * @param {Vec2} vector The vector to test.
	         * @returns {Boolean} true if this vector's components are equal to those of the specified vector,
	         * otherwise false.
	         */
	        Vec2.prototype.equals = function (vector) {
	            return this[0] === vector[0] && this[1] === vector[1];
	        };

	        /**
	         * Computes the average of a specified array of vectors.
	         * @param {Vec2[]} vectors The vectors whose average to compute.
	         * @param {Vec2} result A pre-allocated Vec2 in which to return the computed average.
	         * @returns {Vec2} The result argument set to the average of the specified lists of vectors.
	         * @throws {ArgumentError} If the specified array of vectors is null, undefined or empty, or the specified
	         * result argument is null or undefined.
	         */
	        Vec2.average = function (vectors, result) {
	            if (!vectors || vectors.length < 1) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Vec2", "average", "missingArray"));
	            }

	            if (!result) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Vec2", "average", "missingResult"));
	            }

	            var count = vectors.length,
	                vec;

	            result[0] = 0;
	            result[1] = 0;

	            for (var i = 0, len = vectors.length; i < len; i++) {
	                vec = vectors[i];

	                result[0] += vec[0] / count;
	                result[1] += vec[1] / count;
	            }

	            return result;
	        };

	        /**
	         * Adds a vector to this vector.
	         * @param {Vec2} addend The vector to add to this one.
	         * @returns {Vec2} This vector after adding the specified vector to it.
	         * @throws {ArgumentError} If the specified addend is null or undefined.
	         */
	        Vec2.prototype.add = function (addend) {
	            if (!addend) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Vec2", "add", "missingVector"));
	            }

	            this[0] += addend[0];
	            this[1] += addend[1];

	            return this;
	        };

	        /**
	         * Subtracts a vector from this vector.
	         * @param {Vec2} subtrahend The vector to subtract from this one.
	         * @returns {Vec2} This vector after subtracting the specified vector from it.
	         * @throws {ArgumentError} If the subtrahend is null or undefined.
	         */
	        Vec2.prototype.subtract = function (subtrahend) {
	            if (!subtrahend) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Vec2", "subtract", "missingVector"));
	            }

	            this[0] -= subtrahend[0];
	            this[1] -= subtrahend[1];

	            return this;
	        };

	        /**
	         * Multiplies this vector by a scalar.
	         * @param {Number} scalar The scalar to multiply this vector by.
	         * @returns {Vec2} This vector multiplied by the specified scalar.
	         */
	        Vec2.prototype.multiply = function (scalar) {
	            this[0] *= scalar;
	            this[1] *= scalar;

	            return this;
	        };

	        /**
	         * Divide this vector by a scalar.
	         * @param {Number} divisor The scalar to divide this vector by.
	         * @returns {Vec2} This vector divided by the specified scalar.
	         */
	        Vec2.prototype.divide = function (divisor) {
	            this[0] /= divisor;
	            this[1] /= divisor;

	            return this;
	        };

	        /**
	         * Mixes (interpolates) a specified vector with this vector, modifying this vector.
	         * @param {Vec2} vector The vector to mix.
	         * @param {Number} weight The relative weight of this vector.
	         * @returns {Vec2} This vector modified to the mix of itself and the specified vector.
	         * @throws {ArgumentError} If the specified vector is null or undefined.
	         */
	        Vec2.prototype.mix = function (vector, weight) {
	            if (!vector) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Vec2", "mix", "missingVector"));
	            }

	            var w0 = 1 - weight,
	                w1 = weight;

	            this[0] = this[0] * w0 + vector[0] * w1;
	            this[1] = this[1] * w0 + vector[1] * w1;

	            return this;
	        };

	        /**
	         * Negates this vector.
	         * @returns {Vec2} This vector, negated.
	         */
	        Vec2.prototype.negate = function () {
	            this[0] = -this[0];
	            this[1] = -this[1];

	            return this;
	        };

	        /**
	         * Computes the scalar dot product of this vector and a specified vector.
	         * @param {Vec2} vector The vector to multiply.
	         * @returns {Number} The scalar dot product of the vectors.
	         * @throws {ArgumentError} If the specified vector is null or undefined.
	         */
	        Vec2.prototype.dot = function (vector) {
	            if (!vector) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Vec2", "dot", "missingVector"));
	            }

	            return this[0] * vector[0] + this[1] * vector[1];
	        };

	        /**
	         * Computes the squared magnitude of this vector.
	         * @returns {Number} The squared magnitude of this vector.
	         */
	        Vec2.prototype.magnitudeSquared = function () {
	            return this.dot(this);
	        };

	        /**
	         * Computes the magnitude of this vector.
	         * @returns {Number} The magnitude of this vector.
	         */
	        Vec2.prototype.magnitude = function () {
	            return Math.sqrt(this.magnitudeSquared());
	        };

	        /**
	         * Normalizes this vector to a unit vector.
	         * @returns {Vec2} This vector, normalized.
	         */
	        Vec2.prototype.normalize = function () {
	            var magnitude = this.magnitude(),
	                magnitudeInverse = 1 / magnitude;

	            this[0] *= magnitudeInverse;
	            this[1] *= magnitudeInverse;

	            return this;
	        };

	        /**
	         * Computes the squared distance from this vector to a specified vector.
	         * @param {Vec2} vector The vector to compute the distance to.
	         * @returns {Number} The squared distance between the vectors.
	         * @throws {ArgumentError} If the specified vector is null or undefined.
	         */
	        Vec2.prototype.distanceToSquared = function (vector) {
	            if (!vector) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Vec2", "distanceToSquared", "missingVector"));
	            }

	            var dx = this[0] - vector[0],
	                dy = this[1] - vector[1];

	            return dx * dx + dy * dy;
	        };

	        /**
	         * Computes the distance from this vector to a specified vector.
	         * @param {Vec2} vector The vector to compute the distance to.
	         * @returns {Number} The distance between the vectors.
	         * @throws {ArgumentError} If the specified vector is null or undefined.
	         */
	        Vec2.prototype.distanceTo = function (vector) {
	            if (!vector) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Vec2", "distanceTo", "missingVector"));
	            }

	            return Math.sqrt(this.distanceToSquared(vector));
	        };

	        /**
	         * Creates a {@link Vec3} using this vector's X and Y components and a Z component of 0.
	         * @returns {Vec3} A new vector whose X and Y components are those of this vector and whose Z component is 0.
	         */
	        Vec2.prototype.toVec3 = function () {
	            return new Vec3(this[0], this[1], 0);
	        };

	        /**
	         * Swaps the components of this vector with those of another vector. This vector is set to the values of the
	         * specified vector, and the specified vector's components are set to the values of this vector.
	         * @param {Vec2} that The vector to swap.
	         * @returns {Vec2} This vector set to the values of the specified vector.
	         */
	        Vec2.prototype.swap = function (that) {
	            var tmp = this[0];
	            this[0] = that[0];
	            that[0] = tmp;

	            tmp = this[1];
	            this[1] = that[1];
	            that[1] = tmp;

	            return this;
	        };

	        /**
	         * Returns a string representation of this vector.
	         * @returns {String} A string representation of this vector, in the form "(x, y)".
	         */
	        Vec2.prototype.toString = function () {
	            return "(" + this[0] + ", " + this[1] + ")";
	        };

	        return Vec2;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports Position
	 * @version $Id: Position.js 2933 2015-03-27 01:18:24Z tgaskins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(29),
	        __webpack_require__(30),
	        __webpack_require__(28),
	        __webpack_require__(32),
	        __webpack_require__(36)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Angle,
	              ArgumentError,
	              Location,
	              Logger,
	              WWMath) {
	        "use strict";

	        /**
	         * Constructs a position from a specified latitude and longitude in degrees and altitude in meters.
	         * @alias Position
	         * @constructor
	         * @classdesc Represents a latitude, longitude, altitude triple, with latitude and longitude in degrees and
	         * altitude in meters.
	         * @param {Number} latitude The latitude in degrees.
	         * @param {Number} longitude The longitude in degrees.
	         * @param {Number} altitude The altitude in meters.
	         */
	        var Position = function (latitude, longitude, altitude) {
	            /**
	             * The latitude in degrees.
	             * @type {Number}
	             */
	            this.latitude = latitude;
	            /**
	             * The longitude in degrees.
	             * @type {Number}
	             */
	            this.longitude = longitude;
	            /**
	             * The altitude in meters.
	             * @type {Number}
	             */
	            this.altitude = altitude;
	        };

	        /**
	         * A Position with latitude, longitude and altitude all 0.
	         * @constant
	         * @type {Position}
	         */
	        Position.ZERO = new Position(0, 0, 0);

	        /**
	         * Creates a position from angles specified in radians.
	         * @param {Number} latitudeRadians The latitude in radians.
	         * @param {Number} longitudeRadians The longitude in radians.
	         * @param {Number} altitude The altitude in meters.
	         * @returns {Position} The new position with latitude and longitude in degrees.
	         */
	        Position.fromRadians = function (latitudeRadians, longitudeRadians, altitude) {
	            return new Position(
	                latitudeRadians * Angle.RADIANS_TO_DEGREES,
	                longitudeRadians * Angle.RADIANS_TO_DEGREES,
	                altitude);
	        };

	        /**
	         * Sets this position to the latitude, longitude and altitude of a specified position.
	         * @param {Position} position The position to copy.
	         * @returns {Position} This position, set to the values of the specified position.
	         * @throws {ArgumentError} If the specified position is null or undefined.
	         */
	        Position.prototype.copy = function (position) {
	            if (!position) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Position", "copy", "missingPosition"));
	            }

	            this.latitude = position.latitude;
	            this.longitude = position.longitude;
	            this.altitude = position.altitude;

	            return this;
	        };

	        /**
	         * Indicates whether this position has the same latitude, longitude and altitude as a specified position.
	         * @param {Position} position The position to compare with this one.
	         * @returns {Boolean} true if this position is equal to the specified one, otherwise false.
	         */
	        Position.prototype.equals = function (position) {
	            return position
	                && position.latitude === this.latitude
	                && position.longitude === this.longitude
	                && position.altitude === this.altitude;
	        };

	        /**
	         * Computes a position along a great circle path at a specified distance between two specified positions.
	         * @param {Number} amount The fraction of the path between the two positions at which to compute the new
	         * position. This number should be between 0 and 1. If not, it is clamped to the nearest of those values.
	         * @param {Position} position1 The starting position.
	         * @param {Position} position2 The ending position.
	         * @param {Position} result A Position in which to return the result.
	         * @returns {Position} The specified result position.
	         * @throws {ArgumentError} If either specified position or the result argument is null or undefined.
	         */
	        Position.interpolateGreatCircle = function (amount, position1, position2, result) {
	            if (!position1 || !position2) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Position", "interpolateGreatCircle", "missingPosition"));
	            }

	            if (!result) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Position", "interpolateGreatCircle", "missingResult"));
	            }

	            var t = WWMath.clamp(amount, 0, 1);
	            result.altitude = WWMath.interpolate(t, position1.altitude, position2.altitude);

	            //noinspection JSCheckFunctionSignatures
	            Location.interpolateGreatCircle(t, position1, position2, result);

	            return result;
	        };

	        /**
	         * Computes a position along a rhumb path at a specified distance between two specified positions.
	         * @param {Number} amount The fraction of the path between the two positions at which to compute the new
	         * position. This number should be between 0 and 1. If not, it is clamped to the nearest of those values.
	         * @param {Position} position1 The starting position.
	         * @param {Position} position2 The ending position.
	         * @param {Position} result A Position in which to return the result.
	         * @returns {Position} The specified result position.
	         * @throws {ArgumentError} If either specified position or the result argument is null or undefined.
	         */
	        Position.interpolateRhumb = function (amount, position1, position2, result) {
	            if (!position1 || !position2) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Position", "interpolateRhumb", "missingPosition"));
	            }

	            if (!result) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Position", "interpolateRhumb", "missingResult"));
	            }

	            var t = WWMath.clamp(amount, 0, 1);
	            result.altitude = WWMath.interpolate(t, position1.altitude, position2.altitude);

	            //noinspection JSCheckFunctionSignatures
	            Location.interpolateRhumb(t, position1, position2, result);

	            return result;
	        };

	        /**
	         * Computes a position along a linear path at a specified distance between two specified positions.
	         * @param {Number} amount The fraction of the path between the two positions at which to compute the new
	         * position. This number should be between 0 and 1. If not, it is clamped to the nearest of those values.
	         * @param {Position} position1 The starting position.
	         * @param {Position} position2 The ending position.
	         * @param {Position} result A Position in which to return the result.
	         * @returns {Position} The specified result position.
	         * @throws {ArgumentError} If either specified position or the result argument is null or undefined.
	         */
	        Position.interpolateLinear = function (amount, position1, position2, result) {
	            if (!position1 || !position2) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Position", "interpolateLinear", "missingPosition"));
	            }

	            if (!result) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Position", "interpolateLinear", "missingResult"));
	            }

	            var t = WWMath.clamp(amount, 0, 1);
	            result.altitude = WWMath.interpolate(t, position1.altitude, position2.altitude);

	            //noinspection JSCheckFunctionSignatures
	            Location.interpolateLinear(t, position1, position2, result);

	            return result;
	        };

	        /**
	         * Returns a string representation of this position.
	         * @returns {String}
	         */
	        Position.prototype.toString = function () {
	            return "(" + this.latitude.toString() + "\u00b0, " + this.longitude.toString() + "\u00b0, "
	                + this.altitude.toString() + ")";
	        };

	        return Position;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

	

	var GpuResourceCache = __webpack_require__(49);
	var Logger = __webpack_require__(32);
	var CubeMap = __webpack_require__(55);

	/**
	 * Retrieves the textures for a cube map and puts them in an array.
	 * The images are ordered [posX, negX, posY, negY, posZ, negZ].
	 * @param {WebGLRenderingContext} gl The current WebGL context.
	 * @param {Object} imageSources The image sources.
	 */
	GpuResourceCache.prototype.retrieveCubeMapTextures = function (gl, imageSources) {


	    if (!imageSources) {
	        return null;
	    }

	    if (this.currentRetrievals[imageSources.posX] ||
	        this.absentResourceList.isResourceAbsent(imageSources.posX)) {
	        return null;
	    }

	    var self = this;
	    var images = [];
	    var count = 0;

	    this.retrieveCubeMapTexture(imageSources.posX, 0, images, textureLoaded);
	    this.retrieveCubeMapTexture(imageSources.negX, 1, images, textureLoaded);
	    this.retrieveCubeMapTexture(imageSources.posY, 2, images, textureLoaded);
	    this.retrieveCubeMapTexture(imageSources.negY, 3, images, textureLoaded);
	    this.retrieveCubeMapTexture(imageSources.posZ, 4, images, textureLoaded);
	    this.retrieveCubeMapTexture(imageSources.negZ, 5, images, textureLoaded);

	    function textureLoaded(images) {
	        count++;
	        if (count === 6) {
	            var textureCube = new CubeMap(gl, images);
	            self.putResource(imageSources.posX, textureCube, textureCube.size);
	            var e = document.createEvent('Event');
	            e.initEvent(WorldWind.REDRAW_EVENT_TYPE, true, true);
	            window.dispatchEvent(e);
	        }
	    }

	    return null;
	};

	/**
	 * Retrieves one texture of a cube map.
	 * @param {URL} imageSource The url for the image.
	 * @param {Number} index The index where to put the image in the array.
	 * @param {Image[]} images Array of images.
	 * @param {Function} cb A callback function to call when the image is retrieved.
	 */
	GpuResourceCache.prototype.retrieveCubeMapTexture = function (imageSource, index, images, cb) {
	    var self = this;
	    var image = new Image();

	    if (this.currentRetrievals[imageSource] || this.absentResourceList.isResourceAbsent(imageSource)) {
	        return null;
	    }

	    image.onload = function () {
	        Logger.log(Logger.LEVEL_INFO, "Image retrieval succeeded: " + imageSource);

	        delete self.currentRetrievals[imageSource];
	        self.absentResourceList.unmarkResourceAbsent(imageSource);

	        images[index] = image;
	        cb(images);
	    };

	    image.onerror = function () {
	        delete self.currentRetrievals[imageSource];
	        self.absentResourceList.markResourceAbsent(imageSource);
	        Logger.log(Logger.LEVEL_WARNING, "Image retrieval failed: " + imageSource);
	        images[index] = null;
	        cb(images);
	    };

	    image.crossOrigin = 'anonymous';
	    image.src = imageSource;
	    this.currentRetrievals[imageSource] = imageSource;

	    return null;
	};


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports GpuResourceCache
	 * @version $Id: GpuResourceCache.js 3023 2015-04-15 20:24:17Z tgaskins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(50),
	        __webpack_require__(30),
	        __webpack_require__(51),
	        __webpack_require__(32),
	        __webpack_require__(53),
	        __webpack_require__(54)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (AbsentResourceList,
	              ArgumentError,
	              ImageSource,
	              Logger,
	              MemoryCache,
	              Texture) {
	        "use strict";

	        /**
	         * Constructs a GPU resource cache for a specified size and low-water value.
	         * @alias GpuResourceCache
	         * @constructor
	         * @classdesc Maintains a cache of GPU resources such as textures and GLSL programs.
	         * Applications typically do not interact with this class unless they create their own shapes.
	         * @param {Number} capacity The cache capacity, in bytes.
	         * @param {Number} lowWater The number of bytes to clear the cache to when it exceeds its capacity.
	         * @throws {ArgumentError} If the specified capacity is undefined, 0 or negative or the low-water value is
	         * undefined, negative or not less than the capacity.
	         */
	        var GpuResourceCache = function (capacity, lowWater) {
	            if (!capacity || capacity < 1) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "GpuResourceCache", "constructor",
	                        "Specified cache capacity is undefined, 0 or negative."));
	            }

	            if (!lowWater || lowWater < 0 || lowWater >= capacity) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "GpuResourceCache", "constructor",
	                        "Specified cache low-water value is undefined, negative or not less than the capacity."));
	            }

	            // Private. Holds the actual cache entries.
	            this.entries = new MemoryCache(capacity, lowWater);

	            // Private. Counter for generating cache keys.
	            this.cacheKeyPool = 0;

	            // Private. List of retrievals currently in progress.
	            this.currentRetrievals = {};

	            // Private. Identifies requested resources that whose retrieval failed.
	            this.absentResourceList = new AbsentResourceList(3, 60e3);
	        };

	        Object.defineProperties(GpuResourceCache.prototype, {
	            /**
	             * Indicates the capacity of this cache in bytes.
	             * @type {Number}
	             * @readonly
	             * @memberof GpuResourceCache.prototype
	             */
	            capacity: {
	                get: function () {
	                    return this.entries.capacity;
	                }
	            },

	            /**
	             * Indicates the low-water value for this cache in bytes, the size this cache is cleared to when it
	             * exceeds its capacity.
	             * @type {Number}
	             * @readonly
	             * @memberof GpuResourceCache.prototype
	             */
	            lowWater: {
	                get: function () {
	                    return this.entries.lowWater;
	                }
	            },

	            /**
	             * Indicates the number of bytes currently used by this cache.
	             * @type {Number}
	             * @readonly
	             * @memberof GpuResourceCache.prototype
	             */
	            usedCapacity: {
	                get: function () {
	                    return this.entries.usedCapacity;
	                }
	            },

	            /**
	             * Indicates the number of free bytes in this cache.
	             * @type {Number}
	             * @readonly
	             * @memberof GpuResourceCache.prototype
	             */
	            freeCapacity: {
	                get: function () {
	                    return this.entries.freeCapacity;
	                }
	            }
	        });

	        /**
	         * Creates a cache key unique to this cache, typically for a resource about to be added to this cache.
	         * @returns {String} The generated cache key.
	         */
	        GpuResourceCache.prototype.generateCacheKey = function () {
	            return "GpuResourceCache " + ++this.cacheKeyPool;
	        };

	        /**
	         * Adds a specified resource to this cache. Replaces the existing resource for the specified key if the
	         * cache currently contains a resource for that key.
	         * @param {String|ImageSource} key The key or image source of the resource to add.
	         * @param {Object} resource The resource to add to the cache.
	         * @param {Number} size The resource's size in bytes. Must be greater than 0.
	         * @throws {ArgumentError} If either the key or resource arguments is null or undefined
	         * or if the specified size is less than 1.
	         */
	        GpuResourceCache.prototype.putResource = function (key, resource, size) {
	            if (!key) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "GpuResourceCache", "putResource", "missingKey."));
	            }

	            if (!resource) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "GpuResourceCache", "putResource", "missingResource."));
	            }

	            if (!size || size < 1) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "GpuResourceCache", "putResource",
	                        "The specified resource size is undefined or less than 1."));
	            }

	            var entry = {
	                resource: resource
	            };

	            this.entries.putEntry(key instanceof ImageSource ? key.key : key, entry, size);
	        };

	        /**
	         * Returns the resource associated with a specified key.
	         * @param {String|ImageSource} key The key or image source of the resource to find.
	         * @returns {Object} The resource associated with the specified key, or null if the resource is not in
	         * this cache or the specified key is null or undefined.
	         */
	        GpuResourceCache.prototype.resourceForKey = function (key) {
	            var entry = (key instanceof ImageSource)
	                ? this.entries.entryForKey(key.key) : this.entries.entryForKey(key);

	            return entry ? entry.resource : null;
	        };

	        /**
	         * Indicates whether a specified resource is in this cache.
	         * @param {String|ImageSource} key The key or image source of the resource to find.
	         * @returns {Boolean} true If the resource is in this cache, false if the resource
	         * is not in this cache or the specified key is null or undefined.
	         */
	        GpuResourceCache.prototype.containsResource = function (key) {
	            return this.entries.containsKey(key instanceof ImageSource ? key.key : key);
	        };

	        /**
	         * Removes the specified resource from this cache. The cache is not modified if the specified key is null or
	         * undefined or does not correspond to an entry in the cache.
	         * @param {String|ImageSource} key The key or image source of the resource to remove.
	         */
	        GpuResourceCache.prototype.removeResource = function (key) {
	            this.entries.removeEntry(key instanceof ImageSource ? key.key : key);
	        };

	        /**
	         * Removes all resources from this cache.
	         */
	        GpuResourceCache.prototype.clear = function () {
	            this.entries.clear(false);
	        };

	        /**
	         * Retrieves an image and adds it to this cache when it arrives. If the specified image source is a URL, a
	         * retrieval request for the image is made and this method returns immediately with a value of null. A redraw
	         * event is generated when the image subsequently arrives and is added to this cache. If the image source is an
	         * {@link ImageSource}, the image is used immediately and this method returns the {@link Texture} created and
	         * cached for the image. No redraw event is generated in this case.
	         * @param {WebGLRenderingContext} gl The current WebGL context.
	         * @param {String|ImageSource} imageSource The image source, either a {@link ImageSource} or a String
	         * giving the URL of the image.
	         * @param {GL.enum} wrapMode Optional. Specifies the wrap mode of the texture. Defaults to gl.CLAMP_TO_EDGE
	         * @returns {Texture} The {@link Texture} created for the image if the specified image source is an
	         * {@link ImageSource}, otherwise null.
	         */
	        GpuResourceCache.prototype.retrieveTexture = function (gl, imageSource, wrapMode) {
	            if (!imageSource) {
	                return null;
	            }

	            if (imageSource instanceof ImageSource) {
	                var t = new Texture(gl, imageSource.image, wrapMode);
	                this.putResource(imageSource.key, t, t.size);
	                return t;
	            }

	            if (this.currentRetrievals[imageSource] || this.absentResourceList.isResourceAbsent(imageSource)) {
	                return null;
	            }

	            var cache = this,
	                image = new Image();

	            image.onload = function () {
	                Logger.log(Logger.LEVEL_INFO, "Image retrieval succeeded: " + imageSource);

	                var texture = new Texture(gl, image, wrapMode);

	                cache.putResource(imageSource, texture, texture.size);

	                delete cache.currentRetrievals[imageSource];
	                cache.absentResourceList.unmarkResourceAbsent(imageSource);

	                // Send an event to request a redraw.
	                var e = document.createEvent('Event');
	                e.initEvent(WorldWind.REDRAW_EVENT_TYPE, true, true);
	                window.dispatchEvent(e);
	            };

	            image.onerror = function () {
	                delete cache.currentRetrievals[imageSource];
	                cache.absentResourceList.markResourceAbsent(imageSource);
	                Logger.log(Logger.LEVEL_WARNING, "Image retrieval failed: " + imageSource);
	            };

	            this.currentRetrievals[imageSource] = imageSource;
	            image.crossOrigin = 'anonymous';
	            image.src = imageSource;

	            return null;
	        };

	        return GpuResourceCache;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports AbsentResourceList
	 * @version $Id: AbsentResourceList.js 2952 2015-04-01 00:33:54Z tgaskins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	        "use strict";

	        /**
	         * Constructs an absent resource list.
	         * @alias AbsentResourceList
	         * @constructor
	         * @classdesc Provides a collection to keep track of resources whose retrieval failed and when retrieval
	         * may be tried again. Applications typically do not use this class directly.
	         * @param {Number} maxTrys The number of attempts to make before the resource is marked as absent.
	         * @param {Number} minCheckInterval The amount of time to wait between attempts, in milliseconds.
	         * @constructor
	         */
	        var AbsentResourceList = function (maxTrys, minCheckInterval) {

	            /**
	             * The number  of attempts to make before the resource is marked as absent.
	             * @type {Number}
	             */
	            this.maxTrys = maxTrys;

	            /**
	             * The amount of time to wait before each attempt.
	             * @type {Number}
	             */
	            this.minCheckInterval = minCheckInterval;

	            /**
	             * The amount of time, in milliseconds, beyond which retrieval attempts should again be allowed.
	             * When this time has elapsed from the most recent failed attempt the number of trys attempted is
	             * reset to 0. This prevents the resource from being permanently blocked.
	             * @type {number}
	             * @default 60,000 milliseconds (one minute)
	             */
	            this.tryAgainInterval = 60e3; // 60 seconds

	            this.possiblyAbsent = {};
	        };

	        /**
	         * Indicates whether a specified resource is marked as absent.
	         * @param {String} resourceId The resource identifier.
	         * @returns {Boolean} true if the resource is marked as absent, otherwise false.
	         */
	        AbsentResourceList.prototype.isResourceAbsent = function (resourceId) {
	            var entry = this.possiblyAbsent[resourceId];

	            if (!entry) {
	                return false;
	            }

	            if (entry.permanent) {
	                return true;
	            }

	            var timeSinceLastMark = Date.now() - entry.timeOfLastMark;

	            if (timeSinceLastMark > this.tryAgainInterval) {
	                delete this.possiblyAbsent[resourceId];
	                return false;
	            }

	            return timeSinceLastMark < this.minCheckInterval || entry.numTrys > this.maxTrys;
	        };

	        /**
	         * Marks a resource attempt as having failed. This increments the number-of-tries counter and sets the time
	         * of the last attempt. When this method has been called [this.maxTrys]{@link AbsentResourceList#maxTrys}
	         * times the resource is marked as absent until this absent resource list's
	         * [try-again-interval]{@link AbsentResourceList#tryAgainInterval} is reached.
	         * @param {String} resourceId The resource identifier.
	         */
	        AbsentResourceList.prototype.markResourceAbsent = function (resourceId) {
	            var entry = this.possiblyAbsent[resourceId];

	            if (!entry) {
	                entry = {
	                    timeOfLastMark: Date.now(),
	                    numTrys: 0
	                };
	                this.possiblyAbsent[resourceId] = entry;
	            }

	            entry.numTrys = entry.numTrys + 1;
	            entry.timeOfLastMark = Date.now();
	        };

	        /**
	         * Marks a resource attempt as having failed permanently. No attempt will ever again be made to retrieve
	         * the resource.
	         * @param {String} resourceId The resource identifier.
	         */
	        AbsentResourceList.prototype.markResourceAbsentPermanently = function (resourceId) {
	            var entry = this.possiblyAbsent[resourceId];

	            if (!entry) {
	                entry = {
	                    timeOfLastMark: Date.now(),
	                    numTrys: 0
	                };
	                this.possiblyAbsent[resourceId] = entry;
	            }

	            entry.numTrys = entry.numTrys + 1;
	            entry.timeOfLastMark = Date.now();
	            entry.permanent = true;
	        };

	        /**
	         * Removes the specified resource from this absent resource list. Call this method when retrieval attempts
	         * succeed.
	         * @param {String} resourceId The resource identifier.
	         */
	        AbsentResourceList.prototype.unmarkResourceAbsent = function (resourceId) {
	            var entry = this.possiblyAbsent[resourceId];

	            if (entry) {
	                delete this.possiblyAbsent[resourceId];
	            }
	        };

	        return AbsentResourceList;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2015 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports ImageSource
	 * @version $Id: ImageSource.js 3023 2015-04-15 20:24:17Z tgaskins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(30),
	        __webpack_require__(52),
	        __webpack_require__(32)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
	              Color,
	              Logger) {
	        "use strict";

	        /**
	         * Constructs an image source.
	         * @alias ImageSource
	         * @constructor
	         * @classdesc Holds an Image with an associated key that uniquely identifies that image. The key is
	         * automatically generated but may be reassigned after construction. Instances of this class are used to
	         * specify dynamically created image sources for {@link Placemark}, {@link SurfaceImage},
	         * {@link Polygon} textures and other shapes that display imagery.
	         * @param {Image} image The image for this image source.
	         * @throws {ArgumentError} If the specified image is null or undefined.
	         */
	        var ImageSource = function (image) {
	            if (!image) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "ImageSource", "constructor",
	                    "missingImage"));
	            }

	            /**
	             * This image source's image
	             * @type {Image}
	             * @readonly
	             */
	            this.image = image;

	            /**
	             * This image source's key. A unique key is automatically generated and assigned during construction.
	             * Applications may assign a different key after construction.
	             * @type {String}
	             * @default A unique string for this image source.
	             */
	            this.key = "ImageSource " + ++ImageSource.keyPool;
	        };

	        // Internal. Intentionally not documented.
	        ImageSource.keyPool = 0; // source of unique ids

	        return ImageSource;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports Color
	 * @version $Id: Color.js 3017 2015-04-14 17:10:31Z dcollins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(32)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Logger) {
	        "use strict";

	        /**
	         * Constructs a color from red, green, blue and alpha values.
	         * @alias Color
	         * @constructor
	         * @classdesc Represents a red, green, blue, alpha, color.
	         * @param {Number} red The red component, a number between 0 and 1.
	         * @param {Number} green The green component, a number between 0 and 1.
	         * @param {Number} blue The blue component, a number between 0 and 1.
	         * @param {Number} alpha The alpha component, a number between 0 and 1.
	         */
	        var Color = function (red, green, blue, alpha) {

	            /**
	             * This color's red component, a number between 0 and 1.
	             * @type {Number}
	             */
	            this.red = red;

	            /**
	             * This color's green component, a number between 0 and 1.
	             * @type {Number}
	             */
	            this.green = green;

	            /**
	             * This color's blue component, a number between 0 and 1.
	             * @type {Number}
	             */
	            this.blue = blue;

	            /**
	             * This color's alpha component, a number between 0 and 1.
	             * @type {Number}
	             */
	            this.alpha = alpha;
	        };

	        /**
	         * The color white.
	         * @type {Color}
	         * @constant
	         */
	        Color.WHITE = new Color(1, 1, 1, 1);

	        /**
	         * The color black.
	         * @type {Color}
	         * @constant
	         */
	        Color.BLACK = new Color(0, 0, 0, 1);

	        /**
	         * The color red.
	         * @type {Color}
	         * @constant
	         */
	        Color.RED = new Color(1, 0, 0, 1);

	        /**
	         * The color green.
	         * @type {Color}
	         * @constant
	         */
	        Color.GREEN = new Color(0, 1, 0, 1);

	        /**
	         * The color blue.
	         * @type {Color}
	         * @constant
	         */
	        Color.BLUE = new Color(0, 0, 1, 1);

	        /**
	         * The color cyan.
	         * @type {Color}
	         * @constant
	         */
	        Color.CYAN = new Color(0, 1, 1, 1);

	        /**
	         * The color yellow.
	         * @type {Color}
	         * @constant
	         */
	        Color.YELLOW = new Color(1, 1, 0, 1);

	        /**
	         * The color magenta.
	         * @type {Color}
	         * @constant
	         */
	        Color.MAGENTA = new Color(1, 0, 1, 1);

	        /**
	         * A light gray (75% white).
	         * @type {Color}
	         */
	        Color.LIGHT_GRAY = new Color(0.75, 0.75, 0.75, 1);

	        /**
	         * A medium gray (50% white).
	         * @type {Color}
	         */
	        Color.MEDIUM_GRAY = new Color(0.5, 0.5, 0.5, 1);

	        /**
	         * A dark gray (25% white).
	         * @type {Color}
	         */
	        Color.DARK_GRAY = new Color(0.25, 0.25, 0.25, 1);

	        /**
	         * A transparent color.
	         * @type {Color}
	         */
	        Color.TRANSPARENT = new Color(0, 0, 0, 0);

	        /**
	         * Assigns the components of this color.
	         * @param {Number} red The red component, a number between 0 and 1.
	         * @param {Number} green The green component, a number between 0 and 1.
	         * @param {Number} blue The blue component, a number between 0 and 1.
	         * @param {Number} alpha The alpha component, a number between 0 and 1.
	         * @returns {Color} This color with the specified components assigned.
	         */
	        Color.prototype.set = function (red, green, blue, alpha) {
	            this.red = red;
	            this.green = green;
	            this.blue = blue;
	            this.alpha = alpha;

	            return this;
	        };

	        /**
	         * Copies the components of a specified color to this color.
	         * @param {Color} color The color to copy.
	         * @returns {Color} This color set to the red, green, blue and alpha values of the specified color.
	         * @throws {ArgumentError} If the specified color is null or undefined.
	         */
	        Color.prototype.copy = function (color) {
	            if (!color) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Color", "copy", "missingColor"));
	            }

	            this.red = color.red;
	            this.green = color.green;
	            this.blue = color.blue;
	            this.alpha = color.alpha;

	            return this;
	        };

	        /**
	         * Create a copy of this color.
	         * @returns {Color} A new instance containing the color components of this color.
	         */
	        Color.prototype.clone = function () {
	            return new Color(this.red, this.green, this.blue, this.alpha);
	        };

	        /**
	         * Returns this color's components premultiplied by this color's alpha component.
	         * @param {Float32Array} array A pre-allocated array in which to return the color components.
	         * @returns {Float32Array} This colors premultiplied components as an array, in the order RGBA.
	         */
	        Color.prototype.premultipliedComponents = function (array) {
	            var a = this.alpha;

	            array[0] = this.red * a;
	            array[1] = this.green * a;
	            array[2] = this.blue * a;
	            array[3] = a;

	            return array;
	        };

	        /**
	         * Construct a color from an array of color components expressed as byte values.
	         * @param {Uint8Array} bytes A four-element array containing the red, green, blue and alpha color
	         * components each in the range [0, 255];
	         * @returns {Color} The constructed color.
	         */
	        Color.colorFromByteArray = function (bytes) {
	            return new Color(bytes[0] / 255, bytes[1] / 255, bytes[2] / 255, bytes[3] / 255);
	        };

	        /**
	         * Construct a color from specified color components expressed as byte values.
	         * @param {number} redByte The red component in the range [0, 255].
	         * @param {number} greenByte The green component in the range [0, 255].
	         * @param {number} blueByte The blue component in the range [0, 255].
	         * @param {number} alphaByte The alpha component in the range [0, 255].
	         * @returns {Color} The constructed color.
	         */
	        Color.colorFromBytes = function (redByte, greenByte, blueByte, alphaByte) {
	            return new Color(redByte / 255, greenByte / 255, blueByte / 255, alphaByte / 255);
	        };

	        Color.colorFromHex = function(color) {
	            var red = parseInt(color.substring(0, 2), 16);
	            var green = parseInt(color.substring(2,4), 16);
	            var blue = parseInt(color.substring(4,6), 16);
	            var alpha = parseInt(color.substring(6,8), 16);
	            return Color.colorFromBytes(red, green, blue, alpha);
	        };

	        Color.colorFromKmlHex = function(color) {
	            color = color.split("").reverse().join("");
	            return Color.colorFromHex(color);
	        };

	        /**
	         * Computes and sets this color to the next higher RBG color. If the color overflows, this color is set to
	         * (1 / 255, 0, 0, *), where * indicates the current alpha value.
	         * @returns {Color} This color, set to the next possible color.
	         */
	        Color.prototype.nextColor = function () {
	            var rb = Math.round(this.red * 255),
	                gb = Math.round(this.green * 255),
	                bb = Math.round(this.blue * 255);

	            if (rb < 255) {
	                this.red = (rb + 1) / 255;
	            } else if (gb < 255) {
	                this.red = 0;
	                this.green = (gb + 1) / 255;
	            } else if (bb < 255) {
	                this.red = 0;
	                this.green = 0;
	                this.blue = (bb + 1) / 255;
	            } else {
	                this.red = 1 / 255;
	                this.green = 0;
	                this.blue = 0;
	            }

	            return this;
	        };

	        /**
	         * Indicates whether this color is equal to a specified color after converting the floating-point component
	         * values of each color to byte values.
	         * @param {Color} color The color to test,
	         * @returns {Boolean} true if the colors are equal, otherwise false.
	         */
	        Color.prototype.equals = function (color) {
	            var rbA = Math.round(this.red * 255),
	                gbA = Math.round(this.green * 255),
	                bbA = Math.round(this.blue * 255),
	                abA = Math.round(this.alpha * 255),
	                rbB = Math.round(color.red * 255),
	                gbB = Math.round(color.green * 255),
	                bbB = Math.round(color.blue * 255),
	                abB = Math.round(color.alpha * 255);

	            return rbA === rbB && gbA === gbB && bbA === bbB && abA === abB;
	        };

	        /**
	         * Indicates whether this color is equal to another color expressed as an array of bytes.
	         * @param {Uint8Array} bytes The red, green, blue and alpha color components.
	         * @returns {Boolean} true if the colors are equal, otherwise false.
	         */
	        Color.prototype.equalsBytes = function (bytes) {
	            var rb = Math.round(this.red * 255),
	                gb = Math.round(this.green * 255),
	                bb = Math.round(this.blue * 255),
	                ab = Math.round(this.alpha * 255);

	            return rb === bytes[0] && gb === bytes[1] && bb === bytes[2] && ab === bytes[3];
	        };

	        /**
	         * Returns a string representation of this color, indicating the byte values corresponding to this color's
	         * floating-point component values.
	         * @returns {String}
	         */
	        Color.prototype.toByteString = function () {
	            var rb = Math.round(this.red * 255),
	                gb = Math.round(this.green * 255),
	                bb = Math.round(this.blue * 255),
	                ab = Math.round(this.alpha * 255);

	            return "(" + rb + "," + gb + "," + bb + "," + ab + ")";
	        };

	        /**
	         * Create a hex color string that CSS can use. Optionally, inhibit capturing alpha,
	         * because some uses reject a four-component color specification.
	         * @param {Boolean} isUsingAlpha Enable the use of an alpha component.
	         * @returns {string} A color string suitable for CSS.
	         */
	        Color.prototype.toHexString = function(isUsingAlpha) {
	            // Use Math.ceil() to get 0.75 to map to 0xc0. This is important if the display is dithering.
	            var redHex = Math.ceil(this.red * 255).toString(16),
	                greenHex = Math.ceil(this.green * 255).toString(16),
	                blueHex = Math.ceil(this.blue * 255).toString(16),
	                alphaHex = Math.ceil(this.alpha * 255).toString(16);

	            var result = "#";
	            result += (redHex.length < 2) ? ('0' + redHex) : redHex;
	            result += (greenHex.length < 2) ? ('0' + greenHex) : greenHex;
	            result += (blueHex.length < 2) ? ('0' + blueHex) : blueHex;
	            if (isUsingAlpha) {
	                result += (alphaHex.length < 2) ? ('0' + alphaHex) : alphaHex;
	            }

	            return result;
	        };

	        /**
	         * Create a rgba color string that CSS can use.
	         * @returns {string} A color string suitable for CSS.
	         */
	        Color.prototype.toRGBAString = function () {
	            var red = Math.floor(this.red * 255),
	                green = Math.floor(this.green * 255),
	                blue = Math.floor(this.blue * 255);

	            return 'rgba(' + red + ' ,' + green + ' ,' + blue + ' ,' + this.alpha + ')';
	        };

	        return Color;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports MemoryCache
	 * @version $Id: MemoryCache.js 2911 2015-03-19 18:36:01Z tgaskins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(30),
	        __webpack_require__(32)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
	              Logger) {
	        "use strict";

	        /**
	         * Constructs a memory cache of a specified size.
	         * @alias MemoryCache
	         * @constructor
	         * @classdesc Provides a limited-size memory cache of key-value pairs. The meaning of size depends on usage.
	         * Some instances of this class work in bytes while others work in counts. See the documentation for the
	         * specific use to determine the size units.
	         * @param {Number} capacity The cache's capacity.
	         * @param {Number} lowWater The size to clear the cache to when its capacity is exceeded.
	         * @throws {ArgumentError} If either the capacity is 0 or negative or the low-water value is greater than
	         * or equal to the capacity or less than 1.
	         */
	        var MemoryCache = function (capacity, lowWater) {
	            if (!capacity || capacity < 1) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "MemoryCache", "constructor",
	                    "The specified capacity is undefined, zero or negative"));
	            }

	            if (!lowWater || lowWater >= capacity || lowWater < 0) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "MemoryCache", "constructor",
	                    "The specified low-water value is undefined, greater than or equal to the capacity, or less than 1"));
	            }

	            // Documented with its property accessor below.
	            this._capacity = capacity;

	            // Documented with its property accessor below.
	            this._lowWater = lowWater;

	            /**
	             * The size currently used by this cache.
	             * @type {Number}
	             * @readonly
	             */
	            this.usedCapacity = 0;

	            /**
	             * The size currently unused by this cache.
	             * @type {Number}
	             * @readonly
	             */
	            this.freeCapacity = capacity;

	            // Private. The cache entries.
	            this.entries = {};

	            // Private. The cache listeners.
	            this.listeners = [];
	        };

	        Object.defineProperties(MemoryCache.prototype, {
	            /**
	             * The maximum this cache may hold. When the capacity is explicitly set via this property, and the current
	             * low-water value is greater than the specified capacity, the low-water value is adjusted to be 85% of
	             * the specified capacity. The specified capacity may not be less than or equal to 0.
	             * @type {Number}
	             * @memberof MemoryCache.prototype
	             */
	            capacity: {
	                get: function() {
	                    return this._capacity;
	                },
	                set: function (value) {
	                    if (!value || value < 1) {
	                        throw new ArgumentError(
	                            Logger.logMessage(Logger.LEVEL_SEVERE, "MemoryCache", "capacity",
	                                "Specified cache capacity is undefined, 0 or negative."));
	                    }

	                    var oldCapacity = this._capacity;

	                    this._capacity = value;

	                    if (this._capacity <= this.lowWater) {
	                        this._lowWater = 0.85 * this._capacity;
	                    }

	                    // Trim the cache to the low-water mark if it's less than the old capacity
	                    if (this._capacity < oldCapacity) {
	                        this.makeSpace(0);
	                    }
	                }
	            },

	            /**
	             * The size to clear this cache to when its capacity is exceeded. It must be less than the current
	             * capacity and not negative.
	             * @type {Number}
	             * @memberof MemoryCache.prototype
	             */
	            lowWater: {
	                get: function () {
	                    return this._lowWater;
	                },
	                set: function (value) {
	                    if (!value || value >= this._capacity || value < 0) {
	                        throw new ArgumentError(
	                            Logger.logMessage(Logger.LEVEL_SEVERE, "MemoryCache", "lowWater",
	                                "Specified cache low-water value is undefined, negative or not less than the current capacity."));
	                    }

	                    this._lowWater = value;
	                }
	            }
	        });

	        /**
	         * Returns the entry for a specified key.
	         * @param {String} key The key of the entry to return.
	         * @returns {Object} The entry associated with the specified key, or null if the key is not in the cache or
	         * is null or undefined.
	         */
	        MemoryCache.prototype.entryForKey = function (key) {
	            if (!key)
	                return null;

	            var cacheEntry = this.entries[key];
	            if (!cacheEntry)
	                return null;

	            cacheEntry.lastUsed = Date.now();

	            return cacheEntry.entry;
	        };

	        /**
	         * Adds a specified entry to this cache.
	         * @param {String} key The entry's key.
	         * @param {Object} entry The entry.
	         * @param {Number} size The entry's size.
	         * @throws {ArgumentError} If the specified key or entry is null or undefined or the specified size is less
	         * than 1.
	         */
	        MemoryCache.prototype.putEntry = function (key, entry, size) {
	            if (!key) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "MemoryCache", "putEntry", "missingKey."));
	            }

	            if (!entry) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "MemoryCache", "putEntry", "missingEntry."));
	            }

	            if (size < 1) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "MemoryCache", "putEntry",
	                        "The specified entry size is less than 1."));
	            }

	            var existing = this.entries[key],
	                cacheEntry;

	            if (existing) {
	                this.removeEntry(key);
	            }

	            if (this.usedCapacity + size > this._capacity) {
	                this.makeSpace(size);
	            }

	            this.usedCapacity += size;
	            this.freeCapacity = this._capacity - this.usedCapacity;

	            cacheEntry = {
	                key: key,
	                entry: entry,
	                size: size,
	                lastUsed: Date.now()
	            };

	            this.entries[key] = cacheEntry;
	        };

	        /**
	         * Removes all resources from this cache.
	         * @param {Boolean} callListeners If true, the current cache listeners are called for each entry removed.
	         * If false, the cache listeners are not called.
	         */
	        MemoryCache.prototype.clear = function (callListeners) {
	            if (callListeners) {
	                // Remove each entry individually so that the listeners can be called for each entry.
	                for (var key in this.entries) {
	                    if (this.entries.hasOwnProperty(key)) {
	                        this.removeCacheEntry(key);
	                    }
	                }
	            }

	            this.entries = {};
	            this.freeCapacity = this._capacity;
	            this.usedCapacity = 0;
	        };

	        /**
	         * Remove an entry from this cache.
	         * @param {String} key The key of the entry to remove. If null or undefined, this cache is not modified.
	         */
	        MemoryCache.prototype.removeEntry = function (key) {
	            if (!key)
	                return;

	            var cacheEntry = this.entries[key];
	            if (cacheEntry) {
	                this.removeCacheEntry(cacheEntry);
	            }
	        };

	        // Private. Removes a specified entry from this cache.
	        MemoryCache.prototype.removeCacheEntry = function (cacheEntry) {
	            // All removal passes through this function.

	            delete this.entries[cacheEntry.key];

	            this.usedCapacity -= cacheEntry.size;
	            this.freeCapacity = this._capacity - this.usedCapacity;

	            for (var i = 0, len = this.listeners.length; i < len; i++) {
	                try {
	                    this.listeners[i].entryRemoved(cacheEntry.key, cacheEntry.entry);
	                } catch (e) {
	                    this.listeners[i].removalError(e, cacheEntry.key, cacheEntry.entry);
	                }
	            }
	        };

	        /**
	         * Indicates whether a specified entry is in this cache.
	         * @param {String} key The key of the entry to search for.
	         * @returns {Boolean} true if the entry exists, otherwise false.
	         */
	        MemoryCache.prototype.containsKey = function (key) {
	            return key && this.entries[key];
	        };

	        /**
	         * Adds a cache listener to this cache.
	         * @param {MemoryCacheListener} listener The listener to add.
	         * @throws {ArgumentError} If the specified listener is null or undefined or does not implement both the
	         * entryRemoved and removalError functions.
	         */
	        MemoryCache.prototype.addCacheListener = function (listener) {
	            if (!listener) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "MemoryCache", "addCacheListener", "missingListener"));
	            }

	            if (typeof listener.entryRemoved != "function" || typeof listener.removalError != "function") {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "MemoryCache", "addCacheListener",
	                        "The specified listener does not implement the required functions."));
	            }

	            this.listeners.push(listener);
	        };

	        /**
	         * Removes a cache listener from this cache.
	         * @param {MemoryCacheListener} listener The listener to remove.
	         * @throws {ArgumentError} If the specified listener is null or undefined.
	         */
	        MemoryCache.prototype.removeCacheListener = function (listener) {
	            if (!listener) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "MemoryCache", "removeCacheListener", "missingListener"));
	            }

	            var index = this.listeners.indexOf(listener);
	            if (index > -1) {
	                this.listeners.splice(index, 1);
	            }
	        };

	        // Private. Clears this cache to that necessary to contain a specified amount of free space.
	        MemoryCache.prototype.makeSpace = function (spaceRequired) {
	            var sortedEntries = [];

	            // Sort the entries from least recently used to most recently used, then remove the least recently used entries
	            // until the cache capacity reaches the low water and the cache has enough free capacity for the required
	            // space.

	            var sizeAtStart = this.usedCapacity;
	            for (var key in this.entries) {
	                if (this.entries.hasOwnProperty(key)) {
	                    sortedEntries.push(this.entries[key]);
	                }
	            }

	            sortedEntries.sort(function (a, b) {
	                return a.lastUsed - b.lastUsed;
	            });

	            for (var i = 0, len = sortedEntries.length; i < len; i++) {
	                if (this.usedCapacity > this._lowWater || this.freeCapacity < spaceRequired) {
	                    this.removeCacheEntry(sortedEntries[i]);
	                } else {
	                    break;
	                }
	            }
	        };

	        return MemoryCache;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports Texture
	 * @version $Id: Texture.js 3414 2015-08-20 19:09:19Z tgaskins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(30),
	        __webpack_require__(32),
	        __webpack_require__(36)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
	              Logger,
	              WWMath) {
	        "use strict";

	        /**
	         * Constructs a texture for a specified image.
	         * @alias Texture
	         * @constructor
	         * @classdesc Represents a WebGL texture. Applications typically do not interact with this class.
	         * @param {WebGLRenderingContext} gl The current WebGL rendering context.
	         * @param {Image} image The texture's image.
	         * @param {GL.enum} wrapMode Optional. Specifies the wrap mode of the texture. Defaults to gl.CLAMP_TO_EDGE
	         * @throws {ArgumentError} If the specified WebGL context or image is null or undefined.
	         */
	        var Texture = function (gl, image, wrapMode) {

	            if (!gl) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "Texture", "constructor",
	                    "missingGlContext"));
	            }

	            if (!image) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "Texture", "constructor",
	                    "missingImage"));
	            }

	            if (!wrapMode) {
	                wrapMode = gl.CLAMP_TO_EDGE;
	            }

	            var textureId = gl.createTexture(),
	                isPowerOfTwo = (WWMath.isPowerOfTwo(image.width) && WWMath.isPowerOfTwo(image.height));

	            this.originalImageWidth = image.width;
	            this.originalImageHeight = image.height;

	            if (wrapMode === gl.REPEAT && !isPowerOfTwo) {
	                image = this.resizeImage(image);
	                isPowerOfTwo = true;
	            }

	            this.imageWidth = image.width;
	            this.imageHeight = image.height;
	            this.size = image.width * image.height * 4;

	            gl.bindTexture(gl.TEXTURE_2D, textureId);
	            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER,
	                isPowerOfTwo ? gl.LINEAR_MIPMAP_LINEAR : gl.LINEAR);
	            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER,
	                gl.LINEAR);

	            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrapMode);
	            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapMode);

	            // Setup 4x anisotropic texture filtering when this feature is available.
	            // https://www.khronos.org/registry/webgl/extensions/EXT_texture_filter_anisotropic
	            var ext = (
	            gl.getExtension("EXT_texture_filter_anisotropic") ||
	            gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic"));
	            if (ext) {
	                gl.texParameteri(gl.TEXTURE_2D, ext.TEXTURE_MAX_ANISOTROPY_EXT, 4);
	            }

	            gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 1);
	            gl.texImage2D(gl.TEXTURE_2D, 0,
	                gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
	            gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);

	            if (isPowerOfTwo) {
	                gl.generateMipmap(gl.TEXTURE_2D);
	            }

	            this.textureId = textureId;

	            /**
	             * The time at which this texture was created.
	             * @type {Date}
	             */
	            this.creationTime = new Date();
	        };

	        /**
	         * Disposes of the WebGL texture object associated with this texture.
	         * @param gl
	         */
	        Texture.prototype.dispose = function (gl) {
	            gl.deleteTexture(this.textureId);
	            delete this.textureId;
	        };

	        /**
	         * Binds this texture in the current WebGL graphics context.
	         * @param {DrawContext} dc The current draw context.
	         */
	        Texture.prototype.bind = function (dc) {
	            dc.currentGlContext.bindTexture(dc.currentGlContext.TEXTURE_2D, this.textureId);
	            dc.frameStatistics.incrementTextureLoadCount(1);
	            return true;
	        };

	        /**
	         * Resizes an image to a power of two.
	         * @param {Image} image The image to resize.
	         */
	        Texture.prototype.resizeImage = function (image) {
	            var canvas = document.createElement("canvas");
	            canvas.width = WWMath.powerOfTwoFloor(image.width);
	            canvas.height = WWMath.powerOfTwoFloor(image.height);
	            var ctx = canvas.getContext("2d");
	            ctx.drawImage(image, 0, 0, canvas.width, canvas.height);
	            return canvas;
	        };


	        return Texture;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 55 */
/***/ (function(module, exports) {

	
	/**
	 * Constructs a texture cube map for the specified images.
	 * @alias TextureCubeMap
	 * @constructor
	 * @classdesc Represents a WebGL texture cube map. Applications typically do not interact with this class.
	 * @param {WebGLRenderingContext} gl The current WebGL rendering context.
	 * @param {Image[]} images The texture's image.
	 */
	var TextureCubeMap = function (gl, images) {


	    this.size = 0;

	    this.textureId = gl.createTexture();
	    gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.textureId);

	    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
	    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

	    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

	    //gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);

	    for (var i = 0; i < images.length; i++) {
	        var target = gl.TEXTURE_CUBE_MAP_POSITIVE_X + i;
	        var image = images[i];
	        if (image === null) {
	            continue;
	        }
	        gl.texImage2D(target, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
	        this.size += (image.width * image.height * 4);
	    }

	    //gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
	    gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);

	    this.creationTime = new Date();

	};

	/**
	 * Binds this texture in the current WebGL graphics context.
	 * @param {DrawContext} dc The current draw context.
	 */
	TextureCubeMap.prototype.bind = function (dc) {
	    dc.currentGlContext.bindTexture(dc.currentGlContext.TEXTURE_CUBE_MAP, this.textureId);
	    dc.frameStatistics.incrementTextureLoadCount(1);
	    return true;
	};

	module.exports = TextureCubeMap;


/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

	var GestureRecognizer = __webpack_require__(57);
	// var Events = require('../../events/Events');

	var
	    // blocked, // блокировка навигации
	    patched; // патч для qt 5.9

	// Events.listen(Events.BLOCK_NAVIGATION, function (state) {
	//     blocked = state;
	// });

	if (window.navigator.userAgent.indexOf('QtWebEngine/5.9.0') > -1) {
	    patched = true;
	}

	var oldHandleEvent = GestureRecognizer.prototype.handleEvent;


	GestureRecognizer.prototype.handleEvent = function(event) {
	    var self = this;
	    // if (blocked && !event.ctrlKey) {
	    //     return;
	    // }

	    // суть в том, что в qt web engine 5.9 событие event
	    // больше не имеет значения event.pointerType, причины неизвестны
	    if (patched) {
	        if (event.type === "pointerdown") {
	            tryToCall(GestureRecognizer.prototype.handleMouseDown);
	        } else if (event.type === "pointermove") {
	            tryToCall(GestureRecognizer.prototype.handleMouseMove);
	        } else if (event.type === "pointerup") {
	            tryToCall(GestureRecognizer.prototype.handleMouseUp);
	        } else {
	            oldHandleEvent.call(this, event);
	        }
	    } else {
	        oldHandleEvent.call(this, event);
	    }


	    function tryToCall(func){
	        try {
	            func.call(self, event);
	        } catch (e) {
	            console.error(e);
	        }
	    }
	};





/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports GestureRecognizer
	 * @version $Id: GestureRecognizer.js 3241 2015-06-22 23:52:49Z dcollins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(30),
	        __webpack_require__(32),
	        __webpack_require__(58)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
	              Logger,
	              Touch) {
	        "use strict";

	        /**
	         * Constructs a base gesture recognizer. This is an abstract base class and not intended to be instantiated
	         * directly.
	         * @alias GestureRecognizer
	         * @constructor
	         * @classdesc Gesture recognizers translate user input event streams into higher level actions. A gesture
	         * recognizer is associated with an event target, which dispatches mouse and keyboard events to the gesture
	         * recognizer. When a gesture recognizer has received enough information from the event stream to interpret the
	         * action, it calls its callback functions. Callback functions may be specified at construction or added to the
	         * [gestureCallbacks]{@link GestureRecognizer#gestureCallbacks} list after construction.
	         * @param {EventTarget} target The document element this gesture recognizer observes for mouse and touch events.
	         * @param {Function} callback An optional function to call when this gesture is recognized. If non-null, the
	         * function is called when this gesture is recognized, and is passed a single argument: this gesture recognizer,
	         * e.g., <code>gestureCallback(recognizer)</code>.
	         * @throws {ArgumentError} If the specified target is null or undefined.
	         */
	        var GestureRecognizer = function (target, callback) {
	            if (!target) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "GestureRecognizer", "constructor", "missingTarget"));
	            }

	            /**
	             * Indicates the document element this gesture recognizer observes for UI events.
	             * @type {EventTarget}
	             * @readonly
	             */
	            this.target = target;

	            /**
	             * Indicates whether or not this gesture recognizer is enabled. When false, this gesture recognizer will
	             * ignore any events dispatched by its target.
	             * @type {Boolean}
	             * @default true
	             */
	            this.enabled = true;

	            // Documented with its property accessor below.
	            this._state = WorldWind.POSSIBLE;

	            // Intentionally not documented.
	            this._nextState = null;

	            // Documented with its property accessor below.
	            this._clientX = 0;

	            // Documented with its property accessor below.
	            this._clientY = 0;

	            // Intentionally not documented.
	            this._clientStartX = 0;

	            // Intentionally not documented.
	            this._clientStartY = 0;

	            // Documented with its property accessor below.
	            this._translationX = 0;

	            // Documented with its property accessor below.
	            this._translationY = 0;

	            // Intentionally not documented.
	            this._translationWeight = 0.4;

	            // Documented with its property accessor below.
	            this._mouseButtonMask = 0;

	            // Intentionally not documented.
	            this._touches = [];

	            // Intentionally not documented.
	            this._touchCentroidShiftX = 0;

	            // Intentionally not documented.
	            this._touchCentroidShiftY = 0;

	            // Documented with its property accessor below.
	            this._gestureCallbacks = [];

	            // Intentionally not documented.
	            this._canRecognizeWith = [];

	            // Intentionally not documented.
	            this._requiresFailureOf = [];

	            // Intentionally not documented.
	            this._requiredToFailBy = [];

	            // Add the optional gesture callback.
	            if (callback) {
	                this._gestureCallbacks.push(callback);
	            }

	            // Add this recognizer to the list of all recognizers.
	            GestureRecognizer.allRecognizers.push(this);

	            // Register listeners on the event target.
	            var thisRecognizer = this;

	            function eventListener(event) {
	                thisRecognizer.handleEvent(event);
	            }

	            if (window.PointerEvent) {
	                target.addEventListener("pointerdown", eventListener, false);
	                window.addEventListener("pointermove", eventListener, false); // get pointermove events outside event target
	                window.addEventListener("pointercancel", eventListener, false); // get pointercancel events outside event target
	                window.addEventListener("pointerup", eventListener, false); // get pointerup events outside event target
	            } else {
	                target.addEventListener("mousedown", eventListener, false);
	                window.addEventListener("mousemove", eventListener, false); // get mousemove events outside event target
	                window.addEventListener("mouseup", eventListener, false); // get mouseup events outside event target
	                target.addEventListener("touchstart", eventListener, false);
	                target.addEventListener("touchmove", eventListener, false);
	                target.addEventListener("touchend", eventListener, false);
	                target.addEventListener("touchcancel", eventListener, false);
	            }
	        };

	        // Intentionally not documented.
	        GestureRecognizer.allRecognizers = [];

	        Object.defineProperties(GestureRecognizer.prototype, {
	            /**
	             * Indicates this gesture's current state. Possible values are WorldWind.POSSIBLE, WorldWind.FAILED,
	             * WorldWind.RECOGNIZED, WorldWind.BEGAN, WorldWind.CHANGED, WorldWind.CANCELLED and WorldWind.ENDED.
	             * @type {String}
	             * @default WorldWind.POSSIBLE
	             * @memberof GestureRecognizer.prototype
	             */
	            state: {
	                get: function () {
	                    return this._state;
	                },
	                set: function (value) {
	                    this.transitionToState(value);
	                }
	            },

	            /**
	             * Indicates the X coordinate of this gesture.
	             * @type {Number}
	             * @memberof GestureRecognizer.prototype
	             */
	            clientX: {
	                get: function () {
	                    return this._clientX;
	                },
	                set: function (value) {
	                    this._clientX = value;
	                }
	            },

	            /**
	             * Returns the Y coordinate of this gesture.
	             * @type {Number}
	             * @memberof GestureRecognizer.prototype
	             */
	            clientY: {
	                get: function () {
	                    return this._clientY;
	                },
	                set: function (value) {
	                    this._clientY = value;
	                }
	            },

	            /**
	             * Indicates this gesture's translation along the X axis since the gesture started.
	             * @type {Number}
	             * @memberof GestureRecognizer.prototype
	             */
	            translationX: {
	                get: function () {
	                    return this._translationX;
	                },
	                set: function (value) {
	                    this._translationX = value;
	                    this._clientStartX = this._clientX;
	                    this._touchCentroidShiftX = 0;
	                }
	            },

	            /**
	             * Indicates this gesture's translation along the Y axis since the gesture started.
	             * @type {Number}
	             * @memberof GestureRecognizer.prototype
	             */
	            translationY: {
	                get: function () {
	                    return this._translationY;
	                },
	                set: function (value) {
	                    this._translationY = value;
	                    this._clientStartY = this._clientY;
	                    this._touchCentroidShiftY = 0;
	                }
	            },

	            /**
	             * Indicates the currently pressed mouse buttons as a bitmask. A value of 0 indicates that no buttons are
	             * pressed. A nonzero value indicates that one or more buttons are pressed as follows: bit 1 indicates the
	             * primary button, bit 2 indicates the the auxiliary button, bit 3 indicates the secondary button.
	             * @type {Number}
	             * @readonly
	             * @memberof GestureRecognizer.prototype
	             */
	            mouseButtonMask: {
	                get: function () {
	                    return this._mouseButtonMask;
	                }
	            },

	            /**
	             * Indicates the number of active touches.
	             * @type {Number}
	             * @readonly
	             * @memberof GestureRecognizer.prototype
	             */
	            touchCount: {
	                get: function () {
	                    return this._touches.length;
	                }
	            },

	            /**
	             * The list of functions to call when this gesture is recognized. The functions have a single argument:
	             * this gesture recognizer, e.g., <code>gestureCallback(recognizer)</code>. Applications may
	             * add functions to this array or remove them.
	             * @type {Function[]}
	             * @readonly
	             * @memberof GestureRecognizer.prototype
	             */
	            gestureCallbacks: {
	                get: function () {
	                    return this._gestureCallbacks;
	                }
	            }
	        });

	        /**
	         *
	         * @param index
	         * @returns {Touch}
	         * @throws {ArgumentError} If the index is out of range.
	         */
	        GestureRecognizer.prototype.touch = function (index) {
	            if (index < 0 || index >= this._touches.length) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "GestureRecognizer", "touch", "indexOutOfRange"));
	            }

	            return this._touches[index];
	        };

	        /**
	         *
	         * @param recognizer
	         */
	        GestureRecognizer.prototype.recognizeSimultaneouslyWith = function (recognizer) {
	            if (!recognizer) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "GestureRecognizer", "recognizeSimultaneouslyWith",
	                        "The specified gesture recognizer is null or undefined."));
	            }

	            var index = this._canRecognizeWith.indexOf(recognizer);
	            if (index == -1) {
	                this._canRecognizeWith.push(recognizer);
	                recognizer._canRecognizeWith.push(this);
	            }
	        };

	        /**
	         *
	         * @param recognizer
	         * @returns {Boolean}
	         */
	        GestureRecognizer.prototype.canRecognizeSimultaneouslyWith = function (recognizer) {
	            var index = this._canRecognizeWith.indexOf(recognizer);
	            return index != -1;
	        };

	        /**
	         *
	         * @param recognizer
	         */
	        GestureRecognizer.prototype.requireRecognizerToFail = function (recognizer) {
	            if (!recognizer) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "GestureRecognizer", "requireRecognizerToFail",
	                        "The specified gesture recognizer is null or undefined"));
	            }

	            var index = this._requiresFailureOf.indexOf(recognizer);
	            if (index == -1) {
	                this._requiresFailureOf.push(recognizer);
	                recognizer._requiredToFailBy.push(this);
	            }
	        };

	        /**
	         *
	         * @param recognizer
	         * @returns {Boolean}
	         */
	        GestureRecognizer.prototype.requiresRecognizerToFail = function (recognizer) {
	            var index = this._requiresFailureOf.indexOf(recognizer);
	            return index != -1;
	        };

	        /**
	         *
	         * @param recognizer
	         * @returns {Boolean}
	         */
	        GestureRecognizer.prototype.requiredToFailByRecognizer = function (recognizer) {
	            var index = this._requiredToFailBy.indexOf(recognizer);
	            return index != -1;
	        };

	        /**
	         * @protected
	         */
	        GestureRecognizer.prototype.reset = function () {
	            this._state = WorldWind.POSSIBLE;
	            this._nextState = null;
	            this._clientX = 0;
	            this._clientY = 0;
	            this._clientStartX = 0;
	            this._clientStartY = 0;
	            this._translationX = 0;
	            this._translationY = 0;
	            this._mouseButtonMask = 0;
	            this._touches = [];
	            this._touchCentroidShiftX = 0;
	            this._touchCentroidShiftY = 0;
	        };

	        /**
	         * @protected
	         */
	        GestureRecognizer.prototype.prepareToRecognize = function () {
	        };

	        /**
	         *
	         * @param event
	         * @protected
	         */
	        GestureRecognizer.prototype.mouseDown = function (event) {
	        };

	        /**
	         *
	         * @param event
	         * @protected
	         */
	        GestureRecognizer.prototype.mouseMove = function (event) {
	        };

	        /**
	         *
	         * @param event
	         * @protected
	         */
	        GestureRecognizer.prototype.mouseUp = function (event) {
	        };

	        /**
	         *
	         * @param touch
	         * @protected
	         */
	        GestureRecognizer.prototype.touchStart = function (touch) {
	        };

	        /**
	         *
	         * @param touch
	         * @protected
	         */
	        GestureRecognizer.prototype.touchMove = function (touch) {
	        };

	        /**
	         *
	         * @param touch
	         * @protected
	         */
	        GestureRecognizer.prototype.touchCancel = function (touch) {
	        };

	        /**
	         *
	         * @param touch
	         * @protected
	         */
	        GestureRecognizer.prototype.touchEnd = function (touch) {
	        };

	        // Intentionally not documented.
	        GestureRecognizer.prototype.transitionToState = function (newState) {
	            this._nextState = null; // clear any pending state transition

	            if (newState == WorldWind.FAILED) {
	                this._state = newState;
	                this.updateRecognizersWaitingForFailure();
	                this.resetIfEventsEnded();
	            } else if (newState == WorldWind.RECOGNIZED) {
	                this.tryToRecognize(newState); // may prevent the transition to Recognized
	                if (this._state == newState) {
	                    this.prepareToRecognize();
	                    this.callGestureCallbacks();
	                    this.resetIfEventsEnded();
	                }
	            } else if (newState == WorldWind.BEGAN) {
	                this.tryToRecognize(newState); // may prevent the transition to Began
	                if (this._state == newState) {
	                    this.prepareToRecognize();
	                    this.callGestureCallbacks();
	                }
	            } else if (newState == WorldWind.CHANGED) {
	                this._state = newState;
	                this.callGestureCallbacks();
	            } else if (newState == WorldWind.CANCELLED) {
	                this._state = newState;
	                this.callGestureCallbacks();
	                this.resetIfEventsEnded();
	            } else if (newState == WorldWind.ENDED) {
	                this._state = newState;
	                this.callGestureCallbacks();
	                this.resetIfEventsEnded();
	            }
	        };

	        // Intentionally not documented.
	        GestureRecognizer.prototype.updateRecognizersWaitingForFailure = function () {
	            // Transition gestures that are waiting for this gesture to transition to Failed.
	            for (var i = 0, len = this._requiredToFailBy.length; i < len; i++) {
	                var recognizer = this._requiredToFailBy[i];
	                if (recognizer._nextState != null) {
	                    recognizer.transitionToState(recognizer._nextState);
	                }
	            }
	        };

	        // Intentionally not documented.
	        GestureRecognizer.prototype.tryToRecognize = function (newState) {
	            // Transition to Failed if another gesture can prevent this gesture from recognizing.
	            if (GestureRecognizer.allRecognizers.some(this.canBePreventedByRecognizer, this)) {
	                this.transitionToState(WorldWind.FAILED);
	                return;
	            }

	            // Delay the transition to Recognized/Began if this gesture is waiting for a gesture in the Possible state.
	            if (GestureRecognizer.allRecognizers.some(this.isWaitingForRecognizerToFail, this)) {
	                this._nextState = newState;
	                return;
	            }

	            // Transition to Failed all other gestures that can be prevented from recognizing by this gesture.
	            var prevented = GestureRecognizer.allRecognizers.filter(this.canPreventRecognizer, this);
	            for (var i = 0, len = prevented.length; i < len; i++) {
	                prevented[i].transitionToState(WorldWind.FAILED);
	            }

	            this._state = newState;
	        };

	        // Intentionally not documented.
	        GestureRecognizer.prototype.canPreventRecognizer = function (that) {
	            return this != that && this.target == that.target && that.state == WorldWind.POSSIBLE &&
	                (this.requiredToFailByRecognizer(that) || !this.canRecognizeSimultaneouslyWith(that));
	        };

	        // Intentionally not documented.
	        GestureRecognizer.prototype.canBePreventedByRecognizer = function (that) {
	            return this != that && this.target == that.target && that.state == WorldWind.RECOGNIZED &&
	                (this.requiresRecognizerToFail(that) || !this.canRecognizeSimultaneouslyWith(that));
	        };

	        // Intentionally not documented.
	        GestureRecognizer.prototype.isWaitingForRecognizerToFail = function (that) {
	            return this != that && this.target == that.target && that.state == WorldWind.POSSIBLE &&
	                this.requiresRecognizerToFail(that);
	        };

	        // Intentionally not documented.
	        GestureRecognizer.prototype.callGestureCallbacks = function () {
	            for (var i = 0, len = this._gestureCallbacks.length; i < len; i++) {
	                this._gestureCallbacks[i](this);
	            }
	        };

	        // Intentionally not documented.
	        GestureRecognizer.prototype.handleEvent = function (event) {
	            if (!this.enabled) {
	                return;
	            }

	            if (event.defaultPrevented && this.state == WorldWind.POSSIBLE) {
	                return; // ignore cancelled events while in the Possible state
	            }

	            var i, len;

	            try {
	                if (event.type == "mousedown") {
	                    this.handleMouseDown(event);
	                } else if (event.type == "mousemove") {
	                    this.handleMouseMove(event);
	                } else if (event.type == "mouseup") {
	                    this.handleMouseUp(event);
	                } else if (event.type == "touchstart") {
	                    for (i = 0, len = event.changedTouches.length; i < len; i++) {
	                        this.handleTouchStart(event.changedTouches.item(i));
	                    }
	                } else if (event.type == "touchmove") {
	                    for (i = 0, len = event.changedTouches.length; i < len; i++) {
	                        this.handleTouchMove(event.changedTouches.item(i));
	                    }
	                } else if (event.type == "touchcancel") {
	                    for (i = 0, len = event.changedTouches.length; i < len; i++) {
	                        this.handleTouchCancel(event.changedTouches.item(i));
	                    }
	                } else if (event.type == "touchend") {
	                    for (i = 0, len = event.changedTouches.length; i < len; i++) {
	                        this.handleTouchEnd(event.changedTouches.item(i));
	                    }
	                } else if (event.type == "pointerdown" && event.pointerType == "mouse") {
	                    this.handleMouseDown(event);
	                } else if (event.type == "pointermove" && event.pointerType == "mouse") {
	                    this.handleMouseMove(event);
	                } else if (event.type == "pointercancel" && event.pointerType == "mouse") {
	                    // Intentionally left blank. The W3C Pointer Events specification is ambiguous on what cancel means
	                    // for mouse input, and there is no evidence that this event is actually generated (6/19/2015).
	                } else if (event.type == "pointerup" && event.pointerType == "mouse") {
	                    this.handleMouseUp(event);
	                } else if (event.type == "pointerdown" && event.pointerType == "touch") {
	                    this.handleTouchStart(event);
	                } else if (event.type == "pointermove" && event.pointerType == "touch") {
	                    this.handleTouchMove(event);
	                } else if (event.type == "pointercancel" && event.pointerType == "touch") {
	                    this.handleTouchCancel(event);
	                } else if (event.type == "pointerup" && event.pointerType == "touch") {
	                    this.handleTouchEnd(event);
	                } else {
	                    Logger.logMessage(Logger.LEVEL_INFO, "GestureRecognizer", "handleEvent",
	                        "Unrecognized event type: " + event.type);
	                }
	            } catch (e) {
	                Logger.logMessage(Logger.LEVEL_SEVERE, "GestureRecognizer", "handleEvent",
	                    "Error handling event.\n" + e.toString());
	            }
	        };

	        // Intentionally not documented.
	        GestureRecognizer.prototype.handleMouseDown = function (event) {
	            if (event.type == "mousedown" && this._touches.length > 0) {
	                return; // ignore synthesized mouse down events on Android Chrome
	            }

	            var buttonBit = (1 << event.button);
	            if (buttonBit & this._mouseButtonMask != 0) {
	                return; // ignore redundant mouse down events
	            }

	            if (this._mouseButtonMask == 0) { // first button down
	                this._clientX = event.clientX;
	                this._clientY = event.clientY;
	                this._clientStartX = event.clientX;
	                this._clientStartY = event.clientY;
	                this._translationX = 0;
	                this._translationY = 0;
	            }

	            this._mouseButtonMask |= buttonBit;
	            this.mouseDown(event);
	        };

	        // Intentionally not documented.
	        GestureRecognizer.prototype.handleMouseMove = function (event) {
	            if (this._mouseButtonMask == 0) {
	                return; // ignore mouse move events when this recognizer does not consider any button to be down
	            }

	            if (this._clientX == event.clientX && this._clientY == event._clientY) {
	                return; // ignore redundant mouse move events
	            }

	            var dx = event.clientX - this._clientStartX,
	                dy = event.clientY - this._clientStartY,
	                w = this._translationWeight;
	            this._clientX = event.clientX;
	            this._clientY = event.clientY;
	            this._translationX = this._translationX * (1 - w) + dx * w;
	            this._translationY = this._translationY * (1 - w) + dy * w;
	            this.mouseMove(event);
	        };

	        // Intentionally not documented.
	        GestureRecognizer.prototype.handleMouseUp = function (event) {
	            var buttonBit = (1 << event.button);
	            if (buttonBit & this._mouseButtonMask == 0) {
	                return; // ignore mouse up events for buttons this recognizer does not consider to be down
	            }

	            this._mouseButtonMask &= ~buttonBit;
	            this.mouseUp(event);

	            if (this._mouseButtonMask == 0) {
	                this.resetIfEventsEnded(); // last button up
	            }
	        };

	        // Intentionally not documented.
	        GestureRecognizer.prototype.handleTouchStart = function (event) {
	            var touch = new Touch(event.identifier || event.pointerId, event.clientX, event.clientY); // touch events or pointer events
	            this._touches.push(touch);

	            if (this._touches.length == 1) { // first touch
	                this._clientX = event.clientX;
	                this._clientY = event.clientY;
	                this._clientStartX = event.clientX;
	                this._clientStartY = event.clientY;
	                this._translationX = 0;
	                this._translationY = 0;
	                this._touchCentroidShiftX = 0;
	                this._touchCentroidShiftY = 0;
	            } else {
	                this.touchesAddedOrRemoved();
	            }

	            this.touchStart(touch);
	        };

	        // Intentionally not documented.
	        GestureRecognizer.prototype.handleTouchMove = function (event) {
	            var index = this.indexOfTouchWithId(event.identifier || event.pointerId); // touch events or pointer events
	            if (index == -1) {
	                return; // ignore events for touches that did not start in this recognizer's target
	            }

	            var touch = this._touches[index];
	            if (touch.clientX == event.clientX && touch.clientY == event.clientY) {
	                return; // ignore redundant touch move events, which we've encountered on Android Chrome
	            }

	            touch.clientX = event.clientX;
	            touch.clientY = event.clientY;

	            var centroid = this.touchCentroid(),
	                dx = centroid.clientX - this._clientStartX + this._touchCentroidShiftX,
	                dy = centroid.clientY - this._clientStartY + this._touchCentroidShiftY,
	                w = this._translationWeight;
	            this._clientX = centroid.clientX;
	            this._clientY = centroid.clientY;
	            this._translationX = this._translationX * (1 - w) + dx * w;
	            this._translationY = this._translationY * (1 - w) + dy * w;

	            this.touchMove(touch);
	        };

	        // Intentionally not documented.
	        GestureRecognizer.prototype.handleTouchCancel = function (event) {
	            var index = this.indexOfTouchWithId(event.identifier || event.pointerId); // touch events or pointer events
	            if (index == -1) {
	                return; // ignore events for touches that did not start in this recognizer's target
	            }

	            var touch = this._touches[index];
	            this._touches.splice(index, 1);
	            this.touchesAddedOrRemoved();
	            this.touchCancel(touch);
	            this.resetIfEventsEnded();
	        };

	        // Intentionally not documented.
	        GestureRecognizer.prototype.handleTouchEnd = function (event) {
	            var index = this.indexOfTouchWithId(event.identifier || event.pointerId); // touch events or pointer events
	            if (index == -1) {
	                return; // ignore events for touches that did not start in this recognizer's target
	            }

	            var touch = this._touches[index];
	            this._touches.splice(index, 1);
	            this.touchesAddedOrRemoved();
	            this.touchEnd(touch);
	            this.resetIfEventsEnded();
	        };

	        // Intentionally not documented.
	        GestureRecognizer.prototype.resetIfEventsEnded = function () {
	            if (this._state != WorldWind.POSSIBLE && this._mouseButtonMask == 0 && this._touches.length == 0) {
	                this.reset();
	            }
	        };

	        // Intentionally not documented.
	        GestureRecognizer.prototype.touchesAddedOrRemoved = function () {
	            this._touchCentroidShiftX += this._clientX;
	            this._touchCentroidShiftY += this._clientY;
	            var centroid = this.touchCentroid();
	            this._clientX = centroid.clientX;
	            this._clientY = centroid.clientY;
	            this._touchCentroidShiftX -= this._clientX;
	            this._touchCentroidShiftY -= this._clientY;
	        };

	        // Intentionally not documented.
	        GestureRecognizer.prototype.touchCentroid = function () {
	            var x = 0,
	                y = 0;

	            for (var i = 0, len = this._touches.length; i < len; i++) {
	                var touch = this._touches[i];
	                x += touch.clientX / len;
	                y += touch.clientY / len;
	            }

	            return {clientX: x, clientY: y};
	        };

	        // Intentionally not documented.
	        GestureRecognizer.prototype.indexOfTouchWithId = function (identifier) {
	            for (var i = 0, len = this._touches.length; i < len; i++) {
	                if (this._touches[i].identifier == identifier) {
	                    return i;
	                }
	            }

	            return -1;
	        };

	        return GestureRecognizer;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2015 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports Touch
	 * @version $Id: Touch.js 3221 2015-06-19 22:55:04Z dcollins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	        "use strict";

	        /**
	         * Constructs a touch point.
	         * @alias Touch
	         * @constructor
	         * @classdesc Represents a touch point.
	         * @param {Color} identifier A number uniquely identifying the touch point
	         * @param {Number} clientX The X coordinate of the touch point's location.
	         * @param {Number} clientY The Y coordinate of the touch point's location.
	         */
	        var Touch = function (identifier, clientX, clientY) {

	            /**
	             * A number uniquely identifying this touch point.
	             * @type {Number}
	             * @readonly
	             */
	            this.identifier = identifier;

	            // Intentionally not documented.
	            this._clientX = clientX;

	            // Intentionally not documented.
	            this._clientY = clientY;

	            // Intentionally not documented.
	            this._clientStartX = clientX;

	            // Intentionally not documented.
	            this._clientStartY = clientY;
	        };

	        Object.defineProperties(Touch.prototype, {
	            /**
	             * Indicates the X coordinate of this touch point's location.
	             * @type {Number}
	             * @memberof Touch.prototype
	             */
	            clientX: {
	                get: function () {
	                    return this._clientX;
	                },
	                set: function (value) {
	                    this._clientX = value;
	                }
	            },

	            /**
	             * Indicates the Y coordinate of this touch point's location.
	             * @type {Number}
	             * @memberof Touch.prototype
	             */
	            clientY: {
	                get: function () {
	                    return this._clientY;
	                },
	                set: function (value) {
	                    this._clientY = value;
	                }
	            },

	            /**
	             * Indicates this touch point's translation along the X axis since the touch started.
	             * @type {Number}
	             * @memberof Touch.prototype
	             */
	            translationX: {
	                get: function () {
	                    return this._clientX - this._clientStartX;
	                },
	                set: function (value) {
	                    this._clientStartX = this._clientX - value;
	                }
	            },

	            /**
	             * Indicates this touch point's translation along the Y axis since the touch started.
	             * @type {Number}
	             * @memberof Touch.prototype
	             */
	            translationY: {
	                get: function () {
	                    return this._clientY - this._clientStartY;
	                },
	                set: function (value) {
	                    this._clientStartY = this._clientY - value;
	                }
	            }
	        });

	        return Touch;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

	var LookAtNavigator = __webpack_require__(60);
	var Position = __webpack_require__(47);
	var Matrix = __webpack_require__(63);

	// тут сделано так, чтобы учитывалась высота, в той точке на которую смотрим
	LookAtNavigator.prototype.currentState = function () {
	    this.applyLimits();
	    var globe = this.worldWindow.globe;
	    var elevation = globe.elevationAtLocation(this.lookAtLocation.latitude, this.lookAtLocation.longitude);
	    var lookAtPosition = new Position(this.lookAtLocation.latitude, this.lookAtLocation.longitude, elevation);
	    var modelview = Matrix.fromIdentity();
	    modelview.multiplyByLookAtModelview(lookAtPosition, this.range, this.heading, this.tilt, this.roll, globe);
	    return this.currentStateForModelview(modelview);
	};

	LookAtNavigator.prototype.handlePanOrDrag = function(recognizer) {
	    this.handlePanOrDrag3D(recognizer);
	};

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports LookAtNavigator
	 * @version $Id: LookAtNavigator.js 3321 2015-07-16 21:34:58Z dcollins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(29),
	        __webpack_require__(67),
	        __webpack_require__(62),
	        __webpack_require__(57),
	        __webpack_require__(34),
	        __webpack_require__(28),
	        __webpack_require__(32),
	        __webpack_require__(63),
	        __webpack_require__(64),
	        __webpack_require__(61),
	        __webpack_require__(68),
	        __webpack_require__(47),
	        __webpack_require__(69),
	        __webpack_require__(70),
	        __webpack_require__(46),
	        __webpack_require__(35),
	        __webpack_require__(36)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Angle,
	              DragRecognizer,
	              Frustum,
	              GestureRecognizer,
	              Line,
	              Location,
	              Logger,
	              Matrix,
	              Navigator,
	              PanRecognizer,
	              PinchRecognizer,
	              Position,
	              RotationRecognizer,
	              TiltRecognizer,
	              Vec2,
	              Vec3,
	              WWMath) {
	        "use strict";

	        /**
	         * Constructs a look-at navigator.
	         * @alias LookAtNavigator
	         * @constructor
	         * @augments Navigator
	         * @classdesc Represents a navigator that enables the user to pan, zoom and tilt the globe.
	         * This navigator automatically responds to user-input events and gestures.
	         * @param {WorldWindow} worldWindow The world window to associate with this navigator.
	         */
	        var LookAtNavigator = function (worldWindow) {
	            Navigator.call(this, worldWindow);

	            // Prevent the browser's default actions in response to mouse and touch events, which interfere with
	            // navigation. Register these event listeners  before any others to ensure that they're called last.
	            function preventDefaultListener(event) {
	                event.preventDefault();
	            }
	            worldWindow.addEventListener("mousedown", preventDefaultListener);
	            worldWindow.addEventListener("touchstart", preventDefaultListener);
	            worldWindow.addEventListener("contextmenu", preventDefaultListener);
	            worldWindow.addEventListener("wheel", preventDefaultListener);

	            // Prevent the browser's default actions in response to to pointer events, which interfere with navigation.
	            // This CSS style property is configured here to ensure that it's set for all applications.
	            if (window.PointerEvent) {
	                worldWindow.canvas.style.setProperty("touch-action", "none");
	            }

	            /**
	             * The geographic location at the center of the viewport.
	             * @type {Location}
	             */
	            this.lookAtLocation = new Location(30, -110);

	            /**
	             * The distance from this navigator's eye point to its look-at location.
	             * @type {Number}
	             * @default 10,000 kilometers
	             */
	            this.range = 10e6; // TODO: Compute initial range to fit globe in viewport.

	            // Development testing only. Set this to false to suppress default navigator limits on 2D globes.
	            this.enable2DLimits = true;

	            var thisNavigator = this;

	            // Intentionally not documented.
	            this.primaryDragRecognizer = new DragRecognizer(worldWindow, function (recognizer) {
	                thisNavigator.handlePanOrDrag(recognizer);
	            });

	            // Intentionally not documented.
	            this.secondaryDragRecognizer = new DragRecognizer(worldWindow, function (recognizer) {
	                thisNavigator.handleSecondaryDrag(recognizer);
	            });
	            this.secondaryDragRecognizer.button = 2; // secondary mouse button

	            // Intentionally not documented.
	            this.panRecognizer = new PanRecognizer(worldWindow, function (recognizer) {
	                thisNavigator.handlePanOrDrag(recognizer);
	            });

	            // Intentionally not documented.
	            this.pinchRecognizer = new PinchRecognizer(worldWindow, function (recognizer) {
	                thisNavigator.handlePinch(recognizer);
	            });

	            // Intentionally not documented.
	            this.rotationRecognizer = new RotationRecognizer(worldWindow, function (recognizer) {
	                thisNavigator.handleRotation(recognizer);
	            });

	            // Intentionally not documented.
	            this.tiltRecognizer = new TiltRecognizer(worldWindow, function (recognizer) {
	                thisNavigator.handleTilt(recognizer);
	            });

	            // Register wheel event listeners on the WorldWindow's canvas.
	            worldWindow.addEventListener("wheel", function (event) {
	                thisNavigator.handleWheelEvent(event);
	            });

	            // Establish the dependencies between gesture recognizers. The pan, pinch and rotate gesture may recognize
	            // simultaneously with each other.
	            this.panRecognizer.recognizeSimultaneouslyWith(this.pinchRecognizer);
	            this.panRecognizer.recognizeSimultaneouslyWith(this.rotationRecognizer);
	            this.pinchRecognizer.recognizeSimultaneouslyWith(this.rotationRecognizer);

	            // Since the tilt gesture is a subset of the pan gesture, pan will typically recognize before tilt,
	            // effectively suppressing tilt. Establish a dependency between the other touch gestures and tilt to provide
	            // tilt an opportunity to recognize.
	            this.panRecognizer.requireRecognizerToFail(this.tiltRecognizer);
	            this.pinchRecognizer.requireRecognizerToFail(this.tiltRecognizer);
	            this.rotationRecognizer.requireRecognizerToFail(this.tiltRecognizer);

	            // Intentionally not documented.
	            this.beginPoint = new Vec2(0, 0);
	            this.lastPoint = new Vec2(0, 0);
	            this.beginHeading = 0;
	            this.beginTilt = 0;
	            this.beginRange = 0;
	            this.lastRotation = 0;
	        };

	        LookAtNavigator.prototype = Object.create(Navigator.prototype);

	        // Documented in superclass.
	        LookAtNavigator.prototype.currentState = function () {
	            this.applyLimits();

	            var globe = this.worldWindow.globe,
	                lookAtPosition = new Position(this.lookAtLocation.latitude, this.lookAtLocation.longitude, 0),
	                modelview = Matrix.fromIdentity();
	            modelview.multiplyByLookAtModelview(lookAtPosition, this.range, this.heading, this.tilt, this.roll, globe);

	            return this.currentStateForModelview(modelview);
	        };

	        // Intentionally not documented.
	        LookAtNavigator.prototype.handlePanOrDrag = function (recognizer) {
	            if (this.worldWindow.globe.is2D()) {
	                this.handlePanOrDrag2D(recognizer);
	            } else {
	                this.handlePanOrDrag3D(recognizer);
	            }
	        };

	        // Intentionally not documented.
	        LookAtNavigator.prototype.handlePanOrDrag3D = function (recognizer) {
	            var state = recognizer.state,
	                tx = recognizer.translationX,
	                ty = recognizer.translationY;

	            if (state == WorldWind.BEGAN) {
	                this.lastPoint.set(0, 0);
	            } else if (state == WorldWind.CHANGED) {
	                // Convert the translation from screen coordinates to arc degrees. Use this navigator's range as a
	                // metric for converting screen pixels to meters, and use the globe's radius for converting from meters
	                // to arc degrees.
	                var canvas = this.worldWindow.canvas,
	                    globe = this.worldWindow.globe,
	                    globeRadius = WWMath.max(globe.equatorialRadius, globe.polarRadius),
	                    distance = WWMath.max(1, this.range),
	                    metersPerPixel = WWMath.perspectivePixelSize(canvas.clientWidth, canvas.clientHeight, distance),
	                    forwardMeters = (ty - this.lastPoint[1]) * metersPerPixel,
	                    sideMeters = -(tx - this.lastPoint[0]) * metersPerPixel,
	                    forwardDegrees = (forwardMeters / globeRadius) * Angle.RADIANS_TO_DEGREES,
	                    sideDegrees = (sideMeters / globeRadius) * Angle.RADIANS_TO_DEGREES;

	                // Apply the change in latitude and longitude to this navigator, relative to the current heading.
	                var sinHeading = Math.sin(this.heading * Angle.DEGREES_TO_RADIANS),
	                    cosHeading = Math.cos(this.heading * Angle.DEGREES_TO_RADIANS);

	                this.lookAtLocation.latitude += forwardDegrees * cosHeading - sideDegrees * sinHeading;
	                this.lookAtLocation.longitude += forwardDegrees * sinHeading + sideDegrees * cosHeading;
	                this.lastPoint.set(tx, ty);
	                this.applyLimits();
	                this.worldWindow.redraw();
	            }
	        };

	        // Intentionally not documented.
	        LookAtNavigator.prototype.handlePanOrDrag2D = function (recognizer) {
	            var state = recognizer.state,
	                x = recognizer.clientX,
	                y = recognizer.clientY,
	                tx = recognizer.translationX,
	                ty = recognizer.translationY;

	            if (state == WorldWind.BEGAN) {
	                this.beginPoint.set(x, y);
	                this.lastPoint.set(x, y);
	            } else if (state == WorldWind.CHANGED) {
	                var x1 = this.lastPoint[0],
	                    y1 = this.lastPoint[1],
	                    x2 = this.beginPoint[0] + tx,
	                    y2 = this.beginPoint[1] + ty;
	                this.lastPoint.set(x2, y2);

	                var navState = this.currentState(),
	                    globe = this.worldWindow.globe,
	                    ray = navState.rayFromScreenPoint(this.worldWindow.canvasCoordinates(x1, y1)),
	                    point1 = new Vec3(0, 0, 0),
	                    point2 = new Vec3(0, 0, 0),
	                    origin = new Vec3(0, 0, 0);
	                if (!globe.intersectsLine(ray, point1)) {
	                    return;
	                }

	                ray = navState.rayFromScreenPoint(this.worldWindow.canvasCoordinates(x2, y2));
	                if (!globe.intersectsLine(ray, point2)) {
	                    return;
	                }

	                // Transform the original navigator state's modelview matrix to account for the gesture's change.
	                var modelview = Matrix.fromIdentity();
	                modelview.copy(navState.modelview);
	                modelview.multiplyByTranslation(point2[0] - point1[0], point2[1] - point1[1], point2[2] - point1[2]);

	                // Compute the globe point at the screen center from the perspective of the transformed navigator state.
	                modelview.extractEyePoint(ray.origin);
	                modelview.extractForwardVector(ray.direction);
	                if (!globe.intersectsLine(ray, origin)) {
	                    return;
	                }

	                // Convert the transformed modelview matrix to a set of navigator properties, then apply those
	                // properties to this navigator.
	                var params = modelview.extractViewingParameters(origin, this.roll, globe, {});
	                this.lookAtLocation.copy(params.origin);
	                this.range = params.range;
	                this.heading = params.heading;
	                this.tilt = params.tilt;
	                this.roll = params.roll;
	                this.applyLimits();
	                this.worldWindow.redraw();
	            }
	        };

	        // Intentionally not documented.
	        LookAtNavigator.prototype.handleSecondaryDrag = function (recognizer) {
	            var state = recognizer.state,
	                tx = recognizer.translationX,
	                ty = recognizer.translationY;

	            if (state == WorldWind.BEGAN) {
	                this.beginHeading = this.heading;
	                this.beginTilt = this.tilt;
	            } else if (state == WorldWind.CHANGED) {
	                // Compute the current translation from screen coordinates to degrees. Use the canvas dimensions as a
	                // metric for converting the gesture translation to a fraction of an angle.
	                var headingDegrees = 180 * tx / this.worldWindow.canvas.clientWidth,
	                    tiltDegrees = 90 * ty / this.worldWindow.canvas.clientHeight;

	                // Apply the change in heading and tilt to this navigator's corresponding properties.
	                this.heading = this.beginHeading + headingDegrees;
	                this.tilt = this.beginTilt + tiltDegrees;
	                this.applyLimits();
	                this.worldWindow.redraw();
	            }
	        };

	        // Intentionally not documented.
	        LookAtNavigator.prototype.handlePinch = function (recognizer) {
	            var state = recognizer.state,
	                scale = recognizer.scale;

	            if (state == WorldWind.BEGAN) {
	                this.beginRange = this.range;
	            } else if (state == WorldWind.CHANGED) {
	                if (scale != 0) {
	                    // Apply the change in pinch scale to this navigator's range, relative to the range when the gesture
	                    // began.
	                    this.range = this.beginRange / scale;
	                    this.applyLimits();
	                    this.worldWindow.redraw();
	                }
	            }
	        };

	        // Intentionally not documented.
	        LookAtNavigator.prototype.handleRotation = function (recognizer) {
	            var state = recognizer.state,
	                rotation = recognizer.rotation;

	            if (state == WorldWind.BEGAN) {
	                this.lastRotation = 0;
	            } else if (state == WorldWind.CHANGED) {
	                // Apply the change in gesture rotation to this navigator's current heading. We apply relative to the
	                // current heading rather than the heading when the gesture began in order to work simultaneously with
	                // pan operations that also modify the current heading.
	                this.heading -= rotation - this.lastRotation;
	                this.lastRotation = rotation;
	                this.applyLimits();
	                this.worldWindow.redraw();
	            }
	        };

	        // Intentionally not documented.
	        LookAtNavigator.prototype.handleTilt = function (recognizer) {
	            var state = recognizer.state,
	                ty = recognizer.translationY;

	            if (state == WorldWind.BEGAN) {
	                this.beginTilt = this.tilt;
	            } else if (state == WorldWind.CHANGED) {
	                // Compute the gesture translation from screen coordinates to degrees. Use the canvas dimensions as a
	                // metric for converting the translation to a fraction of an angle.
	                var tiltDegrees = -90 * ty / this.worldWindow.canvas.clientHeight;
	                // Apply the change in heading and tilt to this navigator's corresponding properties.
	                this.tilt = this.beginTilt + tiltDegrees;
	                this.applyLimits();
	                this.worldWindow.redraw();
	            }
	        };

	        // Intentionally not documented.
	        LookAtNavigator.prototype.handleWheelEvent = function (event) {
	            // Normalize the wheel delta based on the wheel delta mode. This produces a roughly consistent delta across
	            // browsers and input devices.
	            var normalizedDelta;
	            if (event.deltaMode == WheelEvent.DOM_DELTA_PIXEL) {
	                normalizedDelta = event.deltaY;
	            } else if (event.deltaMode == WheelEvent.DOM_DELTA_LINE) {
	                normalizedDelta = event.deltaY * 40;
	            } else if (event.deltaMode == WheelEvent.DOM_DELTA_PAGE) {
	                normalizedDelta = event.deltaY * 400;
	            }

	            // Compute a zoom scale factor by adding a fraction of the normalized delta to 1. When multiplied by the
	            // navigator's range, this has the effect of zooming out or zooming in depending on whether the delta is
	            // positive or negative, respectfully.
	            var scale = 1 + (normalizedDelta / 1000);

	            // Apply the scale to this navigator's properties.
	            this.range *= scale;
	            this.applyLimits();
	            this.worldWindow.redraw();
	        };

	        // Intentionally not documented.
	        LookAtNavigator.prototype.applyLimits = function () {
	            // Clamp latitude to between -90 and +90, and normalize longitude to between -180 and +180.
	            this.lookAtLocation.latitude = WWMath.clamp(this.lookAtLocation.latitude, -90, 90);
	            this.lookAtLocation.longitude = Angle.normalizedDegreesLongitude(this.lookAtLocation.longitude);

	            // Clamp range to values greater than 1 in order to prevent degenerating to a first-person navigator when
	            // range is zero.
	            this.range = WWMath.clamp(this.range, 1, Number.MAX_VALUE);

	            // Normalize heading to between -180 and +180.
	            this.heading = Angle.normalizedDegrees(this.heading);

	            // Clamp tilt to between 0 and +90 to prevent the viewer from going upside down.
	            this.tilt = WWMath.clamp(this.tilt, 0, 90);

	            // Normalize heading to between -180 and +180.
	            this.roll = Angle.normalizedDegrees(this.roll);

	            // Apply 2D limits when the globe is 2D.
	            if (this.worldWindow.globe.is2D() && this.enable2DLimits) {
	                // Clamp range to prevent more than 360 degrees of visible longitude. Assumes a 45 degree horizontal
	                // field of view.
	                var maxRange = 2 * Math.PI * this.worldWindow.globe.equatorialRadius;
	                this.range = WWMath.clamp(this.range, 1, maxRange);

	                // Force tilt to 0 when in 2D mode to keep the viewer looking straight down.
	                this.tilt = 0;
	            }
	        };

	        return LookAtNavigator;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports PanRecognizer
	 * @version $Id: PanRecognizer.js 3239 2015-06-22 23:28:12Z dcollins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(57)], __WEBPACK_AMD_DEFINE_RESULT__ = function (GestureRecognizer) {
	        "use strict";

	        /**
	         * Constructs a pan gesture recognizer.
	         * @alias PanRecognizer
	         * @constructor
	         * @augments GestureRecognizer
	         * @classdesc A concrete gesture recognizer subclass that looks for touch panning gestures.
	         * @param {EventTarget} target The document element this gesture recognizer observes for mouse and touch events.
	         * @param {Function} callback An optional function to call when this gesture is recognized. If non-null, the
	         * function is called when this gesture is recognized, and is passed a single argument: this gesture recognizer,
	         * e.g., <code>gestureCallback(recognizer)</code>.
	         * @throws {ArgumentError} If the specified target is null or undefined.
	         */
	        var PanRecognizer = function (target, callback) {
	            GestureRecognizer.call(this, target, callback);

	            /**
	             *
	             * @type {Number}
	             */
	            this.minNumberOfTouches = 1;

	            /**
	             *
	             * @type {Number}
	             */
	            this.maxNumberOfTouches = Number.MAX_VALUE;

	            // Intentionally not documented.
	            this.interpretDistance = 20;
	        };

	        PanRecognizer.prototype = Object.create(GestureRecognizer.prototype);

	        // Documented in superclass.
	        PanRecognizer.prototype.mouseDown = function (event) {
	            if (this.state == WorldWind.POSSIBLE) {
	                this.state = WorldWind.FAILED; // touch gestures fail upon receiving a mouse event
	            }
	        };

	        // Documented in superclass.
	        PanRecognizer.prototype.touchMove = function (touch) {
	            if (this.state == WorldWind.POSSIBLE) {
	                if (this.shouldInterpret()) {
	                    if (this.shouldRecognize()) {
	                        this.state = WorldWind.BEGAN;
	                    } else {
	                        this.state = WorldWind.FAILED;
	                    }
	                }
	            } else if (this.state == WorldWind.BEGAN || this.state == WorldWind.CHANGED) {
	                this.state = WorldWind.CHANGED;
	            }
	        };

	        // Documented in superclass.
	        PanRecognizer.prototype.touchEnd = function (touch) {
	            if (this.touchCount == 0) { // last touch ended
	                if (this.state == WorldWind.POSSIBLE) {
	                    this.state = WorldWind.FAILED;
	                } else if (this.state == WorldWind.BEGAN || this.state == WorldWind.CHANGED) {
	                    this.state = WorldWind.ENDED;
	                }
	            }
	        };

	        // Documented in superclass.
	        PanRecognizer.prototype.touchCancel = function (touch) {
	            if (this.touchCount == 0) { // last touch cancelled
	                if (this.state == WorldWind.POSSIBLE) {
	                    this.state = WorldWind.FAILED;
	                } else if (this.state == WorldWind.BEGAN || this.state == WorldWind.CHANGED) {
	                    this.state = WorldWind.CANCELLED;
	                }
	            }
	        };

	        // Documented in superclass.
	        PanRecognizer.prototype.prepareToRecognize = function () {
	            // set translation to zero when the pan begins
	            this.translationX = 0;
	            this.translationY = 0;
	        };

	        /**
	         *
	         * @returns {boolean}
	         * @protected
	         */
	        PanRecognizer.prototype.shouldInterpret = function () {
	            var dx = this.translationX,
	                dy = this.translationY,
	                distance = Math.sqrt(dx * dx + dy * dy);
	            return distance > this.interpretDistance; // interpret touches when the touch centroid moves far enough
	        };

	        /**
	         *
	         * @returns {boolean}
	         * @protected
	         */
	        PanRecognizer.prototype.shouldRecognize = function () {
	            var touchCount = this.touchCount;
	            return touchCount != 0
	                && touchCount >= this.minNumberOfTouches
	                && touchCount <= this.maxNumberOfTouches
	        };

	        return PanRecognizer;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports Frustum
	 * @version $Id: Frustum.js 2919 2015-03-22 20:46:59Z tgaskins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(30),
	        __webpack_require__(63),
	        __webpack_require__(33),
	        __webpack_require__(32)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
	              Matrix,
	              Plane,
	              Logger) {
	        "use strict";

	        /**
	         * Constructs a frustum.
	         * @alias Frustum
	         * @constructor
	         * @classdesc Represents a six-sided view frustum in Cartesian coordinates.
	         * @param {Plane} left The frustum's left plane.
	         * @param {Plane} right The frustum's right plane.
	         * @param {Plane} bottom The frustum's bottom plane.
	         * @param {Plane} top The frustum's top plane.
	         * @param {Plane} near The frustum's near plane.
	         * @param {Plane} far The frustum's far plane.
	         * @throws {ArgumentError} If any specified plane is null or undefined.
	         */
	        var Frustum = function (left, right, bottom, top, near, far) {
	            if (!left || !right || !bottom || !top || !near || !far) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Frustum", "constructor", "missingPlane"));
	            }

	            // Internal. Intentionally not documented. See property accessors below for public interface.
	            this._left = left;
	            this._right = right;
	            this._bottom = bottom;
	            this._top = top;
	            this._near = near;
	            this._far = far;

	            // Internal. Intentionally not documented.
	            this._planes = [this._left, this._right, this._top, this._bottom, this._near, this._far];
	        };

	        // These accessors are defined in order to prevent changes that would make the properties inconsistent with the
	        // planes array.
	        Object.defineProperties(Frustum.prototype, {
	            /**
	             * This frustum's left plane.
	             * @memberof Frustum.prototype
	             * @type {Plane}
	             * @readonly
	             */
	            left: {
	                get: function() {
	                    return this._left;
	                }
	            },
	            /**
	             * This frustum's right plane.
	             * @memberof Frustum.prototype
	             * @type {Plane}
	             * @readonly
	             */
	            right: {
	                get: function() {
	                    return this._right;
	                }
	            },
	            /**
	             * This frustum's bottom plane.
	             * @memberof Frustum.prototype
	             * @type {Plane}
	             * @readonly
	             */
	            bottom: {
	                get: function() {
	                    return this._bottom;
	                }
	            },
	            /**
	             * This frustum's top plane.
	             * @memberof Frustum.prototype
	             * @type {Plane}
	             * @readonly
	             */
	            top: {
	                get: function() {
	                    return this._top;
	                }
	            },
	            /**
	             * This frustum's near plane.
	             * @memberof Frustum.prototype
	             * @type {Plane}
	             * @readonly
	             */
	            near: {
	                get: function() {
	                    return this._near;
	                }
	            },
	            /**
	             * This frustum's far plane.
	             * @memberof Frustum.prototype
	             * @type {Plane}
	             * @readonly
	             */
	            far: {
	                get: function() {
	                    return this._far;
	                }
	            }
	        });

	        /**
	         * Transforms this frustum by a specified matrix.
	         * @param {Matrix} matrix The matrix to apply to this frustum.
	         * @returns {Frustum} This frustum set to its original value multiplied by the specified matrix.
	         * @throws {ArgumentError} If the specified matrix is null or undefined.
	         */
	        Frustum.prototype.transformByMatrix = function (matrix) {
	            if (!matrix) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Frustum", "transformByMatrix", "missingMatrix"));
	            }

	            this._left.transformByMatrix(matrix);
	            this._right.transformByMatrix(matrix);
	            this._bottom.transformByMatrix(matrix);
	            this._top.transformByMatrix(matrix);
	            this._near.transformByMatrix(matrix);
	            this._far.transformByMatrix(matrix);

	            return this;
	        };

	        /**
	         * Normalizes the plane vectors of the planes composing this frustum.
	         * @returns {Frustum} This frustum with its planes normalized.
	         */
	        Frustum.prototype.normalize = function () {
	            this._left.normalize();
	            this._right.normalize();
	            this._bottom.normalize();
	            this._top.normalize();
	            this._near.normalize();
	            this._far.normalize();

	            return this;
	        };

	        /**
	         * Returns a new frustum with each of its planes 1 meter from the center.
	         * @returns {Frustum} The new frustum.
	         */
	        Frustum.unitFrustum = function () {
	            return new Frustum(
	                new Plane(1, 0, 0, 1), // left
	                new Plane(-1, 0, 0, 1), // right
	                new Plane(0, 1, 1, 1), // bottom
	                new Plane(0, -1, 0, 1), // top
	                new Plane(0, 0, -1, 1), // near
	                new Plane(0, 0, 1, 1) // far
	            );
	        };

	        /**
	         * Extracts a frustum from a projection matrix.
	         * <p>
	         * This method assumes that the specified matrix represents a projection matrix. If it does not represent a projection matrix
	         * the results are undefined.
	         * <p>
	         * A projection matrix's view frustum is a Cartesian volume that contains everything visible in a scene displayed
	         * using that projection matrix.
	         *
	         * @param {Matrix} matrix The projection matrix to extract the frustum from.
	         * @return {Frustum} A new frustum containing the projection matrix's view frustum, in eye coordinates.
	         * @throws {ArgumentError} If the specified matrix is null or undefined.
	         */
	        Frustum.fromProjectionMatrix = function (matrix) {
	            if (!matrix) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Frustum", "fromProjectionMatrix", "missingMatrix"));
	            }

	            var x, y, z, w, d, left, right, top, bottom, near, far;

	            // Left Plane = row 4 + row 1:
	            x = matrix[12] + matrix[0];
	            y = matrix[13] + matrix[1];
	            z = matrix[14] + matrix[2];
	            w = matrix[15] + matrix[3];
	            d = Math.sqrt(x * x + y * y + z * z); // for normalizing the coordinates
	            left = new Plane(x / d, y / d, z / d, w / d);

	            // Right Plane = row 4 - row 1:
	            x = matrix[12] - matrix[0];
	            y = matrix[13] - matrix[1];
	            z = matrix[14] - matrix[2];
	            w = matrix[15] - matrix[3];
	            d = Math.sqrt(x * x + y * y + z * z); // for normalizing the coordinates
	            right = new Plane(x / d, y / d, z / d, w / d);

	            // Bottom Plane = row 4 + row 2:
	            x = matrix[12] + matrix[4];
	            y = matrix[13] + matrix[5];
	            z = matrix[14] + matrix[6];
	            w = matrix[15] + matrix[7];
	            d = Math.sqrt(x * x + y * y + z * z); // for normalizing the coordinates
	            bottom = new Plane(x / d, y / d, z / d, w / d);

	            // Top Plane = row 4 - row 2:
	            x = matrix[12] - matrix[4];
	            y = matrix[13] - matrix[5];
	            z = matrix[14] - matrix[6];
	            w = matrix[15] - matrix[7];
	            d = Math.sqrt(x * x + y * y + z * z); // for normalizing the coordinates
	            top = new Plane(x / d, y / d, z / d, w / d);

	            // Near Plane = row 4 + row 3:
	            x = matrix[12] + matrix[8];
	            y = matrix[13] + matrix[9];
	            z = matrix[14] + matrix[10];
	            w = matrix[15] + matrix[11];
	            d = Math.sqrt(x * x + y * y + z * z); // for normalizing the coordinates
	            near = new Plane(x / d, y / d, z / d, w / d);

	            // Far Plane = row 4 - row 3:
	            x = matrix[12] - matrix[8];
	            y = matrix[13] - matrix[9];
	            z = matrix[14] - matrix[10];
	            w = matrix[15] - matrix[11];
	            d = Math.sqrt(x * x + y * y + z * z); // for normalizing the coordinates
	            far = new Plane(x / d, y / d, z / d, w / d);

	            return new Frustum(left, right, bottom, top, near, far);
	        };

	        Frustum.prototype.containsPoint = function (point) {
	            if (!point) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Frustum", "containsPoint", "missingPoint"));
	            }

	            // See if the point is entirely within the frustum. The dot product of the point with each plane's vector
	            // provides a distance to each plane. If this distance is less than 0, the point is clipped by that plane and
	            // neither intersects nor is contained by the space enclosed by this Frustum.

	            if (this._far.dot(point) <= 0)
	                return false;
	            if (this._left.dot(point) <= 0)
	                return false;
	            if (this._right.dot(point) <= 0)
	                return false;
	            if (this._top.dot(point) <= 0)
	                return false;
	            if (this._bottom.dot(point) <= 0)
	                return false;
	            if (this._near.dot(point) <= 0)
	                return false;

	            return true;
	        };

	        /**
	         * Determines whether a line segment intersects this frustum.
	         *
	         * @param {Vec3} pointA One end of the segment.
	         * @param {Vec3} pointB The other end of the segment.
	         *
	         * @return {boolean} <code>true</code> if the segment intersects or is contained in this frustum,
	         * otherwise <code>false</code>.
	         *
	         * @throws {ArgumentError} If either point is null or undefined.
	         */
	        Frustum.prototype.intersectsSegment = function (pointA, pointB) {
	            if (!pointA || !pointB) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Frustum", "containsPoint", "missingPoint"));
	            }

	            // First do a trivial accept test.
	            if (this.containsPoint(pointA) || this.containsPoint(pointB))
	                return true;

	            if (pointA.equals(pointB))
	                return false;

	            for (var i = 0, len = this._planes.length; i < len; i++) {

	                // See if both points are behind the plane and therefore not in the frustum.
	                if (this._planes[i].onSameSide(pointA, pointB) < 0)
	                    return false;

	                // See if the segment intersects the plane.
	                if (this._planes[i].clip(pointA, pointB) != null)
	                    return true;
	            }

	            return false; // segment does not intersect frustum
	        };

	        return Frustum;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports Matrix
	 * @version $Id: Matrix.js 3298 2015-07-06 17:28:33Z dcollins $
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(29),
	        __webpack_require__(30),
	        __webpack_require__(32),
	        __webpack_require__(33),
	        __webpack_require__(47),
	        __webpack_require__(37),
	        __webpack_require__(54),
	        __webpack_require__(35),
	        __webpack_require__(36)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Angle,
	              ArgumentError,
	              Logger,
	              Plane,
	              Position,
	              Rectangle,
	              Texture,
	              Vec3,
	              WWMath) {
	        "use strict";

	        /**
	         * Constructs a matrix.
	         * @alias Matrix
	         * @constructor
	         * @classdesc Represents a 4 x 4 double precision matrix stored in a Float64Array in row-major order.
	         * @param {Number} m11 matrix element at row 1, column 1.
	         * @param {Number} m12 matrix element at row 1, column 2.
	         * @param {Number} m13 matrix element at row 1, column 3.
	         * @param {Number} m14 matrix element at row 1, column 4.
	         * @param {Number} m21 matrix element at row 2, column 1.
	         * @param {Number} m22 matrix element at row 2, column 2.
	         * @param {Number} m23 matrix element at row 2, column 3.
	         * @param {Number} m24 matrix element at row 2, column 4.
	         * @param {Number} m31 matrix element at row 3, column 1.
	         * @param {Number} m32 matrix element at row 3, column 2.
	         * @param {Number} m33 matrix element at row 3, column 3.
	         * @param {Number} m34 matrix element at row 3, column 4.
	         * @param {Number} m41 matrix element at row 4, column 1.
	         * @param {Number} m42 matrix element at row 4, column 2.
	         * @param {Number} m43 matrix element at row 4, column 3.
	         * @param {Number} m44 matrix element at row 4, column 4.
	         */
	        var Matrix = function (m11, m12, m13, m14,
	                               m21, m22, m23, m24,
	                               m31, m32, m33, m34,
	                               m41, m42, m43, m44) {
	            this[0] = m11;
	            this[1] = m12;
	            this[2] = m13;
	            this[3] = m14;
	            this[4] = m21;
	            this[5] = m22;
	            this[6] = m23;
	            this[7] = m24;
	            this[8] = m31;
	            this[9] = m32;
	            this[10] = m33;
	            this[11] = m34;
	            this[12] = m41;
	            this[13] = m42;
	            this[14] = m43;
	            this[15] = m44;
	        };

	        // Derives from Float64Array.
	        Matrix.prototype = new Float64Array(16);

	        /**
	         * Creates an identity matrix.
	         * @returns {Matrix} A new identity matrix.
	         */
	        Matrix.fromIdentity = function () {
	            return new Matrix(
	                1, 0, 0, 0,
	                0, 1, 0, 0,
	                0, 0, 1, 0,
	                0, 0, 0, 1
	            );
	        };

	        /**
	         * Computes the principal axes of a point collection expressed in a typed array.
	         * @param {Float32Array} points The points for which to compute the axes,
	         * expressed as X0, Y0, Z0, X1, Y1, Z1, ...
	         * @param {Vec3} axis1 A vector in which to return the first (longest) principal axis.
	         * @param {Vec3} axis2 A vector in which to return the second (mid-length) principal axis.
	         * @param {Vec3} axis3 A vector in which to return the third (shortest) principal axis.
	         * @throws {ArgumentError} If the specified points array is null, undefined or empty, or one of the
	         * specified axes arguments is null or undefined.
	         */
	        Matrix.principalAxesFromPoints = function (points, axis1, axis2, axis3) {
	            if (!points || points.length < 1) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "Matrix", "principalAxesFromPoints",
	                    "missingPoints"));
	            }

	            if (!axis1 || !axis2 || !axis3) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "Matrix", "principalAxesFromPoints",
	                    "An axis argument is null or undefined."));
	            }

	            // Compute the covariance matrix.
	            var covariance = Matrix.fromIdentity();
	            covariance.setToCovarianceOfPoints(points);

	            // Compute the eigenvectors from the covariance matrix. Since the covariance matrix is symmetric by
	            // definition, we can safely use the "symmetric" method below.
	            covariance.eigensystemFromSymmetricMatrix(axis1, axis2, axis3);

	            // Normalize the eigenvectors, which are already sorted in order from most prominent to least prominent.
	            axis1.normalize();
	            axis2.normalize();
	            axis3.normalize();
	        };

	        /**
	         * Sets the components of this matrix to specified values.
	         * @param {Number} m11 matrix element at row 1, column 1.
	         * @param {Number} m12 matrix element at row 1, column 2.
	         * @param {Number} m13 matrix element at row 1, column 3.
	         * @param {Number} m14 matrix element at row 1, column 4.
	         * @param {Number} m21 matrix element at row 2, column 1.
	         * @param {Number} m22 matrix element at row 2, column 2.
	         * @param {Number} m23 matrix element at row 2, column 3.
	         * @param {Number} m24 matrix element at row 2, column 4.
	         * @param {Number} m31 matrix element at row 3, column 1.
	         * @param {Number} m32 matrix element at row 3, column 2.
	         * @param {Number} m33 matrix element at row 3, column 3.
	         * @param {Number} m34 matrix element at row 3, column 4.
	         * @param {Number} m41 matrix element at row 4, column 1.
	         * @param {Number} m42 matrix element at row 4, column 2.
	         * @param {Number} m43 matrix element at row 4, column 3.
	         * @param {Number} m44 matrix element at row 4, column 4.
	         * @returns {Matrix} This matrix with its components set to the specified values.
	         */
	        Matrix.prototype.set = function (m11, m12, m13, m14,
	                                         m21, m22, m23, m24,
	                                         m31, m32, m33, m34,
	                                         m41, m42, m43, m44) {
	            this[0] = m11;
	            this[1] = m12;
	            this[2] = m13;
	            this[3] = m14;
	            this[4] = m21;
	            this[5] = m22;
	            this[6] = m23;
	            this[7] = m24;
	            this[8] = m31;
	            this[9] = m32;
	            this[10] = m33;
	            this[11] = m34;
	            this[12] = m41;
	            this[13] = m42;
	            this[14] = m43;
	            this[15] = m44;

	            return this;
	        };

	        /**
	         * Sets this matrix to the identity matrix.
	         * @returns {Matrix} This matrix set to the identity matrix.
	         */
	        Matrix.prototype.setToIdentity = function () {
	            this[0] = 1;
	            this[1] = 0;
	            this[2] = 0;
	            this[3] = 0;
	            this[4] = 0;
	            this[5] = 1;
	            this[6] = 0;
	            this[7] = 0;
	            this[8] = 0;
	            this[9] = 0;
	            this[10] = 1;
	            this[11] = 0;
	            this[12] = 0;
	            this[13] = 0;
	            this[14] = 0;
	            this[15] = 1;
	        };

	        /**
	         * Copies the components of a specified matrix to this matrix.
	         * @param {Matrix} matrix The matrix to copy.
	         * @returns {Matrix} This matrix set to the values of the specified matrix.
	         * @throws {ArgumentError} If the specified matrix is null or undefined.
	         */
	        Matrix.prototype.copy = function (matrix) {
	            if (!matrix) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Matrix", "copy", "missingMatrix"));
	            }

	            this[0] = matrix[0];
	            this[1] = matrix[1];
	            this[2] = matrix[2];
	            this[3] = matrix[3];
	            this[4] = matrix[4];
	            this[5] = matrix[5];
	            this[6] = matrix[6];
	            this[7] = matrix[7];
	            this[8] = matrix[8];
	            this[9] = matrix[9];
	            this[10] = matrix[10];
	            this[11] = matrix[11];
	            this[12] = matrix[12];
	            this[13] = matrix[13];
	            this[14] = matrix[14];
	            this[15] = matrix[15];
	        };

	        /**
	         * Indicates whether the components of this matrix are equal to those of a specified matrix.
	         * @param {Matrix} matrix The matrix to test equality with. May be null or undefined, in which case this
	         * function returns false.
	         * @returns {boolean} true if all components of this matrix are equal to the corresponding
	         * components of the specified matrix, otherwise false.
	         */
	        Matrix.prototype.equals = function (matrix) {
	            return matrix
	                && this[0] == matrix[0]
	                && this[1] == matrix[1]
	                && this[2] == matrix[2]
	                && this[3] == matrix[3]
	                && this[4] == matrix[4]
	                && this[5] == matrix[5]
	                && this[6] == matrix[6]
	                && this[7] == matrix[7]
	                && this[8] == matrix[8]
	                && this[9] == matrix[9]
	                && this[10] == matrix[10]
	                && this[11] == matrix[11]
	                && this[12] == matrix[12]
	                && this[13] == matrix[13]
	                && this[14] == matrix[14]
	                && this[15] == matrix[15];
	        };

	        /**
	         * Stores this matrix's components in column-major order in a specified array.
	         * <p>
	         * The array must have space for at least 16 elements. This matrix's components are stored in the array
	         * starting with row 0 column 0 in index 0, row 1 column 0 in index 1, row 2 column 0 in index 2, and so on.
	         *
	         * @param {Float32Array | Float64Array | Number[]} result An array of at least 16 elements. Upon return,
	         * contains this matrix's components in column-major.
	         * @returns {Float32Array} The specified result array.
	         * @throws {ArgumentError} If the specified result array in null or undefined.
	         */
	        Matrix.prototype.columnMajorComponents = function (result) {
	            if (!result) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Matrix", "columnMajorComponents", "missingResult"));
	            }

	            // Column 1
	            result[0] = this[0];
	            result[1] = this[4];
	            result[2] = this[8];
	            result[3] = this[12];
	            // Column 2
	            result[4] = this[1];
	            result[5] = this[5];
	            result[6] = this[9];
	            result[7] = this[13];
	            // Column 3
	            result[8] = this[2];
	            result[9] = this[6];
	            result[10] = this[10];
	            result[11] = this[14];
	            // Column 4
	            result[12] = this[3];
	            result[13] = this[7];
	            result[14] = this[11];
	            result[15] = this[15];

	            return result;
	        };

	        /**
	         * Sets this matrix to a translation matrix with specified translation components.
	         * @param {Number} x The X translation component.
	         * @param {Number} y The Y translation component.
	         * @param {Number} z The Z translation component.
	         * @returns {Matrix} This matrix with its translation components set to those specified and all other
	         * components set to that of an identity matrix.
	         */
	        Matrix.prototype.setToTranslation = function (x, y, z) {
	            this[0] = 1;
	            this[1] = 0;
	            this[2] = 0;
	            this[3] = x;
	            this[4] = 0;
	            this[5] = 1;
	            this[6] = 0;
	            this[7] = y;
	            this[8] = 0;
	            this[9] = 0;
	            this[10] = 1;
	            this[11] = z;
	            this[12] = 0;
	            this[13] = 0;
	            this[14] = 0;
	            this[15] = 1;

	            return this;
	        };

	        /**
	         * Sets the translation components of this matrix to specified values.
	         * @param {Number} x The X translation component.
	         * @param {Number} y The Y translation component.
	         * @param {Number} z The Z translation component.
	         * @returns {Matrix} This matrix with its translation components set to the specified values and all other
	         * components unmodified.
	         */
	        Matrix.prototype.setTranslation = function (x, y, z) {
	            this[3] = x;
	            this[7] = y;
	            this[11] = z;

	            return this;
	        };

	        /**
	         * Sets this matrix to a scale matrix with specified scale components.
	         * @param {Number} xScale The X scale component.
	         * @param {Number} yScale The Y scale component.
	         * @param {Number} zScale The Z scale component.
	         * @returns {Matrix} This matrix with its scale components set to those specified and all other
	         * components set to that of an identity matrix.
	         */
	        Matrix.prototype.setToScale = function (xScale, yScale, zScale) {
	            this[0] = xScale;
	            this[1] = 0;
	            this[2] = 0;
	            this[3] = 0;
	            this[4] = 0;
	            this[5] = yScale;
	            this[6] = 0;
	            this[7] = 0;
	            this[8] = 0;
	            this[9] = 0;
	            this[10] = zScale;
	            this[11] = 0;
	            this[12] = 0;
	            this[13] = 0;
	            this[14] = 0;
	            this[15] = 1;

	            return this;
	        };

	        /**
	         * Sets the scale components of this matrix to specified values.
	         * @param {Number} xScale The X scale component.
	         * @param {Number} yScale The Y scale component.
	         * @param {Number} zScale The Z scale component.
	         * @returns {Matrix} This matrix with its scale components set to the specified values and all other
	         * components unmodified.
	         */
	        Matrix.prototype.setScale = function (xScale, yScale, zScale) {
	            this[0] = xScale;
	            this[5] = yScale;
	            this[10] = zScale;

	            return this;
	        };

	        /**
	         * Sets this matrix to the transpose of a specified matrix.
	         * @param {Matrix} matrix The matrix whose transpose is to be copied.
	         * @returns {Matrix} This matrix, with its values set to the transpose of the specified matrix.
	         * @throws {ArgumentError} If the specified matrix in null or undefined.
	         */
	        Matrix.prototype.setToTransposeOfMatrix = function (matrix) {
	            if (!matrix) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Matrix", "setToTransposeOfMatrix", "missingMatrix"));
	            }

	            this[0] = matrix[0];
	            this[1] = matrix[4];
	            this[2] = matrix[8];
	            this[3] = matrix[12];
	            this[4] = matrix[1];
	            this[5] = matrix[5];
	            this[6] = matrix[9];
	            this[7] = matrix[13];
	            this[8] = matrix[2];
	            this[9] = matrix[6];
	            this[10] = matrix[10];
	            this[11] = matrix[14];
	            this[12] = matrix[3];
	            this[13] = matrix[7];
	            this[14] = matrix[11];
	            this[15] = matrix[15];

	            return this;
	        };

	        /**
	         * Sets this matrix to the matrix product of two specified matrices.
	         * @param {Matrix} matrixA The first matrix multiplicand.
	         * @param {Matrix} matrixB The second matrix multiplicand.
	         * @returns {Matrix} This matrix set to the product of matrixA x matrixB.
	         * @throws {ArgumentError} If either specified matrix is null or undefined.
	         */
	        Matrix.prototype.setToMultiply = function (matrixA, matrixB) {
	            if (!matrixA || !matrixB) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Matrix", "setToMultiply", "missingMatrix"));
	            }

	            var ma = matrixA,
	                mb = matrixB;

	            this[0] = ma[0] * mb[0] + ma[1] * mb[4] + ma[2] * mb[8] + ma[3] * mb[12];
	            this[1] = ma[0] * mb[1] + ma[1] * mb[5] + ma[2] * mb[9] + ma[3] * mb[13];
	            this[2] = ma[0] * mb[2] + ma[1] * mb[6] + ma[2] * mb[10] + ma[3] * mb[14];
	            this[3] = ma[0] * mb[3] + ma[1] * mb[7] + ma[2] * mb[11] + ma[3] * mb[15];

	            this[4] = ma[4] * mb[0] + ma[5] * mb[4] + ma[6] * mb[8] + ma[7] * mb[12];
	            this[5] = ma[4] * mb[1] + ma[5] * mb[5] + ma[6] * mb[9] + ma[7] * mb[13];
	            this[6] = ma[4] * mb[2] + ma[5] * mb[6] + ma[6] * mb[10] + ma[7] * mb[14];
	            this[7] = ma[4] * mb[3] + ma[5] * mb[7] + ma[6] * mb[11] + ma[7] * mb[15];

	            this[8] = ma[8] * mb[0] + ma[9] * mb[4] + ma[10] * mb[8] + ma[11] * mb[12];
	            this[9] = ma[8] * mb[1] + ma[9] * mb[5] + ma[10] * mb[9] + ma[11] * mb[13];
	            this[10] = ma[8] * mb[2] + ma[9] * mb[6] + ma[10] * mb[10] + ma[11] * mb[14];
	            this[11] = ma[8] * mb[3] + ma[9] * mb[7] + ma[10] * mb[11] + ma[11] * mb[15];

	            this[12] = ma[12] * mb[0] + ma[13] * mb[4] + ma[14] * mb[8] + ma[15] * mb[12];
	            this[13] = ma[12] * mb[1] + ma[13] * mb[5] + ma[14] * mb[9] + ma[15] * mb[13];
	            this[14] = ma[12] * mb[2] + ma[13] * mb[6] + ma[14] * mb[10] + ma[15] * mb[14];
	            this[15] = ma[12] * mb[3] + ma[13] * mb[7] + ma[14] * mb[11] + ma[15] * mb[15];

	            return this;
	        };

	        /**
	         * Sets this matrix to the symmetric covariance Matrix computed from the x, y, z coordinates of a specified
	         * points array.
	         * <p/>
	         * The computed covariance matrix represents the correlation between each pair of x-, y-, and z-coordinates as
	         * they're distributed about the point array's arithmetic mean. Its layout is as follows:
	         * <p/>
	         * <code> C(x, x)  C(x, y)  C(x, z) <br/> C(x, y)  C(y, y)  C(y, z) <br/> C(x, z)  C(y, z)  C(z, z) </code>
	         * <p/>
	         * C(i, j) is the covariance of coordinates i and j, where i or j are a coordinate's dispersion about its mean
	         * value. If any entry is zero, then there's no correlation between the two coordinates defining that entry. If the
	         * returned matrix is diagonal, then all three coordinates are uncorrelated, and the specified point is
	         * distributed evenly about its mean point.
	         * @param {Float32Array | Float64Array | Number[]} points The points to consider.
	         * @returns {Matrix} This matrix set to the covariance matrix for the specified list of points.
	         * @throws {ArgumentError} If the specified array of points is null, undefined or empty.
	         */
	        Matrix.prototype.setToCovarianceOfPoints = function (points) {
	            if (!points || points.length < 1) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Matrix", "setToCovarianceOfPoints", "missingArray"));
	            }

	            var mean,
	                dx,
	                dy,
	                dz,
	                count = 0,
	                c11 = 0,
	                c22 = 0,
	                c33 = 0,
	                c12 = 0,
	                c13 = 0,
	                c23 = 0,
	                vec = new Vec3(0, 0, 0);

	            mean = Vec3.averageOfBuffer(points, new Vec3(0, 0, 0));

	            for (var i = 0, len = points.length / 3; i < len; i++) {
	                vec[0] = points[i * 3];
	                vec[1] = points[i * 3 + 1];
	                vec[2] = points[i * 3 + 2];

	                dx = vec[0] - mean[0];
	                dy = vec[1] - mean[1];
	                dz = vec[2] - mean[2];

	                ++count;
	                c11 += dx * dx;
	                c22 += dy * dy;
	                c33 += dz * dz;
	                c12 += dx * dy; // c12 = c21
	                c13 += dx * dz; // c13 = c31
	                c23 += dy * dz; // c23 = c32
	            }

	            // Row 1
	            this[0] = c11 / count;
	            this[1] = c12 / count;
	            this[2] = c13 / count;
	            this[3] = 0;

	            // Row 2
	            this[4] = c12 / count;
	            this[5] = c22 / count;
	            this[6] = c23 / count;
	            this[7] = 0;

	            // Row 3
	            this[8] = c13 / count;
	            this[9] = c23 / count;
	            this[10] = c33 / count;
	            this[11] = 0;

	            // Row 4
	            this[12] = 0;
	            this[13] = 0;
	            this[14] = 0;
	            this[15] = 0;

	            return this;
	        };

	        /**
	         * Multiplies this matrix by a translation matrix with specified translation values.
	         * @param {Number} x The X translation component.
	         * @param {Number} y The Y translation component.
	         * @param {Number} z The Z translation component.
	         * @returns {Matrix} This matrix multiplied by the translation matrix implied by the specified values.
	         */
	        Matrix.prototype.multiplyByTranslation = function (x, y, z) {

	            this.multiply(
	                1, 0, 0, x,
	                0, 1, 0, y,
	                0, 0, 1, z,
	                0, 0, 0, 1);

	            return this;
	        };

	        /**
	         * Multiplies this matrix by a rotation matrix about a specified axis and angle.
	         * @param {Number} x The X component of the rotation axis.
	         * @param {Number} y The Y component of the rotation axis.
	         * @param {Number} z The Z component of the rotation axis.
	         * @param {Number} angleDegrees The angle to rotate, in degrees.
	         * @returns {Matrix} This matrix multiplied by the rotation matrix implied by the specified values.
	         */
	        Matrix.prototype.multiplyByRotation = function (x, y, z, angleDegrees) {

	            var c = Math.cos(angleDegrees * Angle.DEGREES_TO_RADIANS),
	                s = Math.sin(angleDegrees * Angle.DEGREES_TO_RADIANS);

	            this.multiply(
	                c + (1 - c) * x * x, (1 - c) * x * y - s * z, (1 - c) * x * z + s * y, 0,
	                (1 - c) * x * y + s * z, c + (1 - c) * y * y, (1 - c) * y * z - s * x, 0,
	                (1 - c) * x * z - s * y, (1 - c) * y * z + s * x, c + (1 - c) * z * z, 0,
	                0, 0, 0, 1);

	            return this;
	        };

	        /**
	         * Multiplies this matrix by a scale matrix with specified values.
	         * @param {Number} xScale The X scale component.
	         * @param {Number} yScale The Y scale component.
	         * @param {Number} zScale The Z scale component.
	         * @returns {Matrix} This matrix multiplied by the scale matrix implied by the specified values.
	         */
	        Matrix.prototype.multiplyByScale = function (xScale, yScale, zScale) {

	            this.multiply(
	                xScale, 0, 0, 0,
	                0, yScale, 0, 0,
	                0, 0, zScale, 0,
	                0, 0, 0, 1);

	            return this;
	        };

	        /**
	         * Sets this matrix to one that flips and shifts the y-axis.
	         * <p>
	         * The resultant matrix maps Y=0 to Y=1 and Y=1 to Y=0. All existing values are overwritten. This matrix is
	         * usually used to change the coordinate origin from an upper left coordinate origin to a lower left coordinate
	         * origin. This is typically necessary to align the coordinate system of images (top-left origin) with that of
	         * OpenGL (bottom-left origin).
	         * @returns {Matrix} This matrix set to values described above.
	         */
	        Matrix.prototype.setToUnitYFlip = function () {

	            this[0] = 1;
	            this[1] = 0;
	            this[2] = 0;
	            this[3] = 0;
	            this[4] = 0;
	            this[5] = -1;
	            this[6] = 0;
	            this[7] = 1;
	            this[8] = 0;
	            this[9] = 0;
	            this[10] = 1;
	            this[11] = 0;
	            this[12] = 0;
	            this[13] = 0;
	            this[14] = 0;
	            this[15] = 1;

	            return this;
	        };

	        /**
	         * Multiplies this matrix by a local coordinate system transform for the specified globe.
	         * <p>
	         * The local coordinate system is defined such that the local origin (0, 0, 0) maps to the specified origin
	         * point, the z axis maps to the globe's surface normal at the point, the y-axis maps to the north pointing
	         * tangent, and the x-axis maps to the east pointing tangent.
	         *
	         * @param {Vec3} origin The local coordinate system origin, in model coordinates.
	         * @param {Globe} globe The globe the coordinate system is relative to.
	         *
	         * @throws {ArgumentError} If either argument is null or undefined.
	         */
	        Matrix.prototype.multiplyByLocalCoordinateTransform = function (origin, globe) {
	            if (!origin) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Matrix", "multiplyByLocalCoordinateTransform",
	                        "Origin vector is null or undefined"));
	            }

	            if (!globe) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Matrix", "multiplyByLocalCoordinateTransform",
	                        "missingGlobe"));
	            }

	            var xAxis = new Vec3(0, 0, 0),
	                yAxis = new Vec3(0, 0, 0),
	                zAxis = new Vec3(0, 0, 0);

	            WWMath.localCoordinateAxesAtPoint(origin, globe, xAxis, yAxis, zAxis);

	            this.multiply(
	                xAxis[0], yAxis[0], zAxis[0], origin[0],
	                xAxis[1], yAxis[1], zAxis[1], origin[1],
	                xAxis[2], yAxis[2], zAxis[2], origin[2],
	                0, 0, 0, 1);

	            return this;
	        };

	        /**
	         * Multiplies this matrix by a texture transform for the specified texture.
	         * <p>
	         * A texture image transform maps the bottom-left corner of the texture's image data to coordinate [0,0] and maps the
	         * top-right of the texture's image data to coordinate [1,1]. This correctly handles textures whose image data has
	         * non-power-of-two dimensions, and correctly orients textures whose image data has its origin in the upper-left corner.
	         *
	         * @param {Texture} texture The texture to multiply a transform for.
	         *
	         * @throws {ArgumentError} If the texture is null or undefined.
	         */
	        Matrix.prototype.multiplyByTextureTransform = function (texture) {
	            if (!texture) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Matrix", "multiplyByTextureTransform",
	                        "missingTexture"));
	            }

	            // Compute the scale necessary to map the edge of the image data to the range [0,1]. When the texture contains
	            // power-of-two image data the scale is 1 and has no effect. Otherwise, the scale is computed such that the portion
	            // of the texture containing image data maps to the range [0,1].
	            var sx = texture.originalImageWidth / texture.imageWidth,
	                sy = texture.originalImageHeight / texture.imageHeight;

	            // Multiply this by a scaling matrix that maps the texture's image data to the range [0,1] and inverts the y axis.
	            // We have precomputed the result here in order to avoid an unnecessary matrix multiplication.
	            this.multiply(
	                sx, 0, 0, 0,
	                0, -sy, 0, sy,
	                0, 0, 1, 0,
	                0, 0, 0, 1);

	            return this;
	        };

	        /**
	         * Returns the translation components of this matrix.
	         * @param {Vec3} result A pre-allocated {@link Vec3} in which to return the translation components.
	         * @returns {Vec3} The specified result argument set to the translation components of this matrix.
	         * @throws {ArgumentError} If the specified result argument is null or undefined.
	         */
	        Matrix.prototype.extractTranslation = function (result) {
	            if (!result) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Matrix", "extractTranslation", "missingResult"));
	            }

	            result[0] = this[3];
	            result[1] = this[7];
	            result[2] = this[11];

	            return result;
	        };

	        /**
	         * Returns the rotation angles of this matrix.
	         * @param {Vec3} result A pre-allocated {@link Vec3} in which to return the rotation angles.
	         * @returns {Vec3} The specified result argument set to the rotation angles of this matrix. The angles are in
	         * degrees.
	         * @throws {ArgumentError} If the specified result argument is null or undefined.
	         */
	        Matrix.prototype.extractRotationAngles = function (result) {
	            if (!result) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Matrix", "extractRotationAngles", "missingResult"));
	            }

	            // Taken from Extracting Euler Angles from a Rotation Matrix by Mike Day, Insomniac Games.
	            // http://www.insomniacgames.com/mike-day-extracting-euler-angles-from-a-rotation-matrix/

	            var x = Math.atan2(this[6], this[10]),
	                y = Math.atan2(-this[2], Math.sqrt(this[0] * this[0] + this[1] * this[1])),
	                cx = Math.cos(x),
	                sx = Math.sin(x),
	                z = Math.atan2(sx * this[8] - cx * this[4], cx * this[5] - sx * this[9]);

	            result[0] = x * Angle.RADIANS_TO_DEGREES;
	            result[1] = y * Angle.RADIANS_TO_DEGREES;
	            result[2] = z * Angle.RADIANS_TO_DEGREES;

	            return result;
	        };

	        /**
	         * Multiplies this matrix by a first person viewing matrix for the specified globe.
	         * <p>
	         * A first person viewing matrix places the viewer's eye at the specified eyePosition. By default the viewer is looking
	         * straight down at the globe's surface from the eye position, with the globe's normal vector coming out of the screen
	         * and north pointing toward the top of the screen.
	         * <p>
	         * Heading specifies the viewer's azimuth, or its angle relative to North. Heading values range from -180 degrees to 180
	         * degrees. A heading of 0 degrees looks North, 90 degrees looks East, +-180 degrees looks South, and -90 degrees looks
	         * West.
	         * <p>
	         * Tilt specifies the viewer's angle relative to the surface. Tilt values range from -180 degrees to 180 degrees. A tilt
	         * of 0 degrees looks straight down at the globe's surface, 90 degrees looks at the horizon, and 180 degrees looks
	         * straight up. Tilt values greater than 180 degrees cause the viewer to turn upside down, and are therefore rarely used.
	         * <p>
	         * Roll specifies the viewer's angle relative to the horizon. Roll values range from -180 degrees to 180 degrees. A roll
	         * of 0 degrees orients the viewer so that up is pointing to the top of the screen, at 90 degrees up is pointing to the
	         * right, at +-180 degrees up is pointing to the bottom, and at -90 up is pointing to the left.
	         *
	         * @param {Position} eyePosition The viewer's geographic eye position relative to the specified globe.
	         * @param {Number} heading The viewer's angle relative to north, in degrees.
	         * @param {Number} tilt The viewer's angle relative to the surface, in degrees.
	         * @param {Number} roll The viewer's angle relative to the horizon, in degrees.
	         * @param {Globe} globe The globe the viewer is looking at.
	         *
	         * @throws {ArgumentError} If the specified position or globe is null or undefined.
	         */
	        Matrix.prototype.multiplyByFirstPersonModelview = function (eyePosition, heading, tilt, roll, globe) {
	            if (!eyePosition) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Matrix", "multiplyByFirstPersonModelview", "missingPosition"));
	            }

	            if (!globe) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Matrix", "multiplyByFirstPersonModelview", "missingGlobe"));
	            }

	            var c,
	                s,
	                ex, ey, ez,
	                xx, xy, xz,
	                yx, yy, yz,
	                zx, zy, zz,
	                eyePoint = new Vec3(0, 0, 0),
	                xAxis = new Vec3(0, 0, 0),
	                yAxis = new Vec3(0, 0, 0),
	                zAxis = new Vec3(0, 0, 0);

	            // Roll. Rotate the eye point in a counter-clockwise direction about the z axis. Note that we invert the sines used
	            // in the rotation matrix in order to produce the counter-clockwise rotation. We invert only the cosines since
	            // sin(-a) = -sin(a) and cos(-a) = cos(a).
	            c = Math.cos(roll * Angle.DEGREES_TO_RADIANS);
	            s = Math.sin(roll * Angle.DEGREES_TO_RADIANS);
	            this.multiply(
	                c, s, 0, 0,
	                -s, c, 0, 0,
	                0, 0, 1, 0,
	                0, 0, 0, 1);

	            // Tilt. Rotate the eye point in a counter-clockwise direction about the x axis. Note that we invert the sines used
	            // in the rotation matrix in order to produce the counter-clockwise rotation. We invert only the cosines since
	            // sin(-a) = -sin(a) and cos(-a) = cos(a).
	            c = Math.cos(tilt * Angle.DEGREES_TO_RADIANS);
	            s = Math.sin(tilt * Angle.DEGREES_TO_RADIANS);
	            this.multiply(1, 0, 0, 0,
	                0, c, s, 0,
	                0, -s, c, 0,
	                0, 0, 0, 1);

	            // Heading. Rotate the eye point in a clockwise direction about the z axis again. This has a different effect than
	            // roll when tilt is non-zero because the viewer is no longer looking down the z axis.
	            c = Math.cos(heading * Angle.DEGREES_TO_RADIANS);
	            s = Math.sin(heading * Angle.DEGREES_TO_RADIANS);
	            this.multiply(c, -s, 0, 0,
	                s, c, 0, 0,
	                0, 0, 1, 0,
	                0, 0, 0, 1);

	            // Compute the eye point in model coordinates. This point is mapped to the origin in the look at transform below.
	            globe.computePointFromPosition(eyePosition.latitude, eyePosition.longitude, eyePosition.altitude, eyePoint);
	            ex = eyePoint[0];
	            ey = eyePoint[1];
	            ez = eyePoint[2];

	            // Transform the origin to the local coordinate system at the eye point.
	            WWMath.localCoordinateAxesAtPoint(eyePoint, globe, xAxis, yAxis, zAxis);
	            xx = xAxis[0];
	            xy = xAxis[1];
	            xz = xAxis[2];
	            yx = yAxis[0];
	            yy = yAxis[1];
	            yz = yAxis[2];
	            zx = zAxis[0];
	            zy = zAxis[1];
	            zz = zAxis[2];

	            this.multiply(xx, xy, xz, -xx * ex - xy * ey - xz * ez,
	                yx, yy, yz, -yx * ex - yy * ey - yz * ez,
	                zx, zy, zz, -zx * ex - zy * ey - zz * ez,
	                0, 0, 0, 1);

	            return this;
	        };

	        /**
	         * Multiplies this matrix by a look at viewing matrix for the specified globe.
	         * <p>
	         * A look at viewing matrix places the center of the screen at the specified lookAtPosition. By default the viewer is
	         * looking straight down at the look at position from the specified range, with the globe's normal vector coming out of
	         * the screen and north pointing toward the top of the screen.
	         * <p>
	         * Range specifies the distance between the look at position and the viewer's eye point. Range values may be any positive
	         * real number. A range of 0 places the eye point at the look at point, while a positive range moves the eye point away
	         * from but still looking at the look at point.
	         * <p>
	         * Heading specifies the viewer's azimuth, or its angle relative to North. Heading values range from -180 degrees to 180
	         * degrees. A heading of 0 degrees looks North, 90 degrees looks East, +-180 degrees looks South, and -90 degrees looks
	         * West.
	         * <p>
	         * Tilt specifies the viewer's angle relative to the surface. Tilt values range from -180 degrees to 180 degrees. A tilt
	         * of 0 degrees looks straight down at the globe's surface, 90 degrees looks at the horizon, and 180 degrees looks
	         * straight up. Tilt values greater than 180 degrees cause the viewer to turn upside down, and are therefore rarely used.
	         * <p>
	         * Roll specifies the viewer's angle relative to the horizon. Roll values range from -180 degrees to 180 degrees. A roll
	         * of 0 degrees orients the viewer so that up is pointing to the top of the screen, at 90 degrees up is pointing to the
	         * right, at +-180 degrees up is pointing to the bottom, and at -90 up is pointing to the left.
	         *
	         * @param {Position} lookAtPosition The viewer's geographic look at position relative to the specified globe.
	         * @param {Number} range The distance between the eye point and the look at point, in model coordinates.
	         * @param {Number} heading The viewer's angle relative to north, in degrees.
	         * @param {Number} tilt The viewer's angle relative to the surface, in degrees.
	         * @param {Number} roll The viewer's angle relative to the horizon, in degrees.
	         * @param {Globe} globe The globe the viewer is looking at.
	         *
	         * @throws {ArgumentError} If either the specified look-at position or globe is null or undefined, or the
	         * specified range is less than zero.
	         */
	        Matrix.prototype.multiplyByLookAtModelview = function (lookAtPosition, range, heading, tilt, roll, globe) {
	            if (!lookAtPosition) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Matrix", "multiplyByLookAtModelview", "missingPosition"));
	            }

	            if (range < 0) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Matrix", "multiplyByLookAtModelview",
	                        "Range is less than zero"));
	            }

	            if (!globe) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Matrix", "multiplyByLookAtModelview", "missingGlobe"));
	            }

	            // Translate the eye point along the positive z axis while keeping the look at point in the center of the viewport.
	            this.multiplyByTranslation(0, 0, -range);

	            // Transform the origin to the local coordinate system at the look at position, and rotate the viewer by the
	            // specified heading, tilt and roll.
	            this.multiplyByFirstPersonModelview(lookAtPosition, heading, tilt, roll, globe);

	            return this;
	        };

	        /**
	         * Sets this matrix to a perspective projection matrix for the specified viewport dimensions and clip distances.
	         * <p>
	         * A perspective projection matrix maps points in eye coordinates into clip coordinates in a way that causes
	         * distant objects to appear smaller, and preserves the appropriate depth information for each point. In model
	         * coordinates, a perspective projection is defined by frustum originating at the eye position and extending
	         * outward in the viewer's direction. The near distance and the far distance identify the minimum and maximum
	         * distance, respectively, at which an object in the scene is visible. Near and far distances must be positive
	         * and may not be equal.
	         *
	         * @param {Number} viewportWidth The viewport width, in screen coordinates.
	         * @param {Number} viewportHeight The viewport height, in screen coordinates.
	         * @param {Number} nearDistance The near clip plane distance, in model coordinates.
	         * @param {Number} farDistance The far clip plane distance, in model coordinates.
	         * @throws {ArgumentError} If the specified width or height is less than or equal to zero, if the near and far
	         * distances are equal, or if either the near or far distance are less than or equal to zero.
	         */
	        Matrix.prototype.setToPerspectiveProjection = function (viewportWidth, viewportHeight, nearDistance, farDistance) {
	            if (viewportWidth <= 0) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "Matrix", "setToPerspectiveProjection",
	                    "invalidWidth"));
	            }

	            if (viewportHeight <= 0) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "Matrix", "setToPerspectiveProjection",
	                    "invalidHeight"));
	            }

	            if (nearDistance === farDistance) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "Matrix", "setToPerspectiveProjection",
	                        "Near and far distance are the same."));
	            }

	            if (nearDistance <= 0 || farDistance <= 0) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "Matrix", "setToPerspectiveProjection",
	                        "Near or far distance is less than or equal to zero."));
	            }

	            // Compute the dimensions of the viewport rectangle at the near distance.
	            var nearRect = WWMath.perspectiveFrustumRectangle(viewportWidth, viewportHeight, nearDistance),
	                left = nearRect.getMinX(),
	                right = nearRect.getMaxX(),
	                bottom = nearRect.getMinY(),
	                top = nearRect.getMaxY();

	            // Taken from Mathematics for 3D Game Programming and Computer Graphics, Second Edition, equation 4.52.

	            // Row 1
	            this[0] = 2 * nearDistance / (right - left);
	            this[1] = 0;
	            this[2] = (right + left) / (right - left);
	            this[3] = 0;
	            // Row 2
	            this[4] = 0;
	            this[5] = 2 * nearDistance / (top - bottom);
	            this[6] = (top + bottom) / (top - bottom);
	            this[7] = 0;
	            // Row 3
	            this[8] = 0;
	            this[9] = 0;
	            this[10] = -(farDistance + nearDistance) / (farDistance - nearDistance);
	            this[11] = -2 * nearDistance * farDistance / (farDistance - nearDistance);
	            // Row 4
	            this[12] = 0;
	            this[13] = 0;
	            this[14] = -1;
	            this[15] = 0;

	            return this;
	        };

	        /**
	         * Sets this matrix to a screen projection matrix for the specified viewport dimensions.
	         * <p>
	         * A screen projection matrix is an orthographic projection that assumes that points in model coordinates
	         * represent a screen point and a depth. Screen projection matrices therefore map model coordinates directly
	         * into screen coordinates without modification. A point's xy coordinates are interpreted as literal screen
	         * coordinates and must be in the viewport to be visible. A point's z coordinate is interpreted as a depth value
	         * that ranges from 0 to 1. Additionally, the screen projection matrix preserves the depth value returned by
	         * [NavigatorState.project]{@link NavigatorState#project}.
	         *
	         * @param {Number} viewportWidth The viewport width, in screen coordinates.
	         * @param {Number} viewportHeight The viewport height, in screen coordinates.
	         * @throws {ArgumentError} If the specified width or height is less than or equal to zero.
	         */
	        Matrix.prototype.setToScreenProjection = function (viewportWidth, viewportHeight) {
	            if (viewportWidth <= 0) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "Matrix", "setToScreenProjection",
	                    "invalidWidth"));
	            }

	            if (viewportHeight <= 0) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "Matrix", "setToScreenProjection",
	                    "invalidHeight"));
	            }

	            // Taken from Mathematics for 3D Game Programming and Computer Graphics, Second Edition, equation 4.57.
	            // Simplified to assume that the viewport origin is (0, 0).
	            //
	            // The third row of this projection matrix is configured so that points with z coordinates representing
	            // depth values ranging from 0 to 1 are not modified after transformation into window coordinates. This
	            // projection matrix maps z values in the range [0, 1] to the range [-1, 1] by applying the following
	            // function to incoming z coordinates:
	            //
	            // zp = z0 * 2 - 1
	            //
	            // Where 'z0' is the point's z coordinate and 'zp' is the projected z coordinate. The GPU then maps the
	            // projected z coordinate into window coordinates in the range [0, 1] by applying the following function:
	            //
	            // zw = zp * 0.5 + 0.5
	            //
	            // The result is that a point's z coordinate is effectively passed to the GPU without modification.

	            // Row 1
	            this[0] = 2 / viewportWidth;
	            this[1] = 0;
	            this[2] = 0;
	            this[3] = -1;
	            // Row 2
	            this[4] = 0;
	            this[5] = 2 / viewportHeight;
	            this[6] = 0;
	            this[7] = -1;
	            // Row 3
	            this[8] = 0;
	            this[9] = 0;
	            this[10] = 2;
	            this[11] = -1;
	            // Row 4
	            this[12] = 0;
	            this[13] = 0;
	            this[14] = 0;
	            this[15] = 1;

	            return this;
	        };

	        /**
	         * Returns this viewing matrix's eye point.
	         * <p>
	         * This method assumes that this matrix represents a viewing matrix. If this does not represent a viewing matrix the
	         * results are undefined.
	         * <p>
	         * In model coordinates, a viewing matrix's eye point is the point the viewer is looking from and maps to the center of
	         * the screen.
	         *
	         * @param {Vec3} result A pre-allocated {@link Vec3} in which to return the extracted values.
	         * @return {Vec3} The specified result argument containing the viewing matrix's eye point, in model coordinates.
	         * @throws {ArgumentError} If the specified result argument is null or undefined.
	         */
	        Matrix.prototype.extractEyePoint = function (result) {
	            if (!result) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Matrix", "extractEyePoint", "missingResult"));
	            }

	            // The eye point of a modelview matrix is computed by transforming the origin (0, 0, 0, 1) by the matrix's inverse.
	            // This is equivalent to transforming the inverse of this matrix's translation components in the rightmost column by
	            // the transpose of its upper 3x3 components.
	            result[0] = -(this[0] * this[3]) - (this[4] * this[7]) - (this[8] * this[11]);
	            result[1] = -(this[1] * this[3]) - (this[5] * this[7]) - (this[9] * this[11]);
	            result[2] = -(this[2] * this[3]) - (this[6] * this[7]) - (this[10] * this[11]);

	            return result;
	        };

	        /**
	         * Returns this viewing matrix's forward vector.
	         * <p>
	         * This method assumes that this matrix represents a viewing matrix. If this does not represent a viewing matrix the
	         * results are undefined.
	         *
	         * @param {Vec3} result A pre-allocated {@link Vec3} in which to return the extracted values.
	         * @return {Vec3} The specified result argument containing the viewing matrix's forward vector, in model coordinates.
	         * @throws {ArgumentError} If the specified result argument is null or undefined.
	         */
	        Matrix.prototype.extractForwardVector = function (result) {
	            if (!result) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Matrix", "extractForwardVector", "missingResult"));
	            }

	            // The forward vector of a modelview matrix is computed by transforming the negative Z axis (0, 0, -1, 0) by the
	            // matrix's inverse. We have pre-computed the result inline here to simplify this computation.
	            result[0] = -this[8];
	            result[1] = -this[9];
	            result[2] = -this[10];

	            return result;
	        };

	        /**
	         * Extracts this viewing matrix's parameters given a viewing origin and a globe.
	         * <p>
	         * This method assumes that this matrix represents a viewing matrix. If this does not represent a viewing matrix the
	         * results are undefined.
	         * <p>
	         * This returns a parameterization of this viewing matrix based on the specified origin and globe. The origin indicates
	         * the model coordinate point that the view's orientation is relative to, while the globe provides the necessary model
	         * coordinate context for the origin and the orientation. The origin should be either the view's eye point or a point on
	         * the view's forward vector. The view's roll must be specified in order to disambiguate heading and roll when the view's
	         * tilt is zero.
	         * <p>
	         * The following list outlines the returned key-value pairs and their meanings:
	         * <ul>
	         * <li> 'origin' - The geographic position corresponding to the origin point.</li>
	         * <li> 'range' - The distance between the specified origin point and the view's eye point, in model coordinates.</li>
	         * <li> 'heading' - The view's heading angle relative to the globe's north pointing tangent at the origin point, in degrees.</li>
	         * <li> 'tilt' - The view's tilt angle relative to the globe's normal vector at the origin point, in degrees.</li>
	         * <li> 'roll' - The view's roll relative to the globe's normal vector at the origin point, in degrees.</li>
	         * </ul>
	         * @param {Vec3} origin The origin of the viewing parameters, in model coordinates.
	         * @param {Number} roll The view's roll, in degrees.
	         * @param {Globe} globe The globe the viewer is looking at.
	         * @param {Object} result A pre-allocated object in which to return the viewing parameters.
	         *
	         * @return {Object} The specified result argument containing a parameterization of this viewing matrix.
	         *
	         * @throws {ArgumentError} If either the specified origin or globe are null or undefined or the specified
	         * result argument is null or undefined.
	         */
	        Matrix.prototype.extractViewingParameters = function (origin, roll, globe, result) {
	            if (!origin) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Matrix", "extractViewingParameters",
	                        "The specified origin is null or undefined."));
	            }

	            if (!globe) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Matrix", "extractViewingParameters", "missingGlobe"));
	            }

	            if (!result) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Matrix", "extractViewingParameters", "missingResult"));
	            }

	            var originPos = new Position(0, 0, 0),
	                modelviewLocal = Matrix.fromIdentity(),
	                range,
	                ct,
	                st,
	                tilt,
	                cr, sr,
	                ch, sh,
	                heading;

	            globe.computePositionFromPoint(origin[0], origin[1], origin[2], originPos);

	            // Transform the modelview matrix to a local coordinate system at the origin. This eliminates the geographic
	            // transform contained in the modelview matrix while maintaining rotation and translation relative to the origin.
	            modelviewLocal.copy(this);
	            modelviewLocal.multiplyByLocalCoordinateTransform(origin, globe);

	            range = -modelviewLocal[11];
	            ct = modelviewLocal[10];
	            st = Math.sqrt(modelviewLocal[2] * modelviewLocal[2] + modelviewLocal[6] * modelviewLocal[6]);
	            tilt = Math.atan2(st, ct) * Angle.RADIANS_TO_DEGREES;

	            cr = Math.cos(roll * Angle.DEGREES_TO_RADIANS);
	            sr = Math.sin(roll * Angle.DEGREES_TO_RADIANS);
	            ch = cr * modelviewLocal[0] - sr * modelviewLocal[4];
	            sh = sr * modelviewLocal[5] - cr * modelviewLocal[1];
	            heading = Math.atan2(sh, ch) * Angle.RADIANS_TO_DEGREES;

	            result['origin'] = originPos;
	            result['range'] = range;
	            result['heading'] = heading;
	            result['tilt'] = tilt;
	            result['roll'] = roll;

	            return result;
	        };

	        /**
	         * Applies a specified depth offset to this projection matrix.
	         * <p>
	         * This method assumes that this matrix represents a projection matrix. If this does not represent a projection
	         * matrix the results are undefined. Projection matrices can be created by calling
	         * [setToPerspectiveProjection]{@link Matrix#setToPerspectiveProjection} or [setToScreenProjection]{@link Matrix#setToScreenProjection}.
	         * <p>
	         * The depth offset may be any real number and is typically used to draw geometry slightly closer to the user's
	         * eye in order to give those shapes visual priority over nearby or geometry. An offset of zero has no effect.
	         * An offset less than zero brings depth values closer to the eye, while an offset greater than zero pushes
	         * depth values away from the eye.
	         * <p>
	         * Depth offset may be applied to both perspective and orthographic projection matrices. The effect on each
	         * projection type is outlined here:
	         * <p>
	         * <strong>Perspective Projection</strong>
	         * <p>
	         * The effect of depth offset on a perspective projection increases exponentially with distance from the eye.
	         * This has the effect of adjusting the offset for the loss in depth precision with geometry drawn further from
	         * the eye. Distant geometry requires a greater offset to differentiate itself from nearby geometry, while close
	         * geometry does not.
	         * <p>
	         * <strong>Orthographic Projection</strong>
	         * <p>
	         * The effect of depth offset on an orthographic projection increases linearly with distance from the eye. While
	         * it is reasonable to apply a depth offset to an orthographic projection, the effect is most appropriate when
	         * applied to the projection used to draw the scene. For example, when an object's coordinates are projected by
	         * a perspective projection into screen coordinates then drawn using an orthographic projection, it is best to
	         * apply the offset to the original perspective projection. The method [NavigatorState.project]{@link NavigatorState#project} performs the
	         * correct behavior for the projection type used to draw the scene.
	         *
	         * @param {Number} depthOffset The amount of offset to apply.
	         * @returns {Matrix} This matrix with it's depth offset set to the specified offset.
	         */
	        Matrix.prototype.offsetProjectionDepth = function (depthOffset) {

	            this[10] *= 1 + depthOffset;

	            return this;
	        };

	        /**
	         * Multiplies this matrix by a specified matrix.
	         *
	         * @param {Matrix} matrix The matrix to multiply with this matrix.
	         * @returns {Matrix} This matrix after multiplying it by the specified matrix.
	         * @throws {ArgumentError} if the specified matrix is null or undefined.
	         */
	        Matrix.prototype.multiplyMatrix = function (matrix) {
	            if (!matrix) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Matrix", "multiplyMatrix", "missingMatrix"));
	            }

	            var ma = this,
	                mb = matrix,
	                ma0, ma1, ma2, ma3;

	            // Row 1
	            ma0 = ma[0];
	            ma1 = ma[1];
	            ma2 = ma[2];
	            ma3 = ma[3];
	            ma[0] = (ma0 * mb[0]) + (ma1 * mb[4]) + (ma2 * mb[8]) + (ma3 * mb[12]);
	            ma[1] = (ma0 * mb[1]) + (ma1 * mb[5]) + (ma2 * mb[9]) + (ma3 * mb[13]);
	            ma[2] = (ma0 * mb[2]) + (ma1 * mb[6]) + (ma2 * mb[10]) + (ma3 * mb[14]);
	            ma[3] = (ma0 * mb[3]) + (ma1 * mb[7]) + (ma2 * mb[11]) + (ma3 * mb[15]);

	            // Row 2
	            ma0 = ma[4];
	            ma1 = ma[5];
	            ma2 = ma[6];
	            ma3 = ma[7];
	            ma[4] = (ma0 * mb[0]) + (ma1 * mb[4]) + (ma2 * mb[8]) + (ma3 * mb[12]);
	            ma[5] = (ma0 * mb[1]) + (ma1 * mb[5]) + (ma2 * mb[9]) + (ma3 * mb[13]);
	            ma[6] = (ma0 * mb[2]) + (ma1 * mb[6]) + (ma2 * mb[10]) + (ma3 * mb[14]);
	            ma[7] = (ma0 * mb[3]) + (ma1 * mb[7]) + (ma2 * mb[11]) + (ma3 * mb[15]);

	            // Row 3
	            ma0 = ma[8];
	            ma1 = ma[9];
	            ma2 = ma[10];
	            ma3 = ma[11];
	            ma[8] = (ma0 * mb[0]) + (ma1 * mb[4]) + (ma2 * mb[8]) + (ma3 * mb[12]);
	            ma[9] = (ma0 * mb[1]) + (ma1 * mb[5]) + (ma2 * mb[9]) + (ma3 * mb[13]);
	            ma[10] = (ma0 * mb[2]) + (ma1 * mb[6]) + (ma2 * mb[10]) + (ma3 * mb[14]);
	            ma[11] = (ma0 * mb[3]) + (ma1 * mb[7]) + (ma2 * mb[11]) + (ma3 * mb[15]);

	            // Row 4
	            ma0 = ma[12];
	            ma1 = ma[13];
	            ma2 = ma[14];
	            ma3 = ma[15];
	            ma[12] = (ma0 * mb[0]) + (ma1 * mb[4]) + (ma2 * mb[8]) + (ma3 * mb[12]);
	            ma[13] = (ma0 * mb[1]) + (ma1 * mb[5]) + (ma2 * mb[9]) + (ma3 * mb[13]);
	            ma[14] = (ma0 * mb[2]) + (ma1 * mb[6]) + (ma2 * mb[10]) + (ma3 * mb[14]);
	            ma[15] = (ma0 * mb[3]) + (ma1 * mb[7]) + (ma2 * mb[11]) + (ma3 * mb[15]);

	            return this;
	        };

	        /**
	         * Multiplies this matrix by a matrix specified by individual components.
	         *
	         * @param {Number} m00 matrix element at row 1, column 1.
	         * @param {Number} m01 matrix element at row 1, column 2.
	         * @param {Number} m02 matrix element at row 1, column 3.
	         * @param {Number} m03 matrix element at row 1, column 4.
	         * @param {Number} m10 matrix element at row 2, column 1.
	         * @param {Number} m11 matrix element at row 2, column 2.
	         * @param {Number} m12 matrix element at row 2, column 3.
	         * @param {Number} m13 matrix element at row 2, column 4.
	         * @param {Number} m20 matrix element at row 3, column 1.
	         * @param {Number} m21 matrix element at row 3, column 2.
	         * @param {Number} m22 matrix element at row 3, column 3.
	         * @param {Number} m23 matrix element at row 3, column 4.
	         * @param {Number} m30 matrix element at row 4, column 1.
	         * @param {Number} m31 matrix element at row 4, column 2.
	         * @param {Number} m32 matrix element at row 4, column 3.
	         * @param {Number} m33 matrix element at row 4, column 4.
	         * @returns {Matrix} This matrix with its components multiplied by the specified values.
	         */
	        Matrix.prototype.multiply = function (m00, m01, m02, m03,
	                                              m10, m11, m12, m13,
	                                              m20, m21, m22, m23,
	                                              m30, m31, m32, m33) {

	            var ma = this,
	                ma0, ma1, ma2, ma3;

	            // Row 1
	            ma0 = ma[0];
	            ma1 = ma[1];
	            ma2 = ma[2];
	            ma3 = ma[3];
	            ma[0] = (ma0 * m00) + (ma1 * m10) + (ma2 * m20) + (ma3 * m30);
	            ma[1] = (ma0 * m01) + (ma1 * m11) + (ma2 * m21) + (ma3 * m31);
	            ma[2] = (ma0 * m02) + (ma1 * m12) + (ma2 * m22) + (ma3 * m32);
	            ma[3] = (ma0 * m03) + (ma1 * m13) + (ma2 * m23) + (ma3 * m33);

	            // Row 2
	            ma0 = ma[4];
	            ma1 = ma[5];
	            ma2 = ma[6];
	            ma3 = ma[7];
	            ma[4] = (ma0 * m00) + (ma1 * m10) + (ma2 * m20) + (ma3 * m30);
	            ma[5] = (ma0 * m01) + (ma1 * m11) + (ma2 * m21) + (ma3 * m31);
	            ma[6] = (ma0 * m02) + (ma1 * m12) + (ma2 * m22) + (ma3 * m32);
	            ma[7] = (ma0 * m03) + (ma1 * m13) + (ma2 * m23) + (ma3 * m33);

	            // Row 3
	            ma0 = ma[8];
	            ma1 = ma[9];
	            ma2 = ma[10];
	            ma3 = ma[11];
	            ma[8] = (ma0 * m00) + (ma1 * m10) + (ma2 * m20) + (ma3 * m30);
	            ma[9] = (ma0 * m01) + (ma1 * m11) + (ma2 * m21) + (ma3 * m31);
	            ma[10] = (ma0 * m02) + (ma1 * m12) + (ma2 * m22) + (ma3 * m32);
	            ma[11] = (ma0 * m03) + (ma1 * m13) + (ma2 * m23) + (ma3 * m33);

	            // Row 4
	            ma0 = ma[12];
	            ma1 = ma[13];
	            ma2 = ma[14];
	            ma3 = ma[15];
	            ma[12] = (ma0 * m00) + (ma1 * m10) + (ma2 * m20) + (ma3 * m30);
	            ma[13] = (ma0 * m01) + (ma1 * m11) + (ma2 * m21) + (ma3 * m31);
	            ma[14] = (ma0 * m02) + (ma1 * m12) + (ma2 * m22) + (ma3 * m32);
	            ma[15] = (ma0 * m03) + (ma1 * m13) + (ma2 * m23) + (ma3 * m33);

	            return this;
	        };

	        /**
	         * Inverts the specified matrix and stores the result in this matrix.
	         * <p>
	         * This throws an exception if the specified matrix is singular.
	         * <p>
	         * The result of this method is undefined if this matrix is passed in as the matrix to invert.
	         *
	         * @param {Matrix} matrix The matrix whose inverse is computed.
	         * @returns {Matrix} This matrix set to the inverse of the specified matrix.
	         *
	         * @throws {ArgumentError} If the specified matrix is null, undefined or cannot be inverted.
	         */
	        Matrix.prototype.invertMatrix = function (matrix) {
	            if (!matrix) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Matrix", "invertMatrix", "missingMatrix"));
	            }

	            // Copy the specified matrix into a mutable two-dimensional array.
	            var A = [[], [], [], []];
	            A[0][0] = matrix[0];
	            A[0][1] = matrix[1];
	            A[0][2] = matrix[2];
	            A[0][3] = matrix[3];
	            A[1][0] = matrix[4];
	            A[1][1] = matrix[5];
	            A[1][2] = matrix[6];
	            A[1][3] = matrix[7];
	            A[2][0] = matrix[8];
	            A[2][1] = matrix[9];
	            A[2][2] = matrix[10];
	            A[2][3] = matrix[11];
	            A[3][0] = matrix[12];
	            A[3][1] = matrix[13];
	            A[3][2] = matrix[14];
	            A[3][3] = matrix[15];

	            var index = [],
	                d = Matrix.ludcmp(A, index),
	                i,
	                j;

	            // Compute the matrix's determinant.
	            for (i = 0; i < 4; i += 1) {
	                d *= A[i][i];
	            }

	            // The matrix is singular if its determinant is zero or very close to zero.
	            if (Math.abs(d) < 1.0e-8)
	                return null;

	            var Y = [[], [], [], []],
	                col = [];
	            for (j = 0; j < 4; j += 1) {
	                for (i = 0; i < 4; i += 1) {
	                    col[i] = 0.0;
	                }

	                col[j] = 1.0;
	                Matrix.lubksb(A, index, col);

	                for (i = 0; i < 4; i += 1) {
	                    Y[i][j] = col[i];
	                }
	            }

	            this[0] = Y[0][0];
	            this[1] = Y[0][1];
	            this[2] = Y[0][2];
	            this[3] = Y[0][3];
	            this[4] = Y[1][0];
	            this[5] = Y[1][1];
	            this[6] = Y[1][2];
	            this[7] = Y[1][3];
	            this[8] = Y[2][0];
	            this[9] = Y[2][1];
	            this[10] = Y[2][2];
	            this[11] = Y[2][3];
	            this[12] = Y[3][0];
	            this[13] = Y[3][1];
	            this[14] = Y[3][2];
	            this[15] = Y[3][3];

	            return this;
	        };

	        /* Internal. Intentionally not documented.
	         * Utility method to solve a linear system with an LU factorization of a matrix.
	         * Solves Ax=b, where A is in LU factorized form.
	         * Algorithm derived from "Numerical Recipes in C", Press et al., 1988.
	         *
	         * @param {Number[]} A An LU factorization of a matrix.
	         * @param {Number[]} index Permutation vector of that LU factorization.
	         * @param {Number[]} b Vector to be solved.
	         */
	            // Method "lubksb" derived from "Numerical Recipes in C", Press et al., 1988
	        Matrix.lubksb = function (A, index, b) {
	            var ii = -1,
	                i,
	                j,
	                sum;
	            for (i = 0; i < 4; i += 1) {
	                var ip = index[i];
	                sum = b[ip];
	                b[ip] = b[i];

	                if (ii != -1) {
	                    for (j = ii; j <= i - 1; j += 1) {
	                        sum -= A[i][j] * b[j];
	                    }
	                }
	                else if (sum != 0.0) {
	                    ii = i;
	                }

	                b[i] = sum;
	            }

	            for (i = 3; i >= 0; i -= 1) {
	                sum = b[i];
	                for (j = i + 1; j < 4; j += 1) {
	                    sum -= A[i][j] * b[j];
	                }

	                b[i] = sum / A[i][i];
	            }
	        };

	        /* Internal. Intentionally not documented.
	         * Utility method to perform an LU factorization of a matrix.
	         * "ludcmp" is derived from "Numerical Recipes in C", Press et al., 1988.
	         *
	         * @param {Number[]} A matrix to be factored
	         * @param {Number[]} index permutation vector
	         * @returns {Number} Condition number of matrix.
	         */
	        Matrix.ludcmp = function (A, index) {
	            var TINY = 1.0e-20,
	                vv = [], /* new double[4]; */
	                d = 1.0,
	                temp,
	                i,
	                j,
	                k,
	                big,
	                sum,
	                imax,
	                dum;
	            for (i = 0; i < 4; i += 1) {
	                big = 0.0;
	                for (j = 0; j < 4; j += 1) {
	                    if ((temp = Math.abs(A[i][j])) > big) {
	                        big = temp;
	                    }
	                }

	                if (big == 0.0) {
	                    return 0.0; // Matrix is singular if the entire row contains zero.
	                }
	                else {
	                    vv[i] = 1.0 / big;
	                }
	            }

	            for (j = 0; j < 4; j += 1) {
	                for (i = 0; i < j; i += 1) {
	                    sum = A[i][j];
	                    for (k = 0; k < i; k += 1) {
	                        sum -= A[i][k] * A[k][j];
	                    }

	                    A[i][j] = sum;
	                }

	                big = 0.0;
	                imax = -1;
	                for (i = j; i < 4; i += 1) {
	                    sum = A[i][j];
	                    for (k = 0; k < j; k++) {
	                        sum -= A[i][k] * A[k][j];
	                    }

	                    A[i][j] = sum;

	                    if ((dum = vv[i] * Math.abs(sum)) >= big) {
	                        big = dum;
	                        imax = i;
	                    }
	                }

	                if (j != imax) {
	                    for (k = 0; k < 4; k += 1) {
	                        dum = A[imax][k];
	                        A[imax][k] = A[j][k];
	                        A[j][k] = dum;
	                    }

	                    d = -d;
	                    vv[imax] = vv[j];
	                }

	                index[j] = imax;
	                if (A[j][j] == 0.0)
	                    A[j][j] = TINY;

	                if (j != 3) {
	                    dum = 1.0 / A[j][j];
	                    for (i = j + 1; i < 4; i += 1) {
	                        A[i][j] *= dum;
	                    }
	                }
	            }

	            return d;
	        };

	        /**
	         * Inverts the specified matrix and stores the result in this matrix.
	         * <p>
	         * The specified matrix is assumed to represent an orthonormal transform matrix. This matrix's upper 3x3 is
	         * transposed, then its fourth column is transformed by the transposed upper 3x3 and negated.
	         * <p>
	         * The result of this method is undefined if this matrix is passed in as the matrix to invert.
	         *
	         * @param {Matrix} matrix The matrix whose inverse is computed. This matrix is assumed to represent an
	         * orthonormal transform matrix.
	         * @returns {Matrix} This matrix set to the inverse of the specified matrix.
	         *
	         * @throws {ArgumentError} If the specified matrix is null or undefined.
	         */
	        Matrix.prototype.invertOrthonormalMatrix = function (matrix) {
	            if (!matrix) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Matrix", "invertOrthonormalMatrix", "missingMatrix"));
	            }

	            // 'a' is assumed to contain a 3D transformation matrix.
	            // Upper-3x3 is inverted, translation is transformed by inverted-upper-3x3 and negated.

	            var a = matrix;

	            this[0] = a[0];
	            this[1] = a[4];
	            this[2] = a[8];
	            this[3] = 0.0 - (a[0] * a[3]) - (a[4] * a[7]) - (a[8] * a[11]);

	            this[4] = a[1];
	            this[5] = a[5];
	            this[6] = a[9];
	            this[7] = 0.0 - (a[1] * a[3]) - (a[5] * a[7]) - (a[9] * a[11]);

	            this[8] = a[2];
	            this[9] = a[6];
	            this[10] = a[10];
	            this[11] = 0.0 - (a[2] * a[3]) - (a[6] * a[7]) - (a[10] * a[11]);

	            this[12] = 0;
	            this[13] = 0;
	            this[14] = 0;
	            this[15] = 1;

	            return this;
	        };

	        /**
	         * Computes the eigenvectors of this matrix.
	         * <p>
	         * The eigenvectors are returned sorted from the most prominent vector to the least prominent vector.
	         * Each eigenvector has length equal to its corresponding eigenvalue.
	         *
	         * @param {Vec3} result1 A pre-allocated vector in which to return the most prominent eigenvector.
	         * @param {Vec3} result2 A pre-allocated vector in which to return the second most prominent eigenvector.
	         * @param {Vec3} result3 A pre-allocated vector in which to return the least prominent eigenvector.
	         *
	         * @throws {ArgumentError} if any argument is null or undefined or if this matrix is not symmetric.
	         */
	        Matrix.prototype.eigensystemFromSymmetricMatrix = function (result1, result2, result3) {
	            if (!result1 || !result2 || !result3) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Matrix", "eigensystemFromSymmetricMatrix", "missingResult"));
	            }

	            if (this[1] != this[4] || this[2] != this[8] || this[6] != this[9]) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Matrix", "eigensystemFromSymmetricMatrix",
	                        "Matrix is not symmetric"));
	            }

	            // Taken from Mathematics for 3D Game Programming and Computer Graphics, Second Edition, listing 14.6.

	            var epsilon = 1.0e-10,
	            // Since the matrix is symmetric m12=m21, m13=m31 and m23=m32, therefore we can ignore the values m21,
	            // m32 and m32.
	                m11 = this[0],
	                m12 = this[1],
	                m13 = this[2],
	                m22 = this[5],
	                m23 = this[6],
	                m33 = this[10],
	                r = [
	                    [1, 0, 0],
	                    [0, 1, 0],
	                    [0, 0, 1]
	                ],
	                maxSweeps = 32,
	                u, u2, u2p1, t, c, s, temp, i, i1, i2, i3;

	            for (var a = 0; a < maxSweeps; a++) {
	                // Exit if off-diagonal entries small enough
	                if (WWMath.fabs(m12) < epsilon && WWMath.fabs(m13) < epsilon && WWMath.fabs(m23) < epsilon)
	                    break;

	                // Annihilate (1,2) entry.
	                if (m12 != 0) {
	                    u = (m22 - m11) * 0.5 / m12;
	                    u2 = u * u;
	                    u2p1 = u2 + 1;
	                    t = (u2p1 != u2) ? ((u < 0) ? -1 : 1) * (Math.sqrt(u2p1) - WWMath.fabs(u)) : 0.5 / u;
	                    c = 1 / Math.sqrt(t * t + 1);
	                    s = c * t;

	                    m11 -= t * m12;
	                    m22 += t * m12;
	                    m12 = 0;

	                    temp = c * m13 - s * m23;
	                    m23 = s * m13 + c * m23;
	                    m13 = temp;

	                    for (i = 0; i < 3; i++) {
	                        temp = c * r[i][0] - s * r[i][1];
	                        r[i][1] = s * r[i][0] + c * r[i][1];
	                        r[i][0] = temp;
	                    }
	                }

	                // Annihilate (1,3) entry.
	                if (m13 != 0) {
	                    u = (m33 - m11) * 0.5 / m13;
	                    u2 = u * u;
	                    u2p1 = u2 + 1;
	                    t = (u2p1 != u2) ? ((u < 0) ? -1 : 1) * (Math.sqrt(u2p1) - WWMath.fabs(u)) : 0.5 / u;
	                    c = 1 / Math.sqrt(t * t + 1);
	                    s = c * t;

	                    m11 -= t * m13;
	                    m33 += t * m13;
	                    m13 = 0;

	                    temp = c * m12 - s * m23;
	                    m23 = s * m12 + c * m23;
	                    m12 = temp;

	                    for (i = 0; i < 3; i++) {
	                        temp = c * r[i][0] - s * r[i][2];
	                        r[i][2] = s * r[i][0] + c * r[i][2];
	                        r[i][0] = temp;
	                    }
	                }

	                // Annihilate (2,3) entry.
	                if (m23 != 0) {
	                    u = (m33 - m22) * 0.5 / m23;
	                    u2 = u * u;
	                    u2p1 = u2 + 1;
	                    t = (u2p1 != u2) ? ((u < 0) ? -1 : 1) * (Math.sqrt(u2p1) - WWMath.fabs(u)) : 0.5 / u;
	                    c = 1 / Math.sqrt(t * t + 1);
	                    s = c * t;

	                    m22 -= t * m23;
	                    m33 += t * m23;
	                    m23 = 0;

	                    temp = c * m12 - s * m13;
	                    m13 = s * m12 + c * m13;
	                    m12 = temp;

	                    for (i = 0; i < 3; i++) {
	                        temp = c * r[i][1] - s * r[i][2];
	                        r[i][2] = s * r[i][1] + c * r[i][2];
	                        r[i][1] = temp;
	                    }
	                }
	            }

	            i1 = 0;
	            i2 = 1;
	            i3 = 2;

	            if (m11 < m22) {
	                temp = m11;
	                m11 = m22;
	                m22 = temp;

	                temp = i1;
	                i1 = i2;
	                i2 = temp;
	            }

	            if (m22 < m33) {
	                temp = m22;
	                m22 = m33;
	                m33 = temp;

	                temp = i2;
	                i2 = i3;
	                i3 = temp;
	            }

	            if (m11 < m22) {
	                temp = m11;
	                m11 = m22;
	                m22 = temp;

	                temp = i1;
	                i1 = i2;
	                i2 = temp;
	            }

	            result1[0] = r[0][i1];
	            result1[1] = r[1][i1];
	            result1[2] = r[2][i1];

	            result2[0] = r[0][i2];
	            result2[1] = r[1][i2];
	            result2[2] = r[2][i2];

	            result3[0] = r[0][i3];
	            result3[1] = r[1][i3];
	            result3[2] = r[2][i3];

	            result1.normalize();
	            result2.normalize();
	            result3.normalize();

	            result1.multiply(m11);
	            result2.multiply(m22);
	            result3.multiply(m33);
	        };

	        /**
	         * Extracts and returns a new matrix whose upper 3x3 entries are identical to those of this matrix,
	         * and whose fourth row and column are 0 except for a 1 in the diagonal position.
	         * @returns {Matrix} The upper 3x3 matrix of this matrix.
	         */
	        Matrix.prototype.upper3By3 = function () {
	            var result = Matrix.fromIdentity();

	            result[0] = this[0];
	            result[1] = this[1];
	            result[2] = this[2];

	            result[4] = this[4];
	            result[5] = this[5];
	            result[6] = this[6];

	            result[8] = this[8];
	            result[9] = this[9];
	            result[10] = this[10];

	            return result;
	        };

	        return Matrix;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));



/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports Navigator
	 * @version $Id: Navigator.js 3298 2015-07-06 17:28:33Z dcollins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(30),
	        __webpack_require__(32),
	        __webpack_require__(63),
	        __webpack_require__(65),
	        __webpack_require__(47),
	        __webpack_require__(66),
	        __webpack_require__(35),
	        __webpack_require__(36)], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
	              Logger,
	              Matrix,
	              NavigatorState,
	              Position,
	              UnsupportedOperationError,
	              Vec3,
	              WWMath) {
	        "use strict";

	        /**
	         * Constructs a base navigator.
	         * @alias Navigator
	         * @constructor
	         * @classdesc Provides an abstract base class for navigators. This class is not meant to be instantiated
	         * directly. See {@Link LookAtNavigator} for a concrete navigator.
	         * @param {WorldWindow} worldWindow The world window to associate with this navigator.
	         */
	        var Navigator = function (worldWindow) {
	            if (!worldWindow) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Navigator", "constructor", "missingWorldWindow"));
	            }

	            /**
	             * The {@link WorldWindow} associated with this navigator.
	             * @type {WorldWindow}
	             * @readonly
	             */
	            this.worldWindow = worldWindow;

	            /**
	             * This navigator's heading, in degrees clockwise from north.
	             * @type {Number}
	             * @default 0
	             */
	            this.heading = 0;

	            /**
	             * This navigator's tilt, in degrees.
	             * @type {Number}
	             * @default 0
	             */
	            this.tilt = 0;

	            /**
	             * This navigator's roll, in degrees.
	             * @type {Number}
	             * @default 0
	             */
	            this.roll = 0;

	            // Intentionally not documented.
	            this.nearDistance = 1;

	            // Intentionally not documented.
	            this.farDistance = 10e6;
	        };

	        /**
	         * Returns the current state of this navigator. Subclasses must override this method.
	         * @returns {NavigatorState} The current state of this navigator.
	         */
	        Navigator.prototype.currentState = function () {
	            throw new UnsupportedOperationError(
	                Logger.logMessage(Logger.LEVEL_SEVERE, "Navigator", "currentState", "abstractInvocation"));
	        };

	        /**
	         * Returns the current navigator state for a specified model-view matrix.
	         * This method is meant to be called only by subclasses;
	         * applications should not call this method.
	         * @protected
	         * @param {Matrix} modelviewMatrix The modelview matrix.
	         * @returns {NavigatorState} The current navigator state.
	         * @throws {ArgumentError} If the specified matrix is null or undefined.
	         */
	        Navigator.prototype.currentStateForModelview = function (modelviewMatrix) {
	            if (!modelviewMatrix) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Navigator", "currentStateForModelview", "missingMatrix"));
	            }

	            var globe = this.worldWindow.globe,
	                globeRadius = WWMath.max(globe.equatorialRadius, globe.polarRadius),
	                eyePoint = modelviewMatrix.extractEyePoint(new Vec3(0, 0, 0)),
	                eyePos = globe.computePositionFromPoint(eyePoint[0], eyePoint[1], eyePoint[2], new Position(0, 0, 0)),
	                viewport = this.worldWindow.viewport,
	                viewDepthBits = this.worldWindow.depthBits,
	                distanceToSurface,
	                maxNearDistance,
	                projectionMatrix = Matrix.fromIdentity();

	            // Compute the far clip distance based on the current eye altitude. This must be done after computing the
	            // modelview matrix and before computing the near clip distance. The far clip distance depends on the
	            // modelview matrix, and the near clip distance depends on the far clip distance.
	            this.farDistance = WWMath.horizonDistanceForGlobeRadius(globeRadius, eyePos.altitude);
	            // clipping bugfix https://github.com/NASAWorldWind/WebWorldWind/issues/105
	            this.farDistance += 1437568.7253136805; //<-- add this line    
	            if (this.farDistance < 1e3)
	                this.farDistance = 1e3;

	            // Compute the near clip distance in order to achieve a desired depth resolution at the far clip distance.
	            // This computed distance is limited such that it does not intersect the terrain when possible and is never
	            // less than a predetermined minimum (usually one). The computed near distance automatically scales with the
	            // resolution of the WebGL depth buffer.
	            this.nearDistance = WWMath.perspectiveNearDistanceForFarDistance(this.farDistance, 10, viewDepthBits);

	            // Prevent the near clip plane from intersecting the terrain.
	            distanceToSurface = eyePos.altitude - globe.elevationAtLocation(eyePos.latitude, eyePos.longitude);
	            if (distanceToSurface > 0) {
	                maxNearDistance = WWMath.perspectiveNearDistance(viewport.width, viewport.height, distanceToSurface);
	                if (this.nearDistance > maxNearDistance)
	                    this.nearDistance = maxNearDistance;
	            }

	            if (this.nearDistance < 1)
	                this.nearDistance = 1;

	            // Compute the current projection matrix based on this navigator's perspective properties and the current
	            // WebGL viewport.
	            projectionMatrix.setToPerspectiveProjection(viewport.width, viewport.height, this.nearDistance, this.farDistance);

	            return new NavigatorState(modelviewMatrix, projectionMatrix, viewport, this.heading, this.tilt);
	        };

	        return Navigator;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports NavigatorState
	 * @version $Id: NavigatorState.js 3279 2015-06-26 22:42:56Z tgaskins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(30),
	        __webpack_require__(62),
	        __webpack_require__(34),
	        __webpack_require__(32),
	        __webpack_require__(63),
	        __webpack_require__(37),
	        __webpack_require__(46),
	        __webpack_require__(35),
	        __webpack_require__(36)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
	              Frustum,
	              Line,
	              Logger,
	              Matrix,
	              Rectangle,
	              Vec2,
	              Vec3,
	              WWMath) {
	        "use strict";

	        /**
	         * Constructs a navigator state. This constructor is meant to be called by navigators when their current state
	         * is requested.
	         * @alias NavigatorState
	         * @constructor
	         * @classdesc Represents the state of a navigator.
	         * <p>
	         * Properties of NavigatorState objects are
	         * read-only because they are values captured from a {@link Navigator}. Setting the properties on
	         * a NavigatorState instance has no effect on the Navigator from which they came.
	         * @param {Matrix} modelViewMatrix The navigator's model-view matrix.
	         * @param {Matrix} projectionMatrix The navigator's projection matrix.
	         * @param {Rectangle} viewport The navigator's viewport.
	         * @param {Number} heading The navigator's heading.
	         * @param {Number} tilt The navigator's tilt.
	         */
	        var NavigatorState = function (modelViewMatrix, projectionMatrix, viewport, heading, tilt) {

	            /**
	             * The navigator's model-view matrix. The model-view matrix transforms points from model coordinates to eye
	             * coordinates.
	             * @type {Matrix}
	             * @readonly
	             */
	            this.modelview = modelViewMatrix;

	            /**
	             * The navigator's projection matrix. The projection matrix transforms points from eye coordinates to clip
	             * coordinates.
	             * @type {Matrix}
	             * @readonly
	             */
	            this.projection = projectionMatrix;

	            /**
	             * The concatenation of the navigator's model-view and projection matrices. This matrix transforms points
	             * from model coordinates to clip coordinates.
	             * @type {Matrix}
	             * @readonly
	             */
	            this.modelviewProjection = Matrix.fromIdentity();
	            this.modelviewProjection.setToMultiply(projectionMatrix, modelViewMatrix);

	            /**
	             * The navigator's viewport, in WebGL screen coordinates. The viewport places the origin in the bottom-left
	             * corner and has axes that extend up and to the right from the origin.
	             * @type {Rectangle}
	             * @readonly
	             */
	            this.viewport = viewport;

	            /**
	             * Indicates the number of degrees clockwise from north to which the view is directed.
	             * @type {Number}
	             * @readonly
	             */
	            this.heading = heading;

	            /**
	             * The number of degrees the globe is tilted relative to its surface being parallel to the screen. Values are
	             * typically in the range 0 to 90 but may vary from that depending on the navigator in use.
	             * @type {Number}
	             * @readonly
	             */
	            this.tilt = tilt;

	            /**
	             * The navigator's eye point in model coordinates, relative to the globe's center.
	             * @type {Vec3}
	             * @readonly
	             */
	            this.eyePoint = this.modelview.extractEyePoint(new Vec3(0, 0, 0));

	            /**
	             * The navigator's viewing frustum in model coordinates. The frustum originates at the eyePoint and extends
	             * outward along the forward vector. The navigator's near distance and far distance identify the minimum and
	             * maximum distance, respectively, at which an object in the scene is visible.
	             * @type {Frustum}
	             * @readonly
	             */
	            this.frustumInModelCoordinates = null;
	            // Compute the frustum in model coordinates. Start by computing the frustum in eye coordinates from the
	            // projection matrix, then transform this frustum to model coordinates by multiplying its planes by the
	            // transpose of the modelview matrix. We use the transpose of the modelview matrix because planes are
	            // transformed by the inverse transpose of a matrix, and we want to transform from eye coordinates to model
	            // coordinates.
	            var modelviewTranspose = Matrix.fromIdentity();
	            modelviewTranspose.setToTransposeOfMatrix(this.modelview);
	            this.frustumInModelCoordinates = Frustum.fromProjectionMatrix(this.projection);
	            this.frustumInModelCoordinates.transformByMatrix(modelviewTranspose);
	            this.frustumInModelCoordinates.normalize();

	            // Compute the inverse of the modelview, projection, and modelview-projection matrices. The inverse matrices
	            // are used to support operations on navigator state, such as project, unProject, and pixelSizeAtDistance.
	            this.modelviewInv = Matrix.fromIdentity();
	            this.modelviewInv.invertOrthonormalMatrix(this.modelview);
	            this.projectionInv = Matrix.fromIdentity();
	            this.projectionInv.invertMatrix(this.projection);
	            this.modelviewProjectionInv = Matrix.fromIdentity();
	            this.modelviewProjectionInv.invertMatrix(this.modelviewProjection);

	            /**
	             * The matrix that transforms normal vectors in model coordinates to normal vectors in eye coordinates.
	             * Typically used to transform a shape's normal vectors during lighting calculations.
	             * @type {Matrix}
	             * @readonly
	             */
	            this.modelviewNormalTransform = Matrix.fromIdentity().setToTransposeOfMatrix(this.modelviewInv.upper3By3());

	            // Compute the eye coordinate rectangles carved out of the frustum by the near and far clipping planes, and
	            // the distance between those planes and the eye point along the -Z axis. The rectangles are determined by
	            // transforming the bottom-left and top-right points of the frustum from clip coordinates to eye
	            // coordinates.
	            var nbl = new Vec3(-1, -1, -1),
	                ntr = new Vec3(+1, +1, -1),
	                fbl = new Vec3(-1, -1, +1),
	                ftr = new Vec3(+1, +1, +1);
	            // Convert each frustum corner from clip coordinates to eye coordinates by multiplying by the inverse
	            // projection matrix.
	            nbl.multiplyByMatrix(this.projectionInv);
	            ntr.multiplyByMatrix(this.projectionInv);
	            fbl.multiplyByMatrix(this.projectionInv);
	            ftr.multiplyByMatrix(this.projectionInv);

	            var nrRectWidth = WWMath.fabs(ntr[0] - nbl[0]),
	                frRectWidth = WWMath.fabs(ftr[0] - fbl[0]),
	                nrDistance = -nbl[2],
	                frDistance = -fbl[2];

	            // Compute the scale and offset used to determine the width of a pixel on a rectangle carved out of the
	            // frustum at a distance along the -Z axis in eye coordinates. These values are found by computing the scale
	            // and offset of a frustum rectangle at a given distance, then dividing each by the viewport width.
	            var frustumWidthScale = (frRectWidth - nrRectWidth) / (frDistance - nrDistance),
	                frustumWidthOffset = nrRectWidth - frustumWidthScale * nrDistance;
	            this.pixelSizeScale = frustumWidthScale / viewport.width;
	            this.pixelSizeOffset = frustumWidthOffset / viewport.height;
	        };

	        /**
	         * Transforms the specified model point from model coordinates to WebGL screen coordinates.
	         * <p>
	         * The resultant screen point is in WebGL screen coordinates, with the origin in the bottom-left corner and
	         * axes that extend up and to the right from the origin.
	         * <p>
	         * This function stores the transformed point in the result argument, and returns true or false to indicate
	         * whether or not the transformation is successful. It returns false if this navigator state's modelview or
	         * projection matrices are malformed, or if the specified model point is clipped by the near clipping plane or
	         * the far clipping plane.
	         *
	         * @param {Vec3} modelPoint The model coordinate point to project.
	         * @param {Vec3} result A pre-allocated vector in which to return the projected point.
	         * @returns {boolean} true if the transformation is successful, otherwise false.
	         * @throws {ArgumentError} If either the specified point or result argument is null or undefined.
	         */
	        NavigatorState.prototype.project = function (modelPoint, result) {
	            if (!modelPoint) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "NavigatorState", "project",
	                    "missingPoint"));
	            }

	            if (!result) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "NavigatorState", "project",
	                    "missingResult"));
	            }

	            // Transform the model point from model coordinates to eye coordinates then to clip coordinates. This
	            // inverts the Z axis and stores the negative of the eye coordinate Z value in the W coordinate.
	            var mx = modelPoint[0],
	                my = modelPoint[1],
	                mz = modelPoint[2],
	                m = this.modelviewProjection,
	                x = m[0] * mx + m[1] * my + m[2] * mz + m[3],
	                y = m[4] * mx + m[5] * my + m[6] * mz + m[7],
	                z = m[8] * mx + m[9] * my + m[10] * mz + m[11],
	                w = m[12] * mx + m[13] * my + m[14] * mz + m[15],
	                viewport = this.viewport;

	            if (w == 0) {
	                return false;
	            }

	            // Complete the conversion from model coordinates to clip coordinates by dividing by W. The resultant X, Y
	            // and Z coordinates are in the range [-1,1].
	            x /= w;
	            y /= w;
	            z /= w;

	            // Clip the point against the near and far clip planes.
	            if (z < -1 || z > 1) {
	                return false;
	            }

	            // Convert the point from clip coordinate to the range [0,1]. This enables the X and Y coordinates to be
	            // converted to screen coordinates, and the Z coordinate to represent a depth value in the range[0,1].
	            x = x * 0.5 + 0.5;
	            y = y * 0.5 + 0.5;
	            z = z * 0.5 + 0.5;

	            // Convert the X and Y coordinates from the range [0,1] to screen coordinates.
	            x = x * viewport.width + viewport.x;
	            y = y * viewport.height + viewport.y;

	            result[0] = x;
	            result[1] = y;
	            result[2] = z;

	            return true;
	        };
	        /**
	         * Transforms the specified model point from model coordinates to WebGL screen coordinates, applying an offset
	         * to the modelPoint's projected depth value.
	         * <p>
	         * The resultant screen point is in WebGL screen coordinates, with the origin in the bottom-left corner and axes
	         * that extend up and to the right from the origin.
	         * <p>
	         * This function stores the transformed point in the result argument, and returns true or false to indicate whether or
	         * not the transformation is successful. It returns false if this navigator state's modelview or projection
	         * matrices are malformed, or if the modelPoint is clipped by the near clipping plane or the far clipping plane,
	         * ignoring the depth offset.
	         * <p>
	         * The depth offset may be any real number and is typically used to move the screenPoint slightly closer to the
	         * user's eye in order to give it visual priority over nearby objects or terrain. An offset of zero has no effect.
	         * An offset less than zero brings the screenPoint closer to the eye, while an offset greater than zero pushes the
	         * projected screen point away from the eye.
	         * <p>
	         * Applying a non-zero depth offset has no effect on whether the model point is clipped by this method or by
	         * WebGL. Clipping is performed on the original model point, ignoring the depth offset. The final depth value
	         * after applying the offset is clamped to the range [0,1].
	         *
	         * @param {Vec3} modelPoint The model coordinate point to project.
	         * @param {Number} depthOffset The amount of offset to apply.
	         * @param {Vec3} result A pre-allocated vector in which to return the projected point.
	         * @returns {boolean} true if the transformation is successful, otherwise false.
	         * @throws {ArgumentError} If either the specified point or result argument is null or undefined.
	         */
	        NavigatorState.prototype.projectWithDepth = function (modelPoint, depthOffset, result) {
	            if (!modelPoint) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "NavigatorState", "projectWithDepth",
	                    "missingPoint"));
	            }

	            if (!result) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "NavigatorState", "projectWithDepth",
	                    "missingResult"));
	            }

	            // Transform the model point from model coordinates to eye coordinates. The eye coordinate and the clip
	            // coordinate are transformed separately in order to reuse the eye coordinate below.
	            var mx = modelPoint[0],
	                my = modelPoint[1],
	                mz = modelPoint[2],
	                m = this.modelview,
	                ex = m[0] * mx + m[1] * my + m[2] * mz + m[3],
	                ey = m[4] * mx + m[5] * my + m[6] * mz + m[7],
	                ez = m[8] * mx + m[9] * my + m[10] * mz + m[11],
	                ew = m[12] * mx + m[13] * my + m[14] * mz + m[15];

	            // Transform the point from eye coordinates to clip coordinates.
	            var p = this.projection,
	                x = p[0] * ex + p[1] * ey + p[2] * ez + p[3] * ew,
	                y = p[4] * ex + p[5] * ey + p[6] * ez + p[7] * ew,
	                z = p[8] * ex + p[9] * ey + p[10] * ez + p[11] * ew,
	                w = p[12] * ex + p[13] * ey + p[14] * ez + p[15] * ew,
	                viewport = this.viewport;

	            if (w === 0) {
	                return false;
	            }

	            // Complete the conversion from model coordinates to clip coordinates by dividing by W. The resultant X, Y
	            // and Z coordinates are in the range [-1,1].
	            x /= w;
	            y /= w;
	            z /= w;

	            // Clip the point against the near and far clip planes.
	            if (z < -1 || z > 1) {
	                return false;
	            }

	            // Transform the Z eye coordinate to clip coordinates again, this time applying a depth offset. The depth
	            // offset is applied only to the matrix element affecting the projected Z coordinate, so we inline the
	            // computation here instead of re-computing X, Y, Z and W in order to improve performance. See
	            // Matrix.offsetProjectionDepth for more information on the effect of this offset.
	            z = p[8] * ex + p[9] * ey + p[10] * ez * (1 + depthOffset) + p[11] * ew;
	            z /= w;

	            // Clamp the point to the near and far clip planes. We know the point's original Z value is contained within
	            // the clip planes, so we limit its offset z value to the range [-1, 1] in order to ensure it is not clipped
	            // by WebGL. In clip coordinates the near and far clip planes are perpendicular to the Z axis and are
	            // located at -1 and 1, respectively.
	            z = WWMath.clamp(z, -1, 1);

	            // Convert the point from clip coordinates to the range [0, 1]. This enables the XY coordinates to be
	            // converted to screen coordinates, and the Z coordinate to represent a depth value in the range [0, 1].
	            x = x * 0.5 + 0.5;
	            y = y * 0.5 + 0.5;
	            z = z * 0.5 + 0.5;

	            // Convert the X and Y coordinates from the range [0,1] to screen coordinates.
	            x = x * viewport.width + viewport.x;
	            y = y * viewport.height + viewport.y;

	            result[0] = x;
	            result[1] = y;
	            result[2] = z;

	            return true;
	        };

	        /**
	         * Transforms the specified screen point from WebGL screen coordinates to model coordinates.
	         * <p>
	         * The screen point is understood to be in WebGL screen coordinates, with the origin in the bottom-left corner
	         * and axes that extend up and to the right from the origin.
	         * <p>
	         * This function stores the transformed point in the result argument, and returns true or false to indicate whether the
	         * transformation is successful. It returns false if this navigator state's modelview or projection matrices
	         * are malformed, or if the screenPoint is clipped by the near clipping plane or the far clipping plane.
	         *
	         * @param {Vec3} screenPoint The screen coordinate point to un-project.
	         * @param {Vec3} result A pre-allocated vector in which to return the unprojected point.
	         * @returns {boolean} true if the transformation is successful, otherwise false.
	         * @throws {ArgumentError} If either the specified point or result argument is null or undefined.
	         */
	        NavigatorState.prototype.unProject = function (screenPoint, result) {
	            if (!screenPoint) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "NavigatorState", "unProject",
	                    "missingPoint"));
	            }

	            if (!result) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "NavigatorState", "unProject",
	                    "missingResult"));
	            }

	            var sx = screenPoint[0],
	                sy = screenPoint[1],
	                sz = screenPoint[2],
	                viewport = this.viewport;

	            // Convert the XY screen coordinates to coordinates in the range [0, 1]. This enables the XY coordinates to
	            // be converted to clip coordinates.
	            sx = (sx - viewport.x) / viewport.width;
	            sy = (sy - viewport.y) / viewport.height;

	            // Convert from coordinates in the range [0, 1] to clip coordinates in the range [-1, 1].
	            sx = sx * 2 - 1;
	            sy = sy * 2 - 1;
	            sz = sz * 2 - 1;

	            // Clip the point against the near and far clip planes. In clip coordinates the near and far clip planes are
	            // perpendicular to the Z axis and are located at -1 and 1, respectively.
	            if (sz < -1 || sz > 1) {
	                return false;
	            }

	            // Transform the screen point from clip coordinates to model coordinates. This inverts the Z axis and stores
	            // the negative of the eye coordinate Z value in the W coordinate.
	            var m = this.modelviewProjectionInv,
	                x = m[0] * sx + m[1] * sy + m[2] * sz + m[3],
	                y = m[4] * sx + m[5] * sy + m[6] * sz + m[7],
	                z = m[8] * sx + m[9] * sy + m[10] * sz + m[11],
	                w = m[12] * sx + m[13] * sy + m[14] * sz + m[15];

	            if (w === 0) {
	                return false;
	            }

	            // Complete the conversion from model coordinates to clip coordinates by dividing by W.
	            result[0] = x / w;
	            result[1] = y / w;
	            result[2] = z / w;

	            return true;
	        };

	        /**
	         * Converts a WebGL screen point to window coordinates.
	         * <p>
	         * The specified point is understood to be in WebGL screen coordinates, with the origin in the bottom-left
	         * corner and axes that extend up and to the right from the origin point.
	         * <p>
	         * The returned point is in the window coordinate system of the WorldWindow, with the origin in the top-left
	         * corner and axes that extend down and to the right from the origin point.
	         *
	         * @param {Vec2} screenPoint The screen point to convert.
	         * @param {Vec2} result A pre-allocated {@link Vec2} in which to return the computed point.
	         * @returns {Vec2} The specified result argument set to the computed point.
	         * @throws {ArgumentError} If either argument is null or undefined.
	         */
	        NavigatorState.prototype.convertPointToWindow = function (screenPoint, result) {
	            if (!screenPoint) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "NavigatorState", "convertPointToWindow",
	                    "missingPoint"));
	            }

	            if (!result) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "NavigatorState", "convertPointToWindow",
	                    "missingResult"));
	            }

	            result[0] = screenPoint[0];
	            result[1] = this.viewport.height - screenPoint[1];

	            return result;
	        };

	        /**
	         * Converts a window-coordinate point to WebGL screen coordinates.
	         * <p>
	         * The specified point is understood to be in the window coordinate system of the WorldWindow, with the origin
	         * in the top-left corner and axes that extend down and to the right from the origin point.
	         * <p>
	         * The returned point is in WebGL screen coordinates, with the origin in the bottom-left corner and axes that
	         * extend up and to the right from the origin point.
	         *
	         * @param {Vec2} point The window-coordinate point to convert.
	         * @param {Vec2} result A pre-allocated {@link Vec2} in which to return the computed point.
	         * @returns {Vec2} The specified result argument set to the computed point.
	         * @throws {ArgumentError} If either argument is null or undefined.
	         */
	        NavigatorState.prototype.convertPointToViewport = function (point, result) {
	            if (!point) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "NavigatorState", "convertPointToViewport",
	                    "missingPoint"));
	            }

	            if (!result) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "NavigatorState", "convertPointToViewport",
	                    "missingResult"));
	            }

	            result[0] = point[0];
	            result[1] = this.viewport.height - point[1];

	            return result;
	        };

	        /**
	         * Computes a ray originating at the navigator's eyePoint and extending through the specified point in window
	         * coordinates.
	         * <p>
	         * The specified point is understood to be in the window coordinate system of the WorldWindow, with the origin
	         * in the top-left corner and axes that extend down and to the right from the origin point.
	         * <p>
	         * The results of this method are undefined if the specified point is outside of the WorldWindow's
	         * bounds.
	         *
	         * @param {Vec2} point The window coordinates point to compute a ray for.
	         * @returns {Line} A new Line initialized to the origin and direction of the computed ray, or null if the
	         * ray could not be computed.
	         */
	        NavigatorState.prototype.rayFromScreenPoint = function (point) {
	            if (!point) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "NavigatorState", "rayFromScreenPoint",
	                    "missingPoint"));
	            }

	            // Convert the point's xy coordinates from window coordinates to WebGL screen coordinates.
	            var screenPoint = this.convertPointToViewport(point, new Vec3(0, 0, 0)),
	                nearPoint = new Vec3(0, 0, 0),
	                farPoint = new Vec3(0, 0, 0);

	            // Compute the model coordinate point on the near clip plane with the xy coordinates and depth 0.
	            if (!this.unProject(screenPoint, nearPoint)) {
	                return null;
	            }

	            // Compute the model coordinate point on the far clip plane with the xy coordinates and depth 1.
	            screenPoint[2] = 1;
	            if (!this.unProject(screenPoint, farPoint)) {
	                return null;
	            }

	            // Compute a ray originating at the eye point and with direction pointing from the xy coordinate on the near
	            // plane to the same xy coordinate on the far plane.
	            var origin = new Vec3(this.eyePoint[0], this.eyePoint[1], this.eyePoint[2]),
	                direction = new Vec3(farPoint[0], farPoint[1], farPoint[2]);

	            direction.subtract(nearPoint);
	            direction.normalize();

	            return new Line(origin, direction);
	        };

	        /**
	         * Computes the approximate size of a pixel at a specified distance from the navigator's eye point.
	         * <p>
	         * This method assumes rectangular pixels, where pixel coordinates denote
	         * infinitely thin spaces between pixels. The units of the returned size are in model coordinates per pixel
	         * (usually meters per pixel). This returns 0 if the specified distance is zero. The returned size is undefined
	         * if the distance is less than zero.
	         *
	         * @param {Number} distance The distance from the eye point at which to determine pixel size, in model
	         * coordinates.
	         * @returns {Number} The approximate pixel size at the specified distance from the eye point, in model
	         * coordinates per pixel.
	         */
	        NavigatorState.prototype.pixelSizeAtDistance = function (distance) {
	            // Compute the pixel size from the width of a rectangle carved out of the frustum in model coordinates at
	            // the specified distance along the -Z axis and the viewport width in screen coordinates. The pixel size is
	            // expressed in model coordinates per screen coordinate (e.g. meters per pixel).
	            //
	            // The frustum width is determined by noticing that the frustum size is a linear function of distance from
	            // the eye point. The linear equation constants are determined during initialization, then solved for
	            // distance here.
	            //
	            // This considers only the frustum width by assuming that the frustum and viewport share the same aspect
	            // ratio, so that using either the frustum width or height results in the same pixel size.

	            return this.pixelSizeScale * distance + this.pixelSizeOffset;
	        };

	        return NavigatorState;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports UnsupportedOperationError
	 * @version $Id: UnsupportedOperationError.js 2631 2015-01-02 21:32:32Z tgaskins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(31)], __WEBPACK_AMD_DEFINE_RESULT__ = function (AbstractError) {
	        "use strict";

	        /**
	         * Constructs an unsupported-operation error with a specified message.
	         * @alias UnsupportedOperationError
	         * @constructor
	         * @classdesc Represents an error associated with an operation that is not available or should not be invoked.
	         * Typically raised when an abstract function of an abstract base class is called because a subclass has not
	         * implemented the function.
	         * @augments AbstractError
	         * @param {String} message The message.
	         */
	        var UnsupportedOperationError = function (message) {
	            AbstractError.call(this, "UnsupportedOperationError", message);

	            var stack;
	            try {
	                //noinspection ExceptionCaughtLocallyJS
	                throw new Error();
	            } catch (e) {
	                stack = e.stack;
	            }
	            this.stack = stack;
	        };

	        UnsupportedOperationError.prototype = Object.create(AbstractError.prototype);

	        return UnsupportedOperationError;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports DragRecognizer
	 * @version $Id: DragRecognizer.js 3223 2015-06-19 23:16:36Z dcollins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(57)], __WEBPACK_AMD_DEFINE_RESULT__ = function (GestureRecognizer) {
	        "use strict";

	        /**
	         * Constructs a mouse drag gesture recognizer.
	         * @alias DragRecognizer
	         * @constructor
	         * @augments GestureRecognizer
	         * @classdesc A concrete gesture recognizer subclass that looks for mouse drag gestures.
	         * @param {EventTarget} target The document element this gesture recognizer observes for mouse and touch events.
	         * @param {Function} callback An optional function to call when this gesture is recognized. If non-null, the
	         * function is called when this gesture is recognized, and is passed a single argument: this gesture recognizer,
	         * e.g., <code>gestureCallback(recognizer)</code>.
	         * @throws {ArgumentError} If the specified target is null or undefined.
	         */
	        var DragRecognizer = function (target, callback) {
	            GestureRecognizer.call(this, target, callback);

	            /**
	             *
	             * @type {Number}
	             */
	            this.button = 0;

	            // Intentionally not documented.
	            this.interpretDistance = 5;
	        };

	        DragRecognizer.prototype = Object.create(GestureRecognizer.prototype);

	        // Documented in superclass.
	        DragRecognizer.prototype.mouseMove = function (event) {
	            if (this.state == WorldWind.POSSIBLE) {
	                if (this.shouldInterpret()) {
	                    if (this.shouldRecognize()) {
	                        this.translationX = 0; // set translation to zero when the drag begins
	                        this.translationY = 0;
	                        this.state = WorldWind.BEGAN;
	                    } else {
	                        this.state = WorldWind.FAILED;
	                    }
	                }
	            } else if (this.state == WorldWind.BEGAN || this.state == WorldWind.CHANGED) {
	                this.state = WorldWind.CHANGED;
	            }
	        };

	        // Documented in superclass.
	        DragRecognizer.prototype.mouseUp = function (event) {
	            if (this.mouseButtonMask == 0) { // last button up
	                if (this.state == WorldWind.POSSIBLE) {
	                    this.state = WorldWind.FAILED;
	                } else if (this.state == WorldWind.BEGAN || this.state == WorldWind.CHANGED) {
	                    this.state = WorldWind.ENDED;
	                }
	            }
	        };

	        // Documented in superclass.
	        DragRecognizer.prototype.touchStart = function (touch) {
	            if (this.state == WorldWind.POSSIBLE) {
	                this.state = WorldWind.FAILED; // mouse gestures fail upon receiving a touch event
	            }
	        };

	        /**
	         *
	         * @returns {Boolean}
	         * @protected
	         */
	        DragRecognizer.prototype.shouldInterpret = function () {
	            var dx = this.translationX,
	                dy = this.translationY,
	                distance = Math.sqrt(dx * dx + dy * dy);
	            return distance > this.interpretDistance; // interpret mouse movement when the cursor moves far enough
	        };

	        /**
	         *
	         * @returns {Boolean}
	         * @protected
	         */
	        DragRecognizer.prototype.shouldRecognize = function () {
	            var buttonBit = (1 << this.button);
	            return buttonBit == this.mouseButtonMask; // true when the specified button is the only button down
	        };

	        return DragRecognizer;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports PinchRecognizer
	 * @version $Id: PinchRecognizer.js 3239 2015-06-22 23:28:12Z dcollins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(57)], __WEBPACK_AMD_DEFINE_RESULT__ = function (GestureRecognizer) {
	        "use strict";

	        /**
	         * Constructs a pinch gesture recognizer.
	         * @alias PinchRecognizer
	         * @constructor
	         * @augments GestureRecognizer
	         * @classdesc A concrete gesture recognizer subclass that looks for two finger pinch gestures.
	         * @param {EventTarget} target The document element this gesture recognizer observes for mouse and touch events.
	         * @param {Function} callback An optional function to call when this gesture is recognized. If non-null, the
	         * function is called when this gesture is recognized, and is passed a single argument: this gesture recognizer,
	         * e.g., <code>gestureCallback(recognizer)</code>.
	         * @throws {ArgumentError} If the specified target is null or undefined.
	         */
	        var PinchRecognizer = function (target, callback) {
	            GestureRecognizer.call(this, target, callback);

	            // Intentionally not documented.
	            this._scale = 1;

	            // Intentionally not documented.
	            this._offsetScale = 1;

	            // Intentionally not documented.
	            this.referenceDistance = 0;

	            // Intentionally not documented.
	            this.interpretThreshold = 20;

	            // Intentionally not documented.
	            this.weight = 0.4;

	            // Intentionally not documented.
	            this.pinchTouches = [];
	        };

	        PinchRecognizer.prototype = Object.create(GestureRecognizer.prototype);

	        Object.defineProperties(PinchRecognizer.prototype, {
	            scale: {
	                get: function () {
	                    return this._scale * this._offsetScale;
	                }
	            }
	        });

	        // Documented in superclass.
	        PinchRecognizer.prototype.reset = function () {
	            GestureRecognizer.prototype.reset.call(this);

	            this._scale = 1;
	            this._offsetScale = 1;
	            this.referenceDistance = 0;
	            this.pinchTouches = [];
	        };

	        // Documented in superclass.
	        PinchRecognizer.prototype.mouseDown = function (event) {
	            if (this.state == WorldWind.POSSIBLE) {
	                this.state = WorldWind.FAILED; // touch gestures fail upon receiving a mouse event
	            }
	        };

	        // Documented in superclass.
	        PinchRecognizer.prototype.touchStart = function (touch) {
	            if (this.pinchTouches.length < 2) {
	                if (this.pinchTouches.push(touch) == 2) {
	                    this.referenceDistance = this.currentPinchDistance();
	                    this._offsetScale *= this._scale;
	                    this._scale = 1;
	                }
	            }
	        };

	        // Documented in superclass.
	        PinchRecognizer.prototype.touchMove = function (touch) {
	            if (this.pinchTouches.length == 2) {
	                if (this.state == WorldWind.POSSIBLE) {
	                    if (this.shouldRecognize()) {
	                        this.state = WorldWind.BEGAN;
	                    }
	                } else if (this.state == WorldWind.BEGAN || this.state == WorldWind.CHANGED) {
	                    var distance = this.currentPinchDistance(),
	                        newScale = Math.abs(distance / this.referenceDistance),
	                        w = this.weight;
	                    this._scale = this._scale * (1 - w) + newScale * w;
	                    this.state = WorldWind.CHANGED;
	                }
	            }
	        };

	        // Documented in superclass.
	        PinchRecognizer.prototype.touchEnd = function (touch) {
	            var index = this.pinchTouches.indexOf(touch);
	            if (index != -1) {
	                this.pinchTouches.splice(index, 1);
	            }

	            // Transition to the ended state if this was the last touch.
	            if (this.touchCount == 0) { // last touch ended
	                if (this.state == WorldWind.POSSIBLE) {
	                    this.state = WorldWind.FAILED;
	                } else if (this.state == WorldWind.BEGAN || this.state == WorldWind.CHANGED) {
	                    this.state = WorldWind.ENDED;
	                }
	            }
	        };

	        // Documented in superclass.
	        PinchRecognizer.prototype.touchCancel = function (touch) {
	            var index = this.pinchTouches.indexOf(touch);
	            if (index != -1) {
	                this.pinchTouches.splice(index, 1);
	            }

	            // Transition to the cancelled state if this was the last touch.
	            if (this.touchCount == 0) {
	                if (this.state == WorldWind.POSSIBLE) {
	                    this.state = WorldWind.FAILED;
	                } else if (this.state == WorldWind.BEGAN || this.state == WorldWind.CHANGED) {
	                    this.state = WorldWind.CANCELLED;
	                }
	            }
	        };

	        // Documented in superclass.
	        PinchRecognizer.prototype.prepareToRecognize = function () {
	            this.referenceDistance = this.currentPinchDistance();
	            this._scale = 1;
	        };

	        // Intentionally not documented.
	        PinchRecognizer.prototype.shouldRecognize = function () {
	            var distance = this.currentPinchDistance();

	            return Math.abs(distance - this.referenceDistance) > this.interpretThreshold
	        };

	        // Intentionally not documented.
	        PinchRecognizer.prototype.currentPinchDistance = function () {
	            var touch0 = this.pinchTouches[0],
	                touch1 = this.pinchTouches[1],
	                dx = touch0.clientX - touch1.clientX,
	                dy = touch0.clientY - touch1.clientY;

	            return Math.sqrt(dx * dx + dy * dy);
	        };

	        return PinchRecognizer;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports RotationRecognizer
	 * @version $Id: RotationRecognizer.js 3239 2015-06-22 23:28:12Z dcollins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(29),
	        __webpack_require__(57)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Angle,
	              GestureRecognizer) {
	        "use strict";

	        /**
	         * Constructs a rotation gesture recognizer.
	         * @alias RotationRecognizer
	         * @constructor
	         * @augments GestureRecognizer
	         * @classdesc A concrete gesture recognizer subclass that looks for two finger rotation gestures.
	         * @param {EventTarget} target The document element this gesture recognizer observes for mouse and touch events.
	         * @param {Function} callback An optional function to call when this gesture is recognized. If non-null, the
	         * function is called when this gesture is recognized, and is passed a single argument: this gesture recognizer,
	         * e.g., <code>gestureCallback(recognizer)</code>.
	         * @throws {ArgumentError} If the specified target is null or undefined.
	         */
	        var RotationRecognizer = function (target, callback) {
	            GestureRecognizer.call(this, target, callback);

	            // Intentionally not documented.
	            this._rotation = 0;

	            // Intentionally not documented.
	            this._offsetRotation = 0;

	            // Intentionally not documented.
	            this.referenceAngle = 0;

	            // Intentionally not documented.
	            this.interpretThreshold = 20;

	            // Intentionally not documented.
	            this.weight = 0.4;

	            // Intentionally not documented.
	            this.rotationTouches = [];
	        };

	        RotationRecognizer.prototype = Object.create(GestureRecognizer.prototype);

	        Object.defineProperties(RotationRecognizer.prototype, {
	            rotation: {
	                get: function () {
	                    return this._rotation + this._offsetRotation;
	                }
	            }
	        });

	        // Documented in superclass.
	        RotationRecognizer.prototype.reset = function () {
	            GestureRecognizer.prototype.reset.call(this);

	            this._rotation = 0;
	            this._offsetRotation = 0;
	            this.referenceAngle = 0;
	            this.rotationTouches = [];
	        };

	        // Documented in superclass.
	        RotationRecognizer.prototype.mouseDown = function (event) {
	            if (this.state == WorldWind.POSSIBLE) {
	                this.state = WorldWind.FAILED; // touch gestures fail upon receiving a mouse event
	            }
	        };

	        // Documented in superclass.
	        RotationRecognizer.prototype.touchStart = function (touch) {
	            if (this.rotationTouches.length < 2) {
	                if (this.rotationTouches.push(touch) == 2) {
	                    this.referenceAngle = this.currentTouchAngle();
	                    this._offsetRotation += this._rotation;
	                    this._rotation = 0;
	                }
	            }
	        };

	        // Documented in superclass.
	        RotationRecognizer.prototype.touchMove = function (touch) {
	            if (this.rotationTouches.length == 2) {
	                if (this.state == WorldWind.POSSIBLE) {
	                    if (this.shouldRecognize()) {
	                        this.state = WorldWind.BEGAN;
	                    }
	                } else if (this.state == WorldWind.BEGAN || this.state == WorldWind.CHANGED) {
	                    var angle = this.currentTouchAngle(),
	                        newRotation = Angle.normalizedDegrees(angle - this.referenceAngle),
	                        w = this.weight;
	                    this._rotation = this._rotation * (1 - w) + newRotation * w;
	                    this.state = WorldWind.CHANGED;
	                }
	            }
	        };

	        // Documented in superclass.
	        RotationRecognizer.prototype.touchEnd = function (touch) {
	            var index = this.rotationTouches.indexOf(touch);
	            if (index != -1) {
	                this.rotationTouches.splice(index, 1);
	            }

	            // Transition to the ended state if this was the last touch.
	            if (this.touchCount == 0) { // last touch ended
	                if (this.state == WorldWind.POSSIBLE) {
	                    this.state = WorldWind.FAILED;
	                } else if (this.state == WorldWind.BEGAN || this.state == WorldWind.CHANGED) {
	                    this.state = WorldWind.ENDED;
	                }
	            }
	        };

	        // Documented in superclass.
	        RotationRecognizer.prototype.touchCancel = function (touch) {
	            var index = this.rotationTouches.indexOf(touch);
	            if (index != -1) {
	                this.rotationTouches.splice(index, 1);

	                // Transition to the cancelled state if this was the last touch.
	                if (this.touchCount == 0) {
	                    if (this.state == WorldWind.POSSIBLE) {
	                        this.state = WorldWind.FAILED;
	                    } else if (this.state == WorldWind.BEGAN || this.state == WorldWind.CHANGED) {
	                        this.state = WorldWind.CANCELLED;
	                    }
	                }
	            }
	        };

	        // Documented in superclass.
	        RotationRecognizer.prototype.prepareToRecognize = function () {
	            this.referenceAngle = this.currentTouchAngle();
	            this._rotation = 0;
	        };

	        // Intentionally not documented.
	        RotationRecognizer.prototype.shouldRecognize = function () {
	            var angle = this.currentTouchAngle(),
	                rotation = Angle.normalizedDegrees(angle - this.referenceAngle);

	            return Math.abs(rotation) > this.interpretThreshold;
	        };

	        // Intentionally not documented.
	        RotationRecognizer.prototype.currentTouchAngle = function () {
	            var touch0 = this.rotationTouches[0],
	                touch1 = this.rotationTouches[1],
	                dx = touch0.clientX - touch1.clientX,
	                dy = touch0.clientY - touch1.clientY;

	            return Math.atan2(dy, dx) * Angle.RADIANS_TO_DEGREES;
	        };

	        return RotationRecognizer;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports TiltRecognizer
	 * @version $Id: TiltRecognizer.js 3223 2015-06-19 23:16:36Z dcollins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(61)], __WEBPACK_AMD_DEFINE_RESULT__ = function (PanRecognizer) {
	        "use strict";

	        /**
	         * Constructs a tilt gesture recognizer.
	         * @alias TiltRecognizer
	         * @constructor
	         * @augments PanRecognizer
	         * @classdesc A concrete gesture recognizer subclass that looks for two finger tilt gestures.
	         * @param {EventTarget} target The document element this gesture recognizer observes for mouse and touch events.
	         * @param {Function} callback An optional function to call when this gesture is recognized. If non-null, the
	         * function is called when this gesture is recognized, and is passed a single argument: this gesture recognizer,
	         * e.g., <code>gestureCallback(recognizer)</code>.
	         * @throws {ArgumentError} If the specified target is null or undefined.
	         */
	        var TiltRecognizer = function (target, callback) {
	            PanRecognizer.call(this, target, callback);

	            // Intentionally not documented.
	            this.maxTouchDistance = 250;

	            // Intentionally not documented.
	            this.maxTouchDivergence = 50;
	        };

	        // Intentionally not documented.
	        TiltRecognizer.LEFT = (1 << 0);

	        // Intentionally not documented.
	        TiltRecognizer.RIGHT = (1 << 1);

	        // Intentionally not documented.
	        TiltRecognizer.UP = (1 << 2);

	        // Intentionally not documented.
	        TiltRecognizer.DOWN = (1 << 3);

	        TiltRecognizer.prototype = Object.create(PanRecognizer.prototype);

	        // Documented in superclass.
	        TiltRecognizer.prototype.shouldInterpret = function () {
	            for (var i = 0, count = this.touchCount; i < count; i++) {
	                var touch = this.touch(i),
	                    dx = touch.translationX,
	                    dy = touch.translationY,
	                    distance = Math.sqrt(dx * dx + dy * dy);
	                if (distance > this.interpretDistance) {
	                    return true; // interpret touches when any touch moves far enough
	                }
	            }

	            return false;
	        };

	        // Documented in superclass.
	        TiltRecognizer.prototype.shouldRecognize = function () {
	            var touchCount = this.touchCount;
	            if (touchCount < 2) {
	                return false;
	            }

	            var touch0 = this.touch(0),
	                touch1 = this.touch(1),
	                dx = touch0.clientX - touch1.clientX,
	                dy = touch0.clientY - touch1.clientY,
	                distance = Math.sqrt(dx * dx + dy * dy);
	            if (distance > this.maxTouchDistance) {
	                return false; // touches must be close together
	            }

	            var tx = touch0.translationX - touch1.translationX,
	                ty = touch0.translationY - touch1.translationY,
	                divergence = Math.sqrt(tx * tx + ty * ty);
	            if (divergence > this.maxTouchDivergence) {
	                return false; // touches must be moving in a mostly parallel direction
	            }

	            var verticalMask = TiltRecognizer.UP | TiltRecognizer.DOWN,
	                dirMask0 = this.touchDirection(touch0) & verticalMask,
	                dirMask1 = this.touchDirection(touch1) & verticalMask;
	            return (dirMask0 & dirMask1) != 0; // touches must move in the same vertical direction
	        };

	        // Intentionally not documented.
	        TiltRecognizer.prototype.touchDirection = function (touch) {
	            var dx = touch.translationX,
	                dy = touch.translationY,
	                dirMask = 0;

	            if (Math.abs(dx) > Math.abs(dy)) {
	                dirMask |= (dx < 0 ? TiltRecognizer.LEFT : 0);
	                dirMask |= (dx > 0 ? TiltRecognizer.RIGHT : 0);
	            } else {
	                dirMask |= (dy < 0 ? TiltRecognizer.UP : 0);
	                dirMask |= (dy > 0 ? TiltRecognizer.DOWN : 0);
	            }

	            return dirMask;
	        };

	        return TiltRecognizer;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

	// нужен для иньекции шейдера при отрисовке surface symbol

	var SurfaceTileRenderer = __webpack_require__(72);
	var SurfaceSymbol = __webpack_require__(85);
	var SurfaceSdfImage = __webpack_require__(95);
	var oldBeginRenderingFunction = SurfaceTileRenderer.prototype.beginRendering;

	SurfaceTileRenderer.prototype.beginRendering = function (dc, opacity) {
	    var tile = this.currentSurfaceTiles[0];
	    if (tile instanceof SurfaceSymbol || tile instanceof SurfaceSdfImage ) {
	        return tile.beginRendering(dc, opacity);
	    }
	    return oldBeginRenderingFunction.call(this, dc, opacity);
	};

	var oldRenderTilesFunction = SurfaceTileRenderer.prototype.renderTiles;

	SurfaceTileRenderer.prototype.renderTiles = function (dc, surfaceTiles, opacity, tilesHaveOpacity) {
	    this.currentSurfaceTiles = surfaceTiles;
	    oldRenderTilesFunction.call(this, dc, surfaceTiles, opacity, tilesHaveOpacity);
	};

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports SurfaceTileRenderer
	 * @version $Id: SurfaceTileRenderer.js 3345 2015-07-28 20:28:35Z dcollins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(30),
	        __webpack_require__(32),
	        __webpack_require__(63),
	        __webpack_require__(73),
	        __webpack_require__(84)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
	              Logger,
	              Matrix,
	              SurfaceShapeTile,
	              SurfaceTileRendererProgram) {
	        "use strict";

	        /**
	         * Constructs a new surface tile renderer.
	         * @alias SurfaceTileRenderer
	         * @constructor
	         * @classdesc This class is responsible for rendering imagery onto the terrain.
	         * It is meant to be used internally. Applications typically do not interact with this class.
	         */
	        var SurfaceTileRenderer = function () {

	            // Scratch values to avoid constantly recreating these matrices.
	            this.texMaskMatrix = Matrix.fromIdentity();
	            this.texSamplerMatrix = Matrix.fromIdentity();

	            // Internal. Intentionally not documented.
	            this.isSurfaceShapeTileRendering = false;
	        };

	        /**
	         * Render a specified collection of surface tiles.
	         * @param {DrawContext} dc The current draw context.
	         * @param {SurfaceTile[]} surfaceTiles The surface tiles to render.
	         * @param {Number} opacity The opacity at which to draw the surface tiles.
	         * @param {Boolean} tilesHaveOpacity If true, incoming tiles each have their own opacity property and
	         * it's value is applied when the tile is drawn.
	         * @throws {ArgumentError} If the specified surface tiles array is null or undefined.
	         */
	        SurfaceTileRenderer.prototype.renderTiles = function (dc, surfaceTiles, opacity, tilesHaveOpacity) {
	            if (!surfaceTiles) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "SurfaceTileRenderer", "renderTiles",
	                        "Specified surface tiles array is null or undefined."));
	            }

	            if (surfaceTiles.length < 1)
	                return;

	            var terrain = dc.terrain,
	                gl = dc.currentGlContext,
	                tileCount = 0,// for frame statistics,
	                program,
	                terrainTile,
	                terrainTileSector,
	                surfaceTile,
	                currentTileOpacity = 1;

	            if (!terrain)
	                return;

	            this.isSurfaceShapeTileRendering = surfaceTiles[0] instanceof SurfaceShapeTile;

	            opacity *= dc.surfaceOpacity;

	            // For each terrain tile, render it for each overlapping surface tile.
	            program = this.beginRendering(dc, opacity);
	            terrain.beginRendering(dc);
	            try {
	                for (var i = 0, ttLen = terrain.surfaceGeometry.length; i < ttLen; i++) {
	                    terrainTile = terrain.surfaceGeometry[i];
	                    terrainTileSector = terrainTile.sector;

	                    terrain.beginRenderingTile(dc, terrainTile);
	                    try {
	                        // Render the terrain tile for each overlapping surface tile.
	                        for (var j = 0, stLen = surfaceTiles.length; j < stLen; j++) {
	                            surfaceTile = surfaceTiles[j];
	                            if (surfaceTile.sector.overlaps(terrainTileSector)) {
	                                if (surfaceTile.bind(dc)) {
	                                    if (dc.pickingMode) {
	                                        if (surfaceTile.pickColor) {
	                                            program.loadColor(gl, surfaceTile.pickColor);
	                                        } else {
	                                            // Surface shape tiles don't use a pick color. Pick colors are encoded into
	                                            // the colors of the individual shapes drawn into the tile.
	                                        }
	                                    } else {
	                                        if (tilesHaveOpacity && surfaceTile.opacity != currentTileOpacity) {
	                                            program.loadOpacity(gl, opacity * surfaceTile.opacity);
	                                            currentTileOpacity = surfaceTile.opacity;
	                                        }
	                                    }

	                                    this.applyTileState(dc, terrainTile, surfaceTile);
	                                    terrain.renderTile(dc, terrainTile);
	                                    ++tileCount;
	                                }
	                            }
	                        }
	                    }
	                    catch (e) {
	                        console.log(e);
	                    }
	                    finally {
	                        terrain.endRenderingTile(dc, terrainTile);
	                    }
	                }
	            }
	            catch (e) {
	                console.log(e);
	            }
	            finally {
	                terrain.endRendering(dc);
	                this.endRendering(dc);
	                dc.frameStatistics.incrementRenderedTileCount(tileCount);
	            }
	        };

	        // Intentionally not documented.
	        SurfaceTileRenderer.prototype.beginRendering = function (dc, opacity) {
	            var gl = dc.currentGlContext,
	                program = dc.findAndBindProgram(SurfaceTileRendererProgram);
	            program.loadTexSampler(gl, gl.TEXTURE0);

	            if (dc.pickingMode && !this.isSurfaceShapeTileRendering) {
	                program.loadModulateColor(gl, true);
	            } else {
	                program.loadModulateColor(gl, false);
	                program.loadOpacity(gl, opacity);
	            }

	            return program;
	        };

	        // Intentionally not documented.
	        SurfaceTileRenderer.prototype.endRendering = function (dc) {
	            var gl = dc.currentGlContext;
	            gl.bindTexture(gl.TEXTURE_2D, null);
	        };

	        // Intentionally not documented.
	        SurfaceTileRenderer.prototype.applyTileState = function (dc, terrainTile, surfaceTile) {
	            // Sets up the texture transform and mask that applies the texture tile to the terrain tile.
	            var gl = dc.currentGlContext,
	                program = dc.currentProgram,
	                terrainSector = terrainTile.sector,
	                terrainDeltaLat = terrainSector.deltaLatitude(),
	                terrainDeltaLon = terrainSector.deltaLongitude(),
	                surfaceSector = surfaceTile.sector,
	                rawSurfaceDeltaLat = surfaceSector.deltaLatitude(),
	                rawSurfaceDeltaLon = surfaceSector.deltaLongitude(),
	                surfaceDeltaLat = rawSurfaceDeltaLat > 0 ? rawSurfaceDeltaLat : 1,
	                surfaceDeltaLon = rawSurfaceDeltaLon > 0 ? rawSurfaceDeltaLon : 1,
	                sScale = terrainDeltaLon / surfaceDeltaLon,
	                tScale = terrainDeltaLat / surfaceDeltaLat,
	                sTrans = -(surfaceSector.minLongitude - terrainSector.minLongitude) / surfaceDeltaLon,
	                tTrans = -(surfaceSector.minLatitude - terrainSector.minLatitude) / surfaceDeltaLat;

	            this.texMaskMatrix.set(
	                sScale, 0, 0, sTrans,
	                0, tScale, 0, tTrans,
	                0, 0, 1, 0,
	                0, 0, 0, 1
	            );

	            this.texSamplerMatrix.setToUnitYFlip();
	            surfaceTile.applyInternalTransform(dc, this.texSamplerMatrix);
	            this.texSamplerMatrix.multiplyMatrix(this.texMaskMatrix);

	            program.loadTexSamplerMatrix(gl, this.texSamplerMatrix);
	            program.loadTexMaskMatrix(gl, this.texMaskMatrix);
	        };

	        return SurfaceTileRenderer;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports SurfaceShapeTile
	 * @version $Id: SurfaceShapeTile.js 3048 2015-04-23 23:26:47Z danm $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(29),
	        __webpack_require__(30),
	        __webpack_require__(74),
	        __webpack_require__(32),
	        __webpack_require__(75),
	        __webpack_require__(54),
	        __webpack_require__(76)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Angle,
	              ArgumentError,
	              Level,
	              Logger,
	              Sector,
	              Texture,
	              TextureTile) {
	        "use strict";

	        /**
	         * Constructs a surface shape tile.
	         * @alias SurfaceShapeTile
	         * @constructor
	         * @classdesc Represents a texture map containing renditions of surface shapes applied to a portion of a globe's terrain.
	         * @param {Sector} sector The sector this tile covers.
	         * @param {Level} level The level this tile is associated with.
	         * @param {number} row This tile's row in the associated level.
	         * @param {number} column This tile's column in the associated level.
	         * @throws {ArgumentError} If the specified sector or level is null or undefined, the row or column arguments
	         * are less than zero, or the specified image path is null, undefined or empty.
	         *
	         */
	        var SurfaceShapeTile = function(sector, level, row, column) {
	            TextureTile.call(this, sector, level, row, column); // args are checked in the superclass' constructor

	            /**
	             * The surface shapes that affect this tile.
	             * @type {SurfaceShape[]}
	             */
	            this.surfaceShapes = [];

	            /**
	             * The sector that bounds this tile.
	             * @type {Sector}
	             */
	            this.sector = sector;

	            /**
	             * A string to use as a cache key.
	             * @type {string}
	             */
	            this.cacheKey = null;

	            /**
	             * Internal use only. Intentionally not documented.
	             * @type {number}
	             */
	            this.pickSequence = 0;

	            // Internal use only. Intentionally not documented.
	            this.surfaceShapeStateKeys = [];

	            // Internal use only. Intentionally not documented.
	            this.prevSurfaceShapes = [];

	            this.createCtx2D();
	        };

	        SurfaceShapeTile.prototype = Object.create(TextureTile.prototype);

	        /**
	         * Clear all collected surface shapes.
	         */
	        SurfaceShapeTile.prototype.clearShapes = function() {
	            // Exchange previous and next surface shape lists to avoid allocating memory.
	            var swap = this.prevSurfaceShapes;
	            this.prevSurfaceShapes = this.surfaceShapes;
	            this.surfaceShapes = swap;

	            // Clear out next surface shape list.
	            this.surfaceShapes.splice(0, this.surfaceShapes.length);
	        };

	        /**
	         * Query whether any surface shapes have been collected.
	         * @returns {boolean} Returns true if there are collected surface shapes.
	         */
	        SurfaceShapeTile.prototype.hasShapes = function() {
	            return this.surfaceShapes.length > 0;
	        };

	        /**
	         * Get all shapes that this tile references.
	         * @returns {SurfaceShape[]} The collection of surface shapes referenced by this tile.
	         */
	        SurfaceShapeTile.prototype.getShapes = function() {
	            return this.surfaceShapes;
	        };

	        /**
	         * Set the shapes this tile should reference.
	         * @param {SurfaceShape[]} surfaceShapes The collection of surface shapes to be referenced by this tile.
	         */
	        SurfaceShapeTile.prototype.setShapes = function(surfaceShapes) {
	            this.surfaceShapes = surfaceShapes;
	        };

	        /**
	         * The sector that bounds this tile.
	         * @returns {Sector}
	         */
	        SurfaceShapeTile.prototype.getSector = function() {
	            return this.sector;
	        };

	        /**
	         * Add a surface shape to this tile's collection of surface shapes.
	         * @param {SurfaceShape} surfaceShape The surface shape to add.
	         */
	        SurfaceShapeTile.prototype.addSurfaceShape = function(surfaceShape) {
	            this.surfaceShapes.push(surfaceShape);
	            this.surfaceShapeStateKeys.push(surfaceShape.stateKey);
	        };

	        /**
	         * Add multiple surface shapes to this tile's collection.
	         * @param {SurfaceShape[]} shapes A collection of surface shapes to add to the collection of this tile.
	         */
	        SurfaceShapeTile.prototype.addAllSurfaceShapes = function(shapes) {
	            for (var idx = 0, len = shapes.length; idx < len; idx += 1) {
	                var shape = shapes[idx];
	                this.addAllSurfaceShapes(shape);
	            }
	        };

	        // Internal use only. Intentionally not documented.
	        SurfaceShapeTile.prototype.needsUpdate = function(dc) {
	            var idx, len, surfaceShape, surfaceShapeStateKey;

	            // If the number of shapes have changed, ... (cheap test)
	            if (this.prevSurfaceShapes.length != this.surfaceShapes.length) {
	                return true;
	            }

	            // If shapes have been removed since the previous iteration, ...
	            for (idx = 0, len = this.prevSurfaceShapes.length; idx < len; idx += 1) {
	                surfaceShape = this.prevSurfaceShapes[idx];

	                if (this.surfaceShapes.indexOf(surfaceShape) < 0) {
	                    return true;
	                }
	            }

	            // If shapes added since the previous iteration, ...
	            for (idx = 0, len = this.surfaceShapes.length; idx < len; idx += 1) {
	                surfaceShape = this.surfaceShapes[idx];

	                if (this.prevSurfaceShapes.indexOf(surfaceShape) < 0) {
	                    return true;
	                }
	            }

	            // If the state key of the shape is different than the saved state key for that shape, ...
	            for (idx = 0, len = this.surfaceShapes.length; idx < len; idx += 1) {
	                surfaceShape = this.surfaceShapes[idx];
	                surfaceShapeStateKey = this.surfaceShapeStateKeys[idx];

	                if (surfaceShapeStateKey != surfaceShape.stateKey) {
	                    return true;
	                }
	            }

	            // If a texture does not already exist, ...
	            if (!this.hasTexture(dc)) {
	                return true;
	            }

	            // If you get here, the texture can be reused.
	            return false;
	        };

	        /**
	         * Determine whether the surface shape tile has a valid texture.
	         * @param {DrawContext} dc The draw context.
	         * @returns {boolean} True if the surface shape tile has a valid texture, else false.
	         */
	        SurfaceShapeTile.prototype.hasTexture = function(dc) {
	            if (dc.pickingMode) {
	                return false;
	            }

	            var gpuResourceCache = dc.gpuResourceCache;

	            if (!this.gpuCacheKey) {
	                this.gpuCacheKey = this.getCacheKey();
	            }

	            var texture = gpuResourceCache.resourceForKey(this.gpuCacheKey);

	            return !!texture;
	        };

	        /**
	         * Redraw all of the surface shapes onto the texture for this tile.
	         * @param {DrawContext} dc
	         * @returns {Texture}
	         */
	        SurfaceShapeTile.prototype.updateTexture = function(dc) {
	            var gl = dc.currentGlContext,
	                canvas = SurfaceShapeTile.canvas;

	            canvas.width = this.tileWidth;
	            canvas.height = this.tileHeight;

	            var ctx2D = SurfaceShapeTile.ctx2D;

	            // Mapping from lat/lon to x/y:
	            //  lon = minlon => x = 0
	            //  lon = maxLon => x = 256
	            //  lat = minLat => y = 256
	            //  lat = maxLat => y = 0
	            //  (assuming texture size is 256)
	            // So:
	            //  x = 256 / sector.dlon * (lon - minLon)
	            //  y = -256 / sector.dlat * (lat - maxLat)
	            var xScale = this.tileWidth / this.sector.deltaLongitude(),
	                yScale = -this.tileHeight / this.sector.deltaLatitude(),
	                xOffset = -this.sector.minLongitude * xScale,
	                yOffset = -this.sector.maxLatitude * yScale;

	            for (var idx = 0, len = this.surfaceShapes.length; idx < len; idx += 1) {
	                var shape = this.surfaceShapes[idx];
	                this.surfaceShapeStateKeys[idx] = shape.stateKey;

	                shape.renderToTexture(dc, ctx2D, xScale, yScale, xOffset, yOffset);
	            }

	            var texture = new Texture(gl, canvas);

	            var gpuResourceCache = dc.gpuResourceCache;

	            this.gpuCacheKey = this.getCacheKey();

	            gpuResourceCache.putResource(this.gpuCacheKey, texture, texture.size);

	            return texture;
	        };

	        /**
	         * Get a key suitable for cache look-ups.
	         * @returns {string}
	         */
	        SurfaceShapeTile.prototype.getCacheKey = function() {
	            if (!this.cacheKey) {
	                this.cacheKey = "SurfaceShapeTile:" +
	                this.tileKey + "," +
	                this.pickSequence.toString();
	            }

	            return this.cacheKey;
	        };

	        /**
	         * Create a new canvas and its 2D context on demand.
	         */
	        SurfaceShapeTile.prototype.createCtx2D = function() {
	            // If the context was previously created, ...
	            if (!SurfaceShapeTile.ctx2D) {
	                SurfaceShapeTile.canvas = document.createElement("canvas");
	                SurfaceShapeTile.ctx2D = SurfaceShapeTile.canvas.getContext("2d");
	            }
	        };

	        /*
	         * For internal use only.
	         * 2D canvas and context, which is created lazily on demand.
	         */
	        SurfaceShapeTile.canvas = null;
	        SurfaceShapeTile.ctx2D = null;

	        return SurfaceShapeTile;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports Level
	 * @version $Id: Level.js 2952 2015-04-01 00:33:54Z tgaskins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(29),
	        __webpack_require__(30),
	        __webpack_require__(28),
	        __webpack_require__(32)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Angle,
	              ArgumentError,
	              Location,
	              Logger) {
	        "use strict";

	        /**
	         * Constructs a Level within a [LevelSet]{@link LevelSet}. Applications typically do not interact with this
	         * class.
	         * @alias Level
	         * @constructor
	         * @classdesc Represents a level in a tile pyramid.
	         * @throws {ArgumentError} If either the specified tile delta or parent level set is null or undefined.
	         */
	        var Level = function (levelNumber, tileDelta, parent) {
	            if (!tileDelta) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Level", "constructor",
	                        "The specified tile delta is null or undefined"));
	            }

	            if (!parent) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Level", "constructor",
	                        "The specified parent level set is null or undefined"));
	            }

	            /**
	             * The level's ordinal in its parent level set.
	             * @type {Number}
	             */
	            this.levelNumber = levelNumber;

	            /**
	             * The geographic size of tiles within this level.
	             * @type {Location}
	             */
	            this.tileDelta = tileDelta;

	            /**
	             * The level set that this level is a member of.
	             * @type {LevelSet}
	             */
	            this.parent = parent;

	            /**
	             * The size of pixels or elevation cells within this level, in radians per pixel or per cell.
	             * @type {Number}
	             */
	            this.texelSize = (tileDelta.latitude * Angle.DEGREES_TO_RADIANS) / parent.tileHeight;

	            /**
	             * The width in pixels or cells of the resource associated with tiles within this level.
	             * @type {Number}
	             */
	            this.tileWidth = parent.tileWidth;

	            /**
	             * The height in pixels or cells of the resource associated with tiles within this level.
	             * @type {Number}
	             */
	            this.tileHeight = parent.tileHeight;

	            /**
	             * The sector spanned by this level.
	             * @type {Sector}
	             */
	            this.sector = parent.sector;
	        };

	        /**
	         * Indicates whether this level is the lowest resolution level (level 0) within its parent's level set.
	         * @returns {Boolean} true If this tile is the lowest resolution in the parent level set,
	         * otherwise false.
	         */
	        Level.prototype.isFirstLevel = function () {
	            return this.parent.firstLevel() == this;
	        };

	        /**
	         * Indicates whether this level is the highest resolution level within its parent's level set.
	         * @returns {Boolean} true If this tile is the highest resolution in the parent level set,
	         * otherwise false.
	         */
	        Level.prototype.isLastLevel = function () {
	            return this.parent.lastLevel() == this;
	        };

	        /**
	         * Returns the level whose ordinal occurs immediately before this level's ordinal in the parent level set, or
	         * null if this is the fist level.
	         * @returns {Level} The previous level, or null if this is the first level.
	         */
	        Level.prototype.previousLevel = function () {
	            return this.parent.level(this.levelNumber - 1);
	        };

	        /**
	         * Returns the level whose ordinal occurs immediately after this level's ordinal in the parent level set, or
	         * null if this is the last level.
	         * @returns {Level} The next level, or null if this is the last level.
	         */
	        Level.prototype.nextLevel = function () {
	            return this.parent.level(this.levelNumber + 1);
	        };

	        /**
	         * Compare this level's ordinal to that of a specified level.
	         * @param {Level} that The level to compare this one to.
	         * @returns {Number} 0 if the two ordinals are equivalent. -1 if this level's ordinal is less than the specified
	         * level's ordinal. 1 if this level's ordinal is greater than the specified level's ordinal.
	         * @throws {ArgumentError} If the specified level is null or undefined.
	         */
	        Level.prototype.compare = function (that) {
	            if (!that) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Level", "compare",
	                        "The specified level is null or undefined"));
	            }

	            if (this.levelNumber < that.levelNumber)
	                return -1;

	            if (this.levelNumber > that.levelNumber)
	                return 1;

	            return 0;
	        };

	        return Level;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports Sector
	 * @version $Id: Sector.js 2933 2015-03-27 01:18:24Z tgaskins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(29),
	        __webpack_require__(30),
	        __webpack_require__(28),
	        __webpack_require__(32),
	        __webpack_require__(35),
	        __webpack_require__(36)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Angle,
	              ArgumentError,
	              Location,
	              Logger,
	              Vec3,
	              WWMath) {
	        "use strict";

	        /**
	         * Constructs a Sector from specified minimum and maximum latitudes and longitudes in degrees.
	         * @alias Sector
	         * @constructor
	         * @classdesc Represents a rectangular region in geographic coordinates in degrees.
	         * @param {Number} minLatitude The sector's minimum latitude in degrees.
	         * @param {Number} maxLatitude The sector's maximum latitude in degrees.
	         * @param {Number} minLongitude The sector's minimum longitude in degrees.
	         * @param {Number} maxLongitude The sector's maximum longitude in degrees.
	         */
	        var Sector = function (minLatitude, maxLatitude, minLongitude, maxLongitude) {
	            /**
	             * This sector's minimum latitude in degrees.
	             * @type {Number}
	             */
	            this.minLatitude = minLatitude;
	            /**
	             * This sector's maximum latitude in degrees.
	             * @type {Number}
	             */
	            this.maxLatitude = maxLatitude;
	            /**
	             * This sector's minimum longitude in degrees.
	             * @type {Number}
	             */
	            this.minLongitude = minLongitude;
	            /**
	             * This sector's maximum longitude in degrees.
	             * @type {Number}
	             */
	            this.maxLongitude = maxLongitude;
	        };

	        /**
	         * A sector with minimum and maximum latitudes and minimum and maximum longitudes all zero.
	         * @constant
	         * @type {Sector}
	         */
	        Sector.ZERO = new Sector(0, 0, 0, 0);

	        /**
	         * A sector that encompasses the full range of latitude ([-90, 90]) and longitude ([-180, 180]).
	         * @constant
	         * @type {Sector}
	         */
	        Sector.FULL_SPHERE = new Sector(-90, 90, -180, 180);

	        /**
	         * Sets this sector's latitudes and longitudes to those of a specified sector.
	         * @param {Sector} sector The sector to copy.
	         * @returns {Sector} This sector, set to the values of the specified sector.
	         * @throws {ArgumentError} If the specified sector is null or undefined.
	         */
	        Sector.prototype.copy = function (sector) {
	            if (!sector) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "Sector", "copy", "missingSector"));
	            }

	            this.minLatitude = sector.minLatitude;
	            this.maxLatitude = sector.maxLatitude;
	            this.minLongitude = sector.minLongitude;
	            this.maxLongitude = sector.maxLongitude;

	            return this;
	        };

	        /**
	         * Indicates whether this sector has width or height.
	         * @returns {Boolean} true if this sector's minimum and maximum latitudes or minimum and maximum
	         * longitudes do not differ, otherwise false.
	         */
	        Sector.prototype.isEmpty = function () {
	            return this.minLatitude === this.maxLatitude && this.minLongitude === this.maxLongitude;
	        };

	        /**
	         * Returns the angle between this sector's minimum and maximum latitudes, in degrees.
	         * @returns {Number} The difference between this sector's minimum and maximum latitudes, in degrees.
	         */
	        Sector.prototype.deltaLatitude = function () {
	            return this.maxLatitude - this.minLatitude;
	        };

	        /**
	         * Returns the angle between this sector's minimum and maximum longitudes, in degrees.
	         * @returns {Number} The difference between this sector's minimum and maximum longitudes, in degrees.
	         */
	        Sector.prototype.deltaLongitude = function () {
	            return this.maxLongitude - this.minLongitude;
	        };

	        /**
	         * Returns the angle midway between this sector's minimum and maximum latitudes.
	         * @returns {Number} The mid-angle of this sector's minimum and maximum latitudes, in degrees.
	         */
	        Sector.prototype.centroidLatitude = function () {
	            return 0.5 * (this.minLatitude + this.maxLatitude);
	        };

	        /**
	         * Returns the angle midway between this sector's minimum and maximum longitudes.
	         * @returns {Number} The mid-angle of this sector's minimum and maximum longitudes, in degrees.
	         */
	        Sector.prototype.centroidLongitude = function () {
	            return 0.5 * (this.minLongitude + this.maxLongitude);
	        };

	        /**
	         * Computes the location of the angular center of this sector, which is the mid-angle of each of this sector's
	         * latitude and longitude dimensions.
	         * @param {Location} result A pre-allocated {@link Location} in which to return the computed centroid.
	         * @returns {Location} The specified result argument containing the computed centroid.
	         * @throws {ArgumentError} If the result argument is null or undefined.
	         */
	        Sector.prototype.centroid = function (result) {
	            if (!result) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Sector", "centroid", "missingResult"));
	            }

	            result.latitude = this.centroidLatitude();
	            result.longitude = this.centroidLongitude();

	            return result;
	        };

	        /**
	         * Returns this sector's minimum latitude in radians.
	         * @returns {Number} This sector's minimum latitude in radians.
	         */
	        Sector.prototype.minLatitudeRadians = function () {
	            return this.minLatitude * Angle.DEGREES_TO_RADIANS;
	        };

	        /**
	         * Returns this sector's maximum latitude in radians.
	         * @returns {Number} This sector's maximum latitude in radians.
	         */
	        Sector.prototype.maxLatitudeRadians = function () {
	            return this.maxLatitude * Angle.DEGREES_TO_RADIANS;
	        };

	        /**
	         * Returns this sector's minimum longitude in radians.
	         * @returns {Number} This sector's minimum longitude in radians.
	         */
	        Sector.prototype.minLongitudeRadians = function () {
	            return this.minLongitude * Angle.DEGREES_TO_RADIANS;
	        };

	        /**
	         * Returns this sector's maximum longitude in radians.
	         * @returns {Number} This sector's maximum longitude in radians.
	         */
	        Sector.prototype.maxLongitudeRadians = function () {
	            return this.maxLongitude * Angle.DEGREES_TO_RADIANS;
	        };

	        /**
	         * Modifies this sector to encompass an array of specified locations.
	         * @param {Location[]} locations An array of locations. The array may be sparse.
	         * @returns {Sector} This sector, modified to encompass all locations in the specified array.
	         * @throws {ArgumentError} If the specified array is null, undefined or empty or has fewer than two locations.
	         */
	        Sector.prototype.setToBoundingSector = function (locations) {
	            if (!locations || locations.length < 2) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "Sector", "setToBoundingSector",
	                    "missingArray"));
	            }

	            var minLatitude = 90,
	                maxLatitude = -90,
	                minLongitude = 180,
	                maxLongitude = -180;

	            for (var idx = 0, len = locations.length; idx < len; idx += 1) {
	                var location = locations[idx];

	                if (!location) {
	                    continue;
	                }

	                minLatitude = Math.min(minLatitude, location.latitude);
	                maxLatitude = Math.max(maxLatitude, location.latitude);
	                minLongitude = Math.min(minLongitude, location.longitude);
	                maxLongitude = Math.max(maxLongitude, location.longitude);
	            }

	            this.minLatitude = minLatitude;
	            this.maxLatitude = maxLatitude;
	            this.minLongitude = minLongitude;
	            this.maxLongitude = maxLongitude;

	            return this;
	        };

	        /**
	         * Computes bounding sectors from a list of locations that span the dateline.
	         * @param {Location[]} locations The locations to bound.
	         * @returns {Sector[]} Two sectors, one in the eastern hemisphere and one in the western hemisphere.
	         * Returns null if the computed bounding sector has zero width or height.
	         * @throws {ArgumentError} If the specified array is null, undefined or empty or the number of locations
	         * is less than 2.
	         */
	        Sector.splitBoundingSectors = function(locations) {
	            if (!locations || locations.length < 2) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "Sector", "splitBoundingSectors",
	                    "missingArray"));
	            }

	            var minLat = 90;
	            var minLon = 180;
	            var maxLat = -90;
	            var maxLon = -180;

	            var lastLocation = null;

	            for (var idx = 0, len = locations.length; idx < len; idx += 1) {
	                var location = locations[idx];

	                var lat = location.latitude;
	                if (lat < minLat) {
	                    minLat = lat;
	                }
	                if (lat > maxLat) {
	                    maxLat = lat;
	                }

	                var lon = location.longitude;
	                if (lon >= 0 && lon < minLon) {
	                    minLon = lon;
	                }
	                if (lon <= 0 && lon > maxLon) {
	                    maxLon = lon;
	                }

	                if (lastLocation != null) {
	                    var lastLon = lastLocation.longitude;
	                    if (WWMath.signum(lon) != WWMath.signum(lastLon)) {
	                        if (Math.abs(lon - lastLon) < 180) {
	                            // Crossing the zero longitude line too
	                            maxLon = 0;
	                            minLon = 0;
	                        }
	                    }
	                }
	                lastLocation = location;
	            }

	            if (minLat === maxLat && minLon === maxLon) {
	                return null;
	            }

	            return [
	                new Sector(minLat, maxLat, minLon, 180), // Sector on eastern hemisphere.
	                new Sector(minLat, maxLat, -180, maxLon) // Sector on western hemisphere.
	            ];
	        };

	        /**
	         * Indicates whether this sector intersects a specified sector.
	         * This sector intersects the specified sector when each sector's boundaries either overlap with the specified
	         * sector or are adjacent to the specified sector.
	         * The sectors are assumed to have normalized angles (angles within the range [-90, 90] latitude and
	         * [-180, 180] longitude).
	         * @param {Sector} sector The sector to test intersection with. May be null or undefined, in which case this
	         * function returns false.
	         * @returns {Boolean} true if the specifies sector intersections this sector, otherwise false.
	         */
	        Sector.prototype.intersects = function (sector) {
	            // Assumes normalized angles: [-90, 90], [-180, 180].
	            return sector
	                && this.minLongitude <= sector.maxLongitude
	                && this.maxLongitude >= sector.minLongitude
	                && this.minLatitude <= sector.maxLatitude
	                && this.maxLatitude >= sector.minLatitude;
	        };

	        /**
	         * Indicates whether this sector intersects a specified sector exclusive of the sector boundaries.
	         * This sector overlaps the specified sector when the union of the two sectors defines a non-empty sector.
	         * The sectors are assumed to have normalized angles (angles within the range [-90, 90] latitude and
	         * [-180, 180] longitude).
	         * @param {Sector} sector The sector to test overlap with. May be null or undefined, in which case this
	         * function returns false.
	         * @returns {Boolean} true if the specified sector overlaps this sector, otherwise false.
	         */
	        Sector.prototype.overlaps = function (sector) {
	            // Assumes normalized angles: [-90, 90], [-180, 180].
	            return sector
	                && this.minLongitude < sector.maxLongitude
	                && this.maxLongitude > sector.minLongitude
	                && this.minLatitude < sector.maxLatitude
	                && this.maxLatitude > sector.minLatitude;
	        };

	        /**
	         * Indicates whether this sector fully contains a specified sector.
	         * This sector contains the specified sector when the specified sector's boundaries are completely contained
	         * within this sector's boundaries, or are equal to this sector's boundaries.
	         * The sectors are assumed to have normalized angles (angles within the range [-90, 90] latitude and
	         * [-180, 180] longitude).
	         * @param {Sector} sector The sector to test containment with. May be null or undefined, in which case this
	         * function returns false.
	         * @returns {Boolean} true if the specified sector contains this sector, otherwise false.
	         */
	        Sector.prototype.contains = function (sector) {
	            // Assumes normalized angles: [-90, 90], [-180, 180].
	            return sector
	                && this.minLatitude <= sector.minLatitude
	                && this.maxLatitude >= sector.maxLatitude
	                && this.minLongitude <= sector.minLongitude
	                && this.maxLongitude >= sector.maxLongitude;
	        };

	        /**
	         * Indicates whether this sector contains a specified geographic location.
	         * @param {Number} latitude The location's latitude in degrees.
	         * @param {Number} longitude The location's longitude in degrees.
	         * @returns {Boolean} true if this sector contains the location, otherwise false.
	         */
	        Sector.prototype.containsLocation = function (latitude, longitude) {
	            // Assumes normalized angles: [-90, 90], [-180, 180].
	            return this.minLatitude <= latitude
	                && this.maxLatitude >= latitude
	                && this.minLongitude <= longitude
	                && this.maxLongitude >= longitude;
	        };

	        /**
	         * Sets this sector to the intersection of itself and a specified sector.
	         * @param {Sector} sector The sector to intersect with this one.
	         * @returns {Sector} This sector, set to its intersection with the specified sector.
	         * @throws {ArgumentError} If the specified sector is null or undefined.
	         */
	        Sector.prototype.intersection = function (sector) {
	            if (!sector instanceof Sector) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Sector", "intersection", "missingSector"));
	            }

	            // Assumes normalized angles: [-180, 180], [-90, 90].
	            if (this.minLatitude < sector.minLatitude)
	                this.minLatitude = sector.minLatitude;
	            if (this.maxLatitude > sector.maxLatitude)
	                this.maxLatitude = sector.maxLatitude;
	            if (this.minLongitude < sector.minLongitude)
	                this.minLongitude = sector.minLongitude;
	            if (this.maxLongitude > sector.maxLongitude)
	                this.maxLongitude = sector.maxLongitude;

	            // If the sectors do not overlap in either latitude or longitude, then the result of the above logic results in
	            // the max being greater than the min. In this case, set the max to indicate that the sector is empty in
	            // that dimension.
	            if (this.maxLatitude < this.minLatitude)
	                this.maxLatitude = this.minLatitude;
	            if (this.maxLongitude < this.minLongitude)
	                this.maxLongitude = this.minLongitude;

	            return this;
	        };

	        /**
	         * Sets this sector to the union of itself and a specified sector.
	         * @param {Sector} sector The sector to union with this one.
	         * @returns {Sector} This sector, set to its union with the specified sector.
	         * @throws {ArgumentError} if the specified sector is null or undefined.
	         */
	        Sector.prototype.union = function (sector) {
	            if (!sector instanceof Sector) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Sector", "union", "missingSector"));
	            }

	            // Assumes normalized angles: [-180, 180], [-90, 90].
	            if (this.minLatitude > sector.minLatitude)
	                this.minLatitude = sector.minLatitude;
	            if (this.maxLatitude < sector.maxLatitude)
	                this.maxLatitude = sector.maxLatitude;
	            if (this.minLongitude > sector.minLongitude)
	                this.minLongitude = sector.minLongitude;
	            if (this.maxLongitude < sector.maxLongitude)
	                this.maxLongitude = sector.maxLongitude;

	            return this;
	        };

	        return Sector;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports TextureTile
	 * @version $Id: TextureTile.js 2941 2015-03-30 21:11:43Z tgaskins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(30),
	        __webpack_require__(32),
	        __webpack_require__(77)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
	              Logger,
	              Tile) {
	        "use strict";

	        /**
	         * Constructs a texture tile.
	         * @alias TextureTile
	         * @constructor
	         * @augments Tile
	         * @classdesc Represents an image applied to a portion of a globe's terrain. Applications typically do not
	         * interact with this class.
	         * @param {Sector} sector The sector this tile covers.
	         * @param {Level} level The level this tile is associated with.
	         * @param {Number} row This tile's row in the associated level.
	         * @param {Number} column This tile's column in the associated level.
	         * @throws {ArgumentError} If the specified sector or level is null or undefined, the row or column arguments
	         * are less than zero, or the specified image path is null, undefined or empty.
	         *
	         */
	        var TextureTile = function (sector, level, row, column) {
	            Tile.call(this, sector, level, row, column); // args are checked in the superclass' constructor

	            /**
	             * GPU cache key
	             * @type {string}
	             */
	            this.gpuCacheKey = null;
	        };

	        TextureTile.prototype = Object.create(Tile.prototype);

	        /**
	         * Returns the size of the this tile in bytes.
	         * @returns {Number} The size of this tile in bytes, not including the associated texture size.
	         */
	        TextureTile.prototype.size = function () {
	            return Tile.prototype.size.call(this);
	        };

	        /**
	         * Causes this tile's texture to be active. Implements [SurfaceTile.bind]{@link SurfaceTile#bind}.
	         * @param {DrawContext} dc The current draw context.
	         * @returns {Boolean} true if the texture was bound successfully, otherwise false.
	         */
	        TextureTile.prototype.bind = function (dc) {
	            var texture = dc.gpuResourceCache.resourceForKey(this.gpuCacheKey);
	            if (texture) {
	                return texture.bind(dc);
	            }

	            return false;
	        };

	        /**
	         * If this tile's fallback texture is used, applies the appropriate texture transform to a specified matrix.
	         * Otherwise, this is a no-op.
	         * @param {DrawContext} dc The current draw context.
	         * @param {Matrix} matrix The matrix to apply the transform to.
	         */
	        TextureTile.prototype.applyInternalTransform = function (dc, matrix) {
	            // Override this method if the tile has a fallback texture.
	        };

	        return TextureTile;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports Tile
	 * @version $Id: Tile.js 3125 2015-05-29 14:43:25Z tgaskins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(30),
	        __webpack_require__(78),
	        __webpack_require__(32),
	        __webpack_require__(75),
	        __webpack_require__(35),
	        __webpack_require__(83)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
	              BoundingBox,
	              Logger,
	              Sector,
	              Vec3,
	              WWUtil) {
	        "use strict";

	        /**
	         * Constructs a tile for a specified sector, level, row and column.
	         * @alias Tile
	         * @constructor
	         * @classdesc Represents a tile of terrain or imagery.
	         * Provides a base class for texture tiles used by tiled image layers and elevation tiles used by elevation models.
	         * Applications typically do not interact with this class.
	         * @param {Sector} sector The sector represented by this tile.
	         * @param {Level} level This tile's level in a tile pyramid.
	         * @param {Number} row This tile's row in the specified level in a tile pyramid.
	         * @param {Number} column This tile's column in the specified level in a tile pyramid.
	         * @throws {ArgumentError} If the specified sector or level is null or undefined or the row or column arguments
	         * are less than zero.
	         */
	        var Tile = function (sector, level, row, column) {
	            if (!sector) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Tile", "constructor", "missingSector"));
	            }

	            if (!level) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Tile", "constructor",
	                        "The specified level is null or undefined."));
	            }

	            if (row < 0 || column < 0) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Tile", "constructor",
	                        "The specified row or column is less than zero."));
	            }

	            /**
	             * The sector represented by this tile.
	             * @type {Sector}
	             * @readonly
	             */
	            this.sector = sector;

	            /**
	             * The level at which this tile lies in a tile pyramid.
	             * @type {Number}
	             * @readonly
	             */
	            this.level = level;

	            /**
	             * The row in this tile's level in which this tile lies in a tile pyramid.
	             * @type {Number}
	             * @readonly
	             */
	            this.row = row;

	            /**
	             * The column in this tile's level in which this tile lies in a tile pyramid.
	             * @type {Number}
	             * @readonly
	             */
	            this.column = column;

	            /**
	             * The width in pixels or cells of this tile's associated resource.
	             * @type {Number}
	             */
	            this.tileWidth = level.tileWidth;

	            /**
	             * The height in pixels or cells of this tile's associated resource.
	             * @type {Number}
	             */
	            this.tileHeight = level.tileHeight;

	            /**
	             * The size in radians of pixels or cells of this tile's associated resource.
	             * @type {Number}
	             */
	            this.texelSize = level.texelSize;

	            /**
	             * A key that uniquely identifies this tile within a level set.
	             * @type {String}
	             * @readonly
	             */
	            this.tileKey = level.levelNumber.toString() + "." + row.toString() + "." + column.toString();

	            /**
	             * The Cartesian bounding box of this tile.
	             * @type {BoundingBox}
	             */
	            this.extent = null;

	            /**
	             * The tile's local origin in model coordinates. Any model coordinate points associates with the tile
	             * should be relative to this point.
	             * @type {Vec3}
	             */
	            this.referencePoint = null;

	            /**
	             * This tile's opacity.
	             * @type {Number}
	             * @default 1
	             */
	            this.opacity = 1;

	            // Internal use only. Intentionally not documented.
	            this.samplePoints = null;

	            // Internal use only. Intentionally not documented.
	            this.sampleElevations = null;

	            // Internal use only. Intentionally not documented.
	            this.updateTimestamp = null;

	            // Internal use only. Intentionally not documented.
	            this.updateVerticalExaggeration = null;

	            // Internal use only. Intentionally not documented.
	            this.updateGlobeStateKey = null;
	        };

	        /**
	         * Indicates whether this tile is equivalent to a specified tile.
	         * @param {Tile} that The tile to check equivalence with.
	         * @returns {boolean} true if this tile is equivalent to the specified one, false if
	         * they are not equivalent or the specified tile is null or undefined.
	         */
	        Tile.prototype.isEqual = function (that) {
	            if (!that)
	                return false;

	            if (!that.tileKey)
	                return false;

	            return this.tileKey == that.tileKey;
	        };

	        /**
	         * Returns the size of this tile in bytes.
	         * @returns {Number} The size of this tile in bytes.
	         */
	        Tile.prototype.size = function () {
	            return 4 // child pointer
	                + (4 + 32) // sector
	                + 4 //level pointer (the level is common to the layer or tessellator so is not included here)
	                + 8 // row and column
	                + 8 // texel size
	                + (4 + 32) // reference point
	                + (4 + 676) // bounding box
	                + 8 // min and max height
	                + (4 + 32) // nearest point
	                + 8; // extent timestamp and vertical exaggeration
	        };

	        /**
	         * Computes an approximate distance from this tile to a specified vector.
	         * @param {Vec3} vector The vector to compute the distance to.
	         * @returns {number} The distance between this tile and the vector.
	         * @throws {ArgumentError} If the specified vector is null or undefined.
	         */
	        Tile.prototype.distanceTo = function (vector) {
	            if (!vector) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Tile", "distanceTo", "missingVector"));
	            }

	            var px = vector[0], py = vector[1], pz = vector[2],
	                dx, dy, dz,
	                points = this.samplePoints,
	                distance = Number.POSITIVE_INFINITY;

	            for (var i = 0, len = points.length; i < len; i += 3) {
	                dx = px - points[i];
	                dy = py - points[i + 1];
	                dz = pz - points[i + 2];
	                distance = Math.min(distance, dx * dx + dy * dy + dz * dz); // minimum squared distance
	            }

	            return Math.sqrt(distance);
	        };

	        /**
	         * Returns the four children formed by subdividing this tile.
	         * @param {Level} level The level of the children.
	         * @param {TileFactory} tileFactory The tile factory to use to create the children.
	         * @returns {Tile[]} An array containing the four child tiles.
	         * @throws {ArgumentError} If the specified tile factory or level is null or undefined.
	         */
	        Tile.prototype.subdivide = function (level, tileFactory) {
	            if (!level) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Tile", "subdivide",
	                        "The specified level is null or undefined."));
	            }

	            if (!tileFactory) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Tile", "subdivide",
	                        "The specified tile factory is null or undefined."));
	            }

	            var latMin = this.sector.minLatitude,
	                latMax = this.sector.maxLatitude,
	                latMid = this.sector.centroidLatitude(),

	                lonMin = this.sector.minLongitude,
	                lonMax = this.sector.maxLongitude,
	                lonMid = this.sector.centroidLongitude(),

	                subRow,
	                subCol,
	                childSector,
	                children = [];

	            subRow = 2 * this.row;
	            subCol = 2 * this.column;
	            childSector = new Sector(latMin, latMid, lonMin, lonMid);
	            children.push(tileFactory.createTile(childSector, level, subRow, subCol));

	            subRow = 2 * this.row;
	            subCol = 2 * this.column + 1;
	            childSector = new Sector(latMin, latMid, lonMid, lonMax);
	            children.push(tileFactory.createTile(childSector, level, subRow, subCol));

	            subRow = 2 * this.row + 1;
	            subCol = 2 * this.column;
	            childSector = new Sector(latMid, latMax, lonMin, lonMid);
	            children.push(tileFactory.createTile(childSector, level, subRow, subCol));

	            subRow = 2 * this.row + 1;
	            subCol = 2 * this.column + 1;
	            childSector = new Sector(latMid, latMax, lonMid, lonMax);
	            children.push(tileFactory.createTile(childSector, level, subRow, subCol));

	            return children;
	        };

	        /**
	         * Returns the four children formed by subdividing this tile, drawing those children from a specified cache
	         * if they exist there.
	         * @param {Level} level The level of the children.
	         * @param {TileFactory} tileFactory The tile factory to use to create the children.
	         * @param {MemoryCache} cache A memory cache that may contain pre-existing child tiles. If non-null, the
	         * cache is checked for a child collection prior to creating that tile. If one exists
	         * in the cache it is returned rather than creating a new collection of children. If a new collection is
	         * created, it is added to the cache.
	         * @returns {Tile[]} An array containing the four tiles.
	         * @throws {ArgumentError} If the specified tile factory or level is null or undefined.
	         */
	        Tile.prototype.subdivideToCache = function (level, tileFactory, cache) {
	            if (!level) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Tile", "subdivideToCache",
	                        "The specified level is null or undefined."));
	            }

	            if (!tileFactory) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Tile", "subdivideToCache",
	                        "The specified tile factory is null or undefined."));
	            }

	            var childList = cache ? cache.entryForKey(this.tileKey) : null;
	            if (!childList) {
	                childList = this.subdivide(level, tileFactory);
	                if (childList && cache) {
	                    cache.putEntry(this.tileKey, childList, 4 * childList[0].size());
	                }
	            }

	            return childList;
	        };

	        /**
	         * Indicates whether this tile should be subdivided based on the current navigation state and a specified
	         * detail factor.
	         * @param {DrawContext} dc The current draw context.
	         * @param {Number} detailFactor The detail factor to consider.
	         * @returns {boolean} true If the tile should be subdivided, otherwise false.
	         */
	        Tile.prototype.mustSubdivide = function (dc, detailFactor) {
	            // Split when the cell height (length of a texel) becomes greater than the specified fraction of the eye
	            // distance. The fraction is specified as a power of 10. For example, a detail factor of 3 means split when
	            // the cell height becomes more than one thousandth of the eye distance. Another way to say it is, use the
	            // current tile if the cell height is less than the specified fraction of the eye distance.
	            //
	            // Note: It's tempting to instead compare a screen pixel size to the texel size, but that calculation is
	            // window-size dependent and results in selecting an excessive number of tiles when the window is large.

	            var cellSize = dc.globe.equatorialRadius * this.texelSize,
	                distance = this.distanceTo(dc.navigatorState.eyePoint),
	                pixelSize = dc.navigatorState.pixelSizeAtDistance(distance);

	            return cellSize > Math.max(detailFactor * pixelSize, 0.5);
	        };

	        /**
	         * Updates this tile's frame-dependent properties as necessary, according to the specified draw context.
	         * <p>
	         * The tile's frame-dependent properties, include the extent (bounding volume). These properties are dependent
	         * on the tile's sector and the elevation values currently in memory, and change when those dependencies change.
	         * Therefore <code>update</code> must be called once per frame before the extent and any other frame-dependent
	         * properties are used. <code>update</code> intelligently determines when it is necessary to recompute these
	         * properties, and does nothing if the state of all dependencies has not changed since the last call.
	         * @param {DrawContext} dc The current draw context.
	         */
	        Tile.prototype.update = function (dc) {
	            var elevationTimestamp = dc.globe.elevationTimestamp(),
	                verticalExaggeration = dc.verticalExaggeration,
	                globeStateKey = dc.globeStateKey;

	            if (this.updateTimestamp != elevationTimestamp
	                || this.updateVerticalExaggeration != verticalExaggeration
	                || this.updateGlobeStateKey != globeStateKey) {

	                this.doUpdate(dc);
	                dc.frameStatistics.incrementTileUpdateCount(1);

	                // Set the geometry extent to the globe's elevation timestamp on which the geometry is based. This
	                // ensures that the geometry timestamp can be reliably compared to the elevation timestamp in subsequent
	                // frames.
	                this.updateTimestamp = elevationTimestamp;
	                this.updateVerticalExaggeration = verticalExaggeration;
	                this.updateGlobeStateKey = globeStateKey;
	            }
	        };

	        /**
	         * Updates this tile's frame-dependent properties according to the specified draw context.
	         * @param {DrawContext} dc The current draw context.
	         * @protected
	         */
	        Tile.prototype.doUpdate = function (dc) {
	            // Compute the minimum and maximum world coordinate height for this tile's sector by multiplying the minimum
	            // and maximum elevations by the scene's vertical exaggeration. This ensures that the elevations to used
	            // build the terrain are contained by this tile's extent. Use zero if the globe as no elevations in this
	            // tile's sector.
	            var globe = dc.globe,
	                verticalExaggeration = dc.verticalExaggeration,
	                extremes = globe.minAndMaxElevationsForSector(this.sector),
	                minHeight = extremes ? (extremes[0] * verticalExaggeration) : 0,
	                maxHeight = extremes ? (extremes[1] * verticalExaggeration) : 0;
	            if (minHeight == maxHeight) {
	                minHeight = maxHeight + 10; // TODO: Determine if this is necessary.
	            }

	            // Compute a bounding box for this tile that contains the terrain surface in the tile's coverage area.
	            if (!this.extent) {
	                this.extent = new BoundingBox();
	            }
	            this.extent.setToSector(this.sector, globe, minHeight, maxHeight);

	            // Compute the cartesian points for a 3x3 geographic grid. This grid captures sufficiently close sample
	            // points in order to estimate the distance from the viewer to this tile.
	            if (!this.samplePoints) {
	                this.sampleElevations = new Float64Array(9);
	                this.samplePoints = new Float64Array(3 * this.sampleElevations.length);
	            }
	            WWUtil.fillArray(this.sampleElevations, 0.5 * (minHeight + maxHeight));
	            globe.computePointsForGrid(this.sector, 3, 3, this.sampleElevations, Vec3.ZERO, this.samplePoints);

	            // Compute the reference point used as a local coordinate origin for the tile.
	            if (!this.referencePoint) {
	                this.referencePoint = new Vec3(0, 0, 0);
	            }

	            globe.computePointFromPosition(this.sector.centroidLatitude(), this.sector.centroidLongitude(), 0,
	                this.referencePoint);
	        };

	        /**
	         * Computes a row number for a tile within a level given the tile's latitude.
	         * @param {Number} delta The level's latitudinal tile delta in degrees.
	         * @param {Number} latitude The tile's minimum latitude.
	         * @returns {Number} The computed row number.
	         */
	        Tile.computeRow = function (delta, latitude) {
	            var row = Math.floor((latitude + 90) / delta);

	            // If latitude is at the end of the grid, subtract 1 from the computed row to return the last row.
	            if (latitude == 90) {
	                row -= 1;
	            }

	            return row;
	        };

	        /**
	         * Computes a column number for a tile within a level given the tile's longitude.
	         * @param {Number} delta The level's longitudinal tile delta in degrees.
	         * @param {Number} longitude The tile's minimum longitude.
	         * @returns {Number} The computed column number.
	         */
	        Tile.computeColumn = function (delta, longitude) {
	            var col = Math.floor((longitude + 180) / delta);

	            // If longitude is at the end of the grid, subtract 1 from the computed column to return the last column.
	            if (longitude == 180) {
	                col -= 1;
	            }

	            return col;
	        };

	        /**
	         * Computes the last row number for a tile within a level given the tile's maximum latitude.
	         * @param {Number} delta The level's latitudinal tile delta in degrees.
	         * @param {Number} maxLatitude The tile's maximum latitude in degrees.
	         * @returns {Number} The computed row number.
	         */
	        Tile.computeLastRow = function (delta, maxLatitude) {
	            var row = Math.ceil((maxLatitude + 90) / delta - 1);

	            // If max latitude is in the first row, set the max row to 0.
	            if (maxLatitude + 90 < delta) {
	                row = 0;
	            }

	            return row;
	        };

	        /**
	         * Computes the last column number for a tile within a level given the tile's maximum longitude.
	         * @param {Number} delta The level's longitudinal tile delta in degrees.
	         * @param {Number} maxLongitude The tile's maximum longitude in degrees.
	         * @returns {Number} The computed column number.
	         */
	        Tile.computeLastColumn = function (delta, maxLongitude) {
	            var col = Math.ceil((maxLongitude + 180) / delta - 1);

	            // If max longitude is in the first column, set the max column to 0.
	            if (maxLongitude + 180 < delta) {
	                col = 0;
	            }

	            return col;
	        };

	        /**
	         * Computes a sector spanned by a tile with the specified level number, row and column.
	         * @param {Level} level The tile's level number.
	         * @param {Number} row The tile's row number.
	         * @param {Number} column The tile's column number.
	         * @returns {Sector} The sector spanned by the tile.
	         * @throws {ArgumentError} If the specified level is null or undefined or the row or column are less than zero.
	         */
	        Tile.computeSector = function (level, row, column) {
	            if (!level) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Tile", "computeSector", "missingLevel"));
	            }

	            if (row < 0 || column < 0) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Tile", "computeSector",
	                        "The specified row or column is less than zero."));
	            }

	            var deltaLat = level.tileDelta.latitude,
	                deltaLon = level.tileDelta.longitude,

	                minLat = -90 + row * deltaLat,
	                minLon = -180 + column * deltaLon,
	                maxLat = minLat + deltaLat,
	                maxLon = minLon + deltaLon;

	            return new Sector(minLat, maxLat, minLon, maxLon);
	        };

	        /**
	         * Creates all tiles for a specified level number.
	         * @param {Level} level The level to create the tiles for.
	         * @param {TileFactory} tileFactory The tile factory to use for creating tiles.
	         * @param {Tile[]} result An array in which to return the results.
	         * @throws {ArgumentError} If any argument is null or undefined.
	         */
	        Tile.createTilesForLevel = function (level, tileFactory, result) {
	            if (!level) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Tile", "createTilesForLevel", "missingLevel"));
	            }

	            if (!tileFactory) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Tile", "createTilesForLevel",
	                        "The specified tile factory is null or undefined"));
	            }

	            if (!result) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Tile", "createTilesForLevel", "missingResult"));
	            }

	            var deltaLat = level.tileDelta.latitude,
	                deltaLon = level.tileDelta.longitude,

	                sector = level.sector,
	                firstRow = Tile.computeRow(deltaLat, sector.minLatitude),
	                lastRow = Tile.computeRow(deltaLat, sector.maxLatitude),

	                firstCol = Tile.computeColumn(deltaLon, sector.minLongitude),
	                lastCol = Tile.computeColumn(deltaLon, sector.maxLongitude),

	                firstRowLat = -90 + firstRow * deltaLat,
	                firstRowLon = -180 + firstCol * deltaLon,

	                minLat = firstRowLat,
	                minLon,
	                maxLat,
	                maxLon;

	            for (var row = firstRow; row <= lastRow; row += 1) {
	                maxLat = minLat + deltaLat;
	                minLon = firstRowLon;

	                for (var col = firstCol; col <= lastCol; col += 1) {
	                    maxLon = minLon + deltaLon;
	                    var tileSector = new Sector(minLat, maxLat, minLon, maxLon),
	                        tile = tileFactory.createTile(tileSector, level, row, col);
	                    result.push(tile);

	                    minLon = maxLon;
	                }

	                minLat = maxLat;
	            }
	        };

	        return Tile;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports BoundingBox
	 * @version $Id: BoundingBox.js 3345 2015-07-28 20:28:35Z dcollins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(30),
	        __webpack_require__(80),
	        __webpack_require__(62),
	        __webpack_require__(32),
	        __webpack_require__(63),
	        __webpack_require__(79),
	        __webpack_require__(33),
	        __webpack_require__(75),
	        __webpack_require__(35),
	        __webpack_require__(36),
	        __webpack_require__(83)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
	              BasicProgram,
	              Frustum,
	              Logger,
	              Matrix,
	              NotYetImplementedError,
	              Plane,
	              Sector,
	              Vec3,
	              WWMath,
	              WWUtil) {
	        "use strict";

	        /**
	         * Constructs a unit bounding box.
	         * The unit box has its R, S and T axes aligned with the X, Y and Z axes, respectively, and has its length,
	         * width and height set to 1.
	         * @alias BoundingBox
	         * @constructor
	         * @classdesc Represents a bounding box in Cartesian coordinates. Typically used as a bounding volume.
	         */
	        var BoundingBox = function () {

	            /**
	             * The box's center point.
	             * @type {Vec3}
	             * @default (0, 0, 0)
	             */
	            this.center = new Vec3(0, 0, 0);

	            /**
	             * The center point of the box's bottom. (The origin of the R axis.)
	             * @type {Vec3}
	             * @default (-0.5, 0, 0)
	             */
	            this.bottomCenter = new Vec3(-0.5, 0, 0);

	            /**
	             * The center point of the box's top. (The end of the R axis.)
	             * @type {Vec3}
	             * @default (0.5, 0, 0)
	             */
	            this.topCenter = new Vec3(0.5, 0, 0);

	            /**
	             * The box's R axis, its longest axis.
	             * @type {Vec3}
	             * @default (1, 0, 0)
	             */
	            this.r = new Vec3(1, 0, 0);

	            /**
	             * The box's S axis, its mid-length axis.
	             * @type {Vec3}
	             * @default (0, 1, 0)
	             */
	            this.s = new Vec3(0, 1, 0);

	            /**
	             * The box's T axis, its shortest axis.
	             * @type {Vec3}
	             * @default (0, 0, 1)
	             */
	            this.t = new Vec3(0, 0, 1);

	            /**
	             * The box's radius. (The half-length of its diagonal.)
	             * @type {number}
	             * @default sqrt(3)
	             */
	            this.radius = Math.sqrt(3);

	            // Internal use only. Intentionally not documented.
	            this.tmp1 = new Vec3(0, 0, 0);
	            this.tmp2 = new Vec3(0, 0, 0);
	            this.tmp3 = new Vec3(0, 0, 0);

	            // Internal use only. Intentionally not documented.
	            this.scratchElevations = new Float64Array(9);
	            this.scratchPoints = new Float64Array(3 * this.scratchElevations.length);
	        };

	        // Internal use only. Intentionally not documented.
	        BoundingBox.scratchMatrix = Matrix.fromIdentity();

	        /**
	         * Sets this bounding box such that it minimally encloses a specified collection of points.
	         * @param {Float32Array} points The points to contain.
	         * @returns {BoundingBox} This bounding box set to contain the specified points.
	         * @throws {ArgumentError} If the specified list of points is null, undefined or empty.
	         */
	        BoundingBox.prototype.setToPoints = function (points) {
	            if (!points || points.length < 3) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "BoundingBox", "setToPoints", "missingArray"));
	            }

	            var rMin = +Number.MAX_VALUE,
	                rMax = -Number.MAX_VALUE,
	                sMin = +Number.MAX_VALUE,
	                sMax = -Number.MAX_VALUE,
	                tMin = +Number.MAX_VALUE,
	                tMax = -Number.MAX_VALUE,
	                r = this.r, s = this.s, t = this.t,
	                p = new Vec3(0, 0, 0),
	                pdr, pds, pdt, rLen, sLen, tLen, rSum, sSum, tSum,
	                rx_2, ry_2, rz_2, cx, cy, cz;

	            Matrix.principalAxesFromPoints(points, r, s, t);

	            for (var i = 0, len = points.length / 3; i < len; i++) {
	                p[0] = points[i * 3];
	                p[1] = points[i * 3 + 1];
	                p[2] = points[i * 3 + 2];

	                pdr = p.dot(r);
	                if (rMin > pdr)
	                    rMin = pdr;
	                if (rMax < pdr)
	                    rMax = pdr;

	                pds = p.dot(s);
	                if (sMin > pds)
	                    sMin = pds;
	                if (sMax < pds)
	                    sMax = pds;

	                pdt = p.dot(t);
	                if (tMin > pdt)
	                    tMin = pdt;
	                if (tMax < pdt)
	                    tMax = pdt;
	            }

	            if (rMax === rMin)
	                rMax = rMin + 1;
	            if (sMax === sMin)
	                sMax = sMin + 1;
	            if (tMax === tMin)
	                tMax = tMin + 1;

	            rLen = rMax - rMin;
	            sLen = sMax - sMin;
	            tLen = tMax - tMin;
	            rSum = rMax + rMin;
	            sSum = sMax + sMin;
	            tSum = tMax + tMin;

	            rx_2 = 0.5 * r[0] * rLen;
	            ry_2 = 0.5 * r[1] * rLen;
	            rz_2 = 0.5 * r[2] * rLen;

	            cx = 0.5 * (r[0] * rSum + s[0] * sSum + t[0] * tSum);
	            cy = 0.5 * (r[1] * rSum + s[1] * sSum + t[1] * tSum);
	            cz = 0.5 * (r[2] * rSum + s[2] * sSum + t[2] * tSum);

	            this.center[0] = cx;
	            this.center[1] = cy;
	            this.center[2] = cz;

	            this.topCenter[0] = cx + rx_2;
	            this.topCenter[1] = cy + ry_2;
	            this.topCenter[2] = cz + rz_2;

	            this.bottomCenter[0] = cx - rx_2;
	            this.bottomCenter[1] = cy - ry_2;
	            this.bottomCenter[2] = cz - rz_2;

	            r.multiply(rLen);
	            s.multiply(sLen);
	            t.multiply(tLen);

	            this.radius = 0.5 * Math.sqrt(rLen * rLen + sLen * sLen + tLen * tLen);

	            return this;
	        };

	        /**
	         * Sets this bounding box such that it contains a specified sector on a specified globe with min and max elevation.
	         * <p>
	         * To create a bounding box that contains the sector at mean sea level, specify zero for the minimum and maximum
	         * elevations.
	         * To create a bounding box that contains the terrain surface in this sector, specify the actual minimum and maximum
	         * elevation values associated with the sector, multiplied by the model's vertical exaggeration.
	         * @param {Sector} sector The sector for which to create the bounding box.
	         * @param {Globe} globe The globe associated with the sector.
	         * @param {Number} minElevation The minimum elevation within the sector.
	         * @param {Number} maxElevation The maximum elevation within the sector.
	         * @returns {BoundingBox} This bounding box set to contain the specified sector.
	         * @throws {ArgumentError} If either the specified sector or globe is null or undefined.
	         */
	        BoundingBox.prototype.setToSector = function (sector, globe, minElevation, maxElevation) {
	            if (!sector) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "BoundingBox", "setToSector", "missingSector"));
	            }

	            if (!globe) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "BoundingBox", "setToSector", "missingGlobe"));
	            }

	            // Compute the cartesian points for a 3x3 geographic grid. This grid captures enough detail to bound the
	            // sector. Use minimum elevation at the corners and max elevation everywhere else.
	            var elevations = this.scratchElevations,
	                points = this.scratchPoints;

	            WWUtil.fillArray(elevations, maxElevation);
	            elevations[0] = elevations[2] = elevations[6] = elevations[8] = minElevation;
	            globe.computePointsForGrid(sector, 3, 3, elevations, Vec3.ZERO, points);

	            // Compute the local coordinate axes. Since we know this box is bounding a geographic sector, we use the
	            // local coordinate axes at its centroid as the box axes. Using these axes results in a box that has +-10%
	            // the volume of a box with axes derived from a principal component analysis, but is faster to compute.
	            var index = 12; // index to the center point's X coordinate
	            this.tmp1.set(points[index], points[index + 1], points[index + 2]);
	            WWMath.localCoordinateAxesAtPoint(this.tmp1, globe, this.r, this.s, this.t);

	            // Find the extremes along each axis.
	            var rExtremes = [Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY],
	                sExtremes = [Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY],
	                tExtremes = [Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY];

	            for (var i = 0, len = points.length; i < len; i += 3) {
	                this.tmp1.set(points[i], points[i + 1], points[i + 2]);
	                this.adjustExtremes(this.r, rExtremes, this.s, sExtremes, this.t, tExtremes, this.tmp1);
	            }

	            // Sort the axes from most prominent to least prominent. The frustum intersection methods in WWBoundingBox assume
	            // that the axes are defined in this way.
	            if (rExtremes[1] - rExtremes[0] < sExtremes[1] - sExtremes[0]) {
	                this.swapAxes(this.r, rExtremes, this.s, sExtremes);
	            }
	            if (sExtremes[1] - sExtremes[0] < tExtremes[1] - tExtremes[0]) {
	                this.swapAxes(this.s, sExtremes, this.t, tExtremes);
	            }
	            if (rExtremes[1] - rExtremes[0] < sExtremes[1] - sExtremes[0]) {
	                this.swapAxes(this.r, rExtremes, this.s, sExtremes);
	            }

	            // Compute the box properties from its unit axes and the extremes along each axis.
	            var rLen = rExtremes[1] - rExtremes[0],
	                sLen = sExtremes[1] - sExtremes[0],
	                tLen = tExtremes[1] - tExtremes[0],
	                rSum = rExtremes[1] + rExtremes[0],
	                sSum = sExtremes[1] + sExtremes[0],
	                tSum = tExtremes[1] + tExtremes[0],

	                cx = 0.5 * (this.r[0] * rSum + this.s[0] * sSum + this.t[0] * tSum),
	                cy = 0.5 * (this.r[1] * rSum + this.s[1] * sSum + this.t[1] * tSum),
	                cz = 0.5 * (this.r[2] * rSum + this.s[2] * sSum + this.t[2] * tSum),
	                rx_2 = 0.5 * this.r[0] * rLen,
	                ry_2 = 0.5 * this.r[1] * rLen,
	                rz_2 = 0.5 * this.r[2] * rLen;

	            this.center.set(cx, cy, cz);
	            this.topCenter.set(cx + rx_2, cy + ry_2, cz + rz_2);
	            this.bottomCenter.set(cx - rx_2, cy - ry_2, cz - rz_2);

	            this.r.multiply(rLen);
	            this.s.multiply(sLen);
	            this.t.multiply(tLen);

	            this.radius = 0.5 * Math.sqrt(rLen * rLen + sLen * sLen + tLen * tLen);

	            return this;
	        };

	        /**
	         * Translates this bounding box by a specified translation vector.
	         * @param {Vec3} translation The translation vector.
	         * @returns {BoundingBox} This bounding box translated by the specified translation vector.
	         * @throws {ArgumentError} If the specified translation vector is null or undefined.
	         */
	        BoundingBox.prototype.translate = function (translation) {
	            if (!translation) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "BoundingBox", "translate", "missingVector"));
	            }

	            this.bottomCenter.add(translation);
	            this.topCenter.add(translation);
	            this.center.add(translation);

	            return this;
	        };

	        /**
	         * Computes the approximate distance between this bounding box and a specified point.
	         * <p>
	         * This calculation treats the bounding box as a sphere with the same radius as the box.
	         * @param {Vec3} point The point to compute the distance to.
	         * @returns {Number} The distance from the edge of this bounding box to the specified point.
	         * @throws {ArgumentError} If the specified point is null or undefined.
	         */
	        BoundingBox.prototype.distanceTo = function (point) {
	            if (!point) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "BoundingBox", "distanceTo", "missingPoint"));
	            }

	            var d = this.center.distanceTo(point) - this.radius;

	            return d >= 0 ? d : -d;
	        };

	        /**
	         * Computes the effective radius of this bounding box relative to a specified plane.
	         * @param {Plane} plane The plane of interest.
	         * @returns {Number} The effective radius of this bounding box to the specified plane.
	         * @throws {ArgumentError} If the specified plane is null or undefined.
	         */
	        BoundingBox.prototype.effectiveRadius = function (plane) {
	            if (!plane) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "BoundingBox", "effectiveRadius", "missingPlane"));
	            }

	            var n = plane.normal;

	            return 0.5 * (WWMath.fabs(this.r.dot(n)) + WWMath.fabs(this.s.dot(n)) + WWMath.fabs(this.t.dot(n)));
	        };

	        /**
	         * Indicates whether this bounding box intersects a specified frustum.
	         * @param {Frustum} frustum The frustum of interest.
	         * @returns {boolean} true if the specified frustum intersects this bounding box, otherwise false.
	         * @throws {ArgumentError} If the specified frustum is null or undefined.
	         */
	        BoundingBox.prototype.intersectsFrustum = function (frustum) {
	            if (!frustum) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "BoundingBox", "intersectsFrustum", "missingFrustum"));
	            }

	            this.tmp1.copy(this.bottomCenter);
	            this.tmp2.copy(this.topCenter);

	            if (this.intersectionPoint(frustum.near) < 0) {
	                return false;
	            }
	            if (this.intersectionPoint(frustum.far) < 0) {
	                return false;
	            }
	            if (this.intersectionPoint(frustum.left) < 0) {
	                return false;
	            }
	            if (this.intersectionPoint(frustum.right) < 0) {
	                return false;
	            }
	            if (this.intersectionPoint(frustum.top) < 0) {
	                return false;
	            }
	            if (this.intersectionPoint(frustum.bottom) < 0) {
	                return false;
	            }

	            return true;
	        };

	        // Internal. Intentionally not documented.
	        BoundingBox.prototype.intersectionPoint = function (plane) {
	            var n = plane.normal,
	                effectiveRadius = 0.5 * (Math.abs(this.s.dot(n)) + Math.abs(this.t.dot(n)));

	            return this.intersectsAt(plane, effectiveRadius, this.tmp1, this.tmp2);
	        };

	        // Internal. Intentionally not documented.
	        BoundingBox.prototype.intersectsAt = function (plane, effRadius, endPoint1, endPoint2) {
	            // Test the distance from the first end-point.
	            var dq1 = plane.dot(endPoint1);
	            var bq1 = dq1 <= -effRadius;

	            // Test the distance from the second end-point.
	            var dq2 = plane.dot(endPoint2);
	            var bq2 = dq2 <= -effRadius;

	            if (bq1 && bq2) { // endpoints more distant from plane than effective radius; box is on neg. side of plane
	                return -1;
	            }

	            if (bq1 == bq2) { // endpoints less distant from plane than effective radius; can't draw any conclusions
	                return 0;
	            }

	            // Compute and return the endpoints of the box on the positive side of the plane
	            this.tmp3.copy(endPoint1);
	            this.tmp3.subtract(endPoint2);
	            var t = (effRadius + dq1) / plane.normal.dot(this.tmp3);

	            this.tmp3.copy(endPoint2);
	            this.tmp3.subtract(endPoint1);
	            this.tmp3.multiply(t);
	            this.tmp3.add(endPoint1);

	            // Truncate the line to only that in the positive halfspace, e.g., inside the frustum.
	            if (bq1) {
	                endPoint1.copy(this.tmp3);
	            }
	            else {
	                endPoint2.copy(this.tmp3);
	            }

	            return t;
	        };

	        // Internal. Intentionally not documented.
	        BoundingBox.prototype.adjustExtremes = function (r, rExtremes, s, sExtremes, t, tExtremes, p) {
	            var pdr = p.dot(r);
	            if (rExtremes[0] > pdr) {
	                rExtremes[0] = pdr;
	            }
	            if (rExtremes[1] < pdr) {
	                rExtremes[1] = pdr;
	            }

	            var pds = p.dot(s);
	            if (sExtremes[0] > pds) {
	                sExtremes[0] = pds;
	            }
	            if (sExtremes[1] < pds) {
	                sExtremes[1] = pds;
	            }

	            var pdt = p.dot(t);
	            if (tExtremes[0] > pdt) {
	                tExtremes[0] = pdt;
	            }
	            if (tExtremes[1] < pdt) {
	                tExtremes[1] = pdt;
	            }
	        };

	        // Internal. Intentionally not documented.
	        BoundingBox.prototype.swapAxes = function (a, aExtremes, b, bExtremes) {
	            a.swap(b);

	            var tmp = aExtremes[0];
	            aExtremes[0] = bExtremes[0];
	            bExtremes[0] = tmp;

	            tmp = aExtremes[1];
	            aExtremes[1] = bExtremes[1];
	            bExtremes[1] = tmp;
	        };

	        /**
	         * Renders this bounding box in a semi-transparent color with a highlighted outline. This function is intended
	         * for diagnostic use only.
	         * @param dc {DrawContext} dc The current draw context.
	         */
	        BoundingBox.prototype.render = function (dc) {
	            var gl = dc.currentGlContext,
	                matrix = BoundingBox.scratchMatrix,
	                program = dc.findAndBindProgram(BasicProgram);

	            try {
	                // Setup to transform unit cube coordinates to this bounding box's local coordinates, as viewed by the
	                // current navigator state.
	                matrix.copy(dc.navigatorState.modelviewProjection);
	                matrix.multiply(
	                    this.r[0], this.s[0], this.t[0], this.center[0],
	                    this.r[1], this.s[1], this.t[1], this.center[1],
	                    this.r[2], this.s[2], this.t[2], this.center[2],
	                    0, 0, 0, 1);
	                matrix.multiplyByTranslation(-0.5, -0.5, -0.5);
	                program.loadModelviewProjection(gl, matrix);

	                // Setup to draw the geometry when the eye point is inside or outside the box.
	                gl.disable(gl.CULL_FACE);

	                // Bind the shared unit cube vertex buffer and element buffer.
	                gl.bindBuffer(gl.ARRAY_BUFFER, dc.unitCubeBuffer());
	                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, dc.unitCubeElements());
	                gl.enableVertexAttribArray(program.vertexPointLocation);
	                gl.vertexAttribPointer(program.vertexPointLocation, 3, gl.FLOAT, false, 0, 0);

	                // Draw bounding box fragments that are below the terrain.
	                program.loadColorComponents(gl, 0, 1, 0, 0.6);
	                gl.drawElements(gl.LINES, 24, gl.UNSIGNED_SHORT, 72);
	                program.loadColorComponents(gl, 1, 1, 1, 0.3);
	                gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

	            } finally {
	                // Restore World Wind's default WebGL state.
	                gl.enable(gl.CULL_FACE);
	                gl.bindBuffer(gl.ARRAY_BUFFER, null);
	                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
	            }
	        };

	        return BoundingBox;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports NotYetImplementedError
	 * @version $Id: NotYetImplementedError.js 2631 2015-01-02 21:32:32Z tgaskins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(31)], __WEBPACK_AMD_DEFINE_RESULT__ = function (AbstractError) {
	        "use strict";

	        /**
	         * Constructs a not-yet-implemented error with a specified message.
	         * @alias NotYetImplementedError
	         * @constructor
	         * @classdesc Represents an error associated with an operation that is not yet implemented.
	         * @augments AbstractError
	         * @param {String} message The message.
	         */
	        var NotYetImplementedError = function (message) {
	            AbstractError.call(this, "NotYetImplementedError", message);

	            var stack;
	            try {
	                //noinspection ExceptionCaughtLocallyJS
	                throw new Error();
	            } catch (e) {
	                stack = e.stack;
	            }
	            this.stack = stack;
	        };

	        NotYetImplementedError.prototype = Object.create(AbstractError.prototype);

	        return NotYetImplementedError;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports BasicProgram
	 * @version $Id: BasicProgram.js 3327 2015-07-21 19:03:39Z dcollins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(30),
	        __webpack_require__(52),
	        __webpack_require__(81),
	        __webpack_require__(32)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
	              Color,
	              GpuProgram,
	              Logger) {
	        "use strict";

	        /**
	         * Constructs a new program.
	         * Initializes, compiles and links this GLSL program with the source code for its vertex and fragment shaders.
	         * <p>
	         * This method creates WebGL shaders for the program's shader sources and attaches them to a new GLSL program. This
	         * method then compiles the shaders and then links the program if compilation is successful. Use the bind method to make the
	         * program current during rendering.
	         *
	         * @alias BasicProgram
	         * @constructor
	         * @augments GpuProgram
	         * @classdesc BasicProgram is a GLSL program that draws geometry in a solid color.
	         * @param {WebGLRenderingContext} gl The current WebGL context.
	         * @throws {ArgumentError} If the shaders cannot be compiled, or linking of
	         * the compiled shaders into a program fails.
	         */
	        var BasicProgram = function (gl) {
	            var vertexShaderSource =
	                    'attribute vec4 vertexPoint;\n' +
	                    'uniform mat4 mvpMatrix;\n' +
	                    'void main() {gl_Position = mvpMatrix * vertexPoint;}',
	                fragmentShaderSource =
	                    'precision mediump float;\n' +
	                    'uniform vec4 color;\n' +
	                    'void main() {gl_FragColor = color;}';

	            // Call to the superclass, which performs shader program compiling and linking.
	            GpuProgram.call(this, gl, vertexShaderSource, fragmentShaderSource);

	            /**
	             * The WebGL location for this program's 'vertexPoint' attribute.
	             * @type {Number}
	             * @readonly
	             */
	            this.vertexPointLocation = this.attributeLocation(gl, "vertexPoint");

	            /**
	             * The WebGL location for this program's 'mvpMatrix' uniform.
	             * @type {WebGLUniformLocation}
	             * @readonly
	             */
	            this.mvpMatrixLocation = this.uniformLocation(gl, "mvpMatrix");

	            /**
	             * The WebGL location for this program's 'color' uniform.
	             * @type {WebGLUniformLocation}
	             * @readonly
	             */
	            this.colorLocation = this.uniformLocation(gl, "color");
	        };

	        /**
	         * A string that uniquely identifies this program.
	         * @type {string}
	         * @readonly
	         */
	        BasicProgram.key = "WorldWindGpuBasicProgram";

	        // Inherit from GpuProgram.
	        BasicProgram.prototype = Object.create(GpuProgram.prototype);

	        /**
	         * Loads the specified matrix as the value of this program's 'mvpMatrix' uniform variable.
	         *
	         * @param {WebGLRenderingContext} gl The current WebGL context.
	         * @param {Matrix} matrix The matrix to load.
	         * @throws {ArgumentError} If the specified matrix is null or undefined.
	         */
	        BasicProgram.prototype.loadModelviewProjection = function (gl, matrix) {
	            if (!matrix) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "BasicProgram", "loadModelviewProjection", "missingMatrix"));
	            }

	            this.loadUniformMatrix(gl, matrix, this.mvpMatrixLocation);
	        };

	        /**
	         * Loads the specified color as the value of this program's 'color' uniform variable.
	         *
	         * @param {WebGLRenderingContext} gl The current WebGL context.
	         * @param {Color} color The color to load.
	         * @throws {ArgumentError} If the specified color is null or undefined.
	         */
	        BasicProgram.prototype.loadColor = function (gl, color) {
	            if (!color) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "BasicProgram", "loadColor", "missingColor"));
	            }

	            this.loadUniformColor(gl, color, this.colorLocation);
	        };

	        /**
	         * Loads the specified RGBA color components as the value of this program's 'color' uniform variable.
	         *
	         * @param {WebGLRenderingContext} gl The current WebGL context.
	         * @param {Number} red The red component, a number between 0 and 1.
	         * @param {Number} green The green component, a number between 0 and 1.
	         * @param {Number} blue The blue component, a number between 0 and 1.
	         * @param {Number} alpha The alpha component, a number between 0 and 1.
	         */
	        BasicProgram.prototype.loadColorComponents = function (gl, red, green, blue, alpha) {
	            this.loadUniformColorComponents(gl, red, green, blue, alpha, this.colorLocation);
	        };

	        return BasicProgram;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports GpuProgram
	 * @version $Id: GpuProgram.js 3345 2015-07-28 20:28:35Z dcollins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(30),
	        __webpack_require__(52),
	        __webpack_require__(82),
	        __webpack_require__(32)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
	              Color,
	              GpuShader,
	              Logger) {
	        "use strict";

	        /**
	         * Constructs a GPU program with specified source code for vertex and fragment shaders.
	         * This constructor is intended to be called only by subclasses.
	         * <p>
	         * This constructor creates WebGL shaders for the specified shader sources and attaches them to a new GLSL
	         * program. The method compiles the shaders and then links the program if compilation is successful. Use the
	         * [DrawContext.bindProgram]{@link DrawContext#bindProgram} function to make the program current during rendering.
	         *
	         * @alias GpuProgram
	         * @constructor
	         * @classdesc
	         * Represents an OpenGL shading language (GLSL) shader program and provides methods for identifying and
	         * accessing shader variables. Shader programs are created by instances of this class and made current when the
	         * DrawContext.bindProgram function is invoked.
	         * <p>
	         * This is an abstract class and not intended to be created directly.
	         *
	         * @param {WebGLRenderingContext} gl The current WebGL context.
	         * @param {String} vertexShaderSource The source code for the vertex shader.
	         * @param {String} fragmentShaderSource The source code for the fragment shader.
	         * @param {String[]} attributeBindings An array of attribute variable names whose bindings are to be explicitly
	         * specified. Each name is bound to its corresponding index in the array. May be null, in which case the
	         * linker determines all the bindings.
	         * @throws {ArgumentError} If either source is null or undefined, the shaders cannot be compiled, or linking of
	         * the compiled shaders into a program fails.
	         */
	        var GpuProgram = function (gl, vertexShaderSource, fragmentShaderSource, attributeBindings) {
	            if (!vertexShaderSource || !fragmentShaderSource) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "GpuProgram", "constructor",
	                    "The specified shader source is null or undefined."));
	            }

	            var program, vShader, fShader;

	            try {
	                vShader = new GpuShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
	                fShader = new GpuShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
	            } catch (e) {
	                if (vShader)
	                    vShader.dispose(gl);
	                if (fShader)
	                    fShader.dispose(gl);

	                throw e;
	            }

	            program = gl.createProgram();
	            if (!program) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "GpuProgram", "constructor",
	                    "Unable to create shader program."));
	            }

	            gl.attachShader(program, vShader.shaderId);
	            gl.attachShader(program, fShader.shaderId);

	            if (attributeBindings) {
	                for (var i = 0, len = attributeBindings.length; i < len; i++) {
	                    gl.bindAttribLocation(program, i, attributeBindings[i]);
	                }
	            }

	            if (!this.link(gl, program)) {
	                // Get the info log before deleting the program.
	                var infoLog = gl.getProgramInfoLog(program);

	                gl.detachShader(program, vShader.shaderId);
	                gl.detachShader(program, fShader.shaderId);
	                gl.deleteProgram(program);
	                vShader.dispose(gl);
	                fShader.dispose(gl);

	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "GpuProgram", "constructor",
	                    "Unable to link shader program: " + infoLog));
	            }

	            /**
	             * Indicates the WebGL program object associated with this GPU program.
	             * @type {WebGLProgram}
	             * @readonly
	             */
	            this.programId = program;

	            // Internal. Intentionally not documented. These will be filled in as attribute locations are requested.
	            this.attributeLocations = {};
	            this.uniformLocations = {};

	            // Internal. Intentionally not documented.
	            this.vertexShader = vShader;

	            // Internal. Intentionally not documented.
	            this.fragmentShader = fShader;

	            // Internal. Intentionally not documented.
	            this.size = vertexShaderSource.length + fragmentShaderSource.length;

	            // Internal. Intentionally not documented.
	            this.scratchArray = new Float32Array(16);
	        };

	        /**
	         * Releases this GPU program's WebGL program and associated shaders. Upon return this GPU program's WebGL
	         * program ID is 0 as is that of the associated shaders.
	         *
	         * @param {WebGLRenderingContext} gl The current WebGL context.
	         */
	        GpuProgram.prototype.dispose = function (gl) {
	            if (this.programId) {
	                if (this.vertexShader) {
	                    gl.detachShader(this.programId, this.vertexShader.shaderId);
	                }
	                if (this.fragmentShader) {
	                    gl.detachShader(this.programId, this.fragmentShader.shaderId);
	                }

	                gl.deleteProgram(this.programId);
	                delete this.programId;
	            }

	            if (this.vertexShader) {
	                this.vertexShader.dispose(gl);
	                delete this.vertexShader;
	            }

	            if (this.fragmentShader) {
	                this.fragmentShader.dispose(gl);
	                delete this.fragmentShader;
	            }

	            this.attributeLocations = {};
	            this.uniformLocations = {};
	        };

	        /**
	         * Returns the GLSL attribute location of a specified attribute name.
	         *
	         * @param {WebGLRenderingContext} gl The current WebGL context.
	         * @param {String} attributeName The name of the attribute whose location is determined.
	         * @returns {Number} The WebGL attribute location of the specified attribute, or -1 if the attribute is not
	         * found.
	         * @throws {ArgumentError} If the specified attribute name is null, empty or undefined.
	         */
	        GpuProgram.prototype.attributeLocation = function (gl, attributeName) {
	            if (!attributeName || attributeName.length == 0) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "GpuProgram", "attributeLocation",
	                    "The specified attribute name is null, undefined or empty."));
	            }

	            var location = this.attributeLocations[attributeName];
	            if (!location) {
	                location = gl.getAttribLocation(this.programId, attributeName);
	                this.attributeLocations[attributeName] = location;
	            }

	            return location;
	        };

	        /**
	         * Returns the GLSL uniform location of a specified uniform name.
	         *
	         * @param {WebGLRenderingContext} gl The current WebGL context.
	         * @param {String} uniformName The name of the uniform variable whose location is determined.
	         * @returns {WebGLUniformLocation} The WebGL uniform location of the specified uniform variable,
	         * or -1 if the uniform is not found.
	         * @throws {ArgumentError} If the specified uniform name is null, empty or undefined.
	         */
	        GpuProgram.prototype.uniformLocation = function (gl, uniformName) {
	            if (!uniformName || uniformName.length == 0) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "GpuProgram", "uniformLocation",
	                    "The specified uniform name is null, undefined or empty."));
	            }

	            var location = this.uniformLocations[uniformName];
	            if (!location) {
	                location = gl.getUniformLocation(this.programId, uniformName);
	                this.uniformLocations[uniformName] = location;
	            }

	            return location;
	        };

	        /**
	         * Links a specified GLSL program. This method is not meant to be called by applications. It is called
	         * internally as needed.
	         *
	         * @param {WebGLRenderingContext} gl The current WebGL context.
	         * @param {WebGLProgram} program The WebGL program.
	         * @returns {Boolean} true if linking was successful, otherwise false.
	         * @protected
	         */
	        GpuProgram.prototype.link = function (gl, program) {
	            gl.linkProgram(program);

	            return gl.getProgramParameter(program, gl.LINK_STATUS);
	        };

	        /**
	         * Loads a specified matrix as the value of a GLSL 4x4 matrix uniform variable with the specified location.
	         * <p>
	         * This functions converts the matrix into column-major order prior to loading its components into the GLSL
	         * uniform variable, but does not modify the specified matrix.
	         *
	         * @param {WebGLRenderingContext} gl The current WebGL context.
	         * @param {Matrix} matrix The matrix to load.
	         * @param {WebGLUniformLocation} location The location of the uniform variable in the currently bound GLSL program.
	         * @throws {ArgumentError} If the specified matrix is null or undefined.
	         */
	        GpuProgram.prototype.loadUniformMatrix = function (gl, matrix, location) {
	            if (!matrix) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "GpuProgram", "loadUniformMatrix",
	                    "missingMatrix"));
	            }

	            var columnMajorArray = matrix.columnMajorComponents(this.scratchArray);
	            gl.uniformMatrix4fv(location, false, columnMajorArray);
	        };

	        /**
	         * Loads a specified color as the value of a GLSL vec4 uniform variable with the specified location.
	         * <p>
	         * This function multiplies the red, green and blue components by the alpha component prior to loading the color
	         * in the GLSL uniform variable, but does not modify the specified color.
	         *
	         * @param {WebGLRenderingContext} gl The current WebGL context.
	         * @param {Color} color The color to load.
	         * @param {WebGLUniformLocation} location The location of the uniform variable in the currently bound GLSL program.
	         * @throws {ArgumentError} If the specified color is null or undefined.
	         */
	        GpuProgram.prototype.loadUniformColor = function (gl, color, location) {
	            if (!color) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "GpuProgram", "loadUniformColor",
	                    "missingColor"));
	            }

	            var premul = color.premultipliedComponents(this.scratchArray);
	            gl.uniform4f(location, premul[0], premul[1], premul[2], premul[3]);
	        };

	        /**
	         * Loads the specified RGBA color components as the value of a GLSL vec4 uniform variable with the specified
	         * location.
	         * <p>
	         * This function multiplies the red, green and blue components by the alpha component prior to loading the color
	         * in the GLSL uniform variable.
	         *
	         * @param {WebGLRenderingContext} gl The current WebGL context.
	         * @param {Number} red The red component, a number between 0 and 1.
	         * @param {Number} green The green component, a number between 0 and 1.
	         * @param {Number} blue The blue component, a number between 0 and 1.
	         * @param {Number} alpha The alpha component, a number between 0 and 1.
	         * @param {WebGLUniformLocation} location The location of the uniform variable in the currently bound GLSL program.
	         */
	        GpuProgram.prototype.loadUniformColorComponents = function (gl, red, green, blue, alpha, location) {
	            gl.uniform4f(location, red * alpha, green * alpha, blue * alpha, alpha);
	        };

	        return GpuProgram;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports GpuShader
	 * @version $Id: GpuShader.js 2906 2015-03-17 18:45:22Z tgaskins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(30),
	        __webpack_require__(32)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
	              Logger) {
	        "use strict";

	        /**
	         * Constructs a GPU shader of a specified type with specified GLSL source code.
	         *
	         * @alias GpuShader
	         * @constructor
	         * @classdesc
	         * Represents an OpenGL shading language (GLSL) shader and provides methods for compiling and disposing
	         * of them.
	         *
	         * @param {WebGLRenderingContext} gl The current WebGL context.
	         * @param {Number} shaderType The type of shader, either WebGLRenderingContext.VERTEX_SHADER
	         * or WebGLRenderingContext.FRAGMENT_SHADER.
	         * @param {String} shaderSource The shader's source code.
	         * @throws {ArgumentError} If the shader type is unrecognized, the shader source is null or undefined or shader
	         * compilation fails. If the compilation fails the error thrown contains any compilation messages.
	         */
	        var GpuShader = function (gl, shaderType, shaderSource) {
	            if (!(shaderType === gl.VERTEX_SHADER
	                || shaderType === gl.FRAGMENT_SHADER)) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "GpuShader", "constructor",
	                    "The specified shader type is unrecognized."));
	            }

	            if (!shaderSource) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "GpuShader", "constructor",
	                    "The specified shader source is null or undefined."));
	            }

	            var shader = gl.createShader(shaderType);
	            if (!shader) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "GpuShader", "constructor",
	                    "Unable to create shader of type " +
	                    (shaderType == gl.VERTEX_SHADER ? "VERTEX_SHADER." : "FRAGMENT_SHADER.")));
	            }

	            if (!this.compile(gl, shader, shaderType, shaderSource)) {
	                var infoLog = gl.getShaderInfoLog(shader);

	                gl.deleteShader(shader);

	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "GpuShader", "constructor",
	                    "Unable to compile shader: " + infoLog));
	            }

	            this.shaderId = shader;
	        };

	        /**
	         * Compiles the source code for this shader. This method is not meant to be invoked by applications. It is
	         * invoked internally as needed.
	         * @param {WebGLRenderingContext} gl The current WebGL rendering context.
	         * @param {WebGLShader} shaderId The shader ID.
	         * @param {Number} shaderType The type of shader, either WebGLRenderingContext.VERTEX_SHADER
	         * or WebGLRenderingContext.FRAGMENT_SHADER.
	         * @param {String} shaderSource The shader's source code.
	         * @returns {boolean} <code>true</code> if the shader compiled successfully, otherwise <code>false</code>.
	         */
	        GpuShader.prototype.compile = function (gl, shaderId, shaderType, shaderSource) {
	            gl.shaderSource(shaderId, shaderSource);
	            gl.compileShader(shaderId);

	            return gl.getShaderParameter(shaderId, gl.COMPILE_STATUS);
	        };

	        /**
	         * Releases this shader's WebGL shader.
	         * @param {WebGLRenderingContext} gl The current WebGL rendering context.
	         */
	        GpuShader.prototype.dispose = function (gl) {
	            if (this.shaderId) {
	                gl.deleteShader(this.shaderId);
	                delete this.shaderId;
	            }
	        };

	        return GpuShader;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @version $Id: WWUtil.js 3402 2015-08-14 17:28:09Z tgaskins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(30),
	        __webpack_require__(34),
	        __webpack_require__(32),
	        __webpack_require__(37),
	        __webpack_require__(35)], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
	              Line,
	              Logger,
	              Rectangle,
	              Vec3) {
	        "use strict";
	        /**
	         * Provides math constants and functions.
	         * @exports WWUtil
	         */
	        var WWUtil = {
	            // A regular expression that matches latitude followed by a comma and possible white space followed by
	            // longitude. Latitude and longitude ranges are not considered.
	            latLonRegex: /^(\-?\d+(\.\d+)?),\s*(\-?\d+(\.\d+)?)$/,

	            /**
	             * Returns the suffix for a specified mime type.
	             * @param {String} mimeType The mime type to determine a suffix for.
	             * @returns {String} The suffix for the specified mime type, or null if the mime type is not recognized.
	             */
	            suffixForMimeType: function (mimeType) {
	                if (mimeType === "image/png")
	                    return "png";

	                if (mimeType === "image/jpeg")
	                    return "jpg";

	                if (mimeType === "application/bil16")
	                    return "bil";

	                if (mimeType === "application/bil32")
	                    return "bil";

	                return null;
	            },

	            /**
	             * Returns the current location URL as obtained from window.location with the last path component
	             * removed.
	             * @returns {String} The current location URL with the last path component removed.
	             */
	            currentUrlSansFilePart: function () {
	                var protocol = window.location.protocol,
	                    host = window.location.host,
	                    path = window.location.pathname,
	                    pathParts = path.split("/"),
	                    newPath = "";

	                for (var i = 0, len = pathParts.length; i < len - 1; i++) {
	                    if (pathParts[i].length > 0) {
	                        newPath = newPath + "/" + pathParts[i];
	                    }
	                }

	                return protocol + "//" + host + newPath;
	            },

	            /**
	             * Returns the URL of the directory containing the World Wind library.
	             * @returns {String} The URL of the directory containing the World Wind library, or null if that directory
	             * cannot be determined.
	             */
	            worldwindlibLocation: function () {
	                var scripts = document.getElementsByTagName("script"),
	                    libraryName = "/worldwind.";

	                for (var i = 0; i < scripts.length; i++) {
	                    var index = scripts[i].src.indexOf(libraryName);
	                    if (index >= 0) {
	                        return scripts[i].src.substring(0, index) + "/";
	                    }
	                }

	                return null;
	            },

	            /**
	             * Returns the path component of a specified URL.
	             * @param {String} url The URL from which to determine the path component.
	             * @returns {String} The path component, or the empty string if the specified URL is null, undefined
	             * or empty.
	             */
	            urlPath: function (url) {
	                if (!url)
	                    return "";

	                var urlParts = url.split("/"),
	                    newPath = "";

	                for (var i = 0, len = urlParts.length; i < len; i++) {
	                    var part = urlParts[i];

	                    if (!part || part.length === 0
	                        || part.indexOf(":") != -1
	                        || part === "."
	                        || part === ".."
	                        || part === "null"
	                        || part === "undefined") {
	                        continue;
	                    }

	                    if (newPath.length !== 0) {
	                        newPath = newPath + "/";
	                    }

	                    newPath = newPath + part;
	                }

	                return newPath;
	            },

	            /**
	             * Sets each element of an array to a specified value. This function is intentionally generic, and works
	             * with any data structure with a length property whose elements may be referenced using array index syntax.
	             * @param array The array to fill.
	             * @param {*} value The value to assign to each array element.
	             */
	            fillArray: function (array, value) {
	                if (!array) {
	                    return;
	                }

	                for (var i = 0, len = array.length; i < len; i++) {
	                    array[i] = value;
	                }
	            },

	            /**
	             * Multiplies each element of an array by a specified value and assigns each element to the result. This
	             * function is intentionally generic, and works with any data structure with a length property whose
	             * elements may be referenced using array index syntax.
	             * @param array The array to fill.
	             * @param {*} value The value to multiply by each array element.
	             */
	            multiplyArray: function (array, value) {
	                if (!array) {
	                    return;
	                }

	                for (var i = 0, len = array.length; i < len; i++) {
	                    array[i] *= value;
	                }
	            },

	            // Used to form unique function names for JSONP callback functions.
	            jsonpCounter: 0,

	            /**
	             * Request a resource using JSONP.
	             * @param {String} url The url to receive the request.
	             * @param {String} parameterName The JSONP callback function key required by the server. Typically
	             * "jsonp" or "callback".
	             * @param {Function} callback The function to invoke when the request succeeds. The function receives
	             * one argument, the JSON payload of the JSONP request.
	             */
	            jsonp: function (url, parameterName, callback) {

	                // Generate a unique function name for the JSONP callback.
	                var functionName = "gov_nasa_worldwind_jsonp_" + WWUtil.jsonpCounter++;

	                // Define a JSONP callback function. Assign it to global scope the browser can find it.
	                window[functionName] = function (jsonData) {
	                    // Remove the JSONP callback from global scope.
	                    delete window[functionName];

	                    // Call the client's callback function.
	                    callback(jsonData);
	                };

	                // Append the callback query parameter to the URL.
	                var jsonpUrl = url + (url.indexOf('?') === -1 ? '?' : '&');
	                jsonpUrl += parameterName + "=" + functionName;

	                // Create a script element for the browser to invoke.
	                var script = document.createElement('script');
	                script.async = true;
	                script.src = jsonpUrl;

	                // Prepare to add the script to the document's head.
	                var head = document.getElementsByTagName('head')[0];

	                // Set up to remove the script element once it's invoked.
	                var cleanup = function () {
	                    script.onload = undefined;
	                    script.onerror = undefined;
	                    head.removeChild(script);
	                };

	                script.onload = cleanup;
	                script.onerror = cleanup;

	                // Add the script element to the document, causing the browser to invoke it.
	                head.appendChild(script);
	            },

	            arrayEquals: function (array1, array2) {
	                return (array1.length == array2.length) && array1.every(function (element, index) {
	                        return element === array2[index] || element.equals && element.equals(array2[index]);
	                    });
	            },

	            /**
	             * It transforms given item to the boolean. It respects that 0, "0" and "false" are percieved as false
	             * on top of the standard Boolean function.
	             * @param item {String} Item to transform
	             * @returns {boolean} Value transformed to the boolean.
	             */
	            transformToBoolean: function (item) {
	                if (item == 0 || item == "0" || item == "false") {
	                    return false;
	                } else {
	                    return Boolean(item);
	                }
	            },

	            /**
	             * It clones original object into the new one. It is necessary to retain the options information valid
	             * for all nodes.
	             * @param original Object to clone
	             * @returns {Object} Cloned object
	             */
	            clone: function (original) {
	                var clone = {};
	                var i, keys = Object.keys(original);

	                for (i = 0; i < keys.length; i++) {
	                    // copy each property into the clone
	                    clone[keys[i]] = original[keys[i]];
	                }

	                return clone;
	            },

	            /**
	             * It returns unique GUID.
	             * @returns {string} String representing unique identifier in the application.
	             */
	            guid: function () {
	                function s4() {
	                    return Math.floor((1 + Math.random()) * 0x10000)
	                        .toString(16)
	                        .substring(1);
	                }

	                return s4() + s4() + '-' + s4() + '-' + s4() + '-' +
	                    s4() + '-' + s4() + s4() + s4();
	            },

	            /**
	             * Transforms item to date. It accepts ISO-8601 format.
	             * @param item {String} To transform.
	             * @returns {Date} Date extracted from the current information.
	             */
	            date: function(item) {
	                return new Date(item);
	            }
	        };

	        return WWUtil;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports SurfaceTileRendererProgram
	 * @version $Id: SurfaceTileRendererProgram.js 3327 2015-07-21 19:03:39Z dcollins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(30),
	        __webpack_require__(52),
	        __webpack_require__(81),
	        __webpack_require__(32)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
	              Color,
	              GpuProgram,
	              Logger) {
	        "use strict";

	        /**
	         * Constructs a new surface-tile-renderer program.
	         * Initializes, compiles and links this GLSL program with the source code for its vertex and fragment shaders.
	         * <p>
	         * This method creates WebGL shaders for the program's shader sources and attaches them to a new GLSL program. This
	         * method then compiles the shaders and links the program if compilation is successful. Use the bind method to make the
	         * program current during rendering.
	         *
	         * @alias SurfaceTileRendererProgram
	         * @constructor
	         * @augments GpuProgram
	         * @classdesc A GLSL program that draws textured geometry on the globe's terrain.
	         * Application's typically do not interact with this class.
	         * @param {WebGLRenderingContext} gl The current WebGL context.
	         */
	        var SurfaceTileRendererProgram = function (gl) {
	            var vertexShaderSource =
	                    'attribute vec4 vertexPoint;\n' +
	                    'attribute vec4 vertexTexCoord;\n' +
	                    'uniform mat4 mvpMatrix;\n' +
	                    'uniform mat4 texSamplerMatrix;\n' +
	                    'uniform mat4 texMaskMatrix;\n' +
	                    'varying vec2 texSamplerCoord;\n' +
	                    'varying vec2 texMaskCoord;\n' +
	                    'void main() {\n' +
	                    'gl_Position = mvpMatrix * vertexPoint;\n' +
	                        /* Transform the vertex texture coordinate into sampler texture coordinates. */
	                    'texSamplerCoord = (texSamplerMatrix * vertexTexCoord).st;\n' +
	                        /* Transform the vertex texture coordinate into mask texture coordinates. */
	                    'texMaskCoord = (texMaskMatrix * vertexTexCoord).st;\n' +
	                    '}',
	                fragmentShaderSource =
	                    'precision mediump float;\n' +
	                        /* Uniform sampler indicating the texture 2D unit (0, 1, 2, etc.) to use when sampling texture color. */
	                    'uniform sampler2D texSampler;\n' +
	                    'uniform float opacity;\n' +
	                    'uniform vec4 color;\n' +
	                    'uniform bool modulateColor;\n' +
	                    'varying vec2 texSamplerCoord;\n' +
	                    'varying vec2 texMaskCoord;\n' +
	                        /*
	                         * Returns true when the texture coordinate samples texels outside the texture image.
	                         */
	                    'bool isInsideTextureImage(const vec2 coord) {\n' +
	                    '    return coord.x >= 0.0 && coord.x <= 1.0 && coord.y >= 0.0 && coord.y <= 1.0;\n' +
	                    '}\n' +
	                        /*
	                         * OpenGL ES Shading Language v1.00 fragment shader for SurfaceTileRendererProgram. Writes the value of the texture 2D
	                         * object bound to texSampler at the current transformed texture coordinate, multiplied by the uniform opacity. Writes
	                         * transparent black (0, 0, 0, 0) if the transformed texture coordinate indicates a texel outside of the texture data's
	                         * standard range of [0,1].
	                         */
	                    'void main(void) {\n' +
	                        'float mask = float(isInsideTextureImage(texMaskCoord));' +
	                    'if (modulateColor) {\n' +
	                    '    gl_FragColor = color * mask * floor(texture2D(texSampler, texSamplerCoord).a + 0.5);\n' +
	                    '} else {\n' +
	                        /* Return either the sampled texture2D color multiplied by opacity or transparent black. */
	                    '    gl_FragColor = texture2D(texSampler, texSamplerCoord) * mask * opacity;\n' +
	                    '}\n' +
	                    '}';

	            // Call to the superclass, which performs shader program compiling and linking.
	            GpuProgram.call(this, gl, vertexShaderSource, fragmentShaderSource);

	            // Capture the attribute and uniform locations.

	            /**
	             * This program's vertex point location.
	             * @type {Number}
	             * @readonly
	             */
	            this.vertexPointLocation = this.attributeLocation(gl, "vertexPoint");

	            /**
	             * This program's texture coordinate location.
	             * @type {Number}
	             * @readonly
	             */
	            this.vertexTexCoordLocation = this.attributeLocation(gl, "vertexTexCoord");

	            /**
	             * This program's modelview-projection matrix location.
	             * @type {WebGLUniformLocation}
	             * @readonly
	             */
	            this.mvpMatrixLocation = this.uniformLocation(gl, "mvpMatrix");

	            /**
	             * The WebGL location for this program's 'color' uniform.
	             * @type {WebGLUniformLocation}
	             * @readonly
	             */
	            this.colorLocation = this.uniformLocation(gl, "color");

	            /**
	             * The WebGL location for this program's 'modulateColor' uniform.
	             * @type {WebGLUniformLocation}
	             * @readonly
	             */
	            this.modulateColorLocation = this.uniformLocation(gl, "modulateColor");

	            // The rest of these are strictly internal and intentionally not documented.
	            this.texSamplerMatrixLocation = this.uniformLocation(gl, "texSamplerMatrix");
	            this.texMaskMatrixLocation = this.uniformLocation(gl, "texMaskMatrix");
	            this.texSamplerLocation = this.uniformLocation(gl, "texSampler");
	            this.opacityLocation = this.uniformLocation(gl, "opacity");

	            /**
	             * The WebGL location for this program's 'vertexTexCoord' attribute.
	             * @type {Number}
	             * @readonly
	             */
	            this.vertexPointLocation = -1;
	        };

	        /**
	         * A string that uniquely identifies this program.
	         * @type {string}
	         * @readonly
	         */
	        SurfaceTileRendererProgram.key = "WorldWindGpuSurfaceTileRenderingProgram";

	        SurfaceTileRendererProgram.prototype = Object.create(GpuProgram.prototype);

	        /**
	         * Loads the specified matrix as the value of this program's 'mvpMatrix' uniform variable.
	         *
	         * @param {WebGLRenderingContext} gl The current WebGL context.
	         * @param {Matrix} matrix The matrix to load.
	         * @throws {ArgumentError} If the specified matrix is null or undefined.
	         */
	        SurfaceTileRendererProgram.prototype.loadModelviewProjection = function (gl, matrix) {
	            if (!matrix) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "SurfaceTileRendererProgram", "loadModelviewProjection",
	                        "missingMatrix"));
	            }

	            this.loadUniformMatrix(gl, matrix, this.mvpMatrixLocation);
	        };

	        /**
	         * Loads the specified matrix as the value of this program's 'texSamplerMatrix' uniform variable.
	         *
	         * @param {WebGLRenderingContext} gl The current WebGL context.
	         * @param {Matrix} matrix The matrix to load.
	         * @throws {ArgumentError} If the specified matrix is null or undefined.
	         */
	        SurfaceTileRendererProgram.prototype.loadTexSamplerMatrix = function (gl, matrix) {
	            if (!matrix) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "SurfaceTileRendererProgram", "loadTexSamplerMatrix",
	                        "missingMatrix"));
	            }

	            this.loadUniformMatrix(gl, matrix, this.texSamplerMatrixLocation);
	        };

	        /**
	         * Loads the specified matrix as the value of this program's 'texMaskMatrix' uniform variable.
	         *
	         * @param {WebGLRenderingContext} gl The current WebGL context.
	         * @param {Matrix} matrix The matrix to load.
	         * @throws {ArgumentError} If the specified matrix is null or undefined.
	         */
	        SurfaceTileRendererProgram.prototype.loadTexMaskMatrix = function (gl, matrix) {
	            if (!matrix) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "SurfaceTileRendererProgram", "loadTexMaskMatrix",
	                        "missingMatrix"));
	            }

	            this.loadUniformMatrix(gl, matrix, this.texMaskMatrixLocation);
	        };

	        /**
	         * Loads the specified texture unit ID as the value of this program's 'texSampler' uniform variable.
	         * The specified unit ID must be one of the GL_TEXTUREi WebGL enumerations, where i ranges from 0 to
	         * GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1.
	         *
	         * @param {WebGLRenderingContext} gl The current WebGL context.
	         * @param {Number} unit The unit ID to load.
	         */
	        SurfaceTileRendererProgram.prototype.loadTexSampler = function (gl, unit) {
	            gl.uniform1i(this.texSamplerLocation, unit - WebGLRenderingContext.TEXTURE0);
	        };

	        /**
	         * Loads the specified value as the value of this program's 'opacity' uniform variable.
	         *
	         * @param {WebGLRenderingContext} gl The current WebGL context.
	         * @param {Number} opacity The opacity to load.
	         */
	        SurfaceTileRendererProgram.prototype.loadOpacity = function (gl, opacity) {
	            gl.uniform1f(this.opacityLocation, opacity);
	        };

	        /**
	         * Loads the specified color as the value of this program's 'color' uniform variable.
	         *
	         * @param {WebGLRenderingContext} gl The current WebGL context.
	         * @param {Color} color The color to load.
	         * @throws {ArgumentError} If the specified color is null or undefined.
	         */
	        SurfaceTileRendererProgram.prototype.loadColor = function (gl, color) {
	            if (!color) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "SurfaceTileRendererProgram", "loadColor", "missingColor"));
	            }

	            this.loadUniformColor(gl, color, this.colorLocation);
	        };

	        /**
	         * Loads the specified boolean as the value of this program's 'modulateColor' uniform variable. When this
	         * value is true the color uniform of this shader is
	         * multiplied by the rounded alpha component of the texture color at each fragment. This causes the color
	         * to be either fully opaque or fully transparent depending on the value of the texture color's alpha value.
	         * This is used during picking to replace opaque or mostly opaque texture colors with the pick color, and
	         * to make all other texture colors transparent.
	         * @param {WebGLRenderingContext} gl The current WebGL context.
	         * @param {Boolean} enable <code>true</code> to enable modulation, <code>false</code> to disable modulation.
	         */
	        SurfaceTileRendererProgram.prototype.loadModulateColor = function (gl, enable) {
	            gl.uniform1i(this.modulateColorLocation, enable ? 1 : 0);
	        };

	        return SurfaceTileRendererProgram;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

	var SurfaceImage =  __webpack_require__(86);
	var Sector =  __webpack_require__(75);
	var DistanceFieldProgram =  __webpack_require__(89);
	var Color = __webpack_require__(52);
	var ImageSource = __webpack_require__(51);
	var Events = __webpack_require__(5);
	var CharSDF = __webpack_require__(90).CharSDF;
	var ImageUtils = __webpack_require__(94);

	var fontsize = 30; // Font size in pixels
	var buffer = 4;    // Whitespace buffer around a glyph in pixels
	var radius = 4;    // How many pixels around the glyph shape to use for encoding distance
	var cutoff = 0.24;  // How much of the radius (relative) is used for the inside part the glyph


	var textBuffer = 0.71;
	var textSmoothing = 0.001;

	Events.listen(Events._DISTANCE_FIELD_SETTINGS, function(newSettings) {
	    textBuffer = newSettings.buffer || textBuffer;
	    textSmoothing = newSettings.smoothing || textSmoothing;
	});

	var SurfaceSymbol = function (position, char, size, color, desc) {

	    this.color = color ? Color.colorFromHex(color) : null;
	  //  this.outline = desc.outline ? Color.colorFromHex(desc.outline) : null;
	    this.opacity = desc.opacity || 1;

	    var charSDF = new CharSDF(fontsize, buffer, radius, cutoff,
	        desc.family || 'sans-serif',
	        desc.weight || 'normal'
	    );
	    var sdfAlpha = charSDF.draw(char);
	    var sdfImage = ImageUtils.makeRGBAImageData(sdfAlpha);
	    var imageSource = new ImageSource(sdfImage);
	    size = size / 2;

	    var cosLat = Math.cos(position.latitude);
	    var sector = new Sector(
	        position.latitude - size,
	        position.latitude + size,
	        position.longitude - size/cosLat,
	        position.longitude + size/cosLat
	    );

	    SurfaceImage.call(this, sector, imageSource);
	};

	SurfaceSymbol.prototype = Object.create(SurfaceImage.prototype);

	SurfaceSymbol.prototype.beginRendering = function (dc) {
	    var gl = dc.currentGlContext;
	    var program = dc.findAndBindProgram(DistanceFieldProgram);
	    program.loadTexSampler(gl, gl.TEXTURE0);
	    program.loadColor(gl, this.color || Color.TRANSPARENT);
	    // program.loadOutlineColor(gl, this.outline || Color.TRANSPARENT);
	    program.loadOpacity(gl, this.opacity);
	    // program.loadSmoothing(gl, textSmoothing);
	    // program.loadBuffer(gl, textBuffer);
	    program.loadRotation(gl, -dc.navigatorState.heading * Math.PI / 180);
	    program.loadTilt(gl, dc.navigatorState.tilt / 90);
	    // program.loadOutlineDistance(gl, this.outline ? 0.65 : -0.65);
	    program.loadScreenSize(gl, [window.engine.canvas.width, window.engine.canvas.height]);
	    program.loadVolume(gl, 0.05);
	    return program;
	};

	module.exports = SurfaceSymbol;


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports SurfaceImage
	 * @version $Id: SurfaceImage.js 3023 2015-04-15 20:24:17Z tgaskins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(30),
	        __webpack_require__(32),
	        __webpack_require__(87),
	        __webpack_require__(88)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
	              Logger,
	              PickedObject,
	              SurfaceTile) {
	        "use strict";

	        /**
	         * Constructs a surface image shape for a specified sector and image path.
	         * @alias SurfaceImage
	         * @constructor
	         * @augments SurfaceTile
	         * @classdesc Represents an image drawn on the terrain.
	         * @param {Sector} sector The sector spanned by this surface image.
	         * @param {String|ImageSource} imageSource The image source of the image to draw on the terrain.
	         * May be either a string identifying the URL of the image, or an {@link ImageSource} object identifying a
	         * dynamically created image.
	         * @throws {ArgumentError} If either the specified sector or image source is null or undefined.
	         */
	        var SurfaceImage = function (sector, imageSource) {
	            if (!sector) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "SurfaceImage", "constructor",
	                    "missingSector"));
	            }

	            if (!imageSource) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "SurfaceImage", "constructor",
	                    "missingImage"));
	            }

	            SurfaceTile.call(this, sector);

	            /**
	             * Indicates whether this surface image is drawn.
	             * @type {boolean}
	             * @default true
	             */
	            this.enabled = true;

	            /**
	             * The path to the image.
	             * @type {String}
	             */
	            this._imageSource = imageSource;

	            /**
	             * This surface image's opacity. When this surface image is drawn, the actual opacity is the product of
	             * this opacity and the opacity of the layer containing this surface image.
	             * @type {number}
	             */
	            this.opacity = 1;

	            /**
	             * This surface image's display name;
	             * @type {string}
	             */
	            this.displayName = "Surface Image";

	            // Internal. Indicates whether the image needs to be updated in the GPU resource cache.
	            this.imageSourceWasUpdated = true;
	        };

	        SurfaceImage.prototype = Object.create(SurfaceTile.prototype);

	        Object.defineProperties(SurfaceImage.prototype, {
	            /**
	             * The source of the image to display.
	             * May be either a string identifying the URL of the image, or an {@link ImageSource} object identifying a
	             * dynamically created image.
	             * @type {String|ImageSource}
	             * @default null
	             * @memberof SurfaceImage.prototype
	             */
	            imageSource: {
	                get: function () {
	                    return this._imageSource;
	                },
	                set: function (imageSource) {
	                    if (!imageSource) {
	                        throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "SurfaceImage", "imageSource",
	                            "missingImage"));
	                    }

	                    this._imageSource = imageSource;
	                    this.imageSourceWasUpdated = true;
	                }
	            }
	        });

	        SurfaceImage.prototype.bind = function (dc) {
	            var texture = dc.gpuResourceCache.resourceForKey(this._imageSource);
	            if (texture && !this.imageSourceWasUpdated) {
	                return texture.bind(dc);
	            } else {
	                texture = dc.gpuResourceCache.retrieveTexture(dc.currentGlContext, this._imageSource);
	                this.imageSourceWasUpdated = false;
	                if (texture) {
	                    return texture.bind(dc);
	                }
	            }
	        };

	        SurfaceImage.prototype.applyInternalTransform = function (dc, matrix) {
	            // No need to apply the transform.
	        };

	        /**
	         * Displays this surface image. Called by the layer containing this surface image.
	         * @param {DrawContext} dc The current draw context.
	         */
	        SurfaceImage.prototype.render = function (dc) {
	            if (!this.enabled || !this.sector.overlaps(dc.terrain.sector)) {
	                return;
	            }

	            if (dc.pickingMode) {
	                this.pickColor = dc.uniquePickColor();
	            }

	            dc.surfaceTileRenderer.renderTiles(dc, [this], this.opacity * dc.currentLayer.opacity);

	            if (dc.pickingMode) {
	                var po = new PickedObject(this.pickColor.clone(), this.pickDelegate ? this.pickDelegate : this,
	                    null, this.layer, false);
	                dc.resolvePick(po);
	            }

	            dc.currentLayer.inCurrentFrame = true;
	        };

	        return SurfaceImage;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports PickedObject
	 * @version $Id: PickedObject.js 2940 2015-03-30 17:58:36Z tgaskins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	        "use strict";

	        /**
	         * Constructs a picked object.
	         * @alias PickedObject
	         * @constructor
	         * @classdesc Represents a picked object.
	         * @param {Color} color The pick color identifying the object.
	         * @param {Object} userObject An object to associate with this picked object, usually the picked shape.
	         * @param {Position} position The picked object's geographic position. May be null if unknown.
	         * @param {Layer} parentLayer The layer containing the picked object.
	         * @param {Boolean} isTerrain true if the picked object is terrain, otherwise false.
	         */
	        var PickedObject = function (color, userObject, position, parentLayer, isTerrain) {

	            /**
	             * This picked object's pick color.
	             * @type {Color}
	             * @readonly
	             */
	            this.color = color;

	            /**
	             * The picked shape.
	             * @type {Object}
	             * @readonly
	             */
	            this.userObject = userObject;

	            /**
	             * This picked object's geographic position.
	             * @type {Position}
	             * @readonly
	             */
	            this.position = position;

	            /**
	             * The layer containing this picked object.
	             * @type {Layer}
	             * @readonly
	             */
	            this.parentLayer = parentLayer;

	            /**
	             * Indicates whether this picked object is terrain.
	             * @type {Boolean}
	             * @readonly
	             */
	            this.isTerrain = isTerrain;

	            /**
	             * Indicates whether this picked object is the top object.
	             * @type {boolean}
	             */
	            this.isOnTop = false;
	        };

	        return PickedObject;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports SurfaceTile
	 * @version $Id: SurfaceTile.js 2941 2015-03-30 21:11:43Z tgaskins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(30),
	        __webpack_require__(32),
	        __webpack_require__(63),
	        __webpack_require__(75),
	        __webpack_require__(66)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
	              Logger,
	              Matrix,
	              Sector,
	              UnsupportedOperationError) {
	        "use strict";

	        /**
	         * Constructs a surface tile for a specified sector.
	         * @alias SurfaceTile
	         * @constructor
	         * @classdesc Defines an abstract base class for imagery to be rendered on terrain. Applications typically
	         * do not interact with this class.
	         * @param {Sector} sector The sector of this surface tile.
	         * @throws {ArgumentError} If the specified sector is null or undefined.
	         */
	        var SurfaceTile = function (sector) {
	            if (!sector) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "SurfaceTile", "constructor",
	                    "missingSector"));
	            }

	            /**
	             * The sector spanned by this surface tile.
	             * @type {Sector}
	             */
	            this.sector = sector;
	        };

	        /**
	         * Causes this surface tile to be active, typically by binding the tile's texture in WebGL.
	         * Subclasses must override this function.
	         * @param {DrawContext} dc The current draw context.
	         * @returns {Boolean} true if the resource was successfully bound, otherwise false.
	         */
	        SurfaceTile.prototype.bind = function (dc) {
	            throw new UnsupportedOperationError(
	                Logger.logMessage(Logger.LEVEL_SEVERE, "SurfaceTile", "bind", "abstractInvocation"));
	        };

	        /**
	         * Applies this surface tile's internal transform, typically a texture transform to align the associated
	         * resource with the terrain.
	         * Subclasses must override this function.
	         * @param {DrawContext} dc The current draw context.
	         * @param {Matrix} matrix The transform to apply.
	         */
	        SurfaceTile.prototype.applyInternalTransform = function (dc, matrix) {
	            throw new UnsupportedOperationError(
	                Logger.logMessage(Logger.LEVEL_SEVERE, "SurfaceTile", "applyInternalTransform", "abstractInvocation"));
	        };

	        return SurfaceTile;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

	var Color = __webpack_require__(52);
	var GpuProgram = __webpack_require__(81);

	var DistanceFieldProgram2 = function (gl) {

	    var vertexShader =
	            'attribute vec4 vertexPoint;\n' +
	            'attribute vec4 vertexTexCoord;\n' +

	            'uniform mat4 mvpMatrix;\n' +
	            'uniform mat4 texSamplerMatrix;\n' +

	            'varying vec2 tx;\n' +

	            'void main() {\n' +
	            '    gl_Position = mvpMatrix * vertexPoint;\n' +
	            '    tx = (texSamplerMatrix * vertexTexCoord).xy;\n' +
	            '}';

	    var fragmentShader =
	        'precision mediump float;\n' +

	        'uniform sampler2D distanceField;\n' +
	        'uniform float opacity;\n' +
	        'uniform vec4 color;\n' +
	        'uniform float rotation;\n' +
	        'uniform float tilt;\n' +
	        'uniform vec2 screen;\n' +
	        'uniform float volume;\n' +

	        'varying vec2 tx;\n' +

	        'const float buffer = 0.71;\n' +
	        'const float smoothing = 0.001;\n' +
	        'const vec2 zero = vec2(0.0);\n' +

	        'vec4 lookup(vec2 dtx) {\n' +
	        '    vec4 rgbd = texture2D(distanceField, tx + dtx);\n' +
	        '    rgbd.a = smoothstep(buffer - smoothing, buffer + smoothing, rgbd.a);\n' +
	        '    return rgbd;\n' +
	        '}\n' +

	        'void main(void) {\n' +

	        '   if (tx.x<0.0||tx.x>1.0||tx.y<0.0||tx.y>1.0)discard;' +
	        //'   gl_FragColor = texture2D(distanceField, tx);' +
	        //'   gl_FragColor.r=gl_FragColor.a;' +
	        //'   gl_FragColor.a=0.5;' +
	        //'   return;' +

	        '    vec2 pixel = 0.5 - gl_FragCoord.xy / screen.xy;' +

	        //    fake perspective
	        '    float r = rotation + pixel.x * 0.9;\n' +
	        '    float t = tilt - pixel.y * 0.3;\n' +
	        '    vec2 dtx = vec2(sin(r), cos(r)) * volume * t;\n' +

	        '    vec4 c = lookup(dtx);\n' +
	        '    if (c.a == 1.0) {\n' +
	        '        c.rgb += color.rgb;' +
	        '        gl_FragColor = vec4(c.rgb, opacity);\n' +
	        '        return;\n' +
	        '    }\n' +

	        '    if (volume == 0.0) discard;' +

	        '    vec4 shadow = vec4(0.5, 0.5, 0.5, min(opacity, 0.4));\n'+

	        '    if (lookup(zero).a == 1.0) {\n' +
	        '        gl_FragColor = shadow;\n' +
	        '        return;\n' +
	        '    }\n' +

	        '}';

	    GpuProgram.call(this, gl, vertexShader, fragmentShader);

	    this.vertexPointLocation = this.attributeLocation(gl, "vertexPoint");
	    this.vertexTexCoordLocation = this.attributeLocation(gl, "vertexTexCoord");

	    this.mvpMatrixLocation = this.uniformLocation(gl, "mvpMatrix");
	    this.colorLocation = this.uniformLocation(gl, "color");
	    this.texSamplerMatrixLocation = this.uniformLocation(gl, "texSamplerMatrix");
	    this.texSamplerLocation = this.uniformLocation(gl, "distanceField");
	    this.opacityLocation = this.uniformLocation(gl, "opacity");
	    this.rotationLocation = this.uniformLocation(gl, "rotation");
	    this.tiltLocation = this.uniformLocation(gl, "tilt");
	    this.screenLocation = this.uniformLocation(gl, "screen");
	    this.volumeLocation = this.uniformLocation(gl, "volume");
	};

	DistanceFieldProgram2.key = "DistanceFieldProgram2";

	DistanceFieldProgram2.prototype = Object.create(GpuProgram.prototype);

	DistanceFieldProgram2.prototype.loadModelviewProjection = function (gl, matrix) {
	    this.loadUniformMatrix(gl, matrix, this.mvpMatrixLocation);
	};

	DistanceFieldProgram2.prototype.loadTexSamplerMatrix = function (gl, matrix) {
	    this.loadUniformMatrix(gl, matrix, this.texSamplerMatrixLocation);
	};

	DistanceFieldProgram2.prototype.loadTexMaskMatrix = function (gl, matrix) {
	    // this.loadUniformMatrix(gl, matrix, this.texMaskMatrixLocation);
	};

	DistanceFieldProgram2.prototype.loadTexSampler = function (gl, unit) {
	    gl.uniform1i(this.texSamplerLocation, unit - WebGLRenderingContext.TEXTURE0);
	};

	DistanceFieldProgram2.prototype.loadOpacity = function (gl, opacity) {
	    gl.uniform1f(this.opacityLocation, opacity);
	};

	DistanceFieldProgram2.prototype.loadRotation = function (gl, rotation) {
	    gl.uniform1f(this.rotationLocation, rotation);
	};

	DistanceFieldProgram2.prototype.loadTilt = function (gl, tilt) {
	    gl.uniform1f(this.tiltLocation, tilt);
	};

	DistanceFieldProgram2.prototype.loadScreenSize = function (gl, scr) {
	    gl.uniform2f(this.screenLocation, scr[0], scr[1]);
	};

	DistanceFieldProgram2.prototype.loadVolume = function (gl, volume) {
	    gl.uniform1f(this.volumeLocation, volume);
	};

	DistanceFieldProgram2.prototype.loadColor = function (gl, color) {
	    this.loadUniformColor(gl, color, this.colorLocation);
	};

	////

	DistanceFieldProgram2.prototype.loadOutlineColor = function (gl, color) {
	    // this.loadUniformColor(gl, color, this.outlineColorLocation);
	};

	DistanceFieldProgram2.prototype.loadOutlineDistance = function (gl, outlineDistance) {
	    // gl.uniform1f(this.outlineDistanceLocation, outlineDistance);
	};

	DistanceFieldProgram2.prototype.loadBuffer = function (gl, buffer) {
	    // gl.uniform1f(this.bufferLocation, buffer);
	};

	DistanceFieldProgram2.prototype.loadSmoothing = function (gl, smoothing) {
	    // gl.uniform1f(this.smoothingLocation, smoothing);
	};

	module.exports = DistanceFieldProgram2;

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = {
	    TinySDF: __webpack_require__(91),
	    CharSDF: __webpack_require__(92),
	    ImageSDF: __webpack_require__(93)
	};

/***/ }),
/* 91 */
/***/ (function(module, exports) {

	var INF = 1e20;

	var TinySDF = module.exports = function (size, radius, cutoff) {
	    this.radius = radius || 8;
	    this.cutoff = cutoff || 0.25;
	    this.size = size;
	    this.canvas = document.createElement('canvas');
	    this.canvas.width = this.canvas.height = size;
	    this.ctx = this.canvas.getContext('2d');

	    // temporary arrays for the distance transform
	    this.gridOuter = new Float64Array(size * size);
	    this.gridInner = new Float64Array(size * size);
	    this.f = new Float64Array(size);
	    this.d = new Float64Array(size);
	    this.z = new Float64Array(size + 1);
	    this.v = new Int16Array(size);

	    // hack around https://bugzilla.mozilla.org/show_bug.cgi?id=737852
	    this.middle = Math.round((size / 2) * (navigator.userAgent.indexOf('Gecko/') >= 0 ? 1.2 : 1));
	};

	TinySDF.prototype.clear = function(){
	    this.ctx.clearRect(0, 0, this.size, this.size);
	};

	TinySDF.prototype.sdfAlpha = function (){
	    var imgData = this.ctx.getImageData(0, 0, this.size, this.size);
	    var alphaChannel = new Uint8ClampedArray(this.size * this.size);

	    for (var i = 0; i < this.size * this.size; i++) {
	        var a = imgData.data[i * 4 + 3] / 255; // alpha value
	        this.gridOuter[i] = a === 1 ? 0 : a === 0 ? INF : Math.pow(Math.max(0, 0.5 - a), 2);
	        this.gridInner[i] = a === 1 ? INF : a === 0 ? 0 : Math.pow(Math.max(0, a - 0.5), 2);
	    }

	    edt(this.gridOuter, this.size, this.size, this.f, this.d, this.v, this.z);
	    edt(this.gridInner, this.size, this.size, this.f, this.d, this.v, this.z);

	    for (i = 0; i < this.size * this.size; i++) {
	        var d = this.gridOuter[i] - this.gridInner[i];
	        alphaChannel[i] = Math.max(0, Math.min(255, Math.round(255 - 255 * (d / this.radius + this.cutoff))));
	    }

	    return alphaChannel;
	};

	TinySDF.prototype.makeRGBAImageData = function (alphaChannel, size) {
	    var imageData = this.ctx.createImageData(size, size);
	    var data = imageData.data;
	    for (var i = 0; i < alphaChannel.length; i++) {
	        data[4 * i + 0] = alphaChannel[i];
	        data[4 * i + 1] = alphaChannel[i];
	        data[4 * i + 2] = alphaChannel[i];
	        data[4 * i + 3] = 255;
	    }
	    return imageData;
	};

	// 2D Euclidean distance transform by Felzenszwalb & Huttenlocher https://cs.brown.edu/~pff/dt/
	function edt(data, width, height, f, d, v, z) {
	    for (var x = 0; x < width; x++) {
	        for (var y = 0; y < height; y++) {
	            f[y] = data[y * width + x];
	        }
	        edt1d(f, d, v, z, height);
	        for (y = 0; y < height; y++) {
	            data[y * width + x] = d[y];
	        }
	    }
	    for (y = 0; y < height; y++) {
	        for (x = 0; x < width; x++) {
	            f[x] = data[y * width + x];
	        }
	        edt1d(f, d, v, z, width);
	        for (x = 0; x < width; x++) {
	            data[y * width + x] = Math.sqrt(d[x]);
	        }
	    }
	}

	// 1D squared distance transform
	function edt1d(f, d, v, z, n) {
	    v[0] = 0;
	    z[0] = -INF;
	    z[1] = +INF;

	    for (var q = 1, k = 0; q < n; q++) {
	        var s = ((f[q] + q * q) - (f[v[k]] + v[k] * v[k])) / (2 * q - 2 * v[k]);
	        while (s <= z[k]) {
	            k--;
	            s = ((f[q] + q * q) - (f[v[k]] + v[k] * v[k])) / (2 * q - 2 * v[k]);
	        }
	        k++;
	        v[k] = q;
	        z[k] = s;
	        z[k + 1] = +INF;
	    }

	    for (q = 0, k = 0; q < n; q++) {
	        while (z[k + 1] < q) k++;
	        d[q] = (q - v[k]) * (q - v[k]) + f[v[k]];
	    }
	}


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

	
	var TinySDF = __webpack_require__(91);

	var CharSDF = module.exports = function (fontSize, buffer, radius, cutoff, fontFamily, fontWeight) {
	    this.fontSize = fontSize || 24;
	    this.buffer = buffer === undefined ? 3 : buffer;
	    TinySDF.call(this, this.fontSize + this.buffer * 2, radius, cutoff);
	    this.fontFamily = fontFamily || 'sans-serif';
	    this.fontWeight = fontWeight || 'normal';
	    this.ctx.font = this.fontWeight + ' ' + this.fontSize + 'px ' + this.fontFamily;
	    this.ctx.textBaseline = 'middle';
	    this.ctx.fillStyle = 'black';
	    this.ctx.textAlign = "center";
	};

	CharSDF.prototype = Object.create(TinySDF.prototype);

	CharSDF.prototype.draw = function (char) {
	    this.ctx.clearRect(0, 0, this.size, this.size);
	    this.ctx.fillText(char, this.size/2, this.middle);
	    return this.sdfAlpha();
	};

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

	
	var TinySDF = __webpack_require__(91);

	var ImageSDF = module.exports = function (size, radius, cutoff) {
	    TinySDF.call(this, size, radius, cutoff);
	};

	ImageSDF.prototype = Object.create(TinySDF.prototype);

	ImageSDF.prototype.draw = function (image) {
	    this.ctx.clearRect(0, 0, this.size, this.size);
	    this.ctx.drawImage(image, 0, 0, this.size, this.size);
	    return this.sdfAlpha();
	};

/***/ }),
/* 94 */
/***/ (function(module, exports) {

	module.exports = {
	    makeRGBAImageData: makeRGBAImageData
	};

	function makeRGBAImageData(alphaChannel, img) {
	    var canvas = document.createElement('canvas');
	    canvas.width = img ? img.width : Math.sqrt(alphaChannel.length);
	    canvas.height = img ? img.height : Math.sqrt(alphaChannel.length);
	    var ctx = canvas.getContext('2d');
	    img && ctx.drawImage(img, 0, 0, img.width, img.height);
	    var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
	    var data = imageData.data;
	    for (var i = 0; i < alphaChannel.length; i++) {
	        data[4 * i + 3] = alphaChannel[i];
	    }
	    return imageData;
	}

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

	var SurfaceImage =  __webpack_require__(86);
	var Sector =  __webpack_require__(75);
	var DistanceFieldProgram =  __webpack_require__(89);
	var Color = __webpack_require__(52);
	var ImageSource = __webpack_require__(51);
	var ImageSDF = __webpack_require__(90).ImageSDF;
	var ImageUtils = __webpack_require__(94);

	var SurfaceSdfImage = function (position, image, fakeVolume) {

	    var width = 1;
	    var height = 1;

	    var self = this;

	    var sector = new Sector(
	        position.latitude - height/2,
	        position.latitude + height/2,
	        position.longitude - width/2,
	        position.longitude + width/2
	    );

	    SurfaceImage.call(this, sector, "images/point.png");

	    var img = document.createElement('img');
	    img.src = image;
	    img.onload = function() {
	        var sdfAlpha = new ImageSDF(img.width).draw(img);
	        self.imageSource = new ImageSource(ImageUtils.makeRGBAImageData(sdfAlpha, img))
	    };

	    this.fakeVolume = fakeVolume * 0.05;
	};


	SurfaceSdfImage.prototype = Object.create(SurfaceImage.prototype);

	SurfaceSdfImage.prototype.beginRendering = function (dc) {
	    var gl = dc.currentGlContext;
	    var program = dc.findAndBindProgram(DistanceFieldProgram);
	    program.loadTexSampler(gl, gl.TEXTURE0);
	    program.loadColor(gl, this.color || Color.TRANSPARENT);
	    program.loadOpacity(gl, this.opacity);
	    program.loadRotation(gl, -dc.navigatorState.heading * Math.PI / 180);
	    program.loadTilt(gl, dc.navigatorState.tilt / 90);
	    program.loadScreenSize(gl, [window.engine.canvas.width, window.engine.canvas.height]);
	    program.loadVolume(gl, this.fakeVolume);
	    return program;
	};

	module.exports = SurfaceSdfImage;


/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

	var ElevationModel = __webpack_require__(97);
	var Events = __webpack_require__(5);

	var blocked = false;
	var unblockTimeout;

	// Events.listen(Events._BLOCK_TILE_LOADING, function() {
	//     blocked = true;
	//     unblockTimeout && clearTimeout(unblockTimeout);
	//     unblockTimeout = setTimeout(function(){
	//         blocked = false;
	//     }, 300);
	// });

	var oldFunc = ElevationModel.prototype.retrieveTileImage;

	ElevationModel.prototype.retrieveTileImage = function(tile) {
	    if (blocked) return;
	    oldFunc.call(this, tile);
	};

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports ElevationModel
	 * @version $Id: ElevationModel.js 3415 2015-08-20 19:15:57Z tgaskins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(50),
	        __webpack_require__(29),
	        __webpack_require__(30),
	        __webpack_require__(98),
	        __webpack_require__(99),
	        __webpack_require__(100),
	        __webpack_require__(32),
	        __webpack_require__(53),
	        __webpack_require__(75),
	        __webpack_require__(77),
	        __webpack_require__(36)], __WEBPACK_AMD_DEFINE_RESULT__ = function (AbsentResourceList,
	              Angle,
	              ArgumentError,
	              ElevationImage,
	              ElevationTile,
	              LevelSet,
	              Logger,
	              MemoryCache,
	              Sector,
	              Tile,
	              WWMath) {
	        "use strict";

	        /**
	         * Constructs an elevation model.
	         * @alias ElevationModel
	         * @constructor
	         * @classdesc Represents the elevations for an area, often but not necessarily the whole globe.
	         * <p>
	         *     While this class can be used as-is, it is intended to be a base class for more concrete elevation
	         *     models, such as {@link EarthElevationModel}.
	         * @param {Sector} coverageSector The sector this elevation model spans.
	         * @param {Location} levelZeroDelta The size of top-level tiles, in degrees.
	         * @param {Number} numLevels The number of levels used to represent this elevation model's resolution pyramid.
	         * @param {String} retrievalImageFormat The mime type of the elevation data retrieved by this elevation model.
	         * @param {String} cachePath A string unique to this elevation model relative to other elevation models used by
	         * the application.
	         * @param {Number} tileWidth The number of intervals (cells) in the longitudinal direction of this elevation
	         * model's elevation tiles.
	         * @param {Number} tileHeight The number of intervals (cells) in the latitudinal direction of this elevation
	         * model's elevation tiles.
	         * @throws {ArgumentError} If any argument is null or undefined, if the number of levels specified is less
	         * than one, or if either the tile width or tile height are less than one.
	         */
	        var ElevationModel = function (coverageSector, levelZeroDelta, numLevels, retrievalImageFormat, cachePath,
	                                       tileWidth, tileHeight) {
	            if (!coverageSector) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "ElevationModel", "constructor", "missingSector"));
	            }

	            if (!levelZeroDelta) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "ElevationModel", "constructor",
	                        "The specified level-zero delta is null or undefined."));
	            }

	            if (!retrievalImageFormat) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "ElevationModel", "constructor",
	                        "The specified image format is null or undefined."));
	            }

	            if (!cachePath) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "ElevationModel", "constructor",
	                        "The specified cache path is null or undefined."));
	            }

	            if (!numLevels || numLevels < 1) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "ElevationModel", "constructor",
	                        "The specified number of levels is not greater than zero."));
	            }

	            if (!tileWidth || !tileHeight || tileWidth < 1 || tileHeight < 1) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "ElevationModel", "constructor",
	                        "The specified tile width or height is not greater than zero."));
	            }

	            /**
	             * The sector this elevation model spans.
	             * @type {Sector}
	             * @readonly
	             */
	            this.coverageSector = coverageSector;

	            /**
	             * The mime type to use when retrieving elevations.
	             * @type {String}
	             * @readonly
	             */
	            this.retrievalImageFormat = retrievalImageFormat;

	            /** A unique string identifying this elevation model relative to other elevation models in use.
	             * @type {String}
	             * @readonly
	             */
	            this.cachePath = cachePath;

	            /**
	             * Indicates this elevation model's display name.
	             * @type {String}
	             * @default "Elevations"
	             */
	            this.displayName = "Elevations";

	            /**
	             * Indicates the last time this elevation model changed, in milliseconds since midnight Jan 1, 1970.
	             * @type {Number}
	             * @readonly
	             * @default Date.now() at construction
	             */
	            this.timestamp = Date.now();

	            /**
	             * This elevation model's minimum elevation in meters.
	             * @type {Number}
	             * @default 0
	             */
	            this.minElevation = 0;

	            /**
	             * This elevation model's maximum elevation in meters.
	             * @type {Number}
	             */
	            this.maxElevation = 0;

	            /**
	             * Indicates whether the data associated with this elevation model is point data. A value of false
	             * indicates that the data is area data (pixel is area).
	             * @type {Boolean}
	             * @default true
	             */
	            this.pixelIsPoint = true;

	            /**
	             * The {@link LevelSet} created during construction of this elevation model.
	             * @type {LevelSet}
	             * @readonly
	             */
	            this.levels = new LevelSet(this.coverageSector, levelZeroDelta, numLevels, tileWidth, tileHeight);

	            // These are internal and intentionally not documented.
	            this.currentTiles = []; // holds assembled tiles
	            this.currentSector = new Sector(0, 0, 0, 0); // a scratch variable
	            this.tileCache = new MemoryCache(1000000, 800000); // for elevation tiles
	            this.imageCache = new MemoryCache(10000000, 8000000); // for the elevations, themselves
	            this.currentRetrievals = []; // Identifies elevation retrievals in progress
	            this.absentResourceList = new AbsentResourceList(3, 5e3);
	            this.id = ++ElevationModel.idPool;

	            /**
	             * A string identifying this elevation model's current state. Used to compare states during rendering to
	             * determine whether globe-state dependent cached values must be updated. Applications typically do not
	             * interact with this property. It is primarily used by shapes and terrain generators.
	             * @memberof ElevationModel.prototype
	             * @readonly
	             * @type {String}
	             */
	            this.stateKey = "elevationModel " + this.id.toString() + " ";
	        };

	        ElevationModel.idPool = 0; // Used to assign unique IDs to elevation models for use in their state key.

	        /**
	         * Returns the minimum and maximum elevations within a specified sector.
	         * @param {Sector} sector The sector for which to determine extreme elevations.
	         * @returns {Number[]} An array containing the minimum and maximum elevations within the specified sector,
	         * or null if the specified sector is outside this elevation model's coverage area.
	         * @throws {ArgumentError} If the specified sector is null or undefined.
	         */
	        ElevationModel.prototype.minAndMaxElevationsForSector = function (sector) {
	            if (!sector) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "ElevationModel", "minAndMaxElevationsForSector", "missingSector"));
	            }

	            var level = this.levels.levelForTexelSize(sector.deltaLatitude() * Angle.DEGREES_TO_RADIANS / 64);
	            this.assembleTiles(level, sector, false);

	            if (this.currentTiles.length == 0) {
	                return null; // Sector is outside the elevation model's coverage area. Do not modify the result array.
	            }

	            // Assign the output extreme elevations to the largest and smallest double values, respectively. This has the effect
	            // of expanding the extremes with each subsequent tile as needed. If we initialized this array with zeros then the
	            // output extreme elevations would always contain zero, even when the range of the image's extreme elevations in the
	            // sector does not contain zero.
	            var min = Number.MAX_VALUE,
	                max = -min,
	                image,
	                imageMin,
	                imageMax,
	                result = [];

	            for (var i = 0, len = this.currentTiles.length; i < len; i++) {
	                image = this.currentTiles[i].image();
	                if (image) {
	                    imageMin = image.minElevation;
	                    if (min > imageMin) {
	                        min = imageMin;
	                    }

	                    imageMax = image.maxElevation;
	                    if (max < imageMax) {
	                        max = imageMax;
	                    }
	                } else {
	                    result[0] = this.minElevation;
	                    result[1] = this.maxElevation;
	                    return result; // At least one tile image is not in memory; return the model's extreme elevations.
	                }
	            }

	            result[0] = min;
	            result[1] = max;

	            return result;
	        };

	        /**
	         * Returns the elevation at a specified location.
	         * @param {Number} latitude The location's latitude in degrees.
	         * @param {Number} longitude The location's longitude in degrees.
	         * @returns {Number} The elevation at the specified location, in meters. Returns zero if the location is
	         * outside the coverage area of this elevation model.
	         */
	        ElevationModel.prototype.elevationAtLocation = function (latitude, longitude) {
	            if (!this.coverageSector.containsLocation(latitude, longitude)) {
	                return 0; // location is outside the elevation model's coverage
	            }

	            return this.pointElevationForLocation(latitude, longitude);
	        };

	        /**
	         * Returns the elevations at locations within a specified sector.
	         * @param {Sector} sector The sector for which to determine the elevations.
	         * @param {Number} numLat The number of latitudinal sample locations within the sector.
	         * @param {Number} numLon The number of longitudinal sample locations within the sector.
	         * @param {Number} targetResolution The desired elevation resolution, in radians. (To compute radians from
	         * meters, divide the number of meters by the globe's radius.)
	         * @param {Number[]} result An array in which to return the requested elevations.
	         * @returns {Number} The resolution actually achieved, which may be greater than that requested if the
	         * elevation data for the requested resolution is not currently available.
	         * @throws {ArgumentError} If the specified sector or result array is null or undefined, or if either of the
	         * specified numLat or numLon values is less than one.
	         */
	        ElevationModel.prototype.elevationsForGrid = function (sector, numLat, numLon, targetResolution, result) {
	            if (!sector) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "ElevationModel", "elevationsForSector", "missingSector"));
	            }

	            if (!result) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "ElevationModel", "elevationsForSector", "missingResult"));
	            }

	            if (!numLat || !numLon || numLat < 1 || numLon < 1) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "ElevationModel", "constructor",
	                        "The specified number of latitudinal or longitudinal positions is less than one."));
	            }

	            var level = this.levels.levelForTexelSize(targetResolution);
	            if (this.pixelIsPoint) {
	                return this.pointElevationsForGrid(sector, numLat, numLon, level, result);
	            } else {
	                return this.areaElevationsForGrid(sector, numLat, numLon, level, result);
	            }
	        };

	        // Intentionally not documented.
	        ElevationModel.prototype.pointElevationForLocation = function (latitude, longitude) {
	            var level = this.levels.lastLevel(),
	                deltaLat = level.tileDelta.latitude,
	                deltaLon = level.tileDelta.longitude,
	                r = Tile.computeRow(deltaLat, latitude),
	                c = Tile.computeColumn(deltaLon, longitude),
	                tile,
	                image = null;

	            for (var i = level.levelNumber; i >= 0; i--) {
	                tile = this.tileCache.entryForKey(i + "." + r + "." + c);
	                if (tile) {
	                    image = tile.image();
	                    if (image) {
	                        return image.elevationAtLocation(latitude, longitude);
	                    }
	                }

	                r = Math.floor(r / 2);
	                c = Math.floor(c / 2);
	            }

	            return 0; // did not find a tile with an image
	        };

	        // Intentionally not documented.
	        ElevationModel.prototype.pointElevationsForGrid = function (sector, numLat, numLon, level, result) {
	            var maxResolution = 0,
	                resolution;

	            this.assembleTiles(level, sector, true);
	            if (this.currentTiles.length === 0) {
	                return 0; // Sector is outside the elevation model's coverage area. Do not modify the results array.
	            }

	            // Sort from lowest resolution to highest so that higher resolutions override lower resolutions in the
	            // loop below.
	            this.currentTiles.sort(function (tileA, tileB) {
	                return tileA.level.levelNumber - tileB.level.levelNumber;
	            });

	            for (var i = 0, len = this.currentTiles.length; i < len; i++) {
	                var tile = this.currentTiles[i],
	                    image = tile.image();

	                if (image) {
	                    image.elevationsForGrid(sector, numLat, numLon, result);
	                    resolution = tile.level.texelSize;

	                    if (maxResolution < resolution) {
	                        maxResolution = resolution;
	                    }
	                } else {
	                    maxResolution = Number.MAX_VALUE;
	                }
	            }

	            return maxResolution;
	        };

	        // Internal. Returns elevations for a grid assuming pixel-is-area.
	        ElevationModel.prototype.areaElevationsForGrid = function (sector, numLat, numLon, level, result) {
	            var minLat = sector.minLatitude,
	                maxLat = sector.maxLatitude,
	                minLon = sector.minLongitude,
	                maxLon = sector.maxLongitude,
	                deltaLat = sector.deltaLatitude() / (numLat > 1 ? numLat - 1 : 1),
	                deltaLon = sector.deltaLongitude() / (numLon > 1 ? numLon - 1 : 1),
	                lat, lon, s, t,
	                latIndex, lonIndex, resultIndex = 0;

	            for (latIndex = 0, lat = minLat; latIndex < numLat; latIndex += 1, lat += deltaLat) {
	                if (latIndex === numLat - 1) {
	                    lat = maxLat; // explicitly set the last lat to the max latitude ensure alignment
	                }

	                for (lonIndex = 0, lon = minLon; lonIndex < numLon; lonIndex += 1, lon += deltaLon) {
	                    if (lonIndex === numLon - 1) {
	                        lon = maxLon; // explicitly set the last lon to the max longitude ensure alignment
	                    }

	                    if (this.coverageSector.containsLocation(lat, lon)) { // ignore locations outside of the model
	                        s = (lon + 180) / 360;
	                        t = (lat + 90) / 180;
	                        this.areaElevationForCoord(s, t, level.levelNumber, result, resultIndex);
	                    }

	                    resultIndex++;
	                }
	            }

	            return level.texelSize; // TODO: return the actual achieved
	        };

	        // Internal. Returns an elevation for a location assuming pixel-is-area.
	        ElevationModel.prototype.areaElevationForCoord = function (s, t, levelNumber, result, resultIndex) {
	            var level, levelWidth, levelHeight,
	                tMin, tMax,
	                vMin, vMax,
	                u, v,
	                x0, x1, y0, y1,
	                xf, yf,
	                retrieveTiles,
	                pixels = new Float64Array(4);

	            for (var i = levelNumber; i >= 0; i--) {
	                level = this.levels.level(i);
	                levelWidth = Math.round(level.tileWidth * 360 / level.tileDelta.longitude);
	                levelHeight = Math.round(level.tileHeight * 180 / level.tileDelta.latitude);
	                tMin = 1 / (2 * levelHeight);
	                tMax = 1 - tMin;
	                vMin = 0;
	                vMax = levelHeight - 1;
	                u = levelWidth * WWMath.fract(s); // wrap the horizontal coordinate
	                v = levelHeight * WWMath.clamp(t, tMin, tMax); // clamp the vertical coordinate to the level edge
	                x0 = WWMath.mod(Math.floor(u - 0.5), levelWidth);
	                x1 = WWMath.mod((x0 + 1), levelWidth);
	                y0 = WWMath.clamp(Math.floor(v - 0.5), vMin, vMax);
	                y1 = WWMath.clamp(y0 + 1, vMin, vMax);
	                xf = WWMath.fract(u - 0.5);
	                yf = WWMath.fract(v - 0.5);
	                retrieveTiles = (i == levelNumber) || (i == 0);

	                if (this.lookupPixels(x0, x1, y0, y1, level, retrieveTiles, pixels)) {
	                    result[resultIndex] = (1 - xf) * (1 - yf) * pixels[0] +
	                        xf * (1 - yf) * pixels[1] +
	                        (1 - xf) * yf * pixels[2] +
	                        xf * yf * pixels[3];
	                    return;
	                }
	            }
	        };

	        // Internal. Bilinearly interpolates tile-image elevations.
	        ElevationModel.prototype.lookupPixels = function (x0, x1, y0, y1, level, retrieveTiles, result) {
	            var levelNumber = level.levelNumber,
	                tileWidth = level.tileWidth,
	                tileHeight = level.tileHeight,
	                row0 = Math.floor(y0 / tileHeight),
	                row1 = Math.floor(y1 / tileHeight),
	                col0 = Math.floor(x0 / tileWidth),
	                col1 = Math.floor(x1 / tileWidth),
	                r0c0, r0c1, r1c0, r1c1;

	            if (row0 == row1 && row0 == this.cachedRow && col0 == col1 && col0 == this.cachedCol) {
	                r0c0 = r0c1 = r1c0 = r1c1 = this.cachedImage; // use results from previous lookup
	            } else if (row0 == row1 && col0 == col1) {
	                r0c0 = this.lookupImage(levelNumber, row0, col0, retrieveTiles); // only need to lookup one image
	                r0c1 = r1c0 = r1c1 = r0c0; // re-use the single image
	                this.cachedRow = row0;
	                this.cachedCol = col0;
	                this.cachedImage = r0c0; // note the results for subsequent lookups
	            } else {
	                r0c0 = this.lookupImage(levelNumber, row0, col0, retrieveTiles);
	                r0c1 = this.lookupImage(levelNumber, row0, col1, retrieveTiles);
	                r1c0 = this.lookupImage(levelNumber, row1, col0, retrieveTiles);
	                r1c1 = this.lookupImage(levelNumber, row1, col1, retrieveTiles);
	            }

	            if (r0c0 && r0c1 && r1c0 && r1c1) {
	                result[0] = r0c0.pixel(x0 % tileWidth, y0 % tileHeight);
	                result[1] = r0c1.pixel(x1 % tileWidth, y0 % tileHeight);
	                result[2] = r1c0.pixel(x0 % tileWidth, y1 % tileHeight);
	                result[3] = r1c1.pixel(x1 % tileWidth, y1 % tileHeight);
	                return true;
	            }

	            return false;
	        };

	        // Internal. Intentionally not documented.
	        ElevationModel.prototype.lookupImage = function (levelNumber, row, column, retrieveTiles) {
	            var tile = this.tileForLevel(levelNumber, row, column),
	                image = tile.image();

	            // If the tile's elevations have expired, cause it to be re-retrieved. Note that the current,
	            // expired elevations are still used until the updated ones arrive.
	            if (image == null && retrieveTiles) {
	                this.retrieveTileImage(tile);
	            }

	            return image;
	        };

	        // Intentionally not documented.
	        ElevationModel.prototype.createTile = function (sector, level, row, column) {
	            var imagePath = this.cachePath + "/" + level.levelNumber + "/" + row + "/" + row + "_" + column + ".bil";

	            return new ElevationTile(sector, level, row, column, imagePath, this.imageCache);
	        };

	        // Intentionally not documented.
	        ElevationModel.prototype.assembleTiles = function (level, sector, retrieveTiles) {
	            this.currentTiles = [];

	            // Intersect the requested sector with the elevation model's coverage area. This avoids attempting to assemble tiles
	            // that are outside the coverage area.
	            this.currentSector.copy(sector);
	            this.currentSector.intersection(this.coverageSector);

	            if (this.currentSector.isEmpty())
	                return; // sector is outside the elevation model's coverage area

	            var deltaLat = level.tileDelta.latitude,
	                deltaLon = level.tileDelta.longitude,
	                firstRow = Tile.computeRow(deltaLat, this.currentSector.minLatitude),
	                lastRow = Tile.computeLastRow(deltaLat, this.currentSector.maxLatitude),
	                firstCol = Tile.computeColumn(deltaLon, this.currentSector.minLongitude),
	                lastCol = Tile.computeLastColumn(deltaLon, this.currentSector.maxLongitude);

	            for (var row = firstRow; row <= lastRow; row++) {
	                for (var col = firstCol; col <= lastCol; col++) {
	                    this.addTileOrAncestor(level, row, col, retrieveTiles);
	                }
	            }
	        };

	        // Intentionally not documented.
	        ElevationModel.prototype.addTileOrAncestor = function (level, row, column, retrieveTiles) {
	            var tile = this.tileForLevel(level.levelNumber, row, column);

	            if (this.isTileImageInMemory(tile)) {
	                this.addToCurrentTiles(tile);
	            } else {
	                if (retrieveTiles) {
	                    this.retrieveTileImage(tile);
	                }

	                if (level.isFirstLevel()) {
	                    this.currentTiles.push(tile); // no ancestor tile to add
	                } else {
	                    this.addAncestor(level, row, column, retrieveTiles);
	                }
	            }
	        };

	        // Intentionally not documented.
	        ElevationModel.prototype.addAncestor = function (level, row, column, retrieveTiles) {
	            var tile = null,
	                r = Math.floor(row / 2),
	                c = Math.floor(column / 2);

	            for (var i = level.levelNumber - 1; i >= 0; i--) {
	                tile = this.tileForLevel(i, r, c);
	                if (this.isTileImageInMemory(tile)) {
	                    this.addToCurrentTiles(tile);
	                    return;
	                }

	                r = Math.floor(r / 2);
	                c = Math.floor(c / 2);
	            }

	            // No ancestor tiles have an in-memory image. Retrieve the ancestor tile corresponding for the first level, and
	            // add it. We add the necessary tiles to provide coverage over the requested sector in order to accurately return
	            // whether or not this elevation model has data for the entire sector.
	            this.addToCurrentTiles(tile);

	            if (retrieveTiles) {
	                this.retrieveTileImage(tile);
	            }
	        };

	        // Intentionally not documented.
	        ElevationModel.prototype.addToCurrentTiles = function (tile) {
	            this.currentTiles.push(tile);
	        };

	        // Intentionally not documented.
	        ElevationModel.prototype.tileForLevel = function (levelNumber, row, column) {
	            var tileKey = levelNumber + "." + row + "." + column,
	                tile = this.tileCache.entryForKey(tileKey);

	            if (tile) {
	                return tile;
	            }

	            var level = this.levels.level(levelNumber),
	                sector = Tile.computeSector(level, row, column);

	            tile = this.createTile(sector, level, row, column);
	            this.tileCache.putEntry(tileKey, tile, tile.size());

	            return tile;
	        };

	        // Intentionally not documented.
	        ElevationModel.prototype.isTileImageInMemory = function (tile) {
	            return this.imageCache.containsKey(tile.imagePath);
	        };

	        // Intentionally not documented.
	        ElevationModel.prototype.resourceUrlForTile = function (tile) {
	            return this.urlBuilder.urlForTile(tile, this.retrievalImageFormat);
	        };

	        // Intentionally not documented.
	        ElevationModel.prototype.retrieveTileImage = function (tile) {
	            if (this.currentRetrievals.indexOf(tile.imagePath) < 0) {
	                var url = this.resourceUrlForTile(tile, this.retrievalImageFormat),
	                    xhr = new XMLHttpRequest(),
	                    elevationModel = this;

	                if (!url)
	                    return;

	                xhr.open("GET", url, true);
	                xhr.responseType = 'arraybuffer';
	                xhr.onreadystatechange = function () {
	                    if (xhr.readyState === 4) {
	                        elevationModel.removeFromCurrentRetrievals(tile.imagePath);

	                        var contentType = xhr.getResponseHeader("content-type");

	                        if (xhr.status === 200) {
	                            if (contentType === elevationModel.retrievalImageFormat
	                                || contentType === "text/plain"
	                                || contentType === "application/octet-stream") {
	                                Logger.log(Logger.LEVEL_INFO, "Elevations retrieval succeeded: " + url);
	                                elevationModel.loadElevationImage(tile, xhr);
	                                elevationModel.absentResourceList.unmarkResourceAbsent(tile.imagePath);

	                                // Send an event to request a redraw.
	                                var e = document.createEvent('Event');
	                                e.initEvent(WorldWind.REDRAW_EVENT_TYPE, true, true);
	                                window.dispatchEvent(e);
	                            } else if (contentType === "text/xml") {
	                                elevationModel.absentResourceList.markResourceAbsent(tile.imagePath);
	                                Logger.log(Logger.LEVEL_WARNING,
	                                    "Elevations retrieval failed (" + xhr.statusText + "): " + url + ".\n "
	                                    + String.fromCharCode.apply(null, new Uint8Array(xhr.response)));
	                            } else {
	                                elevationModel.absentResourceList.markResourceAbsent(tile.imagePath);
	                                Logger.log(Logger.LEVEL_WARNING,
	                                    "Elevations retrieval failed: " + url + ". " + "Unexpected content type "
	                                    + contentType);
	                            }
	                        } else {
	                            elevationModel.absentResourceList.markResourceAbsent(tile.imagePath);
	                            Logger.log(Logger.LEVEL_WARNING,
	                                "Elevations retrieval failed (" + xhr.statusText + "): " + url);
	                        }
	                    }
	                };

	                xhr.onerror = function () {
	                    elevationModel.removeFromCurrentRetrievals(tile.imagePath);
	                    elevationModel.absentResourceList.markResourceAbsent(tile.imagePath);
	                    Logger.log(Logger.LEVEL_WARNING, "Elevations retrieval failed: " + url);
	                };

	                xhr.ontimeout = function () {
	                    elevationModel.removeFromCurrentRetrievals(tile.imagePath);
	                    elevationModel.absentResourceList.markResourceAbsent(tile.imagePath);
	                    Logger.log(Logger.LEVEL_WARNING, "Elevations retrieval timed out: " + url);
	                };

	                xhr.send(null);

	                this.currentRetrievals.push(tile.imagePath);
	            }
	        };

	        // Intentionally not documented.
	        ElevationModel.prototype.removeFromCurrentRetrievals = function (imagePath) {
	            var index = this.currentRetrievals.indexOf(imagePath);
	            if (index > -1) {
	                this.currentRetrievals.splice(index, 1);
	            }
	        };

	        // Intentionally not documented.
	        ElevationModel.prototype.loadElevationImage = function (tile, xhr) {
	            var elevationImage = new ElevationImage(tile.imagePath, tile.sector, tile.tileWidth, tile.tileHeight);

	            if (this.retrievalImageFormat == "application/bil16") {
	                elevationImage.imageData = new Int16Array(xhr.response);
	                elevationImage.size = elevationImage.imageData.length * 2;
	            } else if (this.retrievalImageFormat == "application/bil32") {
	                elevationImage.imageData = new Float32Array(xhr.response);
	                elevationImage.size = elevationImage.imageData.length * 4;
	            }

	            if (elevationImage.imageData) {
	                elevationImage.findMinAndMaxElevation();
	                this.imageCache.putEntry(tile.imagePath, elevationImage, elevationImage.size);
	                this.timestamp = Date.now();
	            }
	        };

	        return ElevationModel;

	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports ElevationImage
	 * @version $Id: ElevationImage.js 2936 2015-03-27 22:04:59Z tgaskins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(30),
	        __webpack_require__(32),
	        __webpack_require__(36)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
	              Logger,
	              WWMath) {
	        "use strict";

	        /**
	         * Constructs an elevation image.
	         * @alias ElevationImage
	         * @constructor
	         * @classdesc Holds elevation values for an elevation tile.
	         * This class is typically not used directly by applications.
	         * @param {String} imagePath A string uniquely identifying this elevation image relative to other elevation
	         * images.
	         * @param {Sector} sector The sector spanned by this elevation image.
	         * @param {Number} imageWidth The number of longitudinal sample points in this elevation image.
	         * @param {Number} imageHeight The number of latitudinal sample points in this elevation image.
	         * @throws {ArgumentError} If the specified image path is null, undefined or empty, or the specified
	         * sector is null or undefined.
	         */
	        var ElevationImage = function (imagePath, sector, imageWidth, imageHeight) {
	            if (!imagePath || (imagePath.length < 1)) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "ElevationImage", "constructor",
	                        "The specified image path is null, undefined or zero length."));
	            }

	            if (!sector) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "ElevationImage", "constructor", "missingSector"));
	            }

	            /**
	             * The sector spanned by this elevation image.
	             * @type {Sector}
	             * @readonly
	             */
	            this.sector = sector;

	            /**
	             * A string uniquely identifying this elevation image.
	             * @type {String}
	             * @readonly
	             */
	            this.imagePath = imagePath;

	            /**
	             * The number of longitudinal sample points in this elevation image.
	             * @type {Number}
	             * @readonly
	             */
	            this.imageWidth = imageWidth;

	            /**
	             * The number of latitudinal sample points in this elevation image.
	             * @type {Number}
	             * @readonly
	             */
	            this.imageHeight = imageHeight;

	            /**
	             * The size in bytes of this elevation image.
	             * @type {number}
	             * @readonly
	             */
	            this.size = this.imageWidth * this.imageHeight;
	        };

	        /**
	         * Returns the pixel value at a specified coordinate in this elevation image. The coordinate origin is the
	         * image's lower left corner, so (0, 0) indicates the lower left pixel and (imageWidth-1, imageHeight-1)
	         * indicates the upper right pixel. This returns 0 if the coordinate indicates a pixel outside of this elevation
	         * image.
	         * @param x The pixel's X coordinate.
	         * @param y The pixel's Y coordinate.
	         * @returns {Number} The pixel value at the specified coordinate in this elevation image.
	         * Returns 0 if the coordinate indicates a pixel outside of this elevation image.
	         */
	        ElevationImage.prototype.pixel = function (x, y) {
	            if (x < 0 || x >= this.imageWidth) {
	                return 0;
	            }

	            if (y < 0 || y >= this.imageHeight) {
	                return 0;
	            }

	            y = this.imageHeight - y - 1; // flip the y coordinate origin to the lower left corner
	            return this.imageData[x + y * this.imageWidth];
	        };

	        /**
	         * Returns the elevation at a specified geographic location.
	         * @param {Number} latitude The location's latitude.
	         * @param {Number} longitude The location's longitude.
	         * @returns {Number} The elevation at the specified location.
	         */
	        ElevationImage.prototype.elevationAtLocation = function (latitude, longitude) {
	            var maxLat = this.sector.maxLatitude,
	                minLon = this.sector.minLongitude,
	                deltaLat = this.sector.deltaLatitude(),
	                deltaLon = this.sector.deltaLongitude(),
	                x = (this.imageWidth - 1) * (longitude - minLon) / deltaLon,
	                y = (this.imageHeight - 1) * (maxLat - latitude) / deltaLat,
	                x0 = Math.floor(WWMath.clamp(x, 0, this.imageWidth - 1)),
	                x1 = Math.floor(WWMath.clamp(x0 + 1, 0, this.imageWidth - 1)),
	                y0 = Math.floor(WWMath.clamp(y, 0, this.imageHeight - 1)),
	                y1 = Math.floor(WWMath.clamp(y0 + 1, 0, this.imageHeight - 1)),
	                pixels = this.imageData,
	                x0y0 = pixels[x0 + y0 * this.imageWidth],
	                x1y0 = pixels[x1 + y0 * this.imageWidth],
	                x0y1 = pixels[x0 + y1 * this.imageWidth],
	                x1y1 = pixels[x1 + y1 * this.imageWidth],
	                xf = x - x0,
	                yf = y - y0;

	            return (1 - xf) * (1 - yf) * x0y0 +
	                xf * (1 - yf) * x1y0 +
	                (1 - xf) * yf * x0y1 +
	                xf * yf * x1y1;
	        };

	        /**
	         * Returns elevations for a specified sector.
	         * @param {Sector} sector The sector for which to return the elevations.
	         * @param {Number} numLat The number of sample points in the longitudinal direction.
	         * @param {Number} numLon The number of sample points in the latitudinal direction.
	         * @param {Number[]} result An array in which to return the computed elevations.
	         * @throws {ArgumentError} If either the specified sector or result argument is null or undefined, or if the
	         * specified number of sample points in either direction is less than 1.
	         */
	        ElevationImage.prototype.elevationsForGrid = function (sector, numLat, numLon, result) {
	            if (!sector) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "ElevationImage", "elevationsForSector", "missingSector"));
	            }

	            if (numLat < 1 || numLon < 1) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "ElevationImage", "elevationsForSector",
	                        "The specified number of sample points is less than 1."));
	            }

	            if (!result) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "ElevationImage", "elevationsForSector", "missingResult"));
	            }

	            var minLatSelf = this.sector.minLatitude,
	                maxLatSelf = this.sector.maxLatitude,
	                minLonSelf = this.sector.minLongitude,
	                maxLonSelf = this.sector.maxLongitude,
	                deltaLatSelf = maxLatSelf - minLatSelf,
	                deltaLonSelf = maxLonSelf - minLonSelf,
	                minLat = sector.minLatitude,
	                maxLat = sector.maxLatitude,
	                minLon = sector.minLongitude,
	                maxLon = sector.maxLongitude,
	                deltaLat = (maxLat - minLat) / (numLat > 1 ? numLat - 1 : 1),
	                deltaLon = (maxLon - minLon) / (numLon > 1 ? numLon - 1 : 1),
	                lat, lon,
	                i, j, index = 0,
	                pixels = this.imageData;

	            for (j = 0, lat = minLat; j < numLat; j += 1, lat += deltaLat) {
	                if (j === numLat - 1) {
	                    lat = maxLat; // explicitly set the last lat to the max latitude to ensure alignment
	                }

	                if (lat >= minLatSelf && lat <= maxLatSelf) {
	                    // Image y-coordinate of the specified location, given an image origin in the top-left corner.
	                    var y = (this.imageHeight - 1) * (maxLatSelf - lat) / deltaLatSelf,
	                        y0 = Math.floor(WWMath.clamp(y, 0, this.imageHeight - 1)),
	                        y1 = Math.floor(WWMath.clamp(y0 + 1, 0, this.imageHeight - 1)),
	                        yf = y - y0;

	                    for (i = 0, lon = minLon; i < numLon; i += 1, lon += deltaLon) {
	                        if (i === numLon - 1) {
	                            lon = maxLon; // explicitly set the last lon to the max longitude to ensure alignment
	                        }

	                        if (lon >= minLonSelf && lon <= maxLonSelf) {
	                            // Image x-coordinate of the specified location, given an image origin in the top-left corner.
	                            var x = (this.imageWidth - 1) * (lon - minLonSelf) / deltaLonSelf,
	                                x0 = Math.floor(WWMath.clamp(x, 0, this.imageWidth - 1)),
	                                x1 = Math.floor(WWMath.clamp(x0 + 1, 0, this.imageWidth - 1)),
	                                xf = x - x0;

	                            var x0y0 = pixels[x0 + y0 * this.imageWidth],
	                                x1y0 = pixels[x1 + y0 * this.imageWidth],
	                                x0y1 = pixels[x0 + y1 * this.imageWidth],
	                                x1y1 = pixels[x1 + y1 * this.imageWidth];

	                            result[index] = (1 - xf) * (1 - yf) * x0y0 +
	                            xf * (1 - yf) * x1y0 +
	                            (1 - xf) * yf * x0y1 +
	                            xf * yf * x1y1;
	                        }

	                        index++;
	                    }
	                } else {
	                    index += numLon; // skip this row
	                }
	            }
	        };

	        /**
	         * Returns the minimum and maximum elevations within a specified sector.
	         * @param {Sector} sector The sector of interest. If null or undefined, the minimum and maximum elevations
	         * for the sector associated with this tile are returned.
	         * @returns {Number[]} An array containing the minimum and maximum elevations within the specified sector,
	         * or null if the specified sector does not include this elevation image's coverage sector.
	         */
	        ElevationImage.prototype.minAndMaxElevationsForSector = function (sector) {
	            var result = [];

	            if (!sector) { // the sector is this sector
	                result[0] = this.minElevation;
	                result[1] = this.maxElevation;
	            } else if (sector.contains(this.sector)) { // The specified sector completely contains this image; return the image min and max.
	                if (result[0] > this.minElevation) {
	                    result[0] = this.minElevation;
	                }

	                if (result[1] < this.maxElevation) {
	                    result[1] = this.maxElevation;
	                }
	            } else { // The specified sector intersects a portion of this image; compute the min and max from intersecting pixels.
	                var maxLatSelf = this.sector.maxLatitude,
	                    minLonSelf = this.sector.minLongitude,
	                    deltaLatSelf = this.sector.deltaLatitude(),
	                    deltaLonSelf = this.sector.deltaLongitude(),
	                    minLatOther = sector.minLatitude,
	                    maxLatOther = sector.maxLatitude,
	                    minLonOther = sector.minLongitude,
	                    maxLonOther = sector.maxLongitude;

	                // Image coordinates of the specified sector, given an image origin in the top-left corner. We take the floor and
	                // ceiling of the min and max coordinates, respectively, in order to capture all pixels that would contribute to
	                // elevations computed for the specified sector in a call to elevationsForSector.
	                var minY = Math.floor((this.imageHeight - 1) * (maxLatSelf - maxLatOther) / deltaLatSelf),
	                    maxY = Math.ceil((this.imageHeight - 1) * (maxLatSelf - minLatOther) / deltaLatSelf),
	                    minX = Math.floor((this.imageWidth - 1) * (minLonOther - minLonSelf) / deltaLonSelf),
	                    maxX = Math.ceil((this.imageWidth - 1) * (maxLonOther - minLonSelf) / deltaLonSelf);

	                minY = WWMath.clamp(minY, 0, this.imageHeight - 1);
	                maxY = WWMath.clamp(maxY, 0, this.imageHeight - 1);
	                minX = WWMath.clamp(minX, 0, this.imageWidth - 1);
	                maxX = WWMath.clamp(maxX, 0, this.imageWidth - 1);

	                var pixels = this.imageData,
	                    min = Number.MAX_VALUE,
	                    max = -min;

	                for (var y = minY; y <= maxY; y++) {
	                    for (var x = minX; x <= maxX; x++) {
	                        var p = pixels[Math.floor(x + y * this.imageWidth)];
	                        if (min > p) {
	                            min = p;
	                        }

	                        if (max < p) {
	                            max = p;
	                        }
	                    }
	                }

	                if (result[0] > min) {
	                    result[0] = min;
	                }

	                if (result[1] < max) {
	                    result[1] = max;
	                }
	            }

	            return result;
	        };

	        /**
	         * Determines the minimum and maximum elevations within this elevation image and stores those values within
	         * this object. See [minAndMaxElevationsForSector]{@link ElevationImage#minAndMaxElevationsForSector}
	         */
	        ElevationImage.prototype.findMinAndMaxElevation = function () {
	            if (this.imageData && (this.imageData.length > 0)) {
	                this.minElevation = Number.MAX_VALUE;
	                this.maxElevation = -this.minElevation;

	                var pixels = this.imageData,
	                    pixelCount = this.imageWidth * this.imageHeight;

	                for (var i = 0; i < pixelCount; i++) {
	                    var p = pixels[i];

	                    if (this.minElevation > p) {
	                        this.minElevation = p;
	                    }

	                    if (this.maxElevation < p) {
	                        this.maxElevation = p;
	                    }
	                }
	            } else {
	                this.minElevation = 0;
	                this.maxElevation = 0;
	            }
	        };

	        return ElevationImage;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports ElevationTile
	 * @version $Id: ElevationTile.js 2936 2015-03-27 22:04:59Z tgaskins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(30),
	        __webpack_require__(32),
	        __webpack_require__(77)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
	              Logger,
	              Tile) {
	        "use strict";

	        /**
	         * Constructs an elevation tile.
	         * @alias ElevationTile
	         * @constructor
	         * @augments Tile
	         * @classdesc Represents a region of elevations. Applications typically do not interact directly with this class.
	         * @param {Sector} sector The sector this tile covers.
	         * @param {Level} level The level this tile is associated with.
	         * @param {Number} row This tile's row in the associated level.
	         * @param {Number} column This tile's column in the associated level.
	         * @param {String} imagePath The full path to the image.
	         * @param {MemoryCache} cache The cache to use for caching this elevation tile.
	         * @throws {ArgumentError} If the specified sector or level is null or undefined, the row or column arguments
	         * are less than zero, or the specified image path is null, undefined or empty.
	         *
	         */
	        var ElevationTile = function (sector, level, row, column, imagePath, cache) {
	            if (!imagePath || (imagePath.length < 1)) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "ElevationTile", "constructor",
	                        "The specified image path is null, undefined or zero length."));
	            }

	            if (!cache) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "ElevationTile", "constructor",
	                        "The specified cache is null or undefined."));
	            }

	            Tile.call(this, sector, level, row, column); // args are checked in the superclass' constructor

	            /**
	             * This tile's image path.
	             * @type {String}
	             */
	            this.imagePath = imagePath;

	            this.memoryCache = cache;
	        };

	        ElevationTile.prototype = Object.create(Tile.prototype);

	        /**
	         * Returns the size of the this tile in bytes.
	         * @returns {Number} The size of this tile in bytes, not including the associated elevations image size.
	         */
	        ElevationTile.prototype.size = function () {
	            return Tile.prototype.size.call(this) + this.imagePath.length + 8;
	        };

	        /**
	         * Returns the {@link ElevationImage} associated with this tile.
	         * @returns {ElevationImage} The elevation image associated with this tile, or null if that image is
	         * currently not in the elevation image cache.
	         */
	        ElevationTile.prototype.image = function () {
	            return this.memoryCache.entryForKey(this.imagePath);
	        };

	        return ElevationTile;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports LevelSet
	 * @version $Id: LevelSet.js 2952 2015-04-01 00:33:54Z tgaskins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(30),
	        __webpack_require__(74),
	        __webpack_require__(28),
	        __webpack_require__(32)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
	              Level,
	              Location,
	              Logger) {
	        "use strict";

	        /**
	         * Constructs a level set.
	         * @alias Level
	         * @constructor
	         * @classdesc Represents a multi-resolution, hierarchical collection of tiles. Applications typically do not
	         * interact with this class.
	         * @param {Sector} sector The sector spanned by this level set.
	         * @param {Location} levelZeroDelta The geographic size of tiles in the lowest resolution level of this level set.
	         * @param {Number} numLevels The number of levels in the level set.
	         * @param {Number} tileWidth The height in pixels of images associated with tiles in this level set, or the number of sample
	         * points in the longitudinal direction of elevation tiles associate with this level set.
	         * @param {Number} tileHeight The height in pixels of images associated with tiles in this level set, or the number of sample
	         * points in the latitudinal direction of elevation tiles associate with this level set.
	         * @throws {ArgumentError} If the specified sector or level-zero-delta is null or undefined, the level zero
	         * delta values are less than or equal to zero, or any of the number-of-levels, tile-width or tile-height
	         * arguments are less than 1.
	         */
	        var LevelSet = function (sector, levelZeroDelta, numLevels, tileWidth, tileHeight) {
	            if (!sector) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "LevelSet", "constructor", "missingSector"));
	            }

	            if (!levelZeroDelta) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "LevelSet", "constructor",
	                        "The specified level zero delta is null or undefined"));
	            }

	            if (levelZeroDelta.latitude <= 0 || levelZeroDelta.longitude <= 0) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "LevelSet", "constructor",
	                        "The specified level zero delta is less than or equal to zero."));
	            }

	            if (numLevels < 1) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "LevelSet", "constructor",
	                        "The specified number of levels is less than one."));
	            }

	            if (tileWidth < 1 || tileHeight < 1) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "LevelSet", "constructor",
	                        "The specified tile width or tile height is less than one."));
	            }

	            /**
	             * The sector spanned by this level set.
	             * @type {Sector}
	             * @readonly
	             */
	            this.sector = sector;

	            /**
	             * The geographic size of the lowest resolution (level 0) tiles in this level set.
	             * @type {Location}
	             * @readonly
	             */
	            this.levelZeroDelta = levelZeroDelta;

	            /**
	             * The number of levels in this level set.
	             * @type {Number}
	             * @readonly
	             */
	            this.numLevels = numLevels;

	            /**
	             *  The width in pixels of images associated with tiles in this level set, or the number of sample points
	             *  in the longitudinal direction of elevation tiles associated with this level set.
	             * @type {Number}
	             * @readonly
	             */
	            this.tileWidth = tileWidth;

	            /**
	             *  The height in pixels of images associated with tiles in this level set, or the number of sample points
	             *  in the latitudinal direction of elevation tiles associated with this level set.
	             * @type {Number}
	             * @readonly
	             */
	            this.tileHeight = tileHeight;

	            this.levels = [];

	            for (var i = 0; i < numLevels; i += 1) {
	                var n = Math.pow(2, i),
	                    latDelta = levelZeroDelta.latitude / n,
	                    lonDelta = levelZeroDelta.longitude / n,
	                    tileDelta = new Location(latDelta, lonDelta),
	                    level = new Level(i, tileDelta, this);

	                this.levels[i] = level;
	            }
	        };

	        /**
	         * Returns the {@link Level} for a specified level number.
	         * @param {Number} levelNumber The number of the desired level.
	         * @returns {Level} The requested level, or null if the level does not exist.
	         */
	        LevelSet.prototype.level = function(levelNumber) {
	            if (levelNumber < 0 || levelNumber >= this.levels.length) {
	                return null;
	            } else {
	                return this.levels[levelNumber];
	            }
	        };

	        /**
	         * Returns the level with a specified texel size.
	         * This function returns the first level if the specified texel size is greater than the first level's texel
	         * size, and returns the last level if the delta is less than the last level's texel size.
	         * @param {Number} texelSize The size of pixels or elevation cells in the level, in radians per pixel or cell.
	         */
	        LevelSet.prototype.levelForTexelSize = function(texelSize) {
	            // TODO: Replace this loop with a computation.
	            var lastLevel = this.lastLevel();

	            if (lastLevel.texelSize >= texelSize) {
	                return lastLevel; // Can't do any better than the last level.
	            }

	            for (var index = 0, length = this.levels.length; index < length; index += 1) {
	                var level = this.levels[index];
	                if (level.texelSize <= texelSize) {
	                    return level;
	                }
	            }

	            return lastLevel;
	        };

	        /**
	         * Returns the first (lowest resolution) level of this level set.
	         * @returns {Level} The first level of this level set.
	         */
	        LevelSet.prototype.firstLevel = function() {
	            return this.levels[0];
	        };

	        /**
	         * Returns the last (highest resolution) level of this level set.
	         * @returns {Level} The last level of this level set.
	         */
	        LevelSet.prototype.lastLevel = function() {
	            return this.levels[this.levels.length - 1];
	        };

	        return LevelSet;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

	var ProjectionWgs84 = __webpack_require__(102);

	var ProjectionProgram = __webpack_require__(104);

	var projectionShaderPart =
	    'vec4 applyProjection(vec4 blh) {\n' +
	    '    float lat = blh.x * DEGREES_TO_RADIANS;\n' +
	    '    float lon = blh.y * DEGREES_TO_RADIANS;\n' +
	    '    float alt = blh.z;\n' +
	    '    float cosLat = cos(lat);\n' +
	    '    float sinLat = sin(lat);\n' +
	    '    float cosLon = cos(lon);\n' +
	    '    float sinLon = sin(lon);\n' +
	    '    float rpm = GLOBE_EQUATORIAL_RADIUS / sqrt(1.0 - GLOBE_ECCENTRICITY_SQUARED * sinLat * sinLat);\n' +
	    '    return vec4(' +
	    '        (rpm + alt) * cosLat * sinLon,\n' +
	    '        (rpm * (1.0 - GLOBE_ECCENTRICITY_SQUARED) + alt) * sinLat,\n' +
	    '        (rpm + alt) * cosLat * cosLon,\n' +
	    '        1.0\n' +
	    '    );\n' +
	    '}\n';

	var Wgs84Program = function (gl) {
	    ProjectionProgram.call(this, gl, projectionShaderPart);
	};

	Wgs84Program.prototype = Object.create(ProjectionProgram.prototype);

	Wgs84Program.key = "Wgs84ProjectionGpuProgram";

	ProjectionWgs84.prototype.shader = Wgs84Program;

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2015 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports ProjectionWgs84
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(29),
	        __webpack_require__(30),
	        __webpack_require__(103),
	        __webpack_require__(32),
	        __webpack_require__(47),
	        __webpack_require__(35),
	        __webpack_require__(36)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Angle,
	              ArgumentError,
	              GeographicProjection,
	              Logger,
	              Position,
	              Vec3,
	              WWMath) {
	        "use strict";

	        /**
	         * Constructs a WGS84 ellipsoid
	         * @alias ProjectionWgs84
	         * @constructor
	         * @augments GeographicProjection
	         * @classdesc Represents a WGS84 ellipsoid.
	         */
	        var ProjectionWgs84 = function () {

	            GeographicProjection.call(this, "WGS84", false, null);

	            this.is2D = false;

	            this.scratchPosition = new Position(0, 0, 0);
	        };

	        ProjectionWgs84.prototype = Object.create(GeographicProjection.prototype);

	        Object.defineProperties(ProjectionWgs84.prototype, {
	            /**
	             * A string identifying this projection's current state. Used to compare states during rendering to
	             * determine whether globe-state dependent cached values must be updated. Applications typically do not
	             * interact with this property.
	             * @memberof ProjectionEquirectangular.prototype
	             * @readonly
	             * @type {String}
	             */
	            stateKey: {
	                get: function () {
	                    return "projection wgs84 ";
	                }
	            }
	        });

	        // Documented in base class.
	        ProjectionWgs84.prototype.geographicToCartesian = function (globe, latitude, longitude, altitude, offset,
	                                                                    result) {
	            if (!globe) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "ProjectionWgs84",
	                    "geographicToCartesian", "missingGlobe"));
	            }

	            var cosLat = Math.cos(latitude * Angle.DEGREES_TO_RADIANS),
	                sinLat = Math.sin(latitude * Angle.DEGREES_TO_RADIANS),
	                cosLon = Math.cos(longitude * Angle.DEGREES_TO_RADIANS),
	                sinLon = Math.sin(longitude * Angle.DEGREES_TO_RADIANS),
	                rpm = globe.equatorialRadius / Math.sqrt(1.0 - globe.eccentricitySquared * sinLat * sinLat);

	            result[0] = (rpm + altitude) * cosLat * sinLon;
	            result[1] = (rpm * (1.0 - globe.eccentricitySquared) + altitude) * sinLat;
	            result[2] = (rpm + altitude) * cosLat * cosLon;

	            return result;
	        };

	        // Documented in base class.
	        ProjectionWgs84.prototype.geographicToCartesianGrid = function (globe, sector, numLat, numLon, elevations,
	                                                                        referencePoint, offset, result) {
	            if (!globe) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "ProjectionWgs84",
	                    "geographicToCartesianGrid", "missingGlobe"));
	            }

	            var minLat = sector.minLatitude * Angle.DEGREES_TO_RADIANS,
	                maxLat = sector.maxLatitude * Angle.DEGREES_TO_RADIANS,
	                minLon = sector.minLongitude * Angle.DEGREES_TO_RADIANS,
	                maxLon = sector.maxLongitude * Angle.DEGREES_TO_RADIANS,
	                deltaLat = (maxLat - minLat) / (numLat > 1 ? numLat - 1 : 1),
	                deltaLon = (maxLon - minLon) / (numLon > 1 ? numLon - 1 : 1),
	                refCenter = referencePoint ? referencePoint : new Vec3(0, 0, 0),
	                latIndex, lonIndex,
	                elevIndex = 0, resultIndex = 0,
	                lat, lon, rpm, elev,
	                cosLat, sinLat,
	                cosLon = new Float64Array(numLon), sinLon = new Float64Array(numLon);

	            // Compute and save values that are a function of each unique longitude value in the specified sector. This
	            // eliminates the need to re-compute these values for each column of constant longitude.
	            for (lonIndex = 0, lon = minLon; lonIndex < numLon; lonIndex++, lon += deltaLon) {
	                if (lonIndex === numLon - 1) {
	                    lon = maxLon; // explicitly set the last lon to the max longitude to ensure alignment
	                }

	                cosLon[lonIndex] = Math.cos(lon);
	                sinLon[lonIndex] = Math.sin(lon);
	            }

	            // Iterate over the latitude and longitude coordinates in the specified sector, computing the Cartesian
	            // point corresponding to each latitude and longitude.
	            for (latIndex = 0, lat = minLat; latIndex < numLat; latIndex++, lat += deltaLat) {
	                if (latIndex === numLat - 1) {
	                    lat = maxLat; // explicitly set the last lat to the max longitude to ensure alignment
	                }

	                // Latitude is constant for each row. Values that are a function of latitude can be computed once per row.
	                cosLat = Math.cos(lat);
	                sinLat = Math.sin(lat);
	                rpm = globe.equatorialRadius / Math.sqrt(1.0 - globe.eccentricitySquared * sinLat * sinLat);

	                for (lonIndex = 0; lonIndex < numLon; lonIndex++) {
	                    elev = elevations[elevIndex++];
	                    result[resultIndex++] = (rpm + elev) * cosLat * sinLon[lonIndex] - refCenter[0];
	                    result[resultIndex++] = (rpm * (1.0 - globe.eccentricitySquared) + elev) * sinLat - refCenter[1];
	                    result[resultIndex++] = (rpm + elev) * cosLat * cosLon[lonIndex] - refCenter[2];
	                }
	            }

	            return result;
	        };

	        // Documented in base class.
	        ProjectionWgs84.prototype.cartesianToGeographic = function (globe, x, y, z, offset, result) {
	            if (!globe) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "ProjectionWgs84",
	                    "cartesianToGeographic", "missingGlobe"));
	            }

	            // According to H. Vermeille, "An analytical method to transform geocentric into geodetic coordinates"
	            // http://www.springerlink.com/content/3t6837t27t351227/fulltext.pdf
	            // Journal of Geodesy, accepted 10/2010, not yet published
	            var X = z,
	                Y = x,
	                Z = y,
	                XXpYY = X * X + Y * Y,
	                sqrtXXpYY = Math.sqrt(XXpYY),
	                a = globe.equatorialRadius,
	                ra2 = 1 / (a * a),
	                e2 = globe.eccentricitySquared,
	                e4 = e2 * e2,
	                p = XXpYY * ra2,
	                q = Z * Z * (1 - e2) * ra2,
	                r = (p + q - e4) / 6,
	                h,
	                phi,
	                u,
	                evoluteBorderTest = 8 * r * r * r + e4 * p * q,
	                rad1,
	                rad2,
	                rad3,
	                atan,
	                v,
	                w,
	                k,
	                D,
	                sqrtDDpZZ,
	                e,
	                lambda,
	                s2;

	            if (evoluteBorderTest > 0 || q != 0) {
	                if (evoluteBorderTest > 0) {
	                    // Step 2: general case
	                    rad1 = Math.sqrt(evoluteBorderTest);
	                    rad2 = Math.sqrt(e4 * p * q);

	                    // 10*e2 is my arbitrary decision of what Vermeille means by "near... the cusps of the evolute".
	                    if (evoluteBorderTest > 10 * e2) {
	                        rad3 = WWMath.cbrt((rad1 + rad2) * (rad1 + rad2));
	                        u = r + 0.5 * rad3 + 2 * r * r / rad3;
	                    }
	                    else {
	                        u = r + 0.5 * WWMath.cbrt((rad1 + rad2) * (rad1 + rad2))
	                            + 0.5 * WWMath.cbrt((rad1 - rad2) * (rad1 - rad2));
	                    }
	                }
	                else {
	                    // Step 3: near evolute
	                    rad1 = Math.sqrt(-evoluteBorderTest);
	                    rad2 = Math.sqrt(-8 * r * r * r);
	                    rad3 = Math.sqrt(e4 * p * q);
	                    atan = 2 * Math.atan2(rad3, rad1 + rad2) / 3;

	                    u = -4 * r * Math.sin(atan) * Math.cos(Math.PI / 6 + atan);
	                }

	                v = Math.sqrt(u * u + e4 * q);
	                w = e2 * (u + v - q) / (2 * v);
	                k = (u + v) / (Math.sqrt(w * w + u + v) + w);
	                D = k * sqrtXXpYY / (k + e2);
	                sqrtDDpZZ = Math.sqrt(D * D + Z * Z);

	                h = (k + e2 - 1) * sqrtDDpZZ / k;
	                phi = 2 * Math.atan2(Z, sqrtDDpZZ + D);
	            }
	            else {
	                // Step 4: singular disk
	                rad1 = Math.sqrt(1 - e2);
	                rad2 = Math.sqrt(e2 - p);
	                e = Math.sqrt(e2);

	                h = -a * rad1 * rad2 / e;
	                phi = rad2 / (e * rad2 + rad1 * Math.sqrt(p));
	            }

	            // Compute lambda
	            s2 = Math.sqrt(2);
	            if ((s2 - 1) * Y < sqrtXXpYY + X) {
	                // case 1 - -135deg < lambda < 135deg
	                lambda = 2 * Math.atan2(Y, sqrtXXpYY + X);
	            }
	            else if (sqrtXXpYY + Y < (s2 + 1) * X) {
	                // case 2 - -225deg < lambda < 45deg
	                lambda = -Math.PI * 0.5 + 2 * Math.atan2(X, sqrtXXpYY - Y);
	            }
	            else {
	                // if (sqrtXXpYY-Y<(s2=1)*X) {  // is the test, if needed, but it's not
	                // case 3: - -45deg < lambda < 225deg
	                lambda = Math.PI * 0.5 - 2 * Math.atan2(X, sqrtXXpYY + Y);
	            }

	            result.latitude = Angle.RADIANS_TO_DEGREES * phi;
	            result.longitude = Angle.RADIANS_TO_DEGREES * lambda;
	            result.altitude = h;

	            return result;
	        };

	        ProjectionWgs84.prototype.northTangentAtLocation = function (globe, latitude, longitude, result) {
	            // The north-pointing tangent is derived by rotating the vector (0, 1, 0) about the Y-axis by longitude degrees,
	            // then rotating it about the X-axis by -latitude degrees. The latitude angle must be inverted because latitude
	            // is a clockwise rotation about the X-axis, and standard rotation matrices assume counter-clockwise rotation.
	            // The combined rotation can be represented by a combining two rotation matrices Rlat, and Rlon, then
	            // transforming the vector (0, 1, 0) by the combined transform:
	            //
	            // NorthTangent = (Rlon * Rlat) * (0, 1, 0)
	            //
	            // This computation can be simplified and encoded inline by making two observations:
	            // - The vector's X and Z coordinates are always 0, and its Y coordinate is always 1.
	            // - Inverting the latitude rotation angle is equivalent to inverting sinLat. We know this by the
	            //  trigonometric identities cos(-x) = cos(x), and sin(-x) = -sin(x).

	            var cosLat = Math.cos(latitude * Angle.DEGREES_TO_RADIANS),
	                cosLon = Math.cos(longitude * Angle.DEGREES_TO_RADIANS),
	                sinLat = Math.sin(latitude * Angle.DEGREES_TO_RADIANS),
	                sinLon = Math.sin(longitude * Angle.DEGREES_TO_RADIANS);

	            result[0] = -sinLat * sinLon;
	            result[1] = cosLat;
	            result[2] = -sinLat * cosLon;

	            return result;
	        };

	        ProjectionWgs84.prototype.northTangentAtPoint = function (globe, x, y, z, offset, result) {
	            this.cartesianToGeographic(globe, x, y, z, Vec3.ZERO, this.scratchPosition);

	            return this.northTangentAtLocation(globe, this.scratchPosition.latitude, this.scratchPosition.longitude, result);
	        };

	        ProjectionWgs84.prototype.surfaceNormalAtPoint = function (globe, x, y, z, result) {
	            if (!globe) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "ProjectionWgs84",
	                    "surfaceNormalAtPoint", "missingGlobe"));
	            }

	            var eSquared = globe.equatorialRadius * globe.equatorialRadius,
	                polSquared = globe.polarRadius * globe.polarRadius;

	            result[0] = x / eSquared;
	            result[1] = y / polSquared;
	            result[2] = z / eSquared;

	            return result.normalize();
	        };

	        return ProjectionWgs84;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports GeographicProjection
	 * @version $Id: GeographicProjection.js 2821 2015-02-20 16:59:27Z dcollins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(30),
	        __webpack_require__(32),
	        __webpack_require__(75),
	        __webpack_require__(66)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
	              Logger,
	              Sector,
	              UnsupportedOperationError) {
	        "use strict";

	        /**
	         * Constructs a base geographic projection.
	         * @alias GeographicProjection
	         * @constructor
	         * @classdesc Represents a geographic projection.
	         * This is an abstract class and is meant to be instantiated only by subclasses.
	         * See the following projections:
	         * <ul>
	         *     <li>{@link ProjectionEquirectangular}</li>
	         *     <li>{@link ProjectionMercator}</li>
	         *     <li>{@link ProjectionPolarEquidistant}</li>
	         *     <li>{@link ProjectionUPS}</li>
	         </ul>
	         * @param {String} displayName The projection's display name.
	         * @param {boolean} continuous Indicates whether this projection is continuous.
	         * @param {Sector} projectionLimits This projection's projection limits. May be null to indicate the full
	         * range of latitude and longitude, +/- 90 degrees latitude, +/- 180 degrees longitude.
	         */
	        var GeographicProjection = function (displayName, continuous, projectionLimits) {

	            /**
	             * This projection's display name.
	             * @type {string}
	             */
	            this.displayName = displayName || "Geographic Projection";

	            /**
	             * Indicates whether this projection should be treated as continuous with itself. If true, the 2D map
	             * will appear to scroll continuously horizontally.
	             * @type {boolean}
	             * @readonly
	             */
	            this.continuous = continuous;

	            /**
	             * Indicates the geographic limits of this projection.
	             * @type {Sector}
	             * @readonly
	             */
	            this.projectionLimits = projectionLimits;

	            /**
	             * Indicates whether this projection is a 2D projection.
	             * @type {boolean}
	             * @readonly
	             */
	            this.is2D = true;
	        };

	        /**
	         * Converts a geographic position to Cartesian coordinates.
	         *
	         * @param {Globe} globe The globe this projection is applied to.
	         * @param {number} latitude The latitude of the position, in degrees.
	         * @param {number} longitude The longitude of the position, in degrees.
	         * @param {number} elevation The elevation of the position, in meters.
	         * @param {Vec3} offset An offset to apply to the Cartesian output. Typically only projections that are
	         * continuous (see [continuous]{@link GeographicProjection#continuous}) apply to this offset. Others ignore
	         * it. May be null to indicate no offset is applied.
	         * @param {Vec3} result A variable in which to store the computed Cartesian point.
	         *
	         * @returns {Vec3} The specified result argument containing the computed point.
	         * @throws {ArgumentError} If the specified globe or result is null or undefined.
	         */
	        GeographicProjection.prototype.geographicToCartesian = function (globe, latitude, longitude, elevation,
	                                                                         offset, result) {
	            throw new UnsupportedOperationError(
	                Logger.logMessage(Logger.LEVEL_SEVERE, "GeographicProjection", "geographicToCartesian", "abstractInvocation"));
	        };

	        /**
	         * Computes a grid of Cartesian points within a specified sector and relative to a specified Cartesian
	         * reference point.
	         * <p>
	         * This method is used to compute a collection of points within a sector. It is used by tessellators to
	         * efficiently generate a tile's interior points. The number of points to generate is indicated by the tileWidth
	         * and tileHeight parameters but is one more in each direction. Width refers to the longitudinal direction,
	         * height to the latitudinal.
	         * <p>
	         * For each implied position within the sector, an elevation value is specified via an array of elevations. The
	         * calculation at each position incorporates the associated elevation.
	         * There must be (tileWidth + 1) x (tileHeight + 1) elevations in the array.
	         *
	         * @param {Globe} globe The globe this projection applies to.
	         * @param {Sector} sector The sector in which to compute the points.
	         * @param {Number} numLat The number of latitudinal sections a tile is divided into.
	         * @param {Number} numLon The number of longitudinal sections a tile is divided into.
	         * @param {Number[]} elevations An array of elevations to incorporate in the point calculations. There must be
	         * one elevation value in the array for each generated point. Elevations are in meters.
	         * There must be (tileWidth + 1) x (tileHeight + 1) elevations in the array.
	         * @param {Vec3} referencePoint The X, Y and Z Cartesian coordinates to subtract from the computed coordinates.
	         * This makes the computed coordinates relative to the specified point. May be null.
	         * @param {Vec3} offset An offset to apply to the Cartesian output points. Typically only projections that
	         * are continuous (see [continuous]{@link GeographicProjection#continuous}) apply this offset. Others ignore it.
	         * May be null to indicate that no offset is applied.
	         * @param {Float32Array} result A typed array to hold the computed coordinates. It must be at least of
	         * size (tileWidth + 1) x (tileHeight + 1) * 3.
	         * The points are returned in row major order, beginning with the row of minimum latitude.
	         * @returns {Float32Array} The specified result argument, populated with the computed Cartesian coordinates.
	         * @throws {ArgumentError} if any of the specified globe, sector, elevations array or results arrays is null or
	         * undefined.
	         */
	        GeographicProjection.prototype.geographicToCartesianGrid = function (globe, sector, numLat, numLon, elevations,
	                                                                             referencePoint, offset, result) {
	            throw new UnsupportedOperationError(
	                Logger.logMessage(Logger.LEVEL_SEVERE, "GeographicProjection", "geographicToCartesianGrid", "abstractInvocation"));
	        };

	        /**
	         * Converts a Cartesian point to a geographic position.
	         * @param {Globe} globe The globe this projection is applied to.
	         * @param {number} x The X component of the Cartesian point.
	         * @param {number} y The Y component of the Cartesian point.
	         * @param {number} z The Z component of the Cartesian point.
	         * @param {Vec3} offset An offset to apply to the Cartesian output points. Typically only projections that
	         * are continuous (see [continuous]{@link GeographicProjection#continuous}) apply this offset. Others ignore it.
	         * May be null to indicate that no offset is applied.
	         * @param {Position} result A variable in which to return the computed position.
	         *
	         * @returns {Position} The specified result argument containing the computed position.
	         * @throws {ArgumentError} If either the specified globe or result argument is null or undefined.
	         */
	        GeographicProjection.prototype.cartesianToGeographic = function (globe, x, y, z, offset, result) {
	            throw new UnsupportedOperationError(
	                Logger.logMessage(Logger.LEVEL_SEVERE, "GeographicProjection", "cartesianToGeographic", "abstractInvocation"));
	        };

	        /**
	         * Computes a Cartesian vector that points north and is tangent to the meridian at a specified geographic
	         * location.
	         *
	         * @param {Globe} globe The globe this projection is applied to.
	         * @param {number} latitude The latitude of the location, in degrees.
	         * @param {number} longitude The longitude of the location, in degrees.
	         * @param {Vec3} result A variable in which to return the computed vector.
	         *
	         * @returns{Vec3} The specified result argument containing the computed vector.
	         * @throws {ArgumentError} If either the specified globe or result argument is null or undefined.
	         */
	        GeographicProjection.prototype.northTangentAtLocation = function (globe, latitude, longitude, result) {
	            if (!result) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "ProjectionEquirectangular",
	                    "northTangentAtLocation", "missingResult"));
	            }

	            result[0] = 0;
	            result[1] = 1;
	            result[2] = 0;

	            return result;
	        };

	        /**
	         * Computes a Cartesian vector that points north and is tangent to the meridian at a specified Cartesian
	         * point.
	         *
	         * @param {Globe} globe The globe this projection is applied to.
	         * @param {number} x The X component of the Cartesian point.
	         * @param {number} y The Y component of the Cartesian point.
	         * @param {number} z The Z component of the Cartesian point.
	         * @param {Vec3} offset An offset to apply to the Cartesian point. Typically only projections that
	         * are continuous (see [continuous]{@link GeographicProjection#continuous}) apply this offset. Others ignore it.
	         * May be null to indicate that no offset is applied.
	         * @param {Vec3} result A variable in which to return the computed vector.
	         *
	         * @returns{Vec3} The specified result argument containing the computed vector.
	         * @throws {ArgumentError} If either the specified globe or result argument is null or undefined.
	         */
	        GeographicProjection.prototype.northTangentAtPoint = function (globe, x, y, z, offset, result) {
	            if (!result) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "ProjectionEquirectangular",
	                    "northTangentAtPoint", "missingResult"));
	            }

	            result[0] = 0;
	            result[1] = 1;
	            result[2] = 0;

	            return result;
	        };

	        /**
	         * Computes the Cartesian surface normal vector at a specified Cartesian point.
	         *
	         * @param {Globe} globe The globe this projection is applied to.
	         * @param {number} x The X component of the Cartesian point.
	         * @param {number} y The Y component of the Cartesian point.
	         * @param {number} z The Z component of the Cartesian point.
	         * @param {Vec3} result A variable in which to return the computed vector.
	         *
	         * @returns{Vec3} The specified result argument containing the computed vector.
	         * @throws {ArgumentError} If either the specified globe or result argument is null or undefined.
	         */
	        GeographicProjection.prototype.surfaceNormalAtPoint = function (globe, x, y, z, result) {
	            if (!result) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "GeographicProjection", "surfaceNormalAtPoint",
	                    "missingResult"));
	            }

	            result[0] = 0;
	            result[1] = 0;
	            result[2] = 1;

	            return result;
	        };

	        return GeographicProjection;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

	var ArgumentError = __webpack_require__(30);
	var Color = __webpack_require__(52);
	var GpuProgram = __webpack_require__(81);
	var Logger = __webpack_require__(32);

	var vertexShaderHeaderSection =
	    'attribute vec4 vertexPoint;\n' +
	    'attribute vec4 vertexTexCoord;\n' +
	    'attribute vec4 normalVector;\n' +
	    'attribute float groundPoints;\n' +

	    'uniform float height;\n' +
	    'uniform vec3 referencePoint;\n' +
	    'uniform float minHeight;\n' +

	    'uniform mat4 mvpMatrix;\n' +
	    'uniform mat4 mvInverseMatrix;\n' +
	    'uniform mat4 texCoordMatrix;\n' +
	    'uniform bool applyLighting;\n' +

	    'varying vec2 texCoord;\n' +
	    'varying vec3 normalInterp;\n' +
	    'varying float gradient;\n' +
	    'varying vec3 vertPos;\n' +

	    'const float PI = 3.141592653589;\n' +
	    'const float DEGREES_TO_RADIANS = PI / 180.0;\n'+
	    'const float GLOBE_EQUATORIAL_RADIUS = 6378137.0;\n' +
	    'const float GLOBE_ECCENTRICITY_SQUARED = 0.00669437999013;\n';

	var vertexShaderMainSection =
	    'void main() {' +
	    // '   vec4 p = vertexPoint;\n' +
	    '   if (groundPoints > 0.0) {\n' +
	    '       gradient = 1.0;\n' +
	    '   } else {\n' +
	    '       gradient = 0.0;\n' +
	    '   }\n' +
	    '   vec4 point = vertexPoint;\n' +
	    // '   point.xyz -= referencePoint.xyz;\n' +
	    '   gl_Position = mvpMatrix * point;\n' +
	    '   texCoord = (texCoordMatrix * vertexTexCoord).st;\n' +
	    '   if (applyLighting) {\n' +
	    '       vertPos = point.xyz;\n' +
	    '       normalInterp = normalVector.xyz;\n' +
	    '   }\n' +
	    '}';

	var fragmentShaderSource =
	    'precision highp float;\n' +

	    'uniform float opacity;\n' +
	    'uniform vec4 color;\n' +
	    'uniform bool enableTexture;\n' +
	    'uniform bool modulateColor;\n' +
	    'uniform sampler2D textureSampler;\n' +
	    'uniform bool applyLighting;\n' +

	    'varying vec2 texCoord;\n' +
	    'varying vec3 normalInterp;\n' +
	    'varying float gradient;\n' +
	    'varying vec3 vertPos;\n' +

	    'const vec3 lightPos = vec3(0.0, 0.0, 0.0);\n' +
	    'const vec3 specColor = vec3(0.3, 0.3, 0.3);\n' +

	    'void main() {\n' +
	    '    vec3 ambientColor = color.xyz * 0.7;\n' +
	    '    gl_FragColor = color * opacity;\n' +
	    '    if (gradient < 0.99999) {\n' +
	    '       if (color.r + color.g + color.b < 0.1) {\n' +
	    '           gl_FragColor.rgb += gradient / 3.0;\n' +
	    '       } else {\n' +
	    '           gl_FragColor.rgb *= 1.0 - gradient / 2.0;\n' +
	    '       }\n' +
	    '    }\n' +
	    // '    if (gl_FragColor.a == 0.0) {\n' +
	    // '        discard;\n' +
	    // '    }\n' +
	    //
	    // '    if (applyLighting) {\n' +
	    // '       vec3 normal = normalize(normalInterp);\n' +
	    // '       vec3 lightDir = normalize(lightPos - vertPos);\n' +
	    // '       vec3 reflectDir = reflect(-lightDir, normal);\n' +
	    // '       vec3 viewDir = normalize(-vertPos);\n' +
	    //
	    // '       float lambertian = max(dot(lightDir,normal), 0.0);\n' +
	    // '       float specular = 0.0;\n' +
	    //
	    // '       if(lambertian > 0.0) {\n' +
	    // '           float specAngle = max(dot(reflectDir, viewDir), 0.0);\n' +
	    // '           specular = pow(specAngle, 4.0);\n' +
	    // '       }\n' +
	    //
	    // '       gl_FragColor = vec4(ambientColor + lambertian*color.xyz + specular*specColor, 1.0);\n' +
	    // '    }\n' +
	    '}';

	var ProjectionProgram = function (gl, projectionShaderPart) {

	    // Specify bindings to avoid the WebGL performance warning that's generated when normalVector gets
	    // bound to location 0.
	    var bindings = ["vertexPoint", "normalVector", "vertexTexCoord", "groundPoints"];
	    // Call to the superclass, which performs shader program compiling and linking.
	    var vertexShaderSource = vertexShaderHeaderSection + projectionShaderPart + vertexShaderMainSection;
	    GpuProgram.call(this, gl, vertexShaderSource, fragmentShaderSource, bindings);
	    this.vertexPointLocation = this.attributeLocation(gl, "vertexPoint");
	    this.normalVectorLocation = this.attributeLocation(gl, "normalVector");
	    this.vertexTexCoordLocation = this.attributeLocation(gl, "vertexTexCoord");
	    this.groundPointsLocation = this.attributeLocation(gl, "groundPoints");

	    this.mvpMatrixLocation = this.uniformLocation(gl, "mvpMatrix");
	    this.mvInverseMatrixLocation = this.uniformLocation(gl, "mvInverseMatrix");
	    this.colorLocation = this.uniformLocation(gl, "color");
	    this.textureEnabledLocation = this.uniformLocation(gl, "enableTexture");
	    this.modulateColorLocation = this.uniformLocation(gl, "modulateColor");
	    this.textureUnitLocation = this.uniformLocation(gl, "textureSampler");
	    this.textureMatrixLocation = this.uniformLocation(gl, "texCoordMatrix");
	    this.opacityLocation = this.uniformLocation(gl, "opacity");
	    this.applyLightingLocation = this.uniformLocation(gl, "applyLighting");
	    this.heightLocation = this.uniformLocation(gl, "height");
	    this.minHeightLocation = this.uniformLocation(gl, "minHeight");
	    this.referencePointLocation = this.uniformLocation(gl, "referencePoint");
	};

	ProjectionProgram.prototype = Object.create(GpuProgram.prototype);

	ProjectionProgram.prototype.loadReferencePoint = function (gl, pt) {
	    gl.uniform3f(this.referencePointLocation, pt[0], pt[1], pt[2]);
	};

	ProjectionProgram.prototype.loadModelviewInverse = function (gl, matrix) {
	    this.loadUniformMatrix(gl, matrix, this.mvInverseMatrixLocation);
	};

	ProjectionProgram.prototype.loadModelviewProjection = function (gl, matrix) {
	    this.loadUniformMatrix(gl, matrix, this.mvpMatrixLocation);
	};

	ProjectionProgram.prototype.loadColor = function (gl, color) {
	    this.loadUniformColor(gl, color, this.colorLocation);
	};

	ProjectionProgram.prototype.loadTextureEnabled = function (gl, enable) {
	    gl.uniform1i(this.textureEnabledLocation, enable ? 1 : 0);
	};

	ProjectionProgram.prototype.loadModulateColor = function (gl, enable) {
	    gl.uniform1i(this.modulateColorLocation, enable ? 1 : 0);
	};

	ProjectionProgram.prototype.loadTextureUnit = function (gl, unit) {
	    gl.uniform1i(this.textureUnitLocation, unit - gl.TEXTURE0);
	};

	ProjectionProgram.prototype.loadTextureMatrix = function (gl, matrix) {
	    this.loadUniformMatrix(gl, matrix, this.textureMatrixLocation);
	};

	ProjectionProgram.prototype.loadOpacity = function (gl, opacity) {
	    gl.uniform1f(this.opacityLocation, opacity);
	};

	ProjectionProgram.prototype.loadHeight = function (gl, height) {
	    gl.uniform1f(this.heightLocation, height);
	};

	ProjectionProgram.prototype.loadMinHeight = function (gl, minHeight) {
	    gl.uniform1f(this.minHeightLocation, minHeight);
	};

	ProjectionProgram.prototype.loadApplyLighting = function (gl, applyLighting) {
	    gl.uniform1i(this.applyLightingLocation, applyLighting);
	};

	module.exports = ProjectionProgram;

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

	var ProjectionMercator = __webpack_require__(106);

	var ProjectionProgram = __webpack_require__(104);

	// See "Map Projections: A Working Manual", page 44 for the source of the below formulas.

	var projectionShaderPart =
	    'const float ECC = sqrt(GLOBE_ECCENTRICITY_SQUARED);\n' +

	    'vec4 applyProjection(vec4 point) {\n' +
	    '    float sinLat = sin(point.x * DEGREES_TO_RADIANS);\n' +
	    '    float eccSinLat = ECC * sinLat;\n' +
	    '    float s = ((1.0 + sinLat) / (1.0 - sinLat)) * pow((1.0 - eccSinLat) / (1.0 + eccSinLat), ECC);\n' +
	    '    return vec4(' +
	    '        GLOBE_EQUATORIAL_RADIUS * point.y * DEGREES_TO_RADIANS,\n' +
	    '        0.5 * GLOBE_EQUATORIAL_RADIUS * log(s),\n' +
	    '        point.z,\n' +
	    '        1.0\n' +
	    '    );\n' +
	    '}\n';

	var MercatorProgram = function (gl) {
	    ProjectionProgram.call(this, gl, projectionShaderPart);
	};

	MercatorProgram.prototype = Object.create(ProjectionProgram.prototype);

	MercatorProgram.key = "MercatorProjectionGpuProgram";

	ProjectionMercator.prototype.shader = MercatorProgram;

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports ProjectionMercator
	 * @version $Id: ProjectionMercator.js 2821 2015-02-20 16:59:27Z dcollins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(29),
	        __webpack_require__(30),
	        __webpack_require__(103),
	        __webpack_require__(32),
	        __webpack_require__(75),
	        __webpack_require__(35),
	        __webpack_require__(36)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Angle,
	              ArgumentError,
	              GeographicProjection,
	              Logger,
	              Sector,
	              Vec3,
	              WWMath) {
	        "use strict";

	        /**
	         * Constructs a Mercator geographic projection.
	         * @alias ProjectionMercator
	         * @constructor
	         * @augments GeographicProjection
	         * @classdesc Represents a Mercator geographic projection.
	         */
	        var ProjectionMercator = function () {

	            GeographicProjection.call(this, "Mercator", true, new Sector(-78, 78, -180, 180));
	        };

	        ProjectionMercator.prototype = Object.create(GeographicProjection.prototype);

	        // Documented in base class.
	        ProjectionMercator.prototype.geographicToCartesian = function (globe, latitude, longitude, elevation, offset,
	                                                                       result) {
	            if (!globe) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "ProjectionMercator",
	                    "geographicToCartesian", "missingGlobe"));
	            }

	            if (!result) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "ProjectionMercator",
	                    "geographicToCartesian", "missingResult"));
	            }

	            if (latitude > this.projectionLimits.maxLatitude) {
	                latitude = this.projectionLimits.maxLatitude;
	            }
	            if (latitude < this.projectionLimits.minLatitude) {
	                latitude = this.projectionLimits.minLatitude;
	            }

	            // See "Map Projections: A Working Manual", page 44 for the source of the below formulas.

	            var ecc = Math.sqrt(globe.eccentricitySquared),
	                sinLat = Math.sin(latitude * Angle.DEGREES_TO_RADIANS),
	                s = ((1 + sinLat) / (1 - sinLat)) * Math.pow((1 - ecc * sinLat) / (1 + ecc * sinLat), ecc);

	            result[0] = globe.equatorialRadius * longitude * Angle.DEGREES_TO_RADIANS + (offset ? offset[0] : 0);
	            result[1] = 0.5 * globe.equatorialRadius * Math.log(s);
	            result[2] = elevation;

	            return result;
	        };

	        Object.defineProperties(ProjectionMercator.prototype, {
	            /**
	             * A string identifying this projection's current state. Used to compare states during rendering to
	             * determine whether globe-state dependent cached values must be updated. Applications typically do not
	             * interact with this property.
	             * @memberof ProjectionMercator.prototype
	             * @readonly
	             * @type {String}
	             */
	            stateKey: {
	                get: function () {
	                    return "projection mercator ";
	                }
	            }
	        });

	        // Documented in base class.
	        ProjectionMercator.prototype.geographicToCartesianGrid = function (globe, sector, numLat, numLon, elevations,
	                                                                           referencePoint, offset, result) {
	            if (!globe) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "ProjectionMercator",
	                    "geographicToCartesianGrid", "missingGlobe"));
	            }

	            if (!sector) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "ProjectionMercator",
	                    "geographicToCartesianGrid", "missingSector"));
	            }

	            if (!elevations || elevations.length < numLat * numLon) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "ProjectionMercator",
	                    "geographicToCartesianGrid",
	                    "The specified elevations array is null, undefined or insufficient length"));
	            }

	            if (!result) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "ProjectionMercator",
	                    "geographicToCartesianGrid", "missingResult"));
	            }

	            var eqr = globe.equatorialRadius,
	                ecc = Math.sqrt(globe.eccentricitySquared),
	                minLat = sector.minLatitude * Angle.DEGREES_TO_RADIANS,
	                maxLat = sector.maxLatitude * Angle.DEGREES_TO_RADIANS,
	                minLon = sector.minLongitude * Angle.DEGREES_TO_RADIANS,
	                maxLon = sector.maxLongitude * Angle.DEGREES_TO_RADIANS,
	                deltaLat = (maxLat - minLat) / (numLat > 1 ? numLat - 1 : 1),
	                deltaLon = (maxLon - minLon) / (numLon > 1 ? numLon - 1 : 1),
	                minLatLimit = this.projectionLimits.minLatitude * Angle.DEGREES_TO_RADIANS,
	                maxLatLimit = this.projectionLimits.maxLatitude * Angle.DEGREES_TO_RADIANS,
	                refCenter = referencePoint ? referencePoint : new Vec3(0, 0, 0),
	                offsetX = offset ? offset[0] : 0,
	                latIndex, lonIndex,
	                elevIndex = 0, resultIndex = 0,
	                lat, lon, clampedLat, sinLat, s, y;

	            // Iterate over the latitude and longitude coordinates in the specified sector, computing the Cartesian point
	            // corresponding to each latitude and longitude.
	            for (latIndex = 0, lat = minLat; latIndex < numLat; latIndex++, lat += deltaLat) {
	                if (latIndex === numLat - 1) {
	                    lat = maxLat; // explicitly set the last lat to the max latitude to ensure alignment
	                }

	                // Latitude is constant for each row. Values that are a function of latitude can be computed once per row.
	                clampedLat = WWMath.clamp(lat, minLatLimit, maxLatLimit);
	                sinLat = Math.sin(clampedLat);
	                s = ((1 + sinLat) / (1 - sinLat)) * Math.pow((1 - ecc * sinLat) / (1 + ecc * sinLat), ecc);
	                y = eqr * Math.log(s) * 0.5 - refCenter[1];

	                for (lonIndex = 0, lon = minLon; lonIndex < numLon; lonIndex++, lon += deltaLon) {
	                    if (lonIndex === numLon - 1) {
	                        lon = maxLon; // explicitly set the last lon to the max longitude to ensure alignment
	                    }

	                    result[resultIndex++] = eqr * lon - refCenter[0] + offsetX;
	                    result[resultIndex++] = y;
	                    result[resultIndex++] = elevations[elevIndex++] - refCenter[2];
	                }
	            }

	            return result;
	        };

	        // Documented in base class.
	        ProjectionMercator.prototype.cartesianToGeographic = function (globe, x, y, z, offset, result) {
	            if (!globe) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "ProjectionMercator",
	                    "cartesianToGeographic", "missingGlobe"));
	            }

	            if (!result) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "ProjectionMercator",
	                    "cartesianToGeographic", "missingResult"));
	            }

	            // See "Map Projections: A Working Manual", pages 45 and 19 for the source of the below formulas.

	            var ecc2 = globe.eccentricitySquared,
	                ecc4 = ecc2 * ecc2,
	                ecc6 = ecc4 * ecc2,
	                ecc8 = ecc6 * ecc2,
	                t = Math.pow(Math.E, - y / globe.equatorialRadius),
	                A = Math.PI / 2 - 2 * Math.atan(t),
	                B = ecc2 / 2 + 5 * ecc4 / 24 + ecc6 / 12 + 13 * ecc8 / 360,
	                C = 7 * ecc4 / 48 + 29 * ecc6 / 240 + 811 * ecc8 / 11520,
	                D = 7 * ecc6 / 120 + 81 * ecc8 / 1120,
	                E = 4279 * ecc8 / 161280,
	                Ap = A - C + E,
	                Bp = B - 3 * D,
	                Cp = 2 * C - 8 * E,
	                Dp = 4 * D,
	                Ep = 8 * E,
	                s2p = Math.sin(2 * A),
	                lat = Ap + s2p * (Bp + s2p * (Cp + s2p * (Dp + Ep * s2p)));

	            result.latitude = lat * Angle.RADIANS_TO_DEGREES;
	            result.longitude = ((x - (offset ? offset[0] : 0)) / globe.equatorialRadius) * Angle.RADIANS_TO_DEGREES;
	            result.altitude = z;

	            return result;
	        };

	        return ProjectionMercator;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

	var ProjectionEquirectangular = __webpack_require__(108);

	var ProjectionProgram = __webpack_require__(104);

	var projectionShaderPart =
	    'const float COEFFICIENT = GLOBE_EQUATORIAL_RADIUS * DEGREES_TO_RADIANS;\n' +

	    'vec4 applyProjection(vec4 point) {\n' +
	    '    return vec4(' +
	    '        COEFFICIENT * point.y,\n' +
	    '        COEFFICIENT * point.x,\n' +
	    '        point.z,\n' +
	    '        1.0\n' +
	    '    );\n' +
	    '}\n';

	var EquirectangularProgram = function (gl) {
	    ProjectionProgram.call(this, gl, projectionShaderPart);
	};

	EquirectangularProgram.prototype = Object.create(ProjectionProgram.prototype);

	EquirectangularProgram.key = "EquirectangularProjectionGpuProgram";

	ProjectionEquirectangular.prototype.shader = EquirectangularProgram;

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports ProjectionEquirectangular
	 * @version $Id: ProjectionEquirectangular.js 2821 2015-02-20 16:59:27Z dcollins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(29),
	        __webpack_require__(30),
	        __webpack_require__(103),
	        __webpack_require__(32),
	        __webpack_require__(35)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Angle,
	              ArgumentError,
	              GeographicProjection,
	              Logger,
	              Vec3) {
	        "use strict";

	        /**
	         * Constructs an Equirectangular geographic projection, also known as Equidistant Cylindrical, Plate Carree and
	         * Rectangular. The projected globe is spherical, not ellipsoidal.
	         * @alias ProjectionEquirectangular
	         * @constructor
	         * @augments GeographicProjection
	         * @classdesc Represents an equirectangular geographic projection.
	         */
	        var ProjectionEquirectangular = function () {

	            GeographicProjection.call(this, "Equirectangular", true, null);
	        };

	        ProjectionEquirectangular.prototype = Object.create(GeographicProjection.prototype);

	        Object.defineProperties(ProjectionEquirectangular.prototype, {
	            /**
	             * A string identifying this projection's current state. Used to compare states during rendering to
	             * determine whether globe-state dependent cached values must be updated. Applications typically do not
	             * interact with this property.
	             * @memberof ProjectionEquirectangular.prototype
	             * @readonly
	             * @type {String}
	             */
	            stateKey: {
	                get: function () {
	                    return "projection equirectangular ";
	                }
	            }
	        });

	        // Documented in base class.
	        ProjectionEquirectangular.prototype.geographicToCartesian = function (globe, latitude, longitude, elevation,
	                                                                              offset, result) {
	            if (!globe) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "ProjectionEquirectangular",
	                    "geographicToCartesian", "missingGlobe"));
	            }

	            if (!result) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "ProjectionEquirectangular",
	                    "geographicToCartesian", "missingResult"));
	            }

	            result[0] = globe.equatorialRadius * longitude * Angle.DEGREES_TO_RADIANS + (offset ? offset[0] : 0);
	            result[1] = globe.equatorialRadius * latitude * Angle.DEGREES_TO_RADIANS;
	            result[2] = elevation;

	            return result;
	        };

	        // Documented in base class.
	        ProjectionEquirectangular.prototype.geographicToCartesianGrid = function (globe, sector, numLat, numLon,
	                                                                                  elevations, referencePoint,
	                                                                                  offset, result) {
	            if (!globe) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "ProjectionEquirectangular",
	                    "geographicToCartesianGrid", "missingGlobe"));
	            }

	            if (!sector) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "ProjectionEquirectangular",
	                    "geographicToCartesianGrid", "missingSector"));
	            }

	            if (!elevations || elevations.length < numLat * numLon) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "ProjectionEquirectangular",
	                    "geographicToCartesianGrid",
	                    "The specified elevations array is null, undefined or insufficient length"));
	            }

	            if (!result) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "ProjectionEquirectangular",
	                    "geographicToCartesianGrid", "missingResult"));
	            }

	            var eqr = globe.equatorialRadius,
	                minLat = sector.minLatitude * Angle.DEGREES_TO_RADIANS,
	                maxLat = sector.maxLatitude * Angle.DEGREES_TO_RADIANS,
	                minLon = sector.minLongitude * Angle.DEGREES_TO_RADIANS,
	                maxLon = sector.maxLongitude * Angle.DEGREES_TO_RADIANS,
	                deltaLat = (maxLat - minLat) / (numLat > 1 ? numLat - 1 : 1),
	                deltaLon = (maxLon - minLon) / (numLon > 1 ? numLon - 1 : 1),
	                refPoint = referencePoint ? referencePoint : new Vec3(0, 0, 0),
	                offsetX = offset ? offset[0] : 0,
	                latIndex, lonIndex,
	                elevIndex = 0, resultIndex = 0,
	                lat, lon, y;

	            // Iterate over the latitude and longitude coordinates in the specified sector, computing the Cartesian
	            // point corresponding to each latitude and longitude.
	            for (latIndex = 0, lat = minLat; latIndex < numLat; latIndex++, lat += deltaLat) {
	                if (latIndex === numLat - 1) {
	                    lat = maxLat; // explicitly set the last lat to the max latitude to ensure alignment
	                }

	                // Latitude is constant for each row. Values that are a function of latitude can be computed once per row.
	                y = eqr * lat - refPoint[1];

	                for (lonIndex = 0, lon = minLon; lonIndex < numLon; lonIndex++, lon += deltaLon) {
	                    if (lonIndex === numLon - 1) {
	                        lon = maxLon; // explicitly set the last lon to the max longitude to ensure alignment
	                    }

	                    result[resultIndex++] = eqr * lon - refPoint[0] + offsetX;
	                    result[resultIndex++] = y;
	                    result[resultIndex++] = elevations[elevIndex++] - refPoint[2];
	                }
	            }

	            return result;
	        };

	        // Documented in base class.
	        ProjectionEquirectangular.prototype.cartesianToGeographic = function (globe, x, y, z, offset, result) {
	            if (!globe) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "ProjectionEquirectangular",
	                    "cartesianToGeographic", "missingGlobe"));
	            }

	            if (!result) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "ProjectionEquirectangular",
	                    "cartesianToGeographic", "missingResult"));
	            }

	            result.latitude = (y / globe.equatorialRadius) * Angle.RADIANS_TO_DEGREES;
	            result.longitude = ((x - (offset ? offset[0] : 0)) / globe.equatorialRadius) * Angle.RADIANS_TO_DEGREES;
	            result.altitude = z;

	            return result;
	        };

	        return ProjectionEquirectangular;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports WorldWindow
	 * @version $Id: WorldWindow.js 3402 2015-08-14 17:28:09Z tgaskins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(30),
	        __webpack_require__(121),
	        __webpack_require__(110),
	        __webpack_require__(112),
	        __webpack_require__(113),
	        __webpack_require__(118),
	        __webpack_require__(120),
	        __webpack_require__(49),
	        __webpack_require__(32),
	        __webpack_require__(60),
	        __webpack_require__(65),
	        __webpack_require__(122),
	        __webpack_require__(37),
	        __webpack_require__(75),
	        __webpack_require__(131),
	        __webpack_require__(133),
	        __webpack_require__(115),
	        __webpack_require__(46)], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
	              DrawContext,
	              EarthElevationModel,
	              FrameStatistics,
	              Globe,
	              Globe2D,
	              GoToAnimator,
	              GpuResourceCache,
	              Logger,
	              LookAtNavigator,
	              NavigatorState,
	              PickedObjectList,
	              Rectangle,
	              Sector,
	              SurfaceShape,
	              SurfaceShapeTileBuilder,
	              Terrain,
	              Vec2) {
	        "use strict";

	        /**
	         * Constructs a World Wind window for an HTML canvas.
	         * @alias WorldWindow
	         * @constructor
	         * @classdesc Represents a World Wind window for an HTML canvas.
	         * @param {String} canvasName The name assigned to the HTML canvas in the document.
	         * @param {ElevationModel} elevationModel An optional argument indicating the elevation model to use for the World
	         * Window. If missing or null, a default elevation model is used.
	         * @throws {ArgumentError} If there is no HTML element with the specified name in the document, or if the
	         * HTML canvas does not support WebGL.
	         */
	        var WorldWindow = function (canvasName, elevationModel) {
	            if (!(window.WebGLRenderingContext)) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "WorldWindow", "constructor",
	                        "The specified canvas does not support WebGL."));
	            }

	            // Attempt to get the HTML canvas with the specified name.
	            var canvas = document.getElementById(canvasName);
	            if (!canvas) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "WorldWindow", "constructor",
	                        "The specified canvas name is not in the document."));
	            }

	            // Create the WebGL context associated with the HTML canvas.
	            var gl = this.createContext(canvas);

	            // Internal. Intentionally not documented.
	            this.drawContext = new DrawContext(gl);

	            // Internal. Intentionally not documented. Must be initialized before the navigator is created.
	            this.eventListeners = {};

	            // Internal. Intentionally not documented. Initially true in order to redraw at least once.
	            this.redrawRequested = true;

	            // Internal. Intentionally not documented.
	            this.redrawRequestId = null;

	            /**
	             * The HTML canvas associated with this World Window.
	             * @type {HTMLElement}
	             * @readonly
	             */
	            this.canvas = canvas;

	            /**
	             * The number of bits in the depth buffer associated with this World Window.
	             * @type {number}
	             * @readonly
	             */
	            this.depthBits = gl.getParameter(gl.DEPTH_BITS);

	            /**
	             * The current viewport of this World Window.
	             * @type {Rectangle}
	             * @readonly
	             */
	            this.viewport = new Rectangle(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);

	            /**
	             * The globe displayed.
	             * @type {Globe}
	             */
	            this.globe = new Globe(elevationModel || new EarthElevationModel());

	            /**
	             * The layers to display in this world window.
	             * This property is read-only. Use [addLayer]{@link WorldWindow#addLayer} or
	             * [insertLayer]{@link WorldWindow#insertLayer} to add layers to this world window.
	             * Use [removeLayer]{@link WorldWindow#removeLayer} to remove layers from this world window.
	             * @type {Layer[]}
	             * @readonly
	             */
	            this.layers = [];

	            /**
	             * The navigator used to manipulate the globe.
	             * @type {LookAtNavigator}
	             * @default [LookAtNavigator]{@link LookAtNavigator}
	             */
	            this.navigator = new LookAtNavigator(this);

	            /**
	             * The vertical exaggeration to apply to the terrain.
	             * @type {Number}
	             */
	            this.verticalExaggeration = 1;

	            /**
	             * Indicates that picking will return all objects at the pick point, if any. The top-most object will have
	             * its isOnTop flag set to true.
	             * If deep picking is false, the default, only the top-most object is returned, plus
	             * the picked-terrain object if the pick point is over the terrain.
	             * @type {boolean}
	             * @default false
	             */
	            this.deepPicking = false;

	            /**
	             * Indicates whether this World Window should be configured for sub-surface rendering. If true, shapes
	             * below the terrain can be seen when the terrain is made transparent. If false, sub-surface shapes are
	             * not visible, however, performance is slightly increased.
	             * @type {boolean}
	             * @default false
	             */
	            this.subsurfaceMode = false;

	            /**
	             * The opacity to apply to terrain and surface shapes. This property is typically used when viewing
	             * the sub-surface. It modifies the opacity of the terrain and surface shapes as a whole. It should be
	             * a number between 0 and 1. It is compounded with the individual opacities of the image layers and
	             * surface shapes on the terrain.
	             * @type {Number}
	             * @default 1
	             */
	            this.surfaceOpacity = 1;

	            /**
	             * Performance statistics for this WorldWindow.
	             * @type {FrameStatistics}
	             */
	            this.frameStatistics = new FrameStatistics();

	            /**
	             * The {@link GoToAnimator} used by this world window to respond to its goTo method.
	             * @type {GoToAnimator}
	             */
	            this.goToAnimator = new GoToAnimator(this);

	            // Documented with its property accessor below.
	            this._redrawCallbacks = [];

	            // Documented with its property accessor below.
	            this._orderedRenderingFilters = [
	                function (dc) {
	                    thisWindow.declutter(dc, 1);
	                },
	                function (dc) {
	                    thisWindow.declutter(dc, 2);
	                }
	            ];

	            // Intentionally not documented.
	            this.pixelScale = 1;

	            // Set up to handle WebGL context lost events.
	            var thisWindow = this;

	            function handleContextLost(event) {
	                thisWindow.handleContextLost(event);
	            }

	            this.canvas.addEventListener("webglcontextlost", handleContextLost, false);

	            // Set up to handle WebGL context restored events.
	            function handleContextRestored(event) {
	                thisWindow.handleContextRestored(event);
	            }

	            this.canvas.addEventListener("webglcontextrestored", handleContextRestored, false);

	            // Set up to handle WebGL context events and World Wind redraw request events. Imagery uses the canvas
	            // redraw events because images are generally specific to the WebGL context associated with the canvas.
	            // Elevation models use the global window redraw events because they can be shared among world windows.
	            function handleRedrawEvent(event) {
	                thisWindow.handleRedrawEvent(event)
	            }

	            this.canvas.addEventListener(WorldWind.REDRAW_EVENT_TYPE, handleRedrawEvent, false);
	            window.addEventListener(WorldWind.REDRAW_EVENT_TYPE, handleRedrawEvent, false);

	            // Render to the WebGL context in an animation frame loop until the WebGL context is lost.
	            this.animationFrameLoop();
	        };

	        Object.defineProperties(WorldWindow.prototype, {
	            /**
	             * An array of functions to call during ordered rendering prior to rendering the ordered renderables.
	             * Each function is passed one argument, the current draw context. The function may modify the
	             * ordered renderables in the draw context's ordered renderable list, which has been sorted from front
	             * to back when the filter function is called. Ordered rendering filters are typically used to apply
	             * decluttering. The default set of filter functions contains one function that declutters shapes with
	             * declutter group ID of 1 ({@link GeographicText} by default) and one function that declutters shapes
	             * with declutter group ID 2 ({@link Placemark} by default). Applications can add functions to this
	             * array or remove them.
	             * @type {Function[]}
	             * @default [WorldWindow.declutter]{@link WorldWindow#declutter} with a group ID of 1
	             * @readonly
	             * @memberof WorldWindow.prototype
	             */
	            orderedRenderingFilters: {
	                get: function () {
	                    return this._orderedRenderingFilters;
	                }
	            },
	            /**
	             * The list of callbacks to call immediately before and immediately after performing a redraw. The callbacks
	             * have two arguments: this world window and the redraw stage, e.g., <code style='white-space:nowrap'>redrawCallback(worldWindow, stage);</code>.
	             * The stage will be either WorldWind.BEFORE_REDRAW or WorldWind.AFTER_REDRAW indicating whether the
	             * callback has been called either immediately before or immediately after a redraw, respectively.
	             * Applications may add functions to this array or remove them.
	             * @type {Function[]}
	             * @readonly
	             * @memberof WorldWindow.prototype
	             */
	            redrawCallbacks: {
	                get: function () {
	                    return this._redrawCallbacks;
	                }
	            }
	        });

	        /**
	         * Converts window coordinates to coordinates relative to this World Window's canvas.
	         * @param {Number} x The X coordinate to convert.
	         * @param {Number} y The Y coordinate to convert.
	         * @returns {Vec2} The converted coordinates.
	         */
	        WorldWindow.prototype.canvasCoordinates = function (x, y) {
	            var bbox = this.canvas.getBoundingClientRect(),
	                xc = x - (bbox.left + this.canvas.clientLeft),// * (this.canvas.width / bbox.width),
	                yc = y - (bbox.top + this.canvas.clientTop);// * (this.canvas.height / bbox.height);

	            return new Vec2(xc, yc);
	        };

	        /**
	         * Registers an event listener for the specified event type on this World Window's canvas. This function
	         * delegates the processing of events to the World Window's canvas. For details on this function and its
	         * arguments, see the W3C [EventTarget]{@link https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget}
	         * documentation.
	         *
	         * Registering event listeners using this function enables applications to prevent the World Window's default
	         * navigation behavior. To prevent default navigation behavior, call the [Event]{@link https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-Event}'s
	         * preventDefault method from within an event listener for any events the navigator should not respond to.
	         *
	         * When an event occurs, this calls the registered event listeners in order of reverse registration. Since the
	         * World Window registers its navigator event listeners first, application event listeners are called before
	         * navigator event listeners.
	         *
	         * @param type The event type to listen for.
	         * @param listener The function to call when the event occurs.
	         * @throws {ArgumentError} If any argument is null or undefined.
	         */
	        WorldWindow.prototype.addEventListener = function (type, listener) {
	            if (!type) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "WorldWindow", "addEventListener", "missingType"));
	            }

	            if (!listener) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "WorldWindow", "addEventListener", "missingListener"));
	            }

	            var thisWorldWindow = this;
	            var entry = this.eventListeners[type];
	            if (!entry) {
	                entry = {
	                    listeners: [],
	                    callback: function (event) { // calls listeners in reverse registration order
	                        event.worldWindow = thisWorldWindow;
	                        for (var i = 0, len = entry.listeners.length; i < len; i++) {
	                            entry.listeners[i](event);
	                        }
	                    }
	                };
	                this.eventListeners[type] = entry;
	            }

	            var index = entry.listeners.indexOf(listener);
	            if (index == -1) { // suppress duplicate listeners
	                entry.listeners.splice(0, 0, listener); // insert the listener at the beginning of the list

	                if (entry.listeners.length == 1) { // first listener added, add the event listener callback
	                    this.canvas.addEventListener(type, entry.callback, false);
	                }
	            }
	        };

	        /**
	         * Removes an event listener for the specified event type from this World Window's canvas. The listener must be
	         * the same object passed to addEventListener. Calling removeEventListener with arguments that do not identify a
	         * currently registered listener has no effect.
	         *
	         * @param type Indicates the event type the listener registered for.
	         * @param listener The listener to remove. Must be the same function object passed to addEventListener.
	         * @throws {ArgumentError} If any argument is null or undefined.
	         */
	        WorldWindow.prototype.removeEventListener = function (type, listener) {
	            if (!type) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "WorldWindow", "removeEventListener", "missingType"));
	            }

	            if (!listener) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "WorldWindow", "removeEventListener", "missingListener"));
	            }

	            var entry = this.eventListeners[type];
	            if (!entry) {
	                return; // no entry for the specified type
	            }

	            var index = entry.listeners.indexOf(listener);
	            if (index != -1) {
	                entry.listeners.splice(index, 1); // remove the listener from the list

	                if (entry.listeners.length == 0) { // last listener removed, remove the event listener callback
	                    this.canvas.removeEventListener(type, entry.callback, false);
	                }
	            }
	        };

	        /**
	         * Causes this World Window to redraw itself at the next available opportunity. The redraw occurs on the main
	         * thread at a time of the browser's discretion. Applications should call redraw after changing the World
	         * Window's state, but should not expect that change to be reflected on screen immediately after this function
	         * returns. This is the preferred method for requesting a redraw of the World Window.
	         */
	        WorldWindow.prototype.redraw = function () {
	            this.redrawRequested = true; // redraw during the next animation frame
	        };

	        /**
	         * Requests the World Wind objects displayed at a specified screen-coordinate point.
	         *
	         * If the point intersects the terrain, the returned list contains an object identifying the associated geographic
	         * position. This returns an empty list when nothing in the World Wind scene intersects the specified point.
	         *
	         * @param pickPoint The point to examine in this World Window's screen coordinates.
	         * @returns {PickedObjectList} A list of picked World Wind objects at the specified pick point.
	         * @throws {ArgumentError} If the specified pick point is null or undefined.
	         */
	        WorldWindow.prototype.pick = function (pickPoint) {
	            if (!pickPoint) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "WorldWindow", "pick", "missingPoint"));
	            }

	            // Suppress the picking operation and return an empty list when the WebGL context has been lost.
	            if (this.drawContext.currentGlContext.isContextLost()) {
	                return new PickedObjectList();
	            }

	            this.resize();
	            this.resetDrawContext();
	            this.drawContext.pickingMode = true;
	            this.drawContext.pickPoint = pickPoint;
	            this.drawFrame();

	            return this.drawContext.objectsAtPickPoint;
	        };

	        /**
	         * Requests the position of the World Wind terrain at a specified screen-coordinate point. If the point
	         * intersects the terrain, the returned list contains a single object identifying the associated geographic
	         * position. Otherwise this returns an empty list.
	         * @param pickPoint The point to examine in this World Window's screen coordinates.
	         * @returns {PickedObjectList} A list containing the picked World Wind terrain position at the specified point,
	         * or an empty list if the point does not intersect the terrain.
	         * @throws {ArgumentError} If the specified pick point is null or undefined.
	         */
	        WorldWindow.prototype.pickTerrain = function (pickPoint) {
	            if (!pickPoint) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "WorldWindow", "pickTerrain", "missingPoint"));
	            }

	            // Suppress the picking operation and return an empty list when the WebGL context has been lost.
	            if (this.drawContext.currentGlContext.isContextLost()) {
	                return new PickedObjectList();
	            }

	            this.resize();
	            this.resetDrawContext();
	            this.drawContext.pickingMode = true;
	            this.drawContext.pickTerrainOnly = true;
	            this.drawContext.pickPoint = pickPoint;
	            this.drawFrame();

	            return this.drawContext.objectsAtPickPoint;
	        };

	        /**
	         * Requests the World Wind objects displayed within a specified screen-coordinate region. This returns all
	         * objects that intersect the specified region, regardless of whether or not an object is actually visible, and
	         * marks objects that are visible as on top.
	         * @param {Rectangle} rectangle The screen coordinate rectangle identifying the region to search.
	         * @returns {PickedObjectList} A list of visible World Wind objects within the specified region.
	         * @throws {ArgumentError} If the specified rectangle is null or undefined.
	         */
	        WorldWindow.prototype.pickShapesInRegion = function (rectangle) {
	            if (!rectangle) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "WorldWindow", "pickShapesInRegion", "missingRectangle"));
	            }

	            // Suppress the picking operation and return an empty list when the WebGL context has been lost.
	            if (this.drawContext.currentGlContext.isContextLost()) {
	                return new PickedObjectList();
	            }

	            this.resize();
	            this.resetDrawContext();
	            this.drawContext.pickingMode = true;
	            this.drawContext.regionPicking = true;
	            this.drawContext.pickRectangle =
	                new Rectangle(rectangle.x, this.canvas.height - rectangle.y, rectangle.width, rectangle.height);
	            this.drawFrame();

	            return this.drawContext.objectsAtPickPoint;
	        };

	        // Internal function. Intentionally not documented.
	        WorldWindow.prototype.createContext = function (canvas) {
	            // Request a WebGL context with antialiasing is disabled. Antialiasing causes gaps to appear at the edges of
	            // terrain tiles.
	            var glAttrs = {antialias: false, stencil: true},
	                gl = canvas.getContext("webgl", glAttrs);
	            if (!gl) {
	                gl = canvas.getContext("experimental-webgl", glAttrs);
	            }

	            var actualAttributes = gl.getContextAttributes();
	            this.hasStencilBuffer = actualAttributes.stencil;

	            // uncomment to debug WebGL
	            //var gl = WebGLDebugUtils.makeDebugContext(this.canvas.getContext("webgl"),
	            //        this.throwOnGLError,
	            //        this.logAndValidate
	            //);

	            return gl;
	        };

	        // Internal function. Intentionally not documented.
	        WorldWindow.prototype.handleContextLost = function (event) {
	            Logger.log(Logger.LEVEL_INFO, "WebGL context event: " + event.statusMessage);
	            // Inform WebGL that we handle context restoration, enabling the context restored event to be delivered.
	            event.preventDefault();
	            // Notify the draw context that the WebGL rendering context has been lost.
	            this.drawContext.contextLost();
	            // Stop the rendering animation frame loop, resuming only if the WebGL context is restored.
	            window.cancelAnimationFrame(this.redrawRequestId);
	        };

	        // Internal function. Intentionally not documented.
	        WorldWindow.prototype.handleContextRestored = function (event) {
	            Logger.log(Logger.LEVEL_INFO, "WebGL context event: " + event.statusMessage);
	            // Notify the draw context that the WebGL rendering context has been restored.
	            this.drawContext.contextRestored();
	            // Resume the rendering animation frame loop until the WebGL context is lost.
	            this.redraw();
	            this.animationFrameLoop();
	        };

	        // Internal function. Intentionally not documented.
	        WorldWindow.prototype.handleRedrawEvent = function (event) {
	            this.redraw(); // redraw in the next animation frame
	        };

	        // Internal function. Intentionally not documented.
	        WorldWindow.prototype.animationFrameLoop = function () {
	            // Render to the WebGL context as needed.
	            this.redrawIfNeeded();

	            // Continue the animation frame loop until the WebGL context is lost.
	            var thisWindow = this;

	            function animationFrameCallback() {
	                thisWindow.animationFrameLoop();
	            }

	            this.redrawRequestId = window.requestAnimationFrame(animationFrameCallback);
	        };

	        // Internal function. Intentionally not documented.
	        WorldWindow.prototype.redrawIfNeeded = function () {
	            // Check if the drawing buffer needs to resize to match its screen size, which requires a redraw.
	            this.resize();

	            // Redraw the WebGL drawing buffer only when necessary.
	            if (!this.redrawRequested) {
	                return;
	            }

	            try {
	                // Prepare to redraw and notify the redraw callbacks that a redraw is about to occur.
	                this.redrawRequested = false;
	                this.drawContext.previousRedrawTimestamp = this.drawContext.timestamp;
	                this.callRedrawCallbacks(WorldWind.BEFORE_REDRAW);
	                // Redraw the WebGL drawing buffer.
	                this.resetDrawContext();
	                this.drawFrame();
	            } catch (e) {
	                Logger.logMessage(Logger.LEVEL_SEVERE, "WorldWindow", "redrawIfNeeded",
	                    "Exception occurred during redrawing.\n" + e.toString());
	            } finally {
	                // Notify the redraw callbacks that a redraw has completed.
	                this.callRedrawCallbacks(WorldWind.AFTER_REDRAW);
	                // Handle rendering code redraw requests.
	                if (this.drawContext.redrawRequested) {
	                    this.redrawRequested = true;
	                }
	            }
	        };

	        // Internal function. Intentionally not documented.
	        WorldWindow.prototype.resize = function () {
	            var gl = this.drawContext.currentGlContext,
	                width = gl.canvas.clientWidth * this.pixelScale,
	                height = gl.canvas.clientHeight * this.pixelScale;

	            if (gl.canvas.width != width ||
	                gl.canvas.height != height) {

	                // Make the canvas drawing buffer size match its screen size.
	                gl.canvas.width = width;
	                gl.canvas.height = height;

	                // Set the WebGL viewport to match the canvas drawing buffer size.
	                gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
	                this.viewport = new Rectangle(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);

	                // Cause this World Window to redraw with the new size.
	                this.redrawRequested = true;
	            }
	        };

	        // Internal. Intentionally not documented.
	        WorldWindow.prototype.resetDrawContext = function () {
	            this.globe.offset = 0;

	            var dc = this.drawContext;
	            dc.reset();
	            dc.globe = this.globe;
	            dc.layers = this.layers;
	            dc.navigatorState = this.navigator.currentState();
	            dc.verticalExaggeration = this.verticalExaggeration;
	            dc.surfaceOpacity = this.surfaceOpacity;
	            dc.deepPicking = this.deepPicking;
	            dc.frameStatistics = this.frameStatistics;
	            dc.pixelScale = this.pixelScale;
	            dc.update();
	        };

	        /* useful stuff to debug WebGL */
	        /*
	         function logGLCall(functionName, args) {
	         console.log("gl." + functionName + "(" +
	         WebGLDebugUtils.glFunctionArgsToString(functionName, args) + ")");
	         };

	         function validateNoneOfTheArgsAreUndefined(functionName, args) {
	         for (var ii = 0; ii < args.length; ++ii) {
	         if (args[ii] === undefined) {
	         console.error("undefined passed to gl." + functionName + "(" +
	         WebGLDebugUtils.glFunctionArgsToString(functionName, args) + ")");
	         }
	         }
	         };

	         WorldWindow.prototype.logAndValidate = function logAndValidate(functionName, args) {
	         logGLCall(functionName, args);
	         validateNoneOfTheArgsAreUndefined (functionName, args);
	         };

	         WorldWindow.prototype.throwOnGLError = function throwOnGLError(err, funcName, args) {
	         throw WebGLDebugUtils.glEnumToString(err) + " was caused by call to: " + funcName;
	         };
	         */

	        // Internal function. Intentionally not documented.
	        WorldWindow.prototype.drawFrame = function () {
	            try {
	                this.drawContext.frameStatistics.beginFrame();
	                this.beginFrame();

	                if (this.drawContext.globe.is2D() && this.drawContext.globe.continuous) {
	                    this.do2DContiguousRepaint();
	                } else {
	                    this.doNormalRepaint();
	                }

	            } finally {
	                this.endFrame();
	                this.drawContext.frameStatistics.endFrame();
	                //console.log(this.drawContext.frameStatistics.frameTime);
	            }
	        };

	        WorldWindow.prototype.doNormalRepaint = function () {
	            this.createTerrain();
	            this.clearFrame();
	            this.deferOrderedRendering = false;
	            if (this.drawContext.pickingMode) {
	                if (this.drawContext.makePickFrustum()) {
	                    this.doPick();
	                    this.resolvePick();
	                }
	            } else {
	                this.doDraw();
	                if (this.subsurfaceMode && this.hasStencilBuffer) {
	                    this.redrawSurface();
	                    this.drawScreenRenderables();
	                }
	            }
	        };

	        WorldWindow.prototype.do2DContiguousRepaint = function () {
	            this.createTerrain2DContiguous();
	            this.clearFrame();
	            if (this.drawContext.pickingMode) {
	                if (this.drawContext.makePickFrustum()) {
	                    this.pick2DContiguous();
	                    this.resolvePick();
	                }
	            } else {
	                this.draw2DContiguous();
	            }
	        };

	        WorldWindow.prototype.resolvePick = function () {
	            if (this.drawContext.pickTerrainOnly) {
	                this.resolveTerrainPick();
	            } else if (this.drawContext.regionPicking) {
	                this.resolveRegionPick();
	            } else {
	                this.resolveTopPick();
	            }
	        };

	        // Internal function. Intentionally not documented.
	        WorldWindow.prototype.beginFrame = function () {
	            var gl = this.drawContext.currentGlContext;
	            gl.enable(gl.BLEND);
	            gl.enable(gl.CULL_FACE);
	            gl.enable(gl.DEPTH_TEST);
	            gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
	            gl.depthFunc(gl.LEQUAL);

	            if (this.drawContext.pickingMode) {
	                this.drawContext.makePickFramebuffer();
	                this.drawContext.bindFramebuffer(this.drawContext.pickFramebuffer);
	            }
	        };

	        // Internal function. Intentionally not documented.
	        WorldWindow.prototype.endFrame = function () {
	            var gl = this.drawContext.currentGlContext;
	            gl.disable(gl.BLEND);
	            gl.disable(gl.CULL_FACE);
	            gl.disable(gl.DEPTH_TEST);
	            gl.blendFunc(gl.ONE, gl.ZERO);
	            gl.depthFunc(gl.LESS);
	            gl.clearColor(0, 0, 0, 1);

	            this.drawContext.bindFramebuffer(null);
	            this.drawContext.bindProgram(null);
	        };

	        // Internal function. Intentionally not documented.
	        WorldWindow.prototype.clearFrame = function () {
	            var dc = this.drawContext,
	                gl = dc.currentGlContext;

	            gl.clearColor(dc.clearColor.red, dc.clearColor.green, dc.clearColor.blue, dc.clearColor.alpha);
	            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
	        };

	        // Internal function. Intentionally not documented.
	        WorldWindow.prototype.doDraw = function () {
	            this.drawContext.renderShapes = true;

	            if (this.subsurfaceMode && this.hasStencilBuffer) {
	                // Draw the surface and collect the ordered renderables.
	                this.drawContext.currentGlContext.disable(this.drawContext.currentGlContext.STENCIL_TEST);
	                this.drawContext.surfaceShapeTileBuilder.clear();
	                this.drawLayers(true);
	                this.drawSurfaceRenderables();
	                this.drawContext.surfaceShapeTileBuilder.doRender(this.drawContext);

	                if (!this.deferOrderedRendering) {
	                    // Clear the depth and stencil buffers prior to rendering the ordered renderables. This allows
	                    // sub-surface renderables to be drawn beneath the terrain. Turn on stenciling to capture the
	                    // fragments that ordered renderables draw. The terrain and surface shapes will be subsequently
	                    // drawn again, and the stencil buffer will ensure that they are drawn only where they overlap
	                    // the fragments drawn by the ordered renderables.
	                    this.drawContext.currentGlContext.clear(
	                        this.drawContext.currentGlContext.DEPTH_BUFFER_BIT | this.drawContext.currentGlContext.STENCIL_BUFFER_BIT);
	                    this.drawContext.currentGlContext.enable(this.drawContext.currentGlContext.STENCIL_TEST);
	                    this.drawContext.currentGlContext.stencilFunc(this.drawContext.currentGlContext.ALWAYS, 1, 1);
	                    this.drawContext.currentGlContext.stencilOp(
	                        this.drawContext.currentGlContext.REPLACE, this.drawContext.currentGlContext.REPLACE, this.drawContext.currentGlContext.REPLACE);
	                    this.drawOrderedRenderables();

	                    this.drawContext.screenCreditController.drawCredits(this.drawContext);
	                }
	            } else {
	                this.drawContext.surfaceShapeTileBuilder.clear();
	                this.drawLayers(true);
	                this.drawSurfaceRenderables();
	                this.drawContext.surfaceShapeTileBuilder.doRender(this.drawContext);

	                if (!this.deferOrderedRendering) {
	                    this.drawOrderedRenderables();
	                    this.drawScreenRenderables();
	                }

	                this.drawContext.screenCreditController.drawCredits(this.drawContext);
	            }
	        };

	        WorldWindow.prototype.redrawSurface = function () {
	            // Draw the terrain and surface shapes but only where the current stencil buffer is non-zero.
	            // The non-zero fragments are from drawing the ordered renderables previously.
	            this.drawContext.currentGlContext.enable(this.drawContext.currentGlContext.STENCIL_TEST);
	            this.drawContext.currentGlContext.stencilFunc(this.drawContext.currentGlContext.EQUAL, 1, 1);
	            this.drawContext.currentGlContext.stencilOp(
	                this.drawContext.currentGlContext.KEEP, this.drawContext.currentGlContext.KEEP, this.drawContext.currentGlContext.KEEP);
	            this.drawContext.surfaceShapeTileBuilder.clear();
	            this.drawLayers(false);
	            this.drawSurfaceRenderables();
	            this.drawContext.surfaceShapeTileBuilder.doRender(this.drawContext);
	            this.drawContext.currentGlContext.disable(this.drawContext.currentGlContext.STENCIL_TEST);
	        };

	        // Internal function. Intentionally not documented.
	        WorldWindow.prototype.doPick = function () {
	            if (this.drawContext.terrain) {
	                this.drawContext.terrain.pick(this.drawContext);
	            }

	            if (!this.drawContext.pickTerrainOnly) {
	                if (this.subsurfaceMode && this.hasStencilBuffer) {
	                    // Draw the surface and collect the ordered renderables.
	                    this.drawContext.currentGlContext.disable(this.drawContext.currentGlContext.STENCIL_TEST);
	                    this.drawContext.surfaceShapeTileBuilder.clear();
	                    this.drawLayers(true);
	                    this.drawSurfaceRenderables();
	                    this.drawContext.surfaceShapeTileBuilder.doRender(this.drawContext);

	                    if (!this.deferOrderedRendering) {
	                        // Clear the depth and stencil buffers prior to rendering the ordered renderables. This allows
	                        // sub-surface renderables to be drawn beneath the terrain. Turn on stenciling to capture the
	                        // fragments that ordered renderables draw. The terrain and surface shapes will be subsequently
	                        // drawn again, and the stencil buffer will ensure that they are drawn only where they overlap
	                        // the fragments drawn by the ordered renderables.
	                        this.drawContext.currentGlContext.clear(
	                            this.drawContext.currentGlContext.DEPTH_BUFFER_BIT | this.drawContext.currentGlContext.STENCIL_BUFFER_BIT);
	                        this.drawContext.currentGlContext.enable(this.drawContext.currentGlContext.STENCIL_TEST);
	                        this.drawContext.currentGlContext.stencilFunc(this.drawContext.currentGlContext.ALWAYS, 1, 1);
	                        this.drawContext.currentGlContext.stencilOp(
	                            this.drawContext.currentGlContext.REPLACE, this.drawContext.currentGlContext.REPLACE, this.drawContext.currentGlContext.REPLACE);
	                        this.drawOrderedRenderables();
	                        this.drawContext.terrain.pick(this.drawContext);
	                        this.drawScreenRenderables();
	                    }
	                } else {
	                    this.drawContext.surfaceShapeTileBuilder.clear();

	                    this.drawLayers(true);
	                    this.drawSurfaceRenderables();

	                    this.drawContext.surfaceShapeTileBuilder.doRender(this.drawContext);

	                    if (!this.deferOrderedRendering) {
	                        this.drawOrderedRenderables();
	                        this.drawScreenRenderables();
	                    }
	                }
	            }
	        };

	        // Internal function. Intentionally not documented.
	        WorldWindow.prototype.createTerrain = function () {
	            var dc = this.drawContext;
	            dc.terrain = this.globe.tessellator.tessellate(dc);
	            dc.frameStatistics.setTerrainTileCount(dc.terrain ? dc.terrain.surfaceGeometry.length : 0);
	        };

	        WorldWindow.prototype.makeCurrent = function (offset) {
	            var dc = this.drawContext;
	            dc.globe.offset = offset;
	            dc.globeStateKey = dc.globe.stateKey;

	            switch (offset) {
	                case -1:
	                    dc.terrain = this.terrainLeft;
	                    break;

	                case 0:
	                    dc.terrain = this.terrainCenter;
	                    break;

	                case 1:
	                    dc.terrain = this.terrainRight;
	                    break;
	            }
	        };

	        WorldWindow.prototype.createTerrain2DContiguous = function () {
	            var dc = this.drawContext;

	            this.terrainCenter = null;
	            dc.globe.offset = 0;
	            dc.globeStateKey = dc.globe.stateKey;
	            if (dc.globe.intersectsFrustum(dc.navigatorState.frustumInModelCoordinates)) {
	                this.terrainCenter = dc.globe.tessellator.tessellate(dc);
	            }

	            this.terrainRight = null;
	            dc.globe.offset = 1;
	            dc.globeStateKey = dc.globe.stateKey;
	            if (dc.globe.intersectsFrustum(dc.navigatorState.frustumInModelCoordinates)) {
	                this.terrainRight = dc.globe.tessellator.tessellate(dc);
	            }

	            this.terrainLeft = null;
	            dc.globe.offset = -1;
	            dc.globeStateKey = dc.globe.stateKey;
	            if (dc.globe.intersectsFrustum(dc.navigatorState.frustumInModelCoordinates)) {
	                this.terrainLeft = dc.globe.tessellator.tessellate(dc);
	            }
	        };

	        WorldWindow.prototype.draw2DContiguous = function () {
	            var drawing = "";

	            if (this.terrainCenter) {
	                drawing += " 0 ";
	                this.makeCurrent(0);
	                this.deferOrderedRendering = this.terrainLeft || this.terrainRight;
	                this.doDraw();
	            }

	            if (this.terrainRight) {
	                drawing += " 1 ";
	                this.makeCurrent(1);
	                this.deferOrderedRendering = this.terrainLeft || this.terrainLeft;
	                this.doDraw();
	            }

	            this.deferOrderedRendering = false;

	            if (this.terrainLeft) {
	                drawing += " -1 ";
	                this.makeCurrent(-1);
	                this.doDraw();
	            }
	            //
	            //console.log(drawing);

	            if (this.subsurfaceMode && this.hasStencilBuffer) {
	                this.deferOrderedRendering = true;

	                if (this.terrainCenter) {
	                    drawing += " 0 ";
	                    this.makeCurrent(0);
	                    this.redrawSurface();
	                }

	                if (this.terrainRight) {
	                    drawing += " 1 ";
	                    this.makeCurrent(1);
	                    this.redrawSurface();
	                }

	                if (this.terrainLeft) {
	                    drawing += " -1 ";
	                    this.makeCurrent(-1);
	                    this.redrawSurface();
	                }
	            }

	            this.drawScreenRenderables();
	        };

	        WorldWindow.prototype.pick2DContiguous = function () {
	            if (this.terrainCenter) {
	                this.makeCurrent(0);
	                this.deferOrderedRendering = this.terrainLeft || this.terrainRight;
	                this.doPick();
	            }

	            if (this.terrainRight) {
	                this.makeCurrent(1);
	                this.deferOrderedRendering = this.terrainLeft || this.terrainLeft;
	                this.doPick();
	            }

	            this.deferOrderedRendering = false;

	            if (this.terrainLeft) {
	                this.makeCurrent(-1);
	                this.doPick();
	            }
	        };

	        // Internal function. Intentionally not documented.
	        WorldWindow.prototype.drawLayers = function (accumulateOrderedRenderables) {
	            // Draw all the layers attached to this WorldWindow.

	            var beginTime = Date.now(),
	                dc = this.drawContext,
	                layers = dc.layers,
	                layer;

	            dc.accumulateOrderedRenderables = accumulateOrderedRenderables;

	            for (var i = 0, len = layers.length; i < len; i++) {
	                layer = layers[i];
	                if (layer) {
	                    dc.currentLayer = layer;
	                    try {
	                        layer.render(dc);
	                    } catch (e) {
	                        Logger.log(Logger.LEVEL_SEVERE, "Error while rendering layer " + layer.displayName + ".\n"
	                            + e.toString());
	                        // Keep going. Render the rest of the layers.
	                    }
	                }
	            }

	            var now = Date.now();
	            dc.frameStatistics.layerRenderingTime = now - beginTime;
	        };

	        /**
	         * Adds a specified layer to the end of this world window.
	         * @param {Layer} layer The layer to add. May be null or undefined, in which case this world window is not modified.
	         */
	        WorldWindow.prototype.addLayer = function (layer) {
	            this.layers.push(layer);
	        };

	        /**
	         * Removes the first instance of a specified layer from this world window.
	         * @param {Layer} layer The layer to remove. May be null or undefined, in which case this world window is not
	         * modified. This world window is also not modified if the specified layer does not exist in this world
	         * window's layer list.
	         */
	        WorldWindow.prototype.removeLayer = function (layer) {
	            if (!layer)
	                return;

	            var index = -1;
	            for (var i = 0, len = this.layers.length; i < len; i++) {
	                if (this.layers[i] == layer) {
	                    index = i;
	                    break;
	                }
	            }

	            if (index >= 0) {
	                this.layers.splice(index, 1);
	            }
	        };

	        /**
	         * Inserts a specified layer at a specified position in this world window's layer list.
	         * @param {number} index The index at which to insert the layer. May be negative to specify the position
	         * from the end of the array.
	         * @param {Layer} layer The layer to insert. This world window's layer list is not changed if the specified
	         * layer is null or undefined.
	         */
	        WorldWindow.prototype.insertLayer = function (index, layer) {
	            if (layer) {
	                this.layers.splice(index, 0, layer);
	            }
	        };

	        // Internal function. Intentionally not documented.
	        WorldWindow.prototype.drawSurfaceRenderables = function () {
	            var dc = this.drawContext,
	                sr;

	            dc.reverseSurfaceRenderables();

	            while (sr = dc.popSurfaceRenderable()) {
	                try {
	                    sr.renderSurface(dc);
	                } catch (e) {
	                    Logger.logMessage(Logger.LEVEL_WARNING, "WorldWindow", "drawSurfaceRenderables",
	                        "Error while rendering a surface renderable.\n" + e.message);
	                    // Keep going. Render the rest of the surface renderables.
	                }
	            }
	        };

	        // Internal function. Intentionally not documented.
	        WorldWindow.prototype.drawOrderedRenderables = function () {
	            var beginTime = Date.now(),
	                dc = this.drawContext,
	                or;

	            dc.sortOrderedRenderables();

	            if (this._orderedRenderingFilters) {
	                for (var f = 0; f < this._orderedRenderingFilters.length; f++) {
	                    this._orderedRenderingFilters[f](this.drawContext);
	                }
	            }

	            dc.orderedRenderingMode = true;

	            while (or = dc.popOrderedRenderable()) {
	                try {
	                    or.renderOrdered(dc);
	                } catch (e) {
	                    Logger.logMessage(Logger.LEVEL_WARNING, "WorldWindow", "drawOrderedRenderables",
	                        "Error while rendering an ordered renderable.\n" + e.message);
	                    // Keep going. Render the rest of the ordered renderables.
	                }
	            }

	            dc.orderedRenderingMode = false;
	            dc.frameStatistics.orderedRenderingTime = Date.now() - beginTime;
	        };

	        WorldWindow.prototype.drawScreenRenderables = function () {
	            var dc = this.drawContext,
	                or;

	            while (or = dc.nextScreenRenderable()) {
	                try {
	                    or.renderOrdered(dc);
	                } catch (e) {
	                    Logger.logMessage(Logger.LEVEL_WARNING, "WorldWindow", "drawOrderedRenderables",
	                        "Error while rendering a screen renderable.\n" + e.message);
	                    // Keep going. Render the rest of the screen renderables.
	                }
	            }
	        };

	        // Internal function. Intentionally not documented.
	        WorldWindow.prototype.resolveTopPick = function () {
	            if (this.drawContext.objectsAtPickPoint.objects.length == 0) {
	                return; // nothing picked; avoid calling readPickColor unnecessarily
	            }

	            // Make a last reading to determine what's on top.

	            var pickedObjects = this.drawContext.objectsAtPickPoint,
	                pickColor = this.drawContext.readPickColor(this.drawContext.pickPoint),
	                topObject = null,
	                terrainObject = null;

	            if (pickColor) {
	                // Find the picked object with the top color code and set its isOnTop flag.
	                for (var i = 0, len = pickedObjects.objects.length; i < len; i++) {
	                    var po = pickedObjects.objects[i];

	                    if (po.isTerrain) {
	                        terrainObject = po;
	                    }

	                    if (po.color.equals(pickColor)) {
	                        po.isOnTop = true;
	                        topObject = po;

	                        if (terrainObject) {
	                            break; // no need to search for more than the top object and the terrain object
	                        }
	                    }
	                }

	                // In single-pick mode provide only the top-most object and the terrain object, if any.
	                if (!this.drawContext.deepPicking) {
	                    pickedObjects.clear();
	                    if (topObject) {
	                        pickedObjects.add(topObject);
	                    }
	                    if (terrainObject && terrainObject != topObject) {
	                        pickedObjects.add(terrainObject);
	                    }
	                }
	            } else {
	                pickedObjects.clear(); // nothing drawn at the pick point
	            }
	        };

	        // Internal. Intentionally not documented.
	        WorldWindow.prototype.resolveTerrainPick = function () {
	            var pickedObjects = this.drawContext.objectsAtPickPoint,
	                po;

	            // Mark the first picked terrain object as "on top". The picked object list should contain only one entry
	            // indicating the picked terrain object, but we iterate over the list contents anyway.
	            for (var i = 0, len = pickedObjects.objects.length; i < len; i++) {
	                po = pickedObjects.objects[i];
	                if (po.isTerrain) {
	                    po.isOnTop = true;
	                    break;
	                }
	            }
	        };

	        // Internal. Intentionally not documented.
	        WorldWindow.prototype.resolveRegionPick = function () {
	            if (this.drawContext.objectsAtPickPoint.objects.length == 0) {
	                return; // nothing picked; avoid calling readPickColors unnecessarily
	            }

	            // Mark every picked object with a color in the pick buffer as "on top".

	            var pickedObjects = this.drawContext.objectsAtPickPoint,
	                uniquePickColors = this.drawContext.readPickColors(this.drawContext.pickRectangle),
	                po,
	                color;

	            for (var i = 0, len = pickedObjects.objects.length; i < len; i++) {
	                po = pickedObjects.objects[i];
	                if (!po) continue;
	                var poColor = po.color.toByteString();
	                color = uniquePickColors[poColor];
	                if (color) {
	                    po.isOnTop = true;
	                } else if (po.userObject instanceof SurfaceShape) {
	                    // SurfaceShapes ALWAYS get added to the pick list, since their rendering is deferred
	                    // until the tile they are cached by is rendered. So a SurfaceShape may be in the pick list
	                    // but is not seen in the pick rectangle.
	                    //
	                    // Remove the SurfaceShape that was not visible to the pick rectangle.
	                    pickedObjects.objects.splice(i, 1);
	                    i -= 1;
	                }
	            }
	        };

	        // Internal. Intentionally not documented.
	        WorldWindow.prototype.callRedrawCallbacks = function (stage) {
	            for (var i = 0, len = this._redrawCallbacks.length; i < len; i++) {
	                try {
	                    this._redrawCallbacks[i](this, stage);
	                } catch (e) {
	                    Logger.log(Logger.LEVEL_SEVERE, "Exception calling redraw callback.\n" + e.toString());
	                    // Keep going. Execute the rest of the callbacks.
	                }
	            }
	        };

	        /**
	         * Moves this world window's navigator to a specified location or position.
	         * @param {Location | Position} position The location or position to move the navigator to. If this
	         * argument contains an "altitude" property, as {@link Position} does, the end point of the navigation is
	         * at the specified altitude. Otherwise the end point is at the current altitude of the navigator.
	         *
	         * This function uses this world window's {@link GoToAnimator} property to perform the move. That object's
	         * properties can be specified by the application to modify its behavior during calls to this function.
	         * It's cancel method can also be used to cancel the move initiated by this function.
	         * @param {Function} completionCallback If not null or undefined, specifies a function to call when the
	         * animation completes. The completion callback is called with a single argument, this animator.
	         * @throws {ArgumentError} If the specified location or position is null or undefined.
	         */
	        WorldWindow.prototype.goTo = function (position, completionCallback) {
	            this.goToAnimator.goTo(position, completionCallback);
	        };

	        /**
	         * Declutters the current ordered renderables with a specified group ID. This function is not called by
	         * applications directly. It's meant to be invoked as an ordered rendering filter in this World Window's
	         * [orderedRenderingFilters]{@link WorldWindow#orderedRenderingFilters} property.
	         * <p>
	         * The function operates by setting the target visibility of occluded shapes to 0 and unoccluded shapes to 1.
	         * @param {DrawContext} dc The current draw context.
	         * @param {Number} groupId The ID of the group to declutter. Must not be null, undefined or 0.
	         * @throws {ArgumentError} If the specified group ID is null, undefined or 0.
	         */
	        WorldWindow.prototype.declutter = function (dc, groupId) {
	            if (!groupId) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "WorldWindow", "declutter",
	                        "Group ID is null, undefined or 0."));
	            }

	            // Collect all the declutterables in the specified group.
	            var declutterables = [];
	            for (var i = 0; i < dc.orderedRenderables.length; i++) {
	                var orderedRenderable = dc.orderedRenderables[i].orderedRenderable;
	                if (orderedRenderable.declutterGroup === groupId) {
	                    declutterables.push(orderedRenderable);
	                }
	            }

	            // Filter the declutterables by determining which are partially occluded. Since the ordered renderable
	            // list was already sorted from front to back, the front-most will represent an entire occluded group.
	            var rects = [];
	            for (var j = 0; j < declutterables.length; j++) {
	                var declutterable = declutterables[j],
	                    screenBounds = declutterable.screenBounds;

	                if (screenBounds && screenBounds.intersectsRectangles(rects)) {
	                    declutterable.targetVisibility = 0;
	                } else {
	                    declutterable.targetVisibility = 1;
	                    if (screenBounds) {
	                        rects.push(screenBounds);
	                    }
	                }
	            }
	        };

	        return WorldWindow;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports EarthElevationModel
	 * @version $Id: EarthElevationModel.js 2936 2015-03-27 22:04:59Z tgaskins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(28),
	        __webpack_require__(75),
	        __webpack_require__(97),
	        __webpack_require__(111)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Location,
	              Sector,
	              ElevationModel,
	              WmsUrlBuilder) {
	        "use strict";

	        /**
	         * Constructs an Earth elevation model.
	         * @alias EarthElevationModel
	         * @constructor
	         * @augments ElevationModel
	         * @classdesc Provides elevations for Earth. Elevations are drawn from the NASA World Wind elevation service.
	         */
	        var EarthElevationModel = function () {
	            ElevationModel.call(this,
	                Sector.FULL_SPHERE, new Location(45, 45), 12, "application/bil16", "EarthElevations256", 256, 256);

	            this.displayName = "Earth Elevation Model";
	            this.minElevation = -11000; // Depth of Marianas Trench, in meters
	            this.maxElevation = 8850; // Height of Mt. Everest
	            this.pixelIsPoint = false; // World Wind WMS elevation layers return pixel-as-area images

	            this.urlBuilder = new WmsUrlBuilder("https://worldwind26.arc.nasa.gov/elev",
	                "GEBCO,aster_v2,USGS-NED", "", "1.3.0");
	        };

	        EarthElevationModel.prototype = Object.create(ElevationModel.prototype);

	        return EarthElevationModel;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports WmsUrlBuilder
	 * @version $Id: WmsUrlBuilder.js 3362 2015-07-31 19:29:12Z tgaskins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(30),
	        __webpack_require__(32)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
	              Logger) {
	        "use strict";

	        /**
	         * Constructs a WMS URL builder.
	         * @alias WmsUrlBuilder
	         * @constructor
	         * @classdesc Provides a factory to create URLs for WMS Get Map requests.
	         * @param {String} serviceAddress The address of the WMS server.
	         * @param {String} layerNames The comma-separated list of names of the layers to retrieve.
	         * @param {String} styleNames The comma-separated list of names of the styles to retrieve. May be null.
	         * @param {String} wmsVersion The version of the WMS server. May be null, in which case version 1.3.0 is
	         * assumed.
	         * @param {String} timeString The time parameter included in GetMap requests.
	         * May be null, in which case no time parameter is included in the request.
	         * @throws {ArgumentError} If the service address or layer names are null or empty.
	         *
	         */
	        var WmsUrlBuilder = function (serviceAddress, layerNames, styleNames, wmsVersion, timeString) {
	            if (!serviceAddress || (serviceAddress.length === 0)) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "WmsUrlBuilder", "constructor",
	                        "The WMS service address is missing."));
	            }

	            if (!layerNames || (layerNames.length === 0)) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "WmsUrlBuilder", "constructor",
	                        "The WMS layer names are not specified."));
	            }

	            /**
	             * The address of the WMS server.
	             * @type {String}
	             */
	            this.serviceAddress = serviceAddress;

	            /**
	             * The comma-separated list of layer names to retrieve.
	             * @type {String}
	             */
	            this.layerNames = layerNames;

	            /**
	             * The comma-separated list of style names to retrieve.
	             * @type {String}
	             */
	            this.styleNames = styleNames ? styleNames : "";

	            /**
	             * Indicates whether the layer should be requested with transparency.
	             * @type {Boolean}
	             * @default true
	             */
	            this.transparent = true;

	            /**
	             * The WMS version to specify when requesting resources.
	             * @type {String}
	             * @default 1.3.0
	             */
	            this.wmsVersion = (wmsVersion && wmsVersion.length > 0) ? wmsVersion : "1.3.0";
	            this.isWms130OrGreater = this.wmsVersion >= "1.3.0";

	            /**
	             * The coordinate reference system to use when requesting layers.
	             * @type {String}
	             * @default EPSG:4326
	             */
	            this.crs = "EPSG:4326";

	            /**
	             * The time parameter included in GetMap requests. If null, no time parameter is included in the requests.
	             * @type {String}
	             */
	            this.timeString = timeString;
	        };

	        /**
	         * Creates the URL string for a WMS Get Map request.
	         * @param {Tile} tile The tile for which to create the URL.
	         * @param {String} imageFormat The image format to request.
	         * @throws {ArgumentError} If the specified tile or image format are null or undefined.
	         */
	        WmsUrlBuilder.prototype.urlForTile = function (tile, imageFormat) {
	            if (!tile) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "WmsUrlBuilder", "urlForTile", "missingTile"));
	            }

	            if (!imageFormat) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "WmsUrlBuilder", "urlForTile",
	                        "The image format is null or undefined."));
	            }

	            var sector = tile.sector;

	            var sb = WmsUrlBuilder.fixGetMapString(this.serviceAddress);

	            if (sb.search(/service=wms/i) < 0) {
	                sb = sb + "service=WMS";
	            }

	            sb = sb + "&request=GetMap";
	            sb = sb + "&version=" + this.wmsVersion;
	            sb = sb + "&transparent=" + (this.transparent ? "TRUE" : "FALSE");
	            sb = sb + "&layers=" + this.layerNames;
	            sb = sb + "&styles=" + this.styleNames;
	            sb = sb + "&format=" + imageFormat;
	            sb = sb + "&width=" + tile.tileWidth;
	            sb = sb + "&height=" + tile.tileHeight;

	            if (this.timeString) {
	                sb = sb + "&time=" + this.timeString;
	            }

	            if (this.isWms130OrGreater) {
	                sb = sb + "&crs=" + this.crs;
	                sb = sb + "&bbox=";
	                if (this.crs === "CRS:84") {
	                    sb = sb + sector.minLongitude + "," + sector.minLatitude + ",";
	                    sb = sb + sector.maxLongitude+ "," + sector.maxLatitude;
	                } else {
	                    sb = sb + sector.minLatitude + "," + sector.minLongitude + ",";
	                    sb = sb + sector.maxLatitude+ "," + sector.maxLongitude;
	                }
	            } else {
	                sb = sb + "&srs=" + this.crs;
	                sb = sb + "&bbox=";
	                sb = sb + sector.minLongitude + "," + sector.minLatitude + ",";
	                sb = sb + sector.maxLongitude+ "," + sector.maxLatitude;
	            }

	            sb = sb.replace(" ", "%20");

	            return sb;
	        };

	        // Intentionally not documented.
	        WmsUrlBuilder.fixGetMapString = function (serviceAddress) {
	            if (!serviceAddress) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "WmsUrlBuilder", "fixGetMapString",
	                        "The specified service address is null or undefined."));
	            }

	            var index = serviceAddress.indexOf("?");

	            if (index < 0) { // if string contains no question mark
	                serviceAddress = serviceAddress + "?"; // add one
	            } else if (index !== serviceAddress.length - 1) { // else if question mark not at end of string
	                index = serviceAddress.search(/&$/);
	                if (index < 0) {
	                    serviceAddress = serviceAddress + "&"; // add a parameter separator
	                }
	            }

	            return serviceAddress;
	        };

	        return WmsUrlBuilder;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports FrameStatistics
	 * @version $Id: FrameStatistics.js 3343 2015-07-28 18:22:59Z dcollins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	        "use strict";

	        /**
	         * Constructs a performance statistics instance. This is performed internally by the {@link WorldWindow}.
	         * Applications do not construct instances of this class.
	         * @alias FrameStatistics
	         * @constructor
	         * @classdesc Captures performance statistics.
	         */
	        var FrameStatistics = function () {

	            // Internal: intentionally not documented
	            this.frameCount = 0;

	            // Internal: intentionally not documented
	            this.frameTimeCumulative = 0;

	            // Internal: intentionally not documented
	            this.frameTimeBase = 0;

	            // Internal: intentionally not documented
	            this.frameTimeExtremes = [Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY];

	            /**
	             * The number of milliseconds required to render the most recent frame.
	             * @type {Number}
	             */
	            this.frameTime = 0;

	            /**
	             * The number of milliseconds spent tessellating the terrain during the most recent frame.
	             * @type {Number}
	             */
	            this.tessellationTime = 0;

	            /**
	             * The number of milliseconds spent rendering the active layers during the most recent frame.
	             * @type {Number}
	             */
	            this.layerRenderingTime = 0;

	            /**
	             * The number of milliseconds spent rendering ordered renderables during the most recent frame.
	             * @type {Number}
	             */
	            this.orderedRenderingTime = 0;

	            /**
	             * The number of terrain tiles in the most recent frame.
	             * @type {Number}
	             */
	            this.terrainTileCount = 0;

	            /**
	             * The number of image tiles in the most recent frame.
	             * @type {Number}
	             */
	            this.imageTileCount = 0;

	            /**
	             * The number of terrain tile renderings. Since terrain tiles are generally rendered more than once per
	             * frame, this count will be greater than the number of terrain tiles created for the frame.
	             * @type {Number}
	             */
	            this.renderedTileCount = 0;

	            /**
	             * The number of calls to [Tile.update()]{@link Tile#update} during the most recent frame.
	             * @type {Number}
	             */
	            this.tileUpdateCount = 0;

	            /**
	             * The number of texture bind calls during the most recent frame.
	             * @type {Number}
	             */
	            this.textureLoadCount = 0;

	            /**
	             * The number of WebGL VBO loads during the most recent frame.
	             * @type {Number}
	             */
	            this.vboLoadCount = 0;

	            /**
	             * The average frame time over the most recent two seconds.
	             * @type {Number}
	             */
	            this.frameTimeAverage = 0;

	            /**
	             * The average frame rate over the most recent two seconds.
	             * @type {Number}
	             */
	            this.frameRateAverage = 0;

	            /**
	             * The minimum frame time over the most recent two seconds.
	             * @type {Number}
	             */
	            this.frameTimeMin = 0;

	            /**
	             * The maximum frame time over the most recent two seconds.
	             * @type {Number}
	             */
	            this.frameTimeMax = 0;
	        };

	        /**
	         * Initializes this frame statistics with initial values.
	         */
	        FrameStatistics.prototype.beginFrame = function () {
	            this.frameTime = Date.now();
	            this.tessellationTime = 0;
	            this.layerRenderingTime = 0;
	            this.orderedRenderingTime = 0;
	            this.terrainTileCount = 0;
	            this.imageTileCount = 0;
	            this.renderedTileCount = 0;
	            this.tileUpdateCount = 0;
	            this.textureLoadCount = 0;
	            this.vboLoadCount = 0;

	            ++this.frameCount;
	        };

	        /**
	         * Computes the statistics for the most recent frame.
	         */
	        FrameStatistics.prototype.endFrame = function () {
	            var now = Date.now();
	            this.frameTime = now - this.frameTime;
	            this.frameTimeCumulative += this.frameTime;
	            this.frameTimeExtremes[0] = Math.min(this.frameTimeExtremes[0], this.frameTime);
	            this.frameTimeExtremes[1] = Math.max(this.frameTimeExtremes[1], this.frameTime);

	            // Compute averages every 2 seconds.
	            if (now - this.frameTimeBase > 2000) {
	                this.frameTimeAverage = this.frameTimeCumulative / this.frameCount;
	                this.frameRateAverage = 1000 * this.frameCount / (now - this.frameTimeBase);
	                this.frameTimeMin = this.frameTimeExtremes[0];
	                this.frameTimeMax = this.frameTimeExtremes[1];
	                this.frameCount = 0;
	                this.frameTimeCumulative = 0;
	                this.frameTimeBase = now;
	                this.frameTimeExtremes = [Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY];
	                //console.log(this.frameTimeAverage.toString() + ", " + this.frameRateAverage.toString());
	            }
	        };

	        /**
	         * Increments the rendered tile count.
	         * @param {Number} tileCount The amount to increment the counter.
	         */
	        FrameStatistics.prototype.incrementRenderedTileCount = function (tileCount) {
	            this.renderedTileCount += tileCount;
	        };

	        /**
	         * Sets the terrain tile count.
	         * @param {Number} tileCount The amount to set the counter to.
	         */
	        FrameStatistics.prototype.setTerrainTileCount = function (tileCount) {
	            this.terrainTileCount = tileCount;
	        };

	        /**
	         * Increments the image tile count.
	         * @param {Number} tileCount The amount to increment the counter.
	         */
	        FrameStatistics.prototype.incrementImageTileCount = function (tileCount) {
	            this.imageTileCount = tileCount;
	        };

	        /**
	         * Increments the tile update count.
	         * @param {Number} count The amount to increment the counter.
	         */
	        FrameStatistics.prototype.incrementTileUpdateCount = function (count) {
	            this.tileUpdateCount += count;
	        };

	        /**
	         * Increments the texture load count.
	         * @param {Number} count The amount to increment the counter.
	         */
	        FrameStatistics.prototype.incrementTextureLoadCount = function (count) {
	            this.textureLoadCount += count;
	        };

	        /**
	         * Increments the VBO load count.
	         * @param {Number} count The amount to increment the counter.
	         */
	        FrameStatistics.prototype.incrementVboLoadCount = function (count) {
	            this.vboLoadCount += count;
	        };

	        return FrameStatistics;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports Globe
	 * @version $Id: Globe.js 2940 2015-03-30 17:58:36Z tgaskins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(29),
	        __webpack_require__(30),
	        __webpack_require__(78),
	        __webpack_require__(97),
	        __webpack_require__(34),
	        __webpack_require__(28),
	        __webpack_require__(32),
	        __webpack_require__(47),
	        __webpack_require__(102),
	        __webpack_require__(75),
	        __webpack_require__(114),
	        __webpack_require__(35),
	        __webpack_require__(36)], __WEBPACK_AMD_DEFINE_RESULT__ = function (Angle,
	              ArgumentError,
	              BoundingBox,
	              ElevationModel,
	              Line,
	              Location,
	              Logger,
	              Position,
	              ProjectionWgs84,
	              Sector,
	              Tessellator,
	              Vec3,
	              WWMath) {
	        "use strict";

	        /**
	         * Constructs an ellipsoidal Globe with default radii for Earth (WGS84).
	         * @alias Globe
	         * @constructor
	         * @classdesc Represents an ellipsoidal globe. The default configuration represents Earth but may be changed.
	         * To configure for another planet, set the globe's equatorial and polar radii properties and its
	         * eccentricity-squared property.
	         * <p>
	         * A globe uses a Cartesian coordinate system whose origin is at the globe's center. It's Y axis points to the
	         * north pole, the Z axis points to the intersection of the prime meridian and the equator,
	         * and the X axis completes a right-handed coordinate system, is in the equatorial plane and 90 degrees east
	         * of the Z axis.
	         * <p>
	         *     All Cartesian coordinates and elevations are in meters.

	         * @param {ElevationModel} elevationModel The elevation model to use for this globe.
	         * @param {GeographicProjection} projection The projection to apply to the globe. May be null or undefined,
	         * in which case no projection is applied and the globe is a WGS84 ellipsoid.
	         * @throws {ArgumentError} If the specified elevation model is null or undefined.
	         */
	        var Globe = function (elevationModel, projection) {
	            if (!elevationModel) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "Globe",
	                    "constructor", "Elevation model is null or undefined."));
	            }
	            /**
	             * This globe's elevation model.
	             * @type {ElevationModel}
	             */
	            this.elevationModel = elevationModel;

	            /**
	             * This globe's equatorial radius.
	             * @type {Number}
	             * @default 6378137.0 meters
	             */
	            this.equatorialRadius = 6378137.0;

	            /**
	             * This globe's polar radius.
	             * @type {Number}
	             * @default 6356752.3 meters
	             */
	            this.polarRadius = 6356752.3;

	            /**
	             * This globe's eccentricity squared.
	             * @type {Number}
	             * @default 0.00669437999013
	             */
	            this.eccentricitySquared = 0.00669437999013;

	            /**
	             * The tessellator used to create this globe's terrain.
	             * @type {Tessellator}
	             */
	            this.tessellator = new Tessellator();

	            // Internal. Intentionally not documented.
	            this._projection = projection || new ProjectionWgs84();

	            // Internal. Intentionally not documented.
	            this._offset = 0;

	            // Internal. Intentionally not documented.
	            this.offsetVector = new Vec3(0, 0, 0);

	            // A unique ID for this globe. Intentionally not documented.
	            this.id = ++Globe.idPool;

	            this._stateKey = "globe " + this.id.toString() + " ";
	        };

	        Globe.idPool = 0; // Used to assign unique IDs to globes for use in their state keys.

	        Object.defineProperties(Globe.prototype, {
	            /**
	             * A string identifying this globe's current state. Used to compare states during rendering to
	             * determine whether globe-state dependent cached values must be updated. Applications typically do not
	             * interact with this property.
	             * @memberof Globe.prototype
	             * @readonly
	             * @type {String}
	             */
	            stateKey: {
	                get: function () {
	                    return this._stateKey + this.elevationModel.stateKey + "offset " + this.offset.toString() + " "
	                        + this.projection.stateKey;
	                }
	            },

	            /**
	             * Indicates whether this globe is 2D and continuous with itself -- that it should scroll continuously
	             * horizontally.
	             * @memberof Globe.prototype
	             * @readonly
	             * @type {Boolean}
	             */
	            continuous: {
	                get: function () {
	                    return this.projection.continuous;
	                }
	            },

	            /**
	             * The projection used by this globe.
	             * @memberof Globe.prototype
	             * @default {@link ProjectionWgs84}
	             * @type {GeographicProjection}
	             */
	            projection: {
	                get: function () {
	                    return this._projection;
	                },
	                set: function (projection) {
	                    if (!projection) {
	                        throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "Globe",
	                            "projection", "missingProjection"));
	                    }

	                    if (this.projection != projection) {
	                        this.tessellator = new Tessellator();
	                    }
	                    this._projection = projection;
	                }
	            },

	            /**
	             * The projection limits of the associated projection.
	             * @memberof Globe.prototype
	             * @type {Sector}
	             */
	            projectionLimits: {
	                get: function () {
	                    return this._projection.projectionLimits;
	                }
	            },

	            /**
	             * An offset to apply to this globe when translating between Geographic positions and Cartesian points.
	             * Used during scrolling to position points appropriately.
	             * Applications typically do not access this property. It is used by the associated globe.
	             * @memberof Globe.prototype
	             * @type {Number}
	             */
	            offset: {
	                get: function () {
	                    return this._offset;
	                },
	                set: function (offset) {
	                    this._offset = offset;
	                    this.offsetVector[0] = offset * 2 * Math.PI * this.equatorialRadius;
	                }
	            }
	        });

	        /**
	         * Indicates whether this is a 2D globe.
	         * @returns {Boolean} true if this is a 2D globe, otherwise false.
	         */
	        Globe.prototype.is2D = function () {
	            return this.projection.is2D;
	        };

	        /**
	         * Computes a Cartesian point from a specified position.
	         * See this class' Overview section for a description of the Cartesian coordinate system used.
	         * @param {Number} latitude The position's latitude.
	         * @param {Number} longitude The position's longitude.
	         * @param {Number} altitude The position's altitude.
	         * @param {Vec3} result A reference to a pre-allocated {@link Vec3} in which to return the computed X,
	         * Y and Z Cartesian coordinates.
	         * @returns {Vec3} The result argument.
	         * @throws {ArgumentError} If the specified result argument is null or undefined.
	         */
	        Globe.prototype.computePointFromPosition = function (latitude, longitude, altitude, result) {
	            if (!result) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "Globe", "computePointFromPosition",
	                    "missingResult"));
	            }

	            return this.projection.geographicToCartesian(this, latitude, longitude, altitude, this.offsetVector, result);
	        };

	        /**
	         * Computes a Cartesian point from a specified location.
	         * See this class' Overview section for a description of the Cartesian coordinate system used.
	         * @param {Number} latitude The position's latitude.
	         * @param {Number} longitude The position's longitude.
	         * @param {Vec3} result A reference to a pre-allocated {@link Vec3} in which to return the computed X,
	         * Y and Z Cartesian coordinates.
	         * @returns {Vec3} The result argument.
	         * @throws {ArgumentError} If the specified result argument is null or undefined.
	         */
	        Globe.prototype.computePointFromLocation = function (latitude, longitude, result) {
	            if (!result) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "Globe", "computePointFromLocation",
	                    "missingResult"));
	            }

	            return this.computePointFromPosition(latitude, longitude, 0, result);
	        };

	        /**
	         * Computes a grid of Cartesian points within a specified sector and relative to a specified Cartesian
	         * reference point.
	         * <p>
	         * This method is used to compute a collection of points within a sector. It is used by tessellators to
	         * efficiently generate a tile's interior points. The number of points to generate is indicated by the numLon
	         * and numLat parameters.
	         * <p>
	         * For each implied position within the sector, an elevation value is specified via an array of elevations. The
	         * calculation at each position incorporates the associated elevation. There must be numLat x numLon elevations
	         * in the array.
	         *
	         * @param {Sector} sector The sector for which to compute the points.
	         * @param {Number} numLat The number of latitudinal points in the grid.
	         * @param {Number} numLon The number of longitudinal points in the grid.
	         * @param {Number[]} elevations An array of elevations to incorporate in the point calculations. There must be
	         * one elevation value in the array for each generated point. Elevations are in meters. There must be
	         * numLat x numLon elevations in the array.
	         * @param {Vec3} referencePoint The X, Y and Z Cartesian coordinates to subtract from the computed coordinates.
	         * This makes the computed coordinates relative to the specified point.
	         * @param {Float32Array} result A typed array to hold the computed coordinates. It must be at least of
	         * size numLat x numLon. The points are returned in row major order, beginning with the row of minimum latitude.
	         * @returns {Float32Array} The specified result argument.
	         * @throws {ArgumentError} if the specified sector, elevations array or results arrays are null or undefined, or
	         * if the lengths of any of the arrays are insufficient.
	         */
	        Globe.prototype.computePointsForGrid = function (sector, numLat, numLon, elevations, referencePoint, result) {
	            if (!sector) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "Globe",
	                    "computePointsFromPositions", "missingSector"));
	            }

	            if (numLat < 1 || numLon < 1) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "Globe", "computePointsFromPositions",
	                    "Number of latitude or longitude locations is less than one."));
	            }

	            var numPoints = numLat * numLon;
	            if (!elevations || elevations.length < numPoints) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "Globe", "computePointsFromPositions",
	                    "Elevations array is null, undefined or insufficient length."));
	            }

	            if (!result || result.length < numPoints) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "Globe", "computePointsFromPositions",
	                    "Result array is null, undefined or insufficient length."));
	            }

	            return this.projection.geographicToCartesianGrid(this, sector, numLat, numLon, elevations, referencePoint,
	                this.offsetVector, result);
	        };

	        /**
	         * Computes a geographic position from a specified Cartesian point.
	         *
	         * See this class' Overview section for a description of the Cartesian coordinate system used.
	         *
	         * @param {Number} x The X coordinate.
	         * @param {Number} y The Y coordinate.
	         * @param {Number} z The Z coordinate.
	         * @param {Position} result A pre-allocated {@link Position} instance in which to return the computed position.
	         * @returns {Position} The specified result position.
	         * @throws {ArgumentError} If the specified result argument is null or undefined.
	         */
	        Globe.prototype.computePositionFromPoint = function (x, y, z, result) {
	            if (!result) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "Globe", "computePositionFromPoint",
	                    "missingResult"));
	            }

	            this.projection.cartesianToGeographic(this, x, y, z, this.offsetVector, result);

	            // Wrap if the globe is continuous.
	            if (this.continuous) {
	                if (result.longitude < -180) {
	                    result.longitude += 360;
	                } else if (result.longitude > 180) {
	                    result.longitude -= 360;
	                }
	            }

	            return result;
	        };

	        /**
	         * Computes the radius of this globe at a specified location.
	         * @param {Number} latitude The locations' latitude.
	         * @param {Number} longitude The locations' longitude.
	         * @returns {Number} The radius at the specified location.
	         */
	        Globe.prototype.radiusAt = function (latitude, longitude) {
	            var sinLat = Math.sin(latitude * Angle.DEGREES_TO_RADIANS),
	                rpm = this.equatorialRadius / Math.sqrt(1.0 - this.eccentricitySquared * sinLat * sinLat);

	            return rpm * Math.sqrt(1.0 + (this.eccentricitySquared * this.eccentricitySquared - 2.0 * this.eccentricitySquared) * sinLat * sinLat);
	        };

	        /**
	         * Computes the normal vector to this globe's surface at a specified location.
	         * @param {Number} latitude The location's latitude.
	         * @param {Number} longitude The location's longitude.
	         * @param {Vec3} result A pre-allocated {@Link Vec3} instance in which to return the computed vector. The returned
	         * normal vector is unit length.
	         * @returns {Vec3} The specified result vector.  The returned normal vector is unit length.
	         * @throws {ArgumentError} If the specified result argument is null or undefined.
	         */
	        Globe.prototype.surfaceNormalAtLocation = function (latitude, longitude, result) {
	            if (!result) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "Globe", "surfaceNormalAtLocation",
	                    "missingResult"));
	            }

	            if (this.is2D()) {
	                result[0] = 0;
	                result[1] = 0;
	                result[2] = 1;

	                return result;
	            }

	            var cosLat = Math.cos(latitude * Angle.DEGREES_TO_RADIANS),
	                cosLon = Math.cos(longitude * Angle.DEGREES_TO_RADIANS),
	                sinLat = Math.sin(latitude * Angle.DEGREES_TO_RADIANS),
	                sinLon = Math.sin(longitude * Angle.DEGREES_TO_RADIANS),
	                eqSquared = this.equatorialRadius * this.equatorialRadius,
	                polSquared = this.polarRadius * this.polarRadius;

	            result[0] = cosLat * sinLon / eqSquared;
	            result[1] = (1 - this.eccentricitySquared) * sinLat / polSquared;
	            result[2] = cosLat * cosLon / eqSquared;

	            return result.normalize();
	        };

	        /**
	         * Computes the normal vector to this globe's surface at a specified Cartesian point.
	         * @param {Number} x The point's X coordinate.
	         * @param {Number} y The point's Y coordinate.
	         * @param {Number} z The point's Z coordinate.
	         * @param {Vec3} result A pre-allocated {@Link Vec3} instance in which to return the computed vector. The returned
	         * normal vector is unit length.
	         * @returns {Vec3} The specified result vector.
	         * @throws {ArgumentError} If the specified result argument is null or undefined.
	         */
	        Globe.prototype.surfaceNormalAtPoint = function (x, y, z, result) {
	            if (!result) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "Globe", "surfaceNormalAtPoint",
	                    "missingResult"));
	            }

	            // For backwards compatibility, check whether the projection defines a surfaceNormalAtPoint function
	            // before calling it. If it's not available, use the old code to compute the normal.
	            if (this.projection.surfaceNormalAtPoint) {
	                return this.projection.surfaceNormalAtPoint(this, x, y, z, result);
	            }

	            if (this.is2D()) {
	                result[0] = 0;
	                result[1] = 0;
	                result[2] = 1;

	                return result;
	            }

	            var eSquared = this.equatorialRadius * this.equatorialRadius,
	                polSquared = this.polarRadius * this.polarRadius;

	            result[0] = x / eSquared;
	            result[1] = y / polSquared;
	            result[2] = z / eSquared;

	            return result.normalize();
	        };

	        /**
	         * Computes the north-pointing tangent vector to this globe's surface at a specified location.
	         * @param {Number} latitude The location's latitude.
	         * @param {Number} longitude The location's longitude.
	         * @param {Vec3} result A pre-allocated {@Link Vec3} instance in which to return the computed vector. The returned
	         * tangent vector is unit length.
	         * @returns {Vec3} The specified result vector.
	         * @throws {ArgumentError} If the specified result argument is null or undefined.
	         */
	        Globe.prototype.northTangentAtLocation = function (latitude, longitude, result) {
	            if (!result) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "Globe", "northTangentAtLocation",
	                    "missingResult"));
	            }

	            return this.projection.northTangentAtLocation(this, latitude, longitude, result);
	        };

	        /**
	         * Computes the north-pointing tangent vector to this globe's surface at a specified Cartesian point.
	         * @param {Number} x The point's X coordinate.
	         * @param {Number} y The point's Y coordinate.
	         * @param {Number} z The point's Z coordinate.
	         * @param {Vec3} result A pre-allocated {@Link Vec3} instance in which to return the computed vector. The returned
	         * tangent vector is unit length.
	         * @returns {Vec3} The specified result vector.
	         * @throws {ArgumentError} If the specified result argument is null or undefined.
	         */
	        Globe.prototype.northTangentAtPoint = function (x, y, z, result) {
	            if (!result) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "Globe", "northTangentAtPoint",
	                    "missingResult"));
	            }

	            return this.projection.northTangentAtPoint(this, x, y, z, this.offsetVector, result);
	        };

	        /**
	         * Indicates whether this globe intersects a specified frustum.
	         * @param {Frustum} frustum The frustum to test.
	         * @returns {Boolean} true if this globe intersects the frustum, otherwise false.
	         * @throws {ArgumentError} If the specified frustum is null or undefined.
	         */
	        Globe.prototype.intersectsFrustum = function (frustum) {
	            if (!frustum) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Globe", "intersectsFrustum", "missingFrustum"));
	            }

	            if (this.is2D()) {
	                var bbox = new BoundingBox();
	                bbox.setToSector(Sector.FULL_SPHERE, this, this.elevationModel.minElevation,
	                    this.elevationModel.maxElevation);

	                return bbox.intersectsFrustum(frustum);
	            }

	            if (frustum.far.distance <= this.equatorialRadius)
	                return false;
	            if (frustum.left.distance <= this.equatorialRadius)
	                return false;
	            if (frustum.right.distance <= this.equatorialRadius)
	                return false;
	            if (frustum.top.distance <= this.equatorialRadius)
	                return false;
	            if (frustum.bottom.distance <= this.equatorialRadius)
	                return false;
	            if (frustum.near.distance <= this.equatorialRadius)
	                return false;

	            return true;
	        };

	        /**
	         * Computes the first intersection of this globe with a specified line. The line is interpreted as a ray;
	         * intersection points behind the line's origin are ignored.
	         * @param {Line} line The line to intersect with this globe.
	         * @param {Vec3} result A pre-allocated Vec3 in which to return the computed point.
	         * @returns {boolean} true If the ray intersects the globe, otherwise false.
	         * @throws {ArgumentError} If the specified line or result argument is null or undefined.
	         */
	        Globe.prototype.intersectsLine = function (line, result) {
	            if (!line) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Globe", "intersectWithRay", "missingLine"));
	            }

	            if (!result) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "Globe", "intersectsLine", "missingResult"));
	            }

	            if (this.is2D()) {
	                var vx = line.direction[0],
	                    vy = line.direction[1],
	                    vz = line.direction[2],
	                    sx = line.origin[0],
	                    sy = line.origin[1],
	                    sz = line.origin[2],
	                    t;

	                if (vz == 0 && sz != 0) { // ray is parallel to and not coincident with the XY plane
	                    return false;
	                }

	                t = -sz / vz; // intersection distance, simplified for the XY plane
	                if (t < 0) { // intersection is behind the ray's origin
	                    return false;
	                }

	                result[0] = sx + vx * t;
	                result[1] = sy + vy * t;
	                result[2] = sz + vz * t;

	                return true;
	            }

	            return WWMath.computeEllipsoidalGlobeIntersection(line, this.equatorialRadius, this.polarRadius, result);
	        };

	        /**
	         * Returns the time at which any elevations associated with this globe last changed.
	         * @returns {Number} The time in milliseconds relative to the Epoch of the most recent elevation change.
	         */
	        Globe.prototype.elevationTimestamp = function () {
	            return this.elevationModel.timestamp;
	        };

	        /**
	         * Returns this globe's minimum elevation.
	         * @returns {Number} This globe's minimum elevation.
	         */
	        Globe.prototype.minElevation = function () {
	            return this.elevationModel.minElevation
	        };

	        /**
	         * Returns this globe's maximum elevation.
	         * @returns {Number} This globe's maximum elevation.
	         */
	        Globe.prototype.maxElevation = function () {
	            return this.elevationModel.maxElevation
	        };

	        /**
	         * Returns the minimum and maximum elevations within a specified sector of this globe.
	         * @param {Sector} sector The sector for which to determine extreme elevations.
	         * @returns {Number[]} The An array containing the minimum and maximum elevations.
	         * @throws {ArgumentError} If the specified sector is null or undefined.
	         */
	        Globe.prototype.minAndMaxElevationsForSector = function (sector) {
	            if (!sector) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Globe", "minAndMaxElevationsForSector",
	                        "missingSector"));
	            }

	            return this.elevationModel.minAndMaxElevationsForSector(sector);
	        };

	        /**
	         * Returns the elevation at a specified location.
	         * @param {Number} latitude The location's latitude in degrees.
	         * @param {Number} longitude The location's longitude in degrees.
	         * @returns {Number} The elevation at the specified location, in meters. Returns zero if the location is
	         * outside the coverage area of this elevation model.
	         */
	        Globe.prototype.elevationAtLocation = function (latitude, longitude) {
	            return this.elevationModel.elevationAtLocation(latitude, longitude);
	        };

	        /**
	         * Returns the elevations at locations within a specified sector.
	         * @param {Sector} sector The sector for which to determine the elevations.
	         * @param {Number} numLat The number of latitudinal sample locations within the sector.
	         * @param {Number} numLon The number of longitudinal sample locations within the sector.
	         * @param {Number} targetResolution The desired elevation resolution, in radians. (To compute radians from
	         * meters, divide the number of meters by the globe's radius.)
	         * @param {Number[]} result An array in which to return the requested elevations.
	         * @returns {Number} The resolution actually achieved, which may be greater than that requested if the
	         * elevation data for the requested resolution is not currently available.
	         * @throws {ArgumentError} If the specified sector or result array is null or undefined, or if either of the
	         * specified numLat or numLon values is less than one.
	         */
	        Globe.prototype.elevationsForGrid = function (sector, numLat, numLon, targetResolution, result) {
	            if (!sector) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Globe", "elevationsForSector", "missingSector"));
	            }

	            if (numLat <= 0 || numLon <= 0) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "Globe",
	                    "elevationsForSector", "numLat or numLon is less than 1"));
	            }

	            if (!result || result.length < numLat * numLon) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "Globe",
	                    "elevationsForSector", "missingArray"));
	            }

	            return this.elevationModel.elevationsForGrid(sector, numLat, numLon, targetResolution, result);
	        };

	        return Globe;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
	;

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports Tessellator
	 * @version $Id: Tessellator.js 3345 2015-07-28 20:28:35Z dcollins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(30),
	        __webpack_require__(80),
	        __webpack_require__(113),
	        __webpack_require__(81),
	        __webpack_require__(74),
	        __webpack_require__(100),
	        __webpack_require__(28),
	        __webpack_require__(32),
	        __webpack_require__(63),
	        __webpack_require__(53),
	        __webpack_require__(65),
	        __webpack_require__(79),
	        __webpack_require__(87),
	        __webpack_require__(47),
	        __webpack_require__(37),
	        __webpack_require__(75),
	        __webpack_require__(115),
	        __webpack_require__(116),
	        __webpack_require__(117),
	        __webpack_require__(77),
	        __webpack_require__(36),
	        __webpack_require__(83)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
	              BasicProgram,
	              Globe,
	              GpuProgram,
	              Level,
	              LevelSet,
	              Location,
	              Logger,
	              Matrix,
	              MemoryCache,
	              NavigatorState,
	              NotYetImplementedError,
	              PickedObject,
	              Position,
	              Rectangle,
	              Sector,
	              Terrain,
	              TerrainTile,
	              TerrainTileList,
	              Tile,
	              WWMath,
	              WWUtil) {
	        "use strict";

	        /**
	         * Constructs a Tessellator.
	         * @alias Tessellator
	         * @constructor
	         * @classdesc Provides terrain tessellation for a globe.
	         */
	        var Tessellator = function () {
	            // Parameterize top level subdivision in one place.

	            // TilesInTopLevel describes the most coarse tile structure.
	            this.numRowsTilesInTopLevel = 4; // baseline: 4
	            this.numColumnsTilesInTopLevel = 8; // baseline: 8

	            // The maximum number of levels that will ever be tessellated.
	            this.maximumSubdivisionDepth = 15; // baseline: 15

	            // tileWidth, tileHeight - the number of subdivisions a single tile has; this determines the sampling grid.
	            this.tileWidth = 32; // baseline: 32
	            this.tileHeight = 32; // baseline: 32

	            /**
	             * Controls the level of detail switching for this layer. The next highest resolution level is
	             * used when an elevation tile's cell size is greater than this number of pixels, up to the maximum
	             * resolution of the elevation model.
	             * @type {Number}
	             * @default 1.75
	             */
	            this.detailControl = 40;

	            this.levels = new LevelSet(
	                Sector.FULL_SPHERE,
	                new Location(
	                    180 / this.numRowsTilesInTopLevel,
	                    360 / this.numColumnsTilesInTopLevel),
	                this.maximumSubdivisionDepth,
	                this.tileWidth,
	                this.tileHeight);

	            this.topLevelTiles = {};
	            this.currentTiles = new TerrainTileList(this);

	            this.tileCache = new MemoryCache(5000000, 4000000); // Holds 316 32x32 tiles.

	            this.elevationTimestamp = undefined;
	            this.lastModelViewProjection = undefined;

	            this.vertexPointLocation = -1;
	            this.vertexTexCoordLocation = -1;

	            this.texCoords = null;
	            this.texCoordVboCacheKey = 'global_tex_coords';

	            this.indices = null;
	            this.indicesVboCacheKey = 'global_indices';

	            this.baseIndices = null;
	            this.baseIndicesOffset = null;
	            this.numBaseIndices = null;

	            this.indicesNorth = null;
	            this.indicesNorthOffset = null;
	            this.numIndicesNorth = null;

	            this.indicesSouth = null;
	            this.indicesSouthOffset = null;
	            this.numIndicesSouth = null;

	            this.indicesWest = null;
	            this.indicesWestOffset = null;
	            this.numIndicesWest = null;

	            this.indicesEast = null;
	            this.indicesEastOffset = null;
	            this.numIndicesEast = null;

	            this.indicesLoresNorth = null;
	            this.indicesLoresNorthOffset = null;
	            this.numIndicesLoresNorth = null;

	            this.indicesLoresSouth = null;
	            this.indicesLoresSouthOffset = null;
	            this.numIndicesLoresSouth = null;

	            this.indicesLoresWest = null;
	            this.indicesLoresWestOffset = null;
	            this.numIndicesLoresWest = null;

	            this.indicesLoresEast = null;
	            this.indicesLoresEastOffset = null;
	            this.numIndicesLoresEast = null;

	            this.outlineIndicesOffset = null;
	            this.numOutlineIndices = null;

	            this.wireframeIndicesOffset = null;
	            this.numWireframeIndices = null;

	            this.scratchMatrix = Matrix.fromIdentity();
	            this.scratchElevations = null;
	            this.scratchPrevElevations = null;

	            this.corners = {};
	            this.tiles = [];
	        };

	        /**
	         * Creates the visible terrain of the globe associated with the current draw context.
	         * @param {DrawContext} dc The draw context.
	         * @returns {Terrain} The computed terrain, or null if terrain could not be computed.
	         * @throws {ArgumentError} If the dc is null or undefined.
	         */
	        Tessellator.prototype.tessellate = function (dc) {
	            if (!dc) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Tessellator", "tessellate", "missingDC"));
	            }

	            var lastElevationsChange = dc.globe.elevationTimestamp();
	            if (this.lastGlobeStateKey === dc.globeStateKey
	                && this.lastVerticalExaggeration === dc.verticalExaggeration
	                && this.elevationTimestamp === lastElevationsChange
	                && this.lastModelViewProjection
	                && dc.navigatorState.modelviewProjection.equals(this.lastModelViewProjection)) {

	                return this.lastTerrain;
	            }

	            var navigatorState = dc.navigatorState;

	            this.lastModelViewProjection = navigatorState.modelviewProjection;
	            this.lastGlobeStateKey = dc.globeStateKey;
	            this.elevationTimestamp = lastElevationsChange;
	            this.lastVerticalExaggeration = dc.verticalExaggeration;

	            this.currentTiles.removeAllTiles();

	            if (!this.topLevelTiles[dc.globeStateKey] || this.topLevelTiles[dc.globeStateKey].length == 0) {
	                this.createTopLevelTiles(dc);
	            }

	            this.corners = {};
	            this.tiles = [];

	            for (var index = 0, len = this.topLevelTiles[dc.globeStateKey].length; index < len; index += 1) {
	                var tile = this.topLevelTiles[dc.globeStateKey][index];

	                tile.update(dc);

	                if (this.isTileVisible(dc, tile)) {
	                    this.addTileOrDescendants(dc, tile);
	                }
	            }

	            this.refineNeighbors(dc);
	            this.finishTessellating(dc);

	            this.lastTerrain = this.currentTiles.length === 0 ? null
	                : new Terrain(dc.globe, this, this.currentTiles, dc.verticalExaggeration);

	            return this.lastTerrain;
	        };

	        Tessellator.prototype.createTile = function (tileSector, level, row, column) {
	            if (!tileSector) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Tile", "constructor", "missingSector"));
	            }

	            if (!level) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Tile", "constructor",
	                        "The specified level is null or undefined."));
	            }

	            if (row < 0 || column < 0) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Tile", "constructor",
	                        "The specified row or column is less than zero."));
	            }

	            return new TerrainTile(tileSector, level, row, column);
	        };

	        /**
	         * Initializes rendering state to draw a succession of terrain tiles.
	         * @param {DrawContext} dc The draw context.
	         */
	        Tessellator.prototype.beginRendering = function (dc) {
	            var program = dc.currentProgram; // use the current program; the caller configures other program state
	            if (!program) {
	                Logger.logMessage(Logger.LEVEL_INFO, "Tessellator", "beginRendering", "Current Program is empty");
	                return;
	            }

	            this.buildSharedGeometry();
	            this.cacheSharedGeometryVBOs(dc);

	            var gl = dc.currentGlContext,
	                gpuResourceCache = dc.gpuResourceCache;

	            // Keep track of the program's attribute locations. The tessellator does not know which program the caller has
	            // bound, and therefore must look up the location of attributes by name.
	            this.vertexPointLocation = program.attributeLocation(gl, "vertexPoint");
	            this.vertexTexCoordLocation = program.attributeLocation(gl, "vertexTexCoord");
	            gl.enableVertexAttribArray(this.vertexPointLocation);

	            if (this.vertexTexCoordLocation >= 0) { // location of vertexTexCoord attribute is -1 when the basic program is bound
	                var texCoordVbo = gpuResourceCache.resourceForKey(this.texCoordVboCacheKey);
	                gl.bindBuffer(gl.ARRAY_BUFFER, texCoordVbo);
	                gl.vertexAttribPointer(this.vertexTexCoordLocation, 2, gl.FLOAT, false, 0, 0);
	                gl.enableVertexAttribArray(this.vertexTexCoordLocation);
	            }

	            var indicesVbo = gpuResourceCache.resourceForKey(this.indicesVboCacheKey);
	            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indicesVbo);

	        };

	        /**
	         * Restores rendering state after drawing a succession of terrain tiles.
	         * @param {DrawContext} dc The draw context.
	         */
	        Tessellator.prototype.endRendering = function (dc) {
	            var gl = dc.currentGlContext;

	            gl.bindBuffer(gl.ARRAY_BUFFER, null);
	            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

	            // Restore the global OpenGL vertex attribute array state.
	            if (this.vertexPointLocation >= 0) {
	                gl.disableVertexAttribArray(this.vertexPointLocation);
	            }

	            if (this.vertexTexCoordLocation >= 0) { // location of vertexTexCoord attribute is -1 when the basic program is bound
	                gl.disableVertexAttribArray(this.vertexTexCoordLocation);
	            }
	        };

	        /**
	         * Initializes rendering state for drawing a specified terrain tile.
	         * @param {DrawContext} dc The draw context.
	         * @param {TerrainTile} terrainTile The terrain tile subsequently drawn via this tessellator's render function.
	         * @throws {ArgumentError} If the specified tile is null or undefined.
	         */
	        Tessellator.prototype.beginRenderingTile = function (dc, terrainTile) {
	            if (!terrainTile) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Tessellator", "beginRenderingTile", "missingTile"));
	            }

	            var gl = dc.currentGlContext,
	                gpuResourceCache = dc.gpuResourceCache;

	            this.scratchMatrix.setToMultiply(dc.navigatorState.modelviewProjection, terrainTile.transformationMatrix);
	            dc.currentProgram.loadModelviewProjection(gl, this.scratchMatrix);

	            var vboCacheKey = dc.globeStateKey + terrainTile.tileKey,
	                vbo = gpuResourceCache.resourceForKey(vboCacheKey);
	            if (!vbo) {
	                vbo = gl.createBuffer();
	                gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
	                gl.bufferData(gl.ARRAY_BUFFER, terrainTile.points, gl.STATIC_DRAW);
	                dc.frameStatistics.incrementVboLoadCount(1);
	                gpuResourceCache.putResource(vboCacheKey, vbo, terrainTile.points.length * 4);
	                terrainTile.pointsVboStateKey = terrainTile.pointsStateKey;
	            }
	            else if (terrainTile.pointsVboStateKey != terrainTile.pointsStateKey) {
	                gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
	                gl.bufferSubData(gl.ARRAY_BUFFER, 0, terrainTile.points);
	                terrainTile.pointsVboStateKey = terrainTile.pointsStateKey;
	            }
	            else {
	                dc.currentGlContext.bindBuffer(gl.ARRAY_BUFFER, vbo);
	            }

	            gl.vertexAttribPointer(this.vertexPointLocation, 3, gl.FLOAT, false, 0, 0);
	        };

	        /**
	         * Restores rendering state after drawing the most recent tile specified to
	         * [beginRenderingTile]{@link Tessellator#beginRenderingTile}.
	         * @param {DrawContext} dc The draw context.
	         * @param {TerrainTile} terrainTile The terrain tile most recently rendered.
	         * @throws {ArgumentError} If the specified tile is null or undefined.
	         */
	        Tessellator.prototype.endRenderingTile = function (dc, terrainTile) {
	            // Intentionally empty until there's some reason to add code here.
	        };

	        /**
	         * Renders a specified terrain tile.
	         * @param {DrawContext} dc The draw context.
	         * @param {TerrainTile} terrainTile The terrain tile to render.
	         * @throws {ArgumentError} If the specified tile is null or undefined.
	         */
	        Tessellator.prototype.renderTile = function (dc, terrainTile) {
	            if (!terrainTile) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Tessellator", "renderTile", "missingTile"));
	            }

	            var gl = dc.currentGlContext,
	                prim = gl.TRIANGLE_STRIP; // replace TRIANGLE_STRIP with LINE_STRIP to debug borders

	            /*
	             * Indices order in the buffer:
	             *
	             * base indices
	             *
	             * north border
	             * south border
	             * west border
	             * east border
	             *
	             * north lores
	             * south lores
	             * west lores
	             * east lores
	             *
	             * wireframe
	             * outline
	             */

	            gl.drawElements(
	                prim,
	                this.numBaseIndices,
	                gl.UNSIGNED_SHORT,
	                this.baseIndicesOffset * 2);

	            var level = terrainTile.level,
	                neighborLevel;

	            neighborLevel = terrainTile.neighborLevel(WorldWind.NORTH);
	            if (neighborLevel && neighborLevel.compare(level) < 0) {
	                gl.drawElements(
	                    prim,
	                    this.numIndicesLoresNorth,
	                    gl.UNSIGNED_SHORT,
	                    this.indicesLoresNorthOffset * 2);
	            }
	            else {
	                gl.drawElements(
	                    prim,
	                    this.numIndicesNorth,
	                    gl.UNSIGNED_SHORT,
	                    this.indicesNorthOffset * 2);
	            }

	            neighborLevel = terrainTile.neighborLevel(WorldWind.SOUTH);
	            if (neighborLevel && neighborLevel.compare(level) < 0) {
	                gl.drawElements(
	                    prim,
	                    this.numIndicesLoresSouth,
	                    gl.UNSIGNED_SHORT,
	                    this.indicesLoresSouthOffset * 2);
	            }
	            else {
	                gl.drawElements(
	                    prim,
	                    this.numIndicesSouth,
	                    gl.UNSIGNED_SHORT,
	                    this.indicesSouthOffset * 2);
	            }

	            neighborLevel = terrainTile.neighborLevel(WorldWind.WEST);
	            if (neighborLevel && neighborLevel.compare(level) < 0) {
	                gl.drawElements(
	                    prim,
	                    this.numIndicesLoresWest,
	                    gl.UNSIGNED_SHORT,
	                    this.indicesLoresWestOffset * 2);
	            }
	            else {
	                gl.drawElements(
	                    prim,
	                    this.numIndicesWest,
	                    gl.UNSIGNED_SHORT,
	                    this.indicesWestOffset * 2);
	            }

	            neighborLevel = terrainTile.neighborLevel(WorldWind.EAST);
	            if (neighborLevel && neighborLevel.compare(level) < 0) {
	                gl.drawElements(
	                    prim,
	                    this.numIndicesLoresEast,
	                    gl.UNSIGNED_SHORT,
	                    this.indicesLoresEastOffset * 2);
	            }
	            else {
	                gl.drawElements(
	                    prim,
	                    this.numIndicesEast,
	                    gl.UNSIGNED_SHORT,
	                    this.indicesEastOffset * 2);
	            }
	        };

	        /**
	         * Draws outlines of the triangles composing the tile.
	         * @param {DrawContext} dc The current draw context.
	         * @param {TerrainTile} terrainTile The tile to draw.
	         * @throws {ArgumentError} If the specified tile is null or undefined.
	         */
	        Tessellator.prototype.renderWireframeTile = function (dc, terrainTile) {
	            if (!terrainTile) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Tessellator", "renderWireframeTile", "missingTile"));
	            }

	            var gl = dc.currentGlContext;

	            // Must turn off texture coordinates, which were turned on in beginRendering.
	            if (this.vertexTexCoordLocation >= 0) {
	                gl.disableVertexAttribArray(this.vertexTexCoordLocation);
	            }

	            gl.drawElements(
	                gl.LINES,
	                this.numWireframeIndices,
	                gl.UNSIGNED_SHORT,
	                this.wireframeIndicesOffset * 2);
	        };

	        /**
	         * Draws the outer boundary of a specified terrain tile.
	         * @param {DrawContext} dc The current draw context.
	         * @param {TerrainTile} terrainTile The tile whose outer boundary to draw.
	         * @throws {ArgumentError} If the specified tile is null or undefined.
	         */
	        Tessellator.prototype.renderTileOutline = function (dc, terrainTile) {
	            if (!terrainTile) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Tessellator", "renderTileOutline", "missingTile"));
	            }

	            var gl = dc.currentGlContext;

	            // Must turn off texture coordinates, which were turned on in beginRendering.
	            if (this.vertexTexCoordLocation >= 0) {
	                gl.disableVertexAttribArray(this.vertexTexCoordLocation);
	            }

	            gl.drawElements(
	                gl.LINE_LOOP,
	                this.numOutlineIndices,
	                gl.UNSIGNED_SHORT,
	                this.outlineIndicesOffset * 2);
	        };

	        /**
	         * Causes this terrain to perform the picking operations on the specified tiles, as appropriate for the draw
	         * context's pick settings. Normally, this draws the terrain in a unique pick color and computes the picked
	         * terrain position. When the draw context is set to region picking mode, this omits the computation of a picked
	         * terrain position.
	         * @param {DrawContext} dc The current draw context.
	         * @param {Array} tileList The list of tiles to pick.
	         * @param {Object} pickDelegate Indicates the object to use as the picked object's <code>userObject</code>.
	         * If null, then this tessellator is used as the <code>userObject</code>.
	         * @throws {ArgumentError} If either the draw context or the tile list are null or undefined.
	         */
	        Tessellator.prototype.pick = function (dc, tileList, pickDelegate) {
	            if (!dc) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Tessellator", "pick", "missingDc"));
	            }

	            if (!tileList) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Tessellator", "pick", "missingList"));
	            }

	            var color = null,
	                userObject = pickDelegate || this,
	                position = new Position(0, 0, 0),
	                pickableTiles = [];

	            // Assemble a list of tiles that intersect the pick frustum. This eliminates unnecessary work for tiles that
	            // do not contribute to the pick result.
	            for (var i = 0, len = tileList.length; i < len; i++) {
	                var tile = tileList[i];
	                if (tile.extent.intersectsFrustum(dc.pickFrustum)) {
	                    pickableTiles.push(tile);
	                }
	            }

	            // Draw the pickable tiles in a unique pick color. Suppress this step when picking the terrain only. In this
	            // case drawing to the pick framebuffer is unnecessary.
	            if (!dc.pickTerrainOnly) {
	                color = dc.uniquePickColor();
	                this.drawPickTiles(dc, pickableTiles, color);
	            }

	            // Determine the terrain position at the pick point. If the terrain is picked, add a corresponding picked
	            // object to the draw context. Suppress this step in region picking mode.
	            if (!dc.regionPicking) {
	                var ray = dc.navigatorState.rayFromScreenPoint(dc.pickPoint),
	                    point = this.computeNearestIntersection(ray, pickableTiles);
	                if (point) {
	                    dc.globe.computePositionFromPoint(point[0], point[1], point[2], position);
	                    position.altitude = dc.globe.elevationAtLocation(position.latitude, position.longitude);
	                    dc.addPickedObject(new PickedObject(color, userObject, position, null, true));
	                }
	            }
	        };

	        // Internal function. Intentionally not documented.
	        Tessellator.prototype.drawPickTiles = function (dc, tileList, color) {
	            var gl = dc.currentGlContext;

	            try {
	                dc.findAndBindProgram(BasicProgram);
	                dc.currentProgram.loadColor(gl, color);
	                this.beginRendering(dc);

	                for (var i = 0, len = tileList.length; i < len; i++) {
	                    var tile = tileList[i];
	                    this.beginRenderingTile(dc, tile);
	                    this.renderTile(dc, tile);
	                    this.endRenderingTile(dc, tile);
	                }
	            } finally {
	                this.endRendering(dc);
	            }
	        };

	        // Internal function. Intentionally not documented.
	        Tessellator.prototype.computeNearestIntersection = function (line, tileList) {
	            // Compute all intersections between the specified line and tile list.
	            var results = [];
	            for (var i = 0, len = tileList.length; i < len; i++) {
	                this.computeIntersections(line, tileList[i], results);
	            }

	            if (results.length == 0) {
	                return null; // no intersection
	            } else {
	                // Find and return the intersection nearest to the line's origin.
	                var minDistance = Number.POSITIVE_INFINITY,
	                    minIndex;
	                for (i = 0, len = results.length; i < len; i++) {
	                    var distance = line.origin.distanceToSquared(results[i]);
	                    if (minDistance > distance) {
	                        minDistance = distance;
	                        minIndex = i;
	                    }
	                }

	                return results[minIndex];
	            }
	        };

	        // Internal function. Intentionally not documented.
	        Tessellator.prototype.computeIntersections = function (line, tile, results) {
	            var level = tile.level,
	                neighborLevel,
	                points = tile.points,
	                elements,
	                firstResult = results.length;

	            // Translate the line from model coordinates to tile local coordinates.
	            line.origin.subtract(tile.referencePoint);

	            // Assemble the shared tile index geometry. This initializes the index properties used below.
	            this.buildSharedGeometry(tile);

	            // Compute any intersections with the tile's interior triangles..
	            elements = this.baseIndices;
	            WWMath.computeTriStripIntersections(line, points, elements, results);

	            // Compute any intersections with the tile's south border triangles.
	            neighborLevel = tile.neighborLevel(WorldWind.SOUTH);
	            elements = neighborLevel && neighborLevel.compare(level) < 0 ? this.indicesLoresSouth : this.indicesSouth;
	            WWMath.computeTriStripIntersections(line, points, elements, results);

	            // Compute any intersections with the tile's west border triangles.
	            neighborLevel = tile.neighborLevel(WorldWind.WEST);
	            elements = neighborLevel && neighborLevel.compare(level) < 0 ? this.indicesLoresWest : this.indicesWest;
	            WWMath.computeTriStripIntersections(line, points, elements, results);

	            // Compute any intersections with the tile's east border triangles.
	            neighborLevel = tile.neighborLevel(WorldWind.EAST);
	            elements = neighborLevel && neighborLevel.compare(level) < 0 ? this.indicesLoresEast : this.indicesEast;
	            WWMath.computeTriStripIntersections(line, points, elements, results);

	            // Compute any intersections with the tile's north border triangles.
	            neighborLevel = tile.neighborLevel(WorldWind.NORTH);
	            elements = neighborLevel && neighborLevel.compare(level) < 0 ? this.indicesLoresNorth : this.indicesNorth;
	            WWMath.computeTriStripIntersections(line, points, elements, results);

	            // Translate the line and the intersection results from tile local coordinates to model coordinates.
	            line.origin.add(tile.referencePoint);
	            for (var i = firstResult, len = results.length; i < len; i++) {
	                results[i].add(tile.referencePoint);
	            }
	        };

	        /***********************************************************************
	         * Internal methods - assume that arguments have been validated already.
	         ***********************************************************************/

	        Tessellator.prototype.createTopLevelTiles = function (dc) {
	            this.topLevelTiles[dc.globeStateKey] = [];
	            Tile.createTilesForLevel(this.levels.firstLevel(), this, this.topLevelTiles[dc.globeStateKey]);
	        };

	        Tessellator.prototype.addTileOrDescendants = function (dc, tile) {
	            if (this.tileMeetsRenderCriteria(dc, tile)) {
	                this.addTile(dc, tile);
	                return;
	            }

	            this.addTileDescendants(dc, tile);
	        };

	        Tessellator.prototype.addTileDescendants = function (dc, tile) {
	            var nextLevel = tile.level.nextLevel();
	            var subTiles = tile.subdivideToCache(nextLevel, this, this.tileCache);
	            for (var index = 0; index < subTiles.length; index += 1) {
	                var child = subTiles[index];

	                child.update(dc);

	                if (this.levels.sector.intersects(child.sector) && this.isTileVisible(dc, child)) {
	                    this.addTileOrDescendants(dc, child);
	                }
	            }
	        };

	        Tessellator.prototype.addTile = function (dc, tile) {
	            // Insert tile at index idx.
	            var idx = this.tiles.length;
	            this.tiles.push(tile);

	            // Insert tile into corner data collection for later LOD neighbor analysis.
	            var sector = tile.sector;

	            // Corners of the tile.
	            var neTileCorner = [sector.maxLatitude, sector.maxLongitude].toString(),
	                seTileCorner = [sector.minLatitude, sector.maxLongitude].toString(),
	                nwTileCorner = [sector.maxLatitude, sector.minLongitude].toString(),
	                swTileCorner = [sector.minLatitude, sector.minLongitude].toString(),
	                corner;

	            corner = this.corners[swTileCorner];
	            if (!corner) {
	                this.corners[swTileCorner] = {'sw': idx}; //corner;
	            }
	            else {
	                // assert(!corner.sw, "sw already defined");
	                corner.sw = idx;
	            }

	            corner = this.corners[nwTileCorner];
	            if (!corner) {
	                this.corners[nwTileCorner] = {'nw': idx};
	            }
	            else {
	                // assert(!corner.nw, "nw already defined");
	                corner.nw = idx;
	            }

	            corner = this.corners[seTileCorner];
	            if (!corner) {
	                this.corners[seTileCorner] = {'se': idx};
	            }
	            else {
	                // assert(!corver.se, "se already defined");
	                corner.se = idx;
	            }

	            corner = this.corners[neTileCorner];
	            if (!corner) {
	                this.corners[neTileCorner] = {'ne': idx};
	            }
	            else {
	                //assert(!corner.ne, "ne already defined");
	                corner.ne = idx;
	            }
	        };

	        Tessellator.prototype.refineNeighbors = function (dc) {
	            var tileRefinementSet = {};

	            for (var idx = 0, len = this.tiles.length; idx < len; idx += 1) {
	                var tile = this.tiles[idx],
	                    levelNumber = tile.level.levelNumber,
	                    sector = tile.sector,
	                    corner,
	                    neighbor,
	                    idx,
	                    len;

	                // Corners of the tile.
	                var neTileCorner = [sector.maxLatitude, sector.maxLongitude].toString(),
	                    seTileCorner = [sector.minLatitude, sector.maxLongitude].toString(),
	                    nwTileCorner = [sector.maxLatitude, sector.minLongitude].toString(),
	                    swTileCorner = [sector.minLatitude, sector.minLongitude].toString();

	                corner = this.corners[neTileCorner];
	                // assert(corner, "northeast corner not found");
	                if (corner.hasOwnProperty('se')) {
	                    neighbor = corner.se;
	                    if (this.tiles[neighbor].level.levelNumber < levelNumber - 1) {
	                        if (!tileRefinementSet[neighbor]) {
	                            tileRefinementSet[neighbor] = true;
	                        }
	                    }
	                }
	                if (corner.hasOwnProperty('nw')) {
	                    neighbor = corner.nw;
	                    if (this.tiles[neighbor].level.levelNumber < levelNumber - 1) {
	                        if (!tileRefinementSet[neighbor]) {
	                            tileRefinementSet[neighbor] = true;
	                        }
	                    }
	                }

	                corner = this.corners[seTileCorner];
	                // assert(corner, "southeast corner not found");
	                if (corner.hasOwnProperty('ne')) {
	                    neighbor = corner.ne;
	                    if (this.tiles[neighbor].level.levelNumber < levelNumber - 1) {
	                        if (!tileRefinementSet[neighbor]) {
	                            tileRefinementSet[neighbor] = true;
	                        }
	                    }
	                }
	                if (corner.hasOwnProperty('sw')) {
	                    neighbor = corner.sw;
	                    if (this.tiles[neighbor].level.levelNumber < levelNumber - 1) {
	                        if (!tileRefinementSet[neighbor]) {
	                            tileRefinementSet[neighbor] = true;
	                        }
	                    }
	                }

	                corner = this.corners[nwTileCorner];
	                // assert(corner, "northwest corner not found");
	                if (corner.hasOwnProperty('ne')) {
	                    neighbor = corner.ne;
	                    if (this.tiles[neighbor].level.levelNumber < levelNumber - 1) {
	                        if (!tileRefinementSet[neighbor]) {
	                            tileRefinementSet[neighbor] = true;
	                        }
	                    }
	                }
	                if (corner.hasOwnProperty('sw')) {
	                    neighbor = corner.sw;
	                    if (this.tiles[neighbor].level.levelNumber < levelNumber - 1) {
	                        if (!tileRefinementSet[neighbor]) {
	                            tileRefinementSet[neighbor] = true;
	                        }
	                    }
	                }

	                corner = this.corners[swTileCorner];
	                // assert(corner, "southwest corner not found");
	                if (corner.hasOwnProperty('se')) {
	                    neighbor = corner.se;
	                    if (this.tiles[neighbor].level.levelNumber < levelNumber - 1) {
	                        if (!tileRefinementSet[neighbor]) {
	                            tileRefinementSet[neighbor] = true;
	                        }
	                    }
	                }
	                if (corner.hasOwnProperty('nw')) {
	                    neighbor = corner.nw;
	                    if (this.tiles[neighbor].level.levelNumber < levelNumber - 1) {
	                        if (!tileRefinementSet[neighbor]) {
	                            tileRefinementSet[neighbor] = true;
	                        }
	                    }
	                }
	            }

	            // Partition tiles into those requiring refinement and those that don't need refinement.
	            var tilesNeedingRefinement = [],
	                tilesNotNeedingRefinement = [];
	            for (idx = 0, len = this.tiles.length; idx < len; idx += 1) {
	                tile = this.tiles[idx];
	                if (tileRefinementSet[idx]) {
	                    tilesNeedingRefinement.push(tile);
	                }
	                else {
	                    tilesNotNeedingRefinement.push(tile);
	                }
	            }

	            // When tiles need refinement, recur.
	            if (tilesNeedingRefinement.length > 0) {
	                // Reset refinement state.
	                this.tiles = [];
	                this.corners = {};

	                // For tiles that don't need refinement, simply add the tile.
	                for (idx = 0, len = tilesNotNeedingRefinement.length; idx < len; idx += 1) {
	                    tile = tilesNotNeedingRefinement[idx];

	                    this.addTile(dc, tile);
	                }

	                // For tiles that do need refinement, subdivide the tile and add its descendants.
	                for (idx = 0, len = tilesNeedingRefinement.length; idx < len; idx += 1) {
	                    var tile = tilesNeedingRefinement[idx];

	                    this.addTileDescendants(dc, tile);
	                }

	                // Recur.
	                this.refineNeighbors(dc);
	            }
	        };

	        Tessellator.prototype.finishTessellating = function (dc) {
	            for (var idx = 0, len = this.tiles.length; idx < len; idx += 1) {
	                var tile = this.tiles[idx];
	                this.setNeighbors(tile);
	                this.regenerateTileGeometryIfNeeded(dc, tile);
	                this.currentTiles.addTile(tile);
	            }
	        };

	        Tessellator.prototype.setNeighbors = function (tile) {
	            var sector = tile.sector;

	            // Corners of the tile.
	            var neTileCorner = [sector.maxLatitude, sector.maxLongitude].toString(),
	                seTileCorner = [sector.minLatitude, sector.maxLongitude].toString(),
	                nwTileCorner = [sector.maxLatitude, sector.minLongitude].toString(),
	                swTileCorner = [sector.minLatitude, sector.minLongitude].toString();

	            var neCorner = this.corners[neTileCorner],
	                seCorner = this.corners[seTileCorner],
	                nwCorner = this.corners[nwTileCorner],
	                swCorner = this.corners[swTileCorner];

	            var northIdx = -1, // neCorner.hasOwnProperty('se') ? neCorner.se : nwCorner.hasOwnProperty('sw') ? nwCorner.sw : -1,
	                southIdx = -1, // seCorner.hasOwnProperty('ne') ? seCorner.ne : swCorner.hasOwnProperty('nw') ? swCorner.nw : -1,
	                eastIdx = -1, // neCorner.hasOwnProperty('nw') ? neCorner.nw : seCorner.hasOwnProperty('sw') ? seCorner.sw : -1,
	                westIdx = -1; //nwCorner.hasOwnProperty('ne') ? nwCorner.ne : swCorner.hasOwnProperty('se') ? swCorner.se : -1;

	            if (neCorner.hasOwnProperty('se')) {
	                northIdx = neCorner.se;
	            }
	            else if (nwCorner.hasOwnProperty('sw')) {
	                northIdx = nwCorner.sw;
	            }

	            if (seCorner.hasOwnProperty('ne')) {
	                southIdx = seCorner.ne;
	            }
	            else if (swCorner.hasOwnProperty('nw')) {
	                southIdx = swCorner.nw;
	            }

	            if (neCorner.hasOwnProperty('nw')) {
	                eastIdx = neCorner.nw;
	            }
	            else if (seCorner.hasOwnProperty('sw')) {
	                eastIdx = seCorner.sw;
	            }

	            if (nwCorner.hasOwnProperty('ne')) {
	                westIdx = nwCorner.ne;
	            }
	            else if (swCorner.hasOwnProperty('se')) {
	                westIdx = swCorner.se;
	            }

	            tile.setNeighborLevel(WorldWind.NORTH, (northIdx >= 0) ? this.tiles[northIdx].level : null);
	            tile.setNeighborLevel(WorldWind.SOUTH, (southIdx >= 0) ? this.tiles[southIdx].level : null);
	            tile.setNeighborLevel(WorldWind.EAST, (eastIdx >= 0) ? this.tiles[eastIdx].level : null);
	            tile.setNeighborLevel(WorldWind.WEST, (westIdx >= 0) ? this.tiles[westIdx].level : null);
	        };

	        Tessellator.prototype.isTileVisible = function (dc, tile) {
	            if (dc.globe.projectionLimits && !tile.sector.overlaps(dc.globe.projectionLimits)) {
	                return false;
	            }

	            return tile.extent.intersectsFrustum(dc.navigatorState.frustumInModelCoordinates);
	        };

	        Tessellator.prototype.tileMeetsRenderCriteria = function (dc, tile) {
	            var s = this.detailControl;
	            if (tile.sector.minLatitude >= 75 || tile.sector.maxLatitude <= -75) {
	                s *= 2;
	            }
	            return tile.level.isLastLevel() || !tile.mustSubdivide(dc, s);
	        };

	        Tessellator.prototype.regenerateTileGeometryIfNeeded = function (dc, tile) {
	            var stateKey = dc.globeStateKey + tile.stateKey + dc.verticalExaggeration;

	            if (!tile.points || tile.pointsStateKey != stateKey) {
	                this.regenerateTileGeometry(dc, tile);
	                tile.pointsStateKey = stateKey;
	            }
	        };

	        Tessellator.prototype.regenerateTileGeometry = function (dc, tile) {
	            var numLat = tile.tileHeight + 1, // num points in each dimension is 1 more than the number of tile cells
	                numLon = tile.tileWidth + 1,
	                refPoint = tile.referencePoint,
	                elevations = this.scratchElevations;

	            // Allocate space for the tile's elevations.
	            if (!elevations) {
	                elevations = new Float64Array(numLat * numLon);
	                this.scratchElevations = elevations;
	            }

	            // Allocate space for the tile's Cartesian coordinates.
	            if (!tile.points) {
	                tile.points = new Float32Array(numLat * numLon * 3);
	            }

	            // Retrieve the elevations for all points in the tile.
	            WWUtil.fillArray(elevations, 0);
	            dc.globe.elevationsForGrid(tile.sector, numLat, numLon, tile.texelSize, elevations);

	            // Modify the elevations around the tile's border to match neighbors of lower resolution, if any.
	            if (this.mustAlignNeighborElevations(dc, tile)) {
	                this.alignNeighborElevations(dc, tile, elevations);
	            }

	            // Compute the tile's Cartesian coordinates relative to a local origin, called the reference point.
	            WWUtil.multiplyArray(elevations, dc.verticalExaggeration);
	            dc.globe.computePointsForGrid(tile.sector, numLat, numLon, elevations, refPoint, tile.points);

	            // Establish a transform that is used later to move the tile coordinates into place relative to the globe.
	            tile.transformationMatrix.setTranslation(refPoint[0], refPoint[1], refPoint[2]);
	        };

	        Tessellator.prototype.mustAlignNeighborElevations = function (dc, tile) {
	            var level = tile.level,
	                northLevel = tile.neighborLevel(WorldWind.NORTH),
	                southLevel = tile.neighborLevel(WorldWind.SOUTH),
	                eastLevel = tile.neighborLevel(WorldWind.EAST),
	                westLevel = tile.neighborLevel(WorldWind.WEST);

	            return (northLevel && northLevel.compare(level) < 0) ||
	                (southLevel && southLevel.compare(level) < 0) ||
	                (eastLevel && eastLevel.compare(level) < 0) ||
	                (westLevel && westLevel.compare(level) < 0);
	        };

	        Tessellator.prototype.alignNeighborElevations = function (dc, tile, elevations) {
	            var numLat = tile.tileHeight + 1, // num points in each dimension is 1 more than the number of tile cells
	                numLon = tile.tileWidth + 1,
	                level = tile.level,
	                prevNumLat = Math.floor(numLat / 2) + 1, // num prev level points is 1 more than 1/2 the number of cells
	                prevNumLon = Math.floor(numLon / 2) + 1,
	                prevLevel = level.previousLevel(),
	                prevElevations = this.scratchPrevElevations,
	                neighborLevel,
	                i, index, prevIndex;

	            // Allocate space for the previous level elevations.
	            if (!prevElevations) {
	                prevElevations = new Float64Array(prevNumLat * prevNumLon);
	                this.scratchPrevElevations = prevElevations;
	            }

	            // Retrieve the previous level elevations, using 1/2 the number of tile cells.
	            WWUtil.fillArray(prevElevations, 0);
	            dc.globe.elevationsForGrid(tile.sector, prevNumLat, prevNumLon, prevLevel.texelSize, prevElevations);

	            // Use previous level elevations along the north edge when the northern neighbor is lower resolution.
	            neighborLevel = tile.neighborLevel(WorldWind.NORTH);
	            if (neighborLevel && neighborLevel.compare(level) < 0) {
	                index = (numLat - 1) * numLon;
	                prevIndex = (prevNumLat - 1) * prevNumLon;
	                for (i = 0; i < prevNumLon; i++, index += 2, prevIndex += 1) {
	                    elevations[index] = prevElevations[prevIndex];
	                    if (i < prevNumLon - 1) {
	                        elevations[index + 1] = 0.5 * (prevElevations[prevIndex] + prevElevations[prevIndex + 1]);
	                    }
	                }
	            }

	            // Use previous level elevations along the south edge when the southern neighbor is lower resolution.
	            neighborLevel = tile.neighborLevel(WorldWind.SOUTH);
	            if (neighborLevel && neighborLevel.compare(level) < 0) {
	                index = 0;
	                prevIndex = 0;
	                for (i = 0; i < prevNumLon; i++, index += 2, prevIndex += 1) {
	                    elevations[index] = prevElevations[prevIndex];
	                    if (i < prevNumLon - 1) {
	                        elevations[index + 1] = 0.5 * (prevElevations[prevIndex] + prevElevations[prevIndex + 1]);
	                    }
	                }
	            }

	            // Use previous level elevations along the east edge when the eastern neighbor is lower resolution.
	            neighborLevel = tile.neighborLevel(WorldWind.EAST);
	            if (neighborLevel && neighborLevel.compare(level) < 0) {
	                index = numLon - 1;
	                prevIndex = prevNumLon - 1;
	                for (i = 0; i < prevNumLat; i++, index += 2 * numLon, prevIndex += prevNumLon) {
	                    elevations[index] = prevElevations[prevIndex];
	                    if (i < prevNumLat - 1) {
	                        elevations[index + numLon] = 0.5 * (prevElevations[prevIndex] + prevElevations[prevIndex + prevNumLon]);
	                    }
	                }
	            }

	            // Use previous level elevations along the west edge when the western neighbor is lower resolution.
	            neighborLevel = tile.neighborLevel(WorldWind.WEST);
	            if (neighborLevel && neighborLevel.compare(level) < 0) {
	                index = 0;
	                prevIndex = 0;
	                for (i = 0; i < prevNumLat; i++, index += 2 * numLon, prevIndex += prevNumLon) {
	                    elevations[index] = prevElevations[prevIndex];
	                    if (i < prevNumLat - 1) {
	                        elevations[index + numLon] = 0.5 * (prevElevations[prevIndex] + prevElevations[prevIndex + prevNumLon]);
	                    }
	                }
	            }
	        };

	        Tessellator.prototype.buildSharedGeometry = function () {
	            // TODO: put all indices into a single buffer
	            var tileWidth = this.levels.tileWidth,
	                tileHeight = this.levels.tileHeight;

	            if (!this.texCoords) {
	                this.buildTexCoords(tileWidth, tileHeight);
	            }

	            if (!this.indices) {
	                this.buildIndices(tileWidth, tileHeight);
	            }
	        };

	        Tessellator.prototype.buildTexCoords = function (tileWidth, tileHeight) {
	            var numCols = tileWidth + 1,
	                numRows = tileHeight + 1,
	                colDelta = 1 / tileWidth,
	                rowDelta = 1 / tileHeight,
	                buffer = new Float32Array(numCols * numRows * 2),
	                index = 0;

	            for (var row = 0, t = 0; row < numRows; row++, t += rowDelta) {
	                if (row == numRows - 1) {
	                    t = 1; // explicitly set the last row coordinate to ensure alignment
	                }

	                for (var col = 0, s = 0; col < numCols; col++, s += colDelta) {
	                    if (col == numCols - 1) {
	                        s = 1; // explicitly set the last column coordinate to ensure alignment
	                    }

	                    buffer[index++] = s;
	                    buffer[index++] = t;
	                }
	            }

	            this.texCoords = buffer;
	        };

	        Tessellator.prototype.buildIndices = function (tileWidth, tileHeight) {
	            var vertexIndex; // The index of the vertex in the sample grid.

	            // The number of vertices in each dimension is 1 more than the number of cells.
	            var numLatVertices = tileHeight + 1,
	                numLonVertices = tileWidth + 1,
	                latIndexMid = tileHeight / 2,   // Assumption: tileHeight is even, so that there is a midpoint!
	                lonIndexMid = tileWidth / 2;    // Assumption: tileWidth is even, so that there is a midpoint!

	            // Each vertex has two indices associated with it: the current vertex index and the index of the row.
	            // There are tileHeight rows.
	            // There are tileHeight + 2 columns
	            var numIndices = 2 * (numLatVertices - 3) * (numLonVertices - 2) + 2 * (numLatVertices - 3);
	            var indices = [];

	            // Inset core by one round of sub-tiles. Full grid is numLatVertices x numLonVertices. This must be used
	            // to address vertices in the core as well.
	            var index = 0;
	            for (var lonIndex = 1; lonIndex < numLonVertices - 2; lonIndex += 1) {
	                for (var latIndex = 1; latIndex < numLatVertices - 1; latIndex += 1) {
	                    vertexIndex = lonIndex + latIndex * numLonVertices;

	                    // Create a triangle strip joining each adjacent column of vertices, starting in the top left corner and
	                    // proceeding to the right. The first vertex starts with the left row of vertices and moves right to create a
	                    // counterclockwise winding order.
	                    indices[index++] = vertexIndex;
	                    indices[index++] = vertexIndex + 1;
	                }

	                // Insert indices to create 2 degenerate triangles:
	                //      one for the end of the current row, and
	                //      one for the beginning of the next row.
	                indices[index++] = vertexIndex + 1;
	                vertexIndex = (lonIndex + 1) + 1 * numLonVertices;
	                indices[index++] = vertexIndex;
	            }

	            this.baseIndicesOffset = indices.length - numIndices;
	            this.baseIndices = new Uint16Array(indices.slice(this.baseIndicesOffset));
	            this.numBaseIndices = numIndices;

	            // TODO: parameterize and refactor!!!!!
	            // Software engineering notes: There are patterns being used in the following code that should be abstracted.
	            // However, I suspect that the process of abstracting the patterns will result in as much code created
	            // as gets removed. YMMV. If JavaScript had a meta-programming (a.k.a., macro) facility, that code would be
	            // processed at "compile" time rather than "runtime". But it doesn't have such a facility that I know of.
	            //
	            // Patterns used:
	            //  0) Each tile has four borders: north, south, east, and west.
	            //  1) Counter-clockwise traversal around the outside results in clockwise meshes amendable to back-face elimination.
	            //  2) For each vertex on the exterior, there corresponds a vertex on the interior that creates a diagonal.
	            //  3) Each border construction is broken into three phases:
	            //      a) The starting phase to generate the first half of the border,
	            //      b) The middle phase, where a single vertex reference gets created, and
	            //      c) The ending phase to complete the generation of the border.
	            //  4) Each border is generated in two variants:
	            //      a) one variant that mates with a tile at the same level of detail, and
	            //      b) another variant that mates with a tile at the next lower level of detail.
	            //  5) Borders that mate with the next lower level of detail are constrained to lie on even indices.
	            //  6) Evenness is generated by ANDing the index with a mask that has 1's in all bits except for the LSB,
	            //      which results in clearing the LSB os the index, making it even.
	            //  7) The section that generates lower level LOD borders gives up any attempt to be optimal because of the
	            //      complexity. Instead, correctness was preferred. That said, any performance lost is in the noise,
	            //      since this code only gets run once.

	            /*
	             *  The following section of code generates full resolution boundary meshes. These are used to mate
	             *  with neighboring tiles that are at the same level of detail.
	             */
	            // North border.
	            numIndices = 2 * numLonVertices - 2;
	            latIndex = numLatVertices - 1;

	            // Corner vertex.
	            lonIndex = numLonVertices - 1;
	            vertexIndex = lonIndex + latIndex * numLonVertices;
	            indices[index++] = vertexIndex;

	            for (lonIndex = numLonVertices - 2; lonIndex > 0; lonIndex -= 1) {
	                vertexIndex = lonIndex + latIndex * numLonVertices;
	                indices[index++] = vertexIndex;
	                indices[index++] = vertexIndex - numLonVertices;
	            }

	            // Corner vertex.
	            lonIndex = 0;
	            vertexIndex = lonIndex + latIndex * numLonVertices;
	            indices[index++] = vertexIndex;

	            this.indicesNorthOffset = indices.length - numIndices;
	            this.indicesNorth = new Uint16Array(indices.slice(this.indicesNorthOffset));
	            this.numIndicesNorth = numIndices;

	            // South border.
	            numIndices = 2 * numLonVertices - 2;
	            latIndex = 0;

	            // Corner vertex.
	            lonIndex = 0;
	            vertexIndex = lonIndex + latIndex * numLonVertices;
	            indices[index++] = vertexIndex;

	            for (lonIndex = 1; lonIndex < numLonVertices - 1; lonIndex += 1) {
	                vertexIndex = lonIndex + latIndex * numLonVertices;
	                indices[index++] = vertexIndex;
	                indices[index++] = vertexIndex + numLonVertices;
	            }

	            // Corner vertex.
	            lonIndex = numLonVertices - 1;
	            vertexIndex = lonIndex + latIndex * numLonVertices;
	            indices[index++] = vertexIndex;

	            this.indicesSouthOffset = indices.length - numIndices;
	            this.indicesSouth = new Uint16Array(indices.slice(this.indicesSouthOffset));
	            this.numIndicesSouth = numIndices;

	            // West border.
	            numIndices = 2 * numLatVertices - 2;
	            lonIndex = 0;

	            // Corner vertex.
	            latIndex = numLatVertices - 1;
	            vertexIndex = lonIndex + latIndex * numLonVertices;
	            indices[index++] = vertexIndex;

	            for (latIndex = numLatVertices - 2; latIndex > 0; latIndex -= 1) {
	                vertexIndex = lonIndex + latIndex * numLonVertices;
	                indices[index++] = vertexIndex;
	                indices[index++] = vertexIndex + 1;
	            }

	            // Corner vertex.
	            latIndex = 0;
	            vertexIndex = lonIndex + latIndex * numLonVertices;
	            indices[index++] = vertexIndex;

	            this.indicesWestOffset = indices.length - numIndices;
	            this.indicesWest = new Uint16Array(indices.slice(this.indicesWestOffset));
	            this.numIndicesWest = numIndices;

	            // East border.
	            numIndices = 2 * numLatVertices - 2;
	            lonIndex = numLonVertices - 1;

	            // Corner vertex.
	            latIndex = 0;
	            vertexIndex = lonIndex + latIndex * numLonVertices;
	            indices[index++] = vertexIndex;

	            for (latIndex = 1; latIndex < numLatVertices - 1; latIndex += 1) {
	                vertexIndex = lonIndex + latIndex * numLonVertices;
	                indices[index++] = vertexIndex;
	                indices[index++] = vertexIndex - 1;
	            }

	            // Corner vertex.
	            latIndex = numLatVertices - 1;
	            vertexIndex = lonIndex + latIndex * numLonVertices;
	            indices[index++] = vertexIndex;

	            this.indicesEastOffset = indices.length - numIndices;
	            this.indicesEast = new Uint16Array(indices.slice(this.indicesEastOffset));
	            this.numIndicesEast = numIndices;

	            /*
	             *  The following section of code generates "lores" low resolution boundary meshes. These are used to mate
	             *  with neighboring tiles that are at a lower level of detail. The property of these lower level meshes is that
	             *  they have half the number of vertices.
	             *
	             *  To generate the boundary meshes, force the use of only even boundary vertex indices.
	             */
	            // North border.
	            numIndices = 2 * numLonVertices - 2;
	            latIndex = numLatVertices - 1;

	            // Corner vertex.
	            lonIndex = numLonVertices - 1;
	            vertexIndex = lonIndex + latIndex * numLonVertices;
	            indices[index++] = vertexIndex;

	            for (lonIndex = numLonVertices - 2; lonIndex > 0; lonIndex -= 1) {
	                // Exterior vertex rounded up to even index.
	                vertexIndex = ((lonIndex + 1) & ~1) + latIndex * numLonVertices;
	                indices[index++] = vertexIndex;

	                // Interior vertex.
	                vertexIndex = lonIndex + (latIndex - 1) * numLonVertices;
	                indices[index++] = vertexIndex;
	            }

	            // Corner vertex.
	            lonIndex = 0;
	            vertexIndex = lonIndex + latIndex * numLonVertices;
	            indices[index++] = vertexIndex;

	            this.indicesLoresNorthOffset = indices.length - numIndices;
	            this.indicesLoresNorth = new Uint16Array(indices.slice(this.indicesLoresNorthOffset));
	            this.numIndicesLoresNorth = numIndices;

	            // South border.
	            numIndices = 2 * numLonVertices - 2;
	            latIndex = 0;

	            // Corner vertex.
	            lonIndex = 0;
	            vertexIndex = lonIndex + latIndex * numLonVertices;
	            indices[index++] = vertexIndex;

	            for (lonIndex = 1; lonIndex < numLonVertices - 1; lonIndex += 1) {
	                // Exterior Vertex rounded down to even index.
	                vertexIndex = (lonIndex & ~1) + latIndex * numLonVertices;
	                indices[index++] = vertexIndex;

	                // Interior vertex.
	                vertexIndex = lonIndex + (latIndex + 1) * numLonVertices;
	                indices[index++] = vertexIndex;
	            }

	            // Corner vertex.
	            lonIndex = numLonVertices - 1;
	            vertexIndex = lonIndex + latIndex * numLonVertices;
	            indices[index++] = vertexIndex;

	            this.indicesLoresSouthOffset = indices.length - numIndices;
	            this.indicesLoresSouth = new Uint16Array(indices.slice(this.indicesLoresSouthOffset));
	            this.numIndicesLoresSouth = numIndices;

	            // West border.
	            numIndices = 2 * numLatVertices - 2;
	            lonIndex = 0;

	            // Corner vertex.
	            latIndex = numLatVertices - 1;
	            vertexIndex = lonIndex + latIndex * numLonVertices;
	            indices[index++] = vertexIndex;

	            for (latIndex = numLatVertices - 2; latIndex > 0; latIndex -= 1) {
	                // Exterior Vertex rounded up to even index.
	                vertexIndex = lonIndex + ((latIndex + 1) & ~1) * numLonVertices;
	                indices[index++] = vertexIndex;

	                // Interior vertex.
	                vertexIndex = (lonIndex + 1) + latIndex * numLonVertices;
	                indices[index++] = vertexIndex;
	            }

	            // Corner vertex.
	            latIndex = 0;
	            vertexIndex = lonIndex + latIndex * numLonVertices;
	            indices[index++] = vertexIndex;

	            this.indicesLoresWestOffset = indices.length - numIndices;
	            this.indicesLoresWest = new Uint16Array(indices.slice(this.indicesLoresWestOffset));
	            this.numIndicesLoresWest = numIndices;

	            // East border.
	            numIndices = 2 * numLatVertices - 2;
	            lonIndex = numLonVertices - 1;

	            // Corner vertex.
	            latIndex = 0;
	            vertexIndex = lonIndex + latIndex * numLonVertices;
	            indices[index++] = vertexIndex;

	            for (latIndex = 1; latIndex < numLatVertices - 1; latIndex += 1) {
	                // Exterior vertex rounded down to even index.
	                vertexIndex = lonIndex + (latIndex & ~1) * numLonVertices;
	                indices[index++] = vertexIndex;

	                // Interior vertex.
	                vertexIndex = (lonIndex - 1) + latIndex * numLonVertices;
	                indices[index++] = vertexIndex;
	            }

	            // Corner vertex.
	            latIndex = numLatVertices - 1;
	            vertexIndex = lonIndex + latIndex * numLonVertices;
	            indices[index++] = vertexIndex;

	            this.indicesLoresEastOffset = indices.length - numIndices;
	            this.indicesLoresEast = new Uint16Array(indices.slice(this.indicesLoresEastOffset));
	            this.numIndicesLoresEast = numIndices;

	            var wireframeIndices = this.buildWireframeIndices(tileWidth, tileHeight);
	            var outlineIndices = this.buildOutlineIndices(tileWidth, tileHeight);

	            indices = indices.concat(wireframeIndices);
	            this.wireframeIndicesOffset = indices.length - this.numWireframeIndices;

	            indices = indices.concat(outlineIndices);
	            this.outlineIndicesOffset = indices.length - this.numOutlineIndices;

	            this.indices = new Uint16Array(indices);
	        };

	        Tessellator.prototype.buildWireframeIndices = function (tileWidth, tileHeight) {
	            // The wireframe representation draws the vertices that appear on the surface.

	            // The number of vertices in each dimension is 1 more than the number of cells.
	            var numLatVertices = tileHeight + 1;
	            var numLonVertices = tileWidth + 1;

	            // Allocate an array to hold the computed indices.
	            var numIndices = 2 * tileWidth * numLatVertices + 2 * tileHeight * numLonVertices;
	            var indices = [];

	            var rowStride = numLonVertices;

	            var index = 0,
	                lonIndex,
	                latIndex,
	                vertexIndex;

	            // Add a line between each row to define the horizontal cell outlines.
	            for (latIndex = 0; latIndex < numLatVertices; latIndex += 1) {
	                for (lonIndex = 0; lonIndex < tileWidth; lonIndex += 1) {
	                    vertexIndex = lonIndex + latIndex * rowStride;
	                    indices[index] = vertexIndex;
	                    indices[index + 1] = (vertexIndex + 1);
	                    index += 2
	                }
	            }

	            // Add a line between each column to define the vertical cell outlines.
	            for (lonIndex = 0; lonIndex < numLonVertices; lonIndex += 1) {
	                for (latIndex = 0; latIndex < tileHeight; latIndex += 1) {
	                    vertexIndex = lonIndex + latIndex * rowStride;
	                    indices[index] = vertexIndex;
	                    indices[index + 1] = (vertexIndex + rowStride);
	                    index += 2;
	                }
	            }

	            this.numWireframeIndices = numIndices;
	            return indices;
	        };

	        Tessellator.prototype.buildOutlineIndices = function (tileWidth, tileHeight) {
	            // The outline representation traces the tile's outer edge on the surface.

	            // The number of vertices in each dimension is 1 more than the number of cells.
	            var numLatVertices = tileHeight + 1;
	            var numLonVertices = tileWidth + 1;

	            // Allocate an array to hold the computed indices.
	            var numIndices = 2 * (numLatVertices - 2) + 2 * numLonVertices + 1;
	            var indices = [];

	            var rowStride = numLatVertices;

	            var index = 0,
	                lonIndex,
	                latIndex,
	                vertexIndex;

	            // Bottom row, starting at the left and going right.
	            latIndex = 0;
	            for (lonIndex = 0; lonIndex < numLonVertices; lonIndex += 1) {
	                vertexIndex = lonIndex + latIndex * numLonVertices;
	                indices[index] = vertexIndex;
	                index += 1;
	            }

	            // Right column, starting at the bottom and going up.
	            lonIndex = numLonVertices - 1;
	            for (latIndex = 1; latIndex < numLatVertices; latIndex += 1) {
	                vertexIndex = lonIndex + latIndex * numLonVertices;
	                indices[index] = vertexIndex;
	                index += 1
	            }

	            // Top row, starting on the right and going to the left.
	            latIndex = numLatVertices - 1;
	            for (lonIndex = numLonVertices - 1; lonIndex >= 0; lonIndex -= 1) {
	                vertexIndex = lonIndex + latIndex * numLonVertices;
	                indices[index] = vertexIndex;
	                index += 1
	            }

	            // Leftmost column, starting at the top and going down.
	            lonIndex = 0;
	            for (latIndex = numLatVertices - 1; latIndex >= 0; latIndex -= 1) {
	                vertexIndex = lonIndex + latIndex * numLonVertices;
	                indices[index] = vertexIndex;
	                index += 1
	            }

	            this.numOutlineIndices = numIndices;
	            return indices;
	        };

	        Tessellator.prototype.cacheSharedGeometryVBOs = function (dc) {
	            var gl = dc.currentGlContext,
	                gpuResourceCache = dc.gpuResourceCache;

	            var texCoordVbo = gpuResourceCache.resourceForKey(this.texCoordVboCacheKey);
	            if (!texCoordVbo) {
	                texCoordVbo = gl.createBuffer();
	                gl.bindBuffer(gl.ARRAY_BUFFER, texCoordVbo);
	                gl.bufferData(gl.ARRAY_BUFFER, this.texCoords, gl.STATIC_DRAW);
	                dc.frameStatistics.incrementVboLoadCount(1);
	                gpuResourceCache.putResource(this.texCoordVboCacheKey, texCoordVbo, this.texCoords.length * 4 / 2);
	            }

	            var indicesVbo = gpuResourceCache.resourceForKey(this.indicesVboCacheKey);
	            if (!indicesVbo) {
	                indicesVbo = gl.createBuffer();
	                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indicesVbo);
	                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW);
	                dc.frameStatistics.incrementVboLoadCount(1);
	                gpuResourceCache.putResource(this.indicesVboCacheKey, indicesVbo, this.indices.length * 2);
	            }
	        };

	        return Tessellator;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports Terrain
	 * @version $Id: Terrain.js 3018 2015-04-14 17:50:06Z dcollins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(30),
	        __webpack_require__(32),
	        __webpack_require__(35)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
	              Logger,
	              Vec3) {
	        "use strict";

	        /**
	         * Constructs a Terrain object.
	         * @alias Terrain
	         * @constructor
	         * @classdesc Represents terrain and provides functions for computing points on or relative to the terrain.
	         * Applications do not typically interact directly with this class.
	         */
	        var Terrain = function (globe, tessellator, terrainTiles, verticalExaggeration) {

	            /**
	             * The globe associated with this terrain.
	             * @type {Globe}
	             */
	            this.globe = globe;

	            /**
	             * The vertical exaggeration of this terrain.
	             * @type {Number}
	             */
	            this.verticalExaggeration = verticalExaggeration;

	            /**
	             * The sector spanned by this terrain.
	             * @type {Sector}
	             */
	            this.sector = terrainTiles.sector;

	            /**
	             * The tessellator used to generate this terrain.
	             * @type {Tessellator}
	             */
	            this.tessellator = tessellator;

	            /**
	             * The surface geometry for this terrain
	             * @type {TerrainTile[]}
	             */
	            this.surfaceGeometry = terrainTiles.tileArray;

	            /**
	             * A string identifying this terrain's current state. Used to compare states during rendering to
	             * determine whether state dependent cached values must be updated. Applications typically do not
	             * interact with this property.
	             * @readonly
	             * @type {String}
	             */
	            this.stateKey = globe.stateKey + " ve " + verticalExaggeration.toString();
	        };

	        Terrain.scratchPoint = new Vec3(0, 0, 0);

	        /**
	         * Computes a Cartesian point at a location on the surface of this terrain.
	         * @param {Number} latitude The location's latitude.
	         * @param {Number} longitude The location's longitude.
	         * @param {Number} offset Distance above the terrain, in meters, at which to compute the point.
	         * @param {Vec3} result A pre-allocated Vec3 in which to return the computed point.
	         * @returns {Vec3} The specified result parameter, set to the coordinates of the computed point. If the
	         * specfied location is not within this terrain, the associated globe is used to compute the point.
	         * @throws {ArgumentError} If the specified result argument is null or undefined.
	         */
	        Terrain.prototype.surfacePoint = function (latitude, longitude, offset, result) {
	            if (!result) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Terrain", "surfacePoint", "missingResult"));
	            }

	            for (var i = 0, len = this.surfaceGeometry.length; i < len; i++) {
	                if (this.surfaceGeometry[i].sector.containsLocation(latitude, longitude)) {
	                    this.surfaceGeometry[i].surfacePoint(latitude, longitude, result);

	                    if (offset) {
	                        var normal = this.globe.surfaceNormalAtPoint(result[0], result[1], result[2], Terrain.scratchPoint);
	                        result[0] += normal[0] * offset;
	                        result[1] += normal[1] * offset;
	                        result[2] += normal[2] * offset;
	                    }

	                    return result;
	                }
	            }

	            // No tile was found that contains the location, so approximate one using the globe.
	            var h = offset + this.globe.elevationAtLocation(latitude, longitude) * this.verticalExaggeration;
	            this.globe.computePointFromPosition(latitude, longitude, h, result);

	            return result;
	        };

	        /**
	         * Computes a Cartesian point at a location on the surface of this terrain according to a specified
	         * altitude mode.
	         * @param {Number} latitude The location's latitude.
	         * @param {Number} longitude The location's longitude.
	         * @param {Number} offset Distance above the terrain, in meters relative to the specified altitude mode, at
	         * which to compute the point.
	         * @param {String} altitudeMode The altitude mode to use to compute the point. Recognized values are
	         * WorldWind.ABSOLUTE, WorldWind.CLAMP_TO_GROUND and
	         * WorldWind.RELATIVE_TO_GROUND. The mode WorldWind.ABSOLUTE is used if the
	         * specified mode is null, undefined or unrecognized, or if the specified location is outside this terrain.
	         * @param {Vec3} result A pre-allocated Vec3 in which to return the computed point.
	         * @returns {Vec3} The specified result parameter, set to the coordinates of the computed point.
	         * @throws {ArgumentError} If the specified result argument is null or undefined.
	         */
	        Terrain.prototype.surfacePointForMode = function (latitude, longitude, offset, altitudeMode, result) {
	            if (!result) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Terrain", "surfacePointForMode", "missingResult"));
	            }

	            if (!altitudeMode)
	                altitudeMode = WorldWind.ABSOLUTE;

	            if (altitudeMode === WorldWind.CLAMP_TO_GROUND) {
	                return this.surfacePoint(latitude, longitude, 0, result);
	            } else if (altitudeMode === WorldWind.RELATIVE_TO_GROUND) {
	                return this.surfacePoint(latitude, longitude, offset, result);
	            } else {
	                var height = offset * this.verticalExaggeration;
	                this.globe.computePointFromPosition(latitude, longitude, height, result);
	                return result;
	            }
	        };

	        /**
	         * Initializes rendering state to draw a succession of terrain tiles.
	         * @param {DrawContext} dc The current draw context.
	         */
	        Terrain.prototype.beginRendering = function (dc) {
	            if (this.globe && this.globe.tessellator) {
	                this.globe.tessellator.beginRendering(dc);
	            }
	        };

	        /**
	         * Restores rendering state after drawing a succession of terrain tiles.
	         * @param {DrawContext} dc The current draw context.
	         */
	        Terrain.prototype.endRendering = function (dc) {
	            if (this.globe && this.globe.tessellator) {
	                this.globe.tessellator.endRendering(dc);
	            }
	        };

	        /**
	         * Initializes rendering state for drawing a specified terrain tile.
	         * @param {DrawContext} dc The current draw context.
	         * @param {TerrainTile} terrainTile The terrain tile subsequently drawn via this tessellator's render function.
	         * @throws {ArgumentError} If the specified tile is null or undefined.
	         */
	        Terrain.prototype.beginRenderingTile = function (dc, terrainTile) {
	            if (!terrainTile) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Terrain", "beginRenderingTile", "missingTile"));
	            }

	            if (this.globe && this.globe.tessellator) {
	                this.globe.tessellator.beginRenderingTile(dc, terrainTile);
	            }
	        };

	        /**
	         * Restores rendering state after drawing the most recent tile specified to
	         * [beginRenderingTile]{@link Terrain#beginRenderingTile}.
	         * @param {DrawContext} dc The current draw context.
	         * @param {TerrainTile} terrainTile The terrain tile most recently rendered.
	         * @throws {ArgumentError} If the specified tile is null or undefined.
	         */
	        Terrain.prototype.endRenderingTile = function (dc, terrainTile) {
	            // Intentionally empty.
	        };

	        /**
	         * Renders a specified terrain tile.
	         * @param {DrawContext} dc The current draw context.
	         * @param {TerrainTile} terrainTile The terrain tile to render.
	         * @throws {ArgumentError} If the specified tile is null or undefined.
	         */
	        Terrain.prototype.renderTile = function (dc, terrainTile) {
	            if (!terrainTile) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Terrain", "renderTile", "missingTile"));
	            }

	            if (this.globe && this.globe.tessellator) {
	                this.globe.tessellator.renderTile(dc, terrainTile);
	            }
	        };

	        /**
	         * Causes this terrain to perform the picking operations appropriate for the draw context's pick settings.
	         * Normally, this draws the terrain in a unique pick color and computes the picked terrain position. When the
	         * draw context is set to region picking mode this omits the computation of a picked terrain position.
	         * @param {DrawContext} dc The current draw context.
	         */
	        Terrain.prototype.pick = function (dc) {
	            if (this.globe && this.globe.tessellator) {
	                this.globe.tessellator.pick(dc, this.surfaceGeometry, this); // use this terrain as the userObject
	            }
	        };

	        return Terrain;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports TerrainTile
	 * @version $Id: TerrainTile.js 2936 2015-03-27 22:04:59Z tgaskins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(30),
	        __webpack_require__(32),
	        __webpack_require__(63),
	        __webpack_require__(77)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
	              Logger,
	              Matrix,
	              Tile) {
	        "use strict";

	        /**
	         * Constructs a terrain tile.
	         * @alias TerrainTile
	         * @constructor
	         * @augments Tile
	         * @classdesc Represents a portion of a globe's terrain. Applications typically do not interact directly with
	         * this class.
	         * @param {Sector} sector The sector this tile covers.
	         * @param {Level} level The level this tile is associated with.
	         * @param {Number} row This tile's row in the associated level.
	         * @param {Number} column This tile's column in the associated level.
	         * @throws {ArgumentError} If the specified sector or level is null or undefined or the row or column arguments
	         * are less than zero.
	         */
	        var TerrainTile = function (sector, level, row, column) {
	            Tile.call(this, sector, level, row, column); // args are checked in the superclass' constructor

	            /**
	             * The transformation matrix that maps tile local coordinates to model coordinates.
	             * @type {Matrix}
	             */
	            this.transformationMatrix = Matrix.fromIdentity();

	            /**
	             * The tile's model coordinate points.
	             * @type {Float32Array}
	             */
	            this.points = null;

	            /**
	             * Indicates the state of this tile when the model coordinate points were last updated. This is used to
	             * invalidate the points when this tile's state changes.
	             * @type {String}
	             */
	            this.pointsStateKey = null;

	            /**
	             * Indicates the state of this tile when the model coordinate VBO was last uploaded to GL. This is used to
	             * invalidate the VBO when the tile's state changes.
	             * @type {String}
	             */
	            this.pointsVboStateKey = null;

	            // Internal use. Intentionally not documented.
	            this.neighborMap = {};
	            this.neighborMap[WorldWind.NORTH] = null;
	            this.neighborMap[WorldWind.SOUTH] = null;
	            this.neighborMap[WorldWind.EAST] = null;
	            this.neighborMap[WorldWind.WEST] = null;

	            // Internal use. Intentionally not documented.
	            this._stateKey = null;

	            // Internal use. Intentionally not documented.
	            this._elevationTimestamp = null;

	            // Internal use. Intentionally not documented.
	            this.scratchArray = [];
	        };

	        TerrainTile.prototype = Object.create(Tile.prototype);

	        Object.defineProperties(TerrainTile.prototype, {
	            /**
	             * A string identifying the state of this tile as a function of the elevation model's timestamp and this
	             * tile's neighbors. Used to compare states during rendering to determine whether cached values must be
	             * updated. Applications typically do not interact with this property.
	             * @type {String}
	             * @memberof TerrainTile.prototype
	             * @readonly
	             */
	            stateKey: {
	                get: function () {
	                    if (!this._stateKey) {
	                        this._stateKey = this.computeStateKey();
	                    }

	                    return this._stateKey;
	                }
	            }
	        });

	        /**
	         * Indicates the level of the tile adjacent to this tile in a specified direction. This returns null when this
	         * tile has no neighbor in that direction.
	         * @param {String} direction The cardinal direction. Must be one of WorldWind.NORTH, WorldWind.SOUTH,
	         * WorldWind.EAST or WorldWind.WEST.
	         * @returns {Level} The neighbor tile's level in the specified direction, or null if there is no neighbor.
	         */
	        TerrainTile.prototype.neighborLevel = function (direction) {
	            return this.neighborMap[direction];
	        };

	        /**
	         * Specifies the level of the tile adjacent to this tile in a specified direction.
	         * @param {String} direction The cardinal direction. Must be one of WorldWind.NORTH, WorldWind.SOUTH,
	         * WorldWind.EAST or WorldWind.WEST.
	         * @param {Level} level The neighbor tile's level in the specified direction, or null to indicate that there is
	         * no neighbor in that direction.
	         */
	        TerrainTile.prototype.setNeighborLevel = function (direction, level) {
	            this.neighborMap[direction] = level;
	            this._stateKey = null; // cause updates to any neighbor-dependent cached state
	        };

	        /**
	         * Computes a point on the terrain at a specified location.
	         * @param {Number} latitude The location's latitude.
	         * @param {Number} longitude The location's longitude.
	         * @param {Vec3} result A pre-allocated Vec3 in which to return the computed point.
	         * @returns {Vec3} The result argument set to the computed point.
	         * @throws {ArgumentError} If the specified result argument is null or undefined.
	         */
	        TerrainTile.prototype.surfacePoint = function (latitude, longitude, result) {
	            if (!result) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "TerrainTile", "surfacePoint", "missingResult"));
	            }

	            var tileSector = this.sector,
	                minLat = tileSector.minLatitude,
	                maxLat = tileSector.maxLatitude,
	                minLon = tileSector.minLongitude,
	                maxLon = tileSector.maxLongitude,
	                tileWidth = this.tileWidth,
	                tileHeight = this.tileHeight,
	                s, t, si, ti, rowStride, vertices, points, k, sf, tf, x, y, z;

	            // Compute the location's horizontal (s) and vertical (t) parameterized coordinates within the tiles 2D grid of
	            // points as a floating-point value in the range [0, tileWidth] and [0, tileHeight]. These coordinates indicate
	            // which cell contains the location, as well as the location's placement within the cell. Note that this method
	            // assumes that the caller has tested whether the location is contained within the tile's sector.
	            s = (longitude - minLon) / (maxLon - minLon) * tileWidth;
	            t = (latitude - minLat) / (maxLat - minLat) * tileHeight;

	            // Get the coordinates for the four vertices defining the cell this point is in. Tile vertices start in the lower
	            // left corner and proceed in row major order across the tile. The tile contains one more vertex per row or
	            // column than the tile width or height. Vertices in the points array are organized in the
	            // following order: lower-left, lower-right, upper-left, upper-right. The cell's diagonal starts at the
	            // lower-left vertex and ends at the upper-right vertex.
	            si = s < tileWidth ? Math.floor(s) : tileWidth - 1;
	            ti = t < tileHeight ? Math.floor(t) : tileHeight - 1;
	            rowStride = tileWidth + 1;

	            vertices = this.points;
	            points = this.scratchArray; // temporary working buffer
	            k = 3 * (si + ti * rowStride); // lower-left and lower-right vertices
	            for (var i = 0; i < 6; i++) {
	                points[i] = vertices[k + i];
	            }

	            k = 3 * (si + (ti + 1) * rowStride); // upper-left and upper-right vertices
	            for (var j = 6; j < 12; j++) {
	                points[j] = vertices[k + (j - 6)];
	            }

	            // Compute the location's corresponding point on the cell in tile local coordinates,
	            // given the fractional portion of the parameterized s and t coordinates. These values indicate the location's
	            // relative placement within the cell. The cell's vertices are defined in the following order: lower-left,
	            // lower-right, upper-left, upper-right. The cell's diagonal starts at the lower-right vertex and ends at the
	            // upper-left vertex.
	            sf = (s < tileWidth ? s - Math.floor(s) : 1);
	            tf = (t < tileHeight ? t - Math.floor(t) : 1);

	            if (sf > tf) {
	                result[0] = points[0] + sf * (points[3] - points[0]) + tf * (points[6] - points[0]);
	                result[1] = points[1] + sf * (points[4] - points[1]) + tf * (points[7] - points[1]);
	                result[2] = points[2] + sf * (points[5] - points[2]) + tf * (points[8] - points[2]);
	            }
	            else {
	                result[0] = points[9] + (1 - sf) * (points[6] - points[9]) + (1 - tf) * (points[3] - points[9]);
	                result[1] = points[10] + (1 - sf) * (points[7] - points[10]) + (1 - tf) * (points[4] - points[10]);
	                result[2] = points[11] + (1 - sf) * (points[8] - points[11]) + (1 - tf) * (points[5] - points[11]);
	            }

	            result[0] += this.referencePoint[0];
	            result[1] += this.referencePoint[1];
	            result[2] += this.referencePoint[2];

	            return result;
	        };

	        TerrainTile.prototype.update = function (dc) {
	            Tile.prototype.update.call(this, dc);

	            var elevationTimestamp = dc.globe.elevationTimestamp();
	            if (this._elevationTimestamp != elevationTimestamp) {
	                this._elevationTimestamp = elevationTimestamp;
	                this._stateKey = null; // cause updates to any elevation-dependent cached state
	            }
	        };

	        // Intentionally not documented.
	        TerrainTile.prototype.computeStateKey = function () {
	            var array = [];
	            array.push(this._elevationTimestamp);
	            array.push(this.neighborMap[WorldWind.NORTH] ? this.neighborMap[WorldWind.NORTH].compare(this.level) : 0);
	            array.push(this.neighborMap[WorldWind.SOUTH] ? this.neighborMap[WorldWind.SOUTH].compare(this.level) : 0);
	            array.push(this.neighborMap[WorldWind.EAST] ? this.neighborMap[WorldWind.EAST].compare(this.level) : 0);
	            array.push(this.neighborMap[WorldWind.WEST] ? this.neighborMap[WorldWind.WEST].compare(this.level) : 0);

	            return array.join(".");
	        };

	        return TerrainTile;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports TerrainTileList
	 * @version $Id: TerrainTileList.js 2758 2015-02-09 00:20:46Z tgaskins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(30),
	        __webpack_require__(32),
	        __webpack_require__(75)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
	              Logger,
	              Sector) {
	        "use strict";

	        /**
	         * Constructs a terrain tile list, a container for terrain tiles that also has a tessellator and a sector
	         * associated with it.
	         * @alias TerrainTileList
	         * @constructor
	         * @classdesc Represents a portion of a globe's terrain.
	         * @param {Tessellator} tessellator The tessellator that created this terrain tile list.
	         *
	         */
	        var TerrainTileList = function TerrainTileList(tessellator) {
	            if (!tessellator) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "TerrainTileList", "TerrainTileList", "missingTessellator"));
	            }
	            this.tessellator = tessellator;
	            this.sector = null;
	            this.tileArray = [];
	        };

	        Object.defineProperties(TerrainTileList.prototype, {
	            /**
	             * The number of terrain tiles in this terrain tile list.
	             * @memberof TerrainTileList.prototype
	             * @readonly
	             * @type {Number}
	             */
	            length: {
	                get: function () {
	                    return this.tileArray.length
	                }
	            }
	        });

	        TerrainTileList.prototype.addTile = function (tile) {
	            if (!tile) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "TerrainTileList", "addTile", "missingTile"));
	            }

	            if (this.tileArray.indexOf(tile) == -1) {
	                this.tileArray.push(tile);

	                if (!this.sector) {
	                    this.sector = new Sector(0, 0, 0, 0);
	                    this.sector.copy(tile.sector);
	                } else {
	                    this.sector.union(tile.sector);
	                }
	            }
	        };

	        TerrainTileList.prototype.removeAllTiles = function () {
	            this.tileArray = [];
	            this.sector = null;
	        };

	        return TerrainTileList;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports Globe2D
	 * @version $Id: Globe2D.js 3205 2015-06-17 18:05:23Z tgaskins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(113),
	        __webpack_require__(108),
	        __webpack_require__(119)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Globe,
	              ProjectionEquirectangular,
	              ZeroElevationModel) {
	        "use strict";

	        /**
	         * Constructs a 2D globe with a default {@link ZeroElevationModel} and
	         * [equirectangular projection]{@link ProjectionEquirectangular}.
	         * @alias Globe2D
	         * @constructor
	         * @augments Globe
	         * @classdesc Represents a 2D flat globe with a configurable projection.
	         * The default rectangular projection scrolls longitudinally.
	         */
	        var Globe2D = function () {
	            Globe.call(this, new ZeroElevationModel(), new ProjectionEquirectangular());
	        };

	        Globe2D.prototype = Object.create(Globe.prototype);

	        return Globe2D;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports ZeroElevationModel
	 * @version $Id: ZeroElevationModel.js 2936 2015-03-27 22:04:59Z tgaskins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(30),
	        __webpack_require__(97),
	        __webpack_require__(28),
	        __webpack_require__(32),
	        __webpack_require__(75)], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
	              ElevationModel,
	              Location,
	              Logger,
	              Sector) {
	        "use strict";

	        /**
	         * Constructs a Zero elevation model whose elevations are zero at every location.
	         * @alias ZeroElevationModel
	         * @constructor
	         * @classdesc Represents an elevation model whose elevations are zero at all locations.
	         * @augments ElevationModel
	         */
	        var ZeroElevationModel = function () {
	            ElevationModel.call(this, Sector.FULL_SPHERE, new Location(45, 45), 1, " ", " ", 150, 150);

	            /**
	             * Indicates this elevation model's display name.
	             * @type {string}
	             * @default "Zero Elevations"
	             */
	            this.displayName = "Zero Elevations";

	            /**
	             * Indicates the last time this elevation model changed. Since a zero elevation model never changes, this
	             * property always returns the date and time at which the elevation model was constructed, in milliseconds
	             * since midnight Jan 1, 1970.
	             * @type {number}
	             * @default Date.getTime() at construction
	             * @readonly
	             */
	            this.timestamp = Date.now();

	            /**
	             * This elevation model's minimum elevation, which is always 0.
	             * @type {number}
	             * @default 0
	             * @readonly
	             */
	            this.minElevation = 0;

	            /**
	             * This elevation model's maximum elevation, which is always 0.
	             * @type {number}
	             * @default 0
	             * @readonly
	             */
	            this.maxElevation = 0;
	        };

	        // Inherit from the abstract elevation model class.
	        ZeroElevationModel.prototype = Object.create(ElevationModel.prototype);

	        /**
	         * Returns minimum and maximum elevations of 0.
	         * @param {Sector} sector The sector for which to determine extreme elevations.
	         * @returns {Number[]} An array containing minimum and maximum elevations of 0.
	         */
	        ZeroElevationModel.prototype.minAndMaxElevationsForSector = function (sector) {
	            return [0, 0];
	        };

	        /**
	         * Returns 0 as the elevation at a specified location.
	         * @param {Number} latitude The location's latitude in degrees.
	         * @param {Number} longitude The location's longitude in degrees.
	         * @returns {Number} 0.
	         */
	        ZeroElevationModel.prototype.elevationAtLocation = function (latitude, longitude) {
	            return 0;
	        };

	        /**
	         * Returns the elevations at locations within a specified sector. For this elevation model they are all 0.
	         * @param {Sector} sector The sector for which to determine the elevations.
	         * @param {Number} numLat The number of latitudinal sample locations within the sector.
	         * @param {Number} numLon The number of longitudinal sample locations within the sector.
	         * @param {Number} targetResolution The desired elevation resolution.
	         * @param {Number[]} result An array of size numLat x numLon to contain the requested elevations.
	         * This array must be allocated when passed to this function.
	         * @returns {Number} The resolution actually achieved, which may be greater than that requested if the
	         * elevation data for the requested resolution is not currently available.
	         * @throws {ArgumentError} If the specified sector or result array is null or undefined, if either of the
	         * specified numLat or numLon values is less than 1, or the result array is not of sufficient length
	         * to hold numLat x numLon values.
	         */
	        ZeroElevationModel.prototype.elevationsForGrid = function (sector, numLat, numLon, targetResolution, result) {
	            if (!sector) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "ZeroElevationModel", "elevationsForSector", "missingSector"));
	            }

	            if (numLat <= 0 || numLon <= 0) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "ZeroElevationModel",
	                    "elevationsForSector", "numLat or numLon is less than 1"));
	            }

	            if (!result || result.length < numLat * numLon) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "ZeroElevationModel",
	                    "elevationsForSector", "missingArray"));
	            }

	            for (var i = 0, len = result.length; i < len; i++) {
	                result[i] = 0;
	            }

	            return 0;
	        };

	        return ZeroElevationModel;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports GoToAnimator
	 * @version $Id: GoToAnimator.js 3164 2015-06-09 15:35:14Z tgaskins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(28),
	        __webpack_require__(32),
	        __webpack_require__(47),
	        __webpack_require__(35)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Location,
	              Logger,
	              Position,
	              Vec3) {
	        "use strict";

	        /**
	         * Constructs a GoTo animator.
	         * @alias GoToAnimator
	         * @constructor
	         * @classdesc Incrementally and smoothly moves a {@link Navigator} to a specified position.
	         * @param {WorldWindow} worldWindow The World Window in which to perform the animation.
	         * @throws {ArgumentError} If the specified World Window is null or undefined.
	         */
	        var GoToAnimator = function (worldWindow) {
	            if (!worldWindow) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "GoToAnimator", "constructor",
	                    "missingWorldWindow"));
	            }

	            /**
	             * The World Window associated with this animator.
	             * @type {WorldWindow}
	             * @readonly
	             */
	            this.wwd = worldWindow;

	            /**
	             * The frequency in milliseconds at which to animate the position change.
	             * @type {Number}
	             * @default 20
	             */
	            this.animationFrequency = 20;

	            /**
	             * The animation's duration, in milliseconds. When the distance is short, less than twice the viewport
	             * size, the travel time is reduced proportionally to the distance to travel. It therefore takes less
	             * time to move shorter distances.
	             * @type {Number}
	             * @default 3000
	             */
	            this.travelTime = 3000;

	            /**
	             * Indicates whether the current or most recent animation has been cancelled. Use the cancel() function
	             * to cancel an animation.
	             * @type {Boolean}
	             * @default false
	             * @readonly
	             */
	            this.cancelled = false;
	        };

	        // Stop the current animation.
	        GoToAnimator.prototype.cancel = function () {
	            this.cancelled = true;
	        };

	        /**
	         * Moves the navigator to a specified location or position.
	         * @param {Location | Position} position The location or position to move the navigator to. If this
	         * argument contains an "altitude" property, as {@link Position} does, the end point of the navigation is
	         * at the specified altitude. Otherwise the end point is at the current altitude of the navigator.
	         * @param {Function} completionCallback If not null or undefined, specifies a function to call when the
	         * animation completes. The completion callback is called with a single argument, this animator.
	         * @throws {ArgumentError} If the specified location or position is null or undefined.
	         */
	        GoToAnimator.prototype.goTo = function (position, completionCallback) {
	            if (!position) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "GoToAnimator", "goTo",
	                    "missingPosition"));
	            }

	            this.completionCallback = completionCallback;

	            // Reset the cancellation flag.
	            this.cancelled = false;

	            // Capture the target position and determine its altitude.
	            this.targetPosition = new Position(position.latitude, position.longitude,
	                position.altitude || this.wwd.navigator.range);

	            // Capture the start position and start time.
	            this.startPosition = new Position(
	                this.wwd.navigator.lookAtLocation.latitude,
	                this.wwd.navigator.lookAtLocation.longitude,
	                this.wwd.navigator.range);
	            this.startTime = Date.now();

	            // Determination of the pan and range velocities requires the distance to be travelled.
	            var animationDuration = this.travelTime,
	                panDistance = Location.greatCircleDistance(this.startPosition, this.targetPosition),
	                rangeDistance;

	            // Determine how high we need to go to give the user context. The max altitude computed is approximately
	            // that needed to fit the start and end positions in the same viewport assuming a 45 degree field of view.
	            var pA = this.wwd.globe.computePointFromLocation(
	                    this.startPosition.latitude, this.startPosition.longitude, new Vec3(0, 0, 0)),
	                pB = this.wwd.globe.computePointFromLocation(
	                    this.targetPosition.latitude, this.targetPosition.longitude, new Vec3(0, 0, 0));
	            this.maxAltitude = pA.distanceTo(pB);

	            // Determine an approximate viewport size in radians in order to determine whether we actually change
	            // the range as we pan to the new location. We don't want to change the range if the distance between
	            // the start and target positions is small relative to the current viewport.
	            var viewportSize = this.wwd.navigator.currentState().pixelSizeAtDistance(this.startPosition.altitude)
	                * this.wwd.canvas.clientWidth / this.wwd.globe.equatorialRadius;

	            if (panDistance <= 2 * viewportSize) {
	                // Start and target positions are close, so don't back out.
	                this.maxAltitude = this.startPosition.altitude;
	            }

	            // We need to capture the time the max altitude is reached in order to begin decreasing the range
	            // midway through the animation. If we're already above the max altitude, then that time is now since
	            // we don't back out if the current altitude is above the computed max altitude.
	            this.maxAltitudeReachedTime = this.maxAltitude <= this.wwd.navigator.range ? Date.now() : null;

	            // Compute the total range to travel since we need that to compute the range velocity.
	            // Note that the range velocity and pan velocity are computed so that the respective animations, which
	            // operate independently, finish at the same time.
	            if (this.maxAltitude > this.startPosition.altitude) {
	                rangeDistance = Math.max(0, this.maxAltitude - this.startPosition.altitude);
	                rangeDistance += Math.abs(this.targetPosition.altitude - this.maxAltitude);
	            } else {
	                rangeDistance = Math.abs(this.targetPosition.altitude - this.startPosition.altitude);
	            }

	            // Determine which distance governs the animation duration.
	            var animationDistance = Math.max(panDistance, rangeDistance / this.wwd.globe.equatorialRadius);
	            if (animationDistance === 0) {
	                return; // current and target positions are the same
	            }

	            if (animationDistance < 2 * viewportSize) {
	                // Start and target positions are close, so reduce the travel time based on the
	                // distance to travel relative to the viewport size.
	                animationDuration = Math.min((animationDistance / viewportSize) * this.travelTime, this.travelTime);
	            }

	            // Don't let the animation duration go to 0.
	            animationDuration = Math.max(1, animationDuration);

	            // Determine the pan velocity, in radians per millisecond.
	            this.panVelocity = panDistance / animationDuration;

	            // Determine the range velocity, in meters per millisecond.
	            this.rangeVelocity = rangeDistance / animationDuration; // meters per millisecond

	            // Set up the animation timer.
	            var thisAnimator = this;
	            var timerCallback = function () {
	                if (thisAnimator.cancelled) {
	                    if (thisAnimator.completionCallback) {
	                        thisAnimator.completionCallback(thisAnimator);
	                    }
	                    return;
	                }

	                if (thisAnimator.update()) {
	                    setTimeout(timerCallback, thisAnimator.animationFrequency);
	                } else if (thisAnimator.completionCallback) {
	                    thisAnimator.completionCallback(thisAnimator);
	                }
	            };
	            setTimeout(timerCallback, this.animationFrequency); // invoke it the first time
	        };

	        // Intentionally not documented.
	        GoToAnimator.prototype.update = function () {
	            // This is the timer callback function. It invokes the range animator and the pan animator.

	            var currentPosition = new Position(
	                this.wwd.navigator.lookAtLocation.latitude,
	                this.wwd.navigator.lookAtLocation.longitude,
	                this.wwd.navigator.range);

	            var continueAnimation = this.updateRange(currentPosition);
	            continueAnimation = this.updateLocation(currentPosition) || continueAnimation;

	            this.wwd.redraw();

	            return continueAnimation;
	        };

	        // Intentionally not documented.
	        GoToAnimator.prototype.updateRange = function (currentPosition) {
	            // This function animates the range.
	            var continueAnimation = false,
	                nextRange, elapsedTime;

	            // If we haven't reached the maximum altitude, then step-wise increase it. Otherwise step-wise change
	            // the range towards the target altitude.
	            if (!this.maxAltitudeReachedTime) {
	                elapsedTime = Date.now() - this.startTime;
	                nextRange = Math.min(this.startPosition.altitude + this.rangeVelocity * elapsedTime, this.maxAltitude);
	                // We're done if we get withing 1 meter of the desired range.
	                if (Math.abs(this.wwd.navigator.range - nextRange) < 1) {
	                    this.maxAltitudeReachedTime = Date.now();
	                }
	                this.wwd.navigator.range = nextRange;
	                continueAnimation = true;
	            } else {
	                elapsedTime = Date.now() - this.maxAltitudeReachedTime;
	                if (this.maxAltitude > this.targetPosition.altitude) {
	                    nextRange = this.maxAltitude - (this.rangeVelocity * elapsedTime);
	                    nextRange = Math.max(nextRange, this.targetPosition.altitude);
	                } else {
	                    nextRange = this.maxAltitude + (this.rangeVelocity * elapsedTime);
	                    nextRange = Math.min(nextRange, this.targetPosition.altitude);
	                }
	                this.wwd.navigator.range = nextRange;
	                // We're done if we get withing 1 meter of the desired range.
	                continueAnimation = Math.abs(this.wwd.navigator.range - this.targetPosition.altitude) > 1;
	            }

	            return continueAnimation;
	        };

	        // Intentionally not documented.
	        GoToAnimator.prototype.updateLocation = function (currentPosition) {
	            // This function animates the pan to the desired location.
	            var elapsedTime = Date.now() - this.startTime,
	                distanceTravelled = Location.greatCircleDistance(this.startPosition, currentPosition),
	                distanceRemaining = Location.greatCircleDistance(currentPosition, this.targetPosition),
	                azimuthToTarget = Location.greatCircleAzimuth(currentPosition, this.targetPosition),
	                distanceForNow = this.panVelocity * elapsedTime,
	                nextDistance = Math.min(distanceForNow - distanceTravelled, distanceRemaining),
	                nextLocation = Location.greatCircleLocation(currentPosition, azimuthToTarget, nextDistance,
	                    new Location(0, 0)),
	                locationReached = false;

	            this.wwd.navigator.lookAtLocation.latitude = nextLocation.latitude;
	            this.wwd.navigator.lookAtLocation.longitude = nextLocation.longitude;

	            // We're done if we're within a meter of the desired location.
	            if (nextDistance < 1 / this.wwd.globe.equatorialRadius) {
	                locationReached = true;
	            }

	            return !locationReached;
	        };

	        return GoToAnimator;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports DrawContext
	 * @version $Id: DrawContext.js 3351 2015-07-28 22:03:20Z dcollins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(30),
	        __webpack_require__(52),
	        __webpack_require__(112),
	        __webpack_require__(123),
	        __webpack_require__(124),
	        __webpack_require__(62),
	        __webpack_require__(113),
	        __webpack_require__(81),
	        __webpack_require__(49),
	        __webpack_require__(126),
	        __webpack_require__(32),
	        __webpack_require__(63),
	        __webpack_require__(65),
	        __webpack_require__(122),
	        __webpack_require__(33),
	        __webpack_require__(47),
	        __webpack_require__(37),
	        __webpack_require__(127),
	        __webpack_require__(75),
	        __webpack_require__(131),
	        __webpack_require__(133),
	        __webpack_require__(72),
	        __webpack_require__(134),
	        __webpack_require__(46),
	        __webpack_require__(35),
	        __webpack_require__(36)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
	              Color,
	              FrameStatistics,
	              FramebufferTexture,
	              FramebufferTileController,
	              Frustum,
	              Globe,
	              GpuProgram,
	              GpuResourceCache,
	              Layer,
	              Logger,
	              Matrix,
	              NavigatorState,
	              PickedObjectList,
	              Plane,
	              Position,
	              Rectangle,
	              ScreenCreditController,
	              Sector,
	              SurfaceShape,
	              SurfaceShapeTileBuilder,
	              SurfaceTileRenderer,
	              TextSupport,
	              Vec2,
	              Vec3,
	              WWMath) {
	        "use strict";

	        /**
	         * Constructs a DrawContext. Applications do not call this constructor. A draw context is created by a
	         * {@link WorldWindow} during its construction.
	         * @alias DrawContext
	         * @constructor
	         * @classdesc Provides current state during rendering. The current draw context is passed to most rendering
	         * methods in order to make those methods aware of current state.
	         * @param {WebGLRenderingContext} gl The WebGL rendering context this draw context is associated with.
	         * @throws {ArgumentError} If the specified WebGL rendering context is null or undefined.
	         */
	        var DrawContext = function (gl) {
	            if (!gl) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "Texture", "constructor",
	                    "missingGlContext"));
	            }

	            /**
	             * The current WebGL rendering context.
	             * @type {WebGLRenderingContext}
	             */
	            this.currentGlContext = gl;

	            /**
	             * A 2D canvas for creating texture maps.
	             * @type {HTMLElement}
	             */
	            this.canvas2D = document.createElement("canvas");

	            /**
	             * A 2D context for this draw context's [canvas property]{@link DrawContext#canvas}.
	             */
	            this.ctx2D = this.canvas2D.getContext("2d");

	            /**
	             * The current clear color.
	             * @type {Color}
	             * @default Color.TRANSPARENT (red = 0, green = 0, blue = 0, alpha = 0)
	             */
	            this.clearColor = Color.TRANSPARENT;

	            /**
	             * The GPU resource cache, which tracks WebGL resources.
	             * @type {GpuResourceCache}
	             */
	            this.gpuResourceCache = new GpuResourceCache(WorldWind.configuration.gpuCacheSize,
	                0.8 * WorldWind.configuration.gpuCacheSize);

	            /**
	             * The surface-tile-renderer to use for drawing surface tiles.
	             * @type {SurfaceTileRenderer}
	             */
	            this.surfaceTileRenderer = new SurfaceTileRenderer();

	            /**
	             * The surface shape tile builder used to create and draw surface shapes.
	             * @type {SurfaceShapeTileBuilder}
	             */
	            this.surfaceShapeTileBuilder = new SurfaceShapeTileBuilder();

	            /**
	             * Provides access to a multi-resolution WebGL framebuffer arranged as adjacent tiles in a pyramid. Surface
	             * shapes use these tiles internally to draw on the terrain surface.
	             * @type {FramebufferTileController}
	             */
	            this.surfaceShapeTileController = new FramebufferTileController();

	            /**
	             * The screen credit controller responsible for collecting and drawing screen credits.
	             * @type {ScreenCreditController}
	             */
	            this.screenCreditController = new ScreenCreditController();

	            /**
	             * A shared TextSupport instance.
	             * @type {TextSupport}
	             */
	            this.textSupport = new TextSupport();

	            /**
	             * The current WebGL framebuffer. Null indicates that the default WebGL framebuffer is active.
	             * @type {FramebufferTexture}
	             */
	            this.currentFramebuffer = null;

	            /**
	             * The current WebGL program. Null indicates that no WebGL program is active.
	             * @type {GpuProgram}
	             */
	            this.currentProgram = null;

	            /**
	             * The list of surface renderables.
	             * @type {Array}
	             */
	            this.surfaceRenderables = [];

	            /**
	             * Indicates whether this draw context is in ordered rendering mode.
	             * @type {Boolean}
	             */
	            this.orderedRenderingMode = false;

	            /**
	             * The list of ordered renderables.
	             * @type {Array}
	             */
	            this.orderedRenderables = [];

	            /**
	             * The list of screen renderables.
	             * @type {Array}
	             */
	            this.screeRenderables = [];

	            // Internal. Intentionally not documented. Provides ordinal IDs to ordered renderables.
	            this.orderedRenderablesCounter = 0; // Number

	            /**
	             * The starting time of the current frame, in milliseconds. The frame timestamp is updated immediately
	             * before the World Window associated with this draw context is rendered, either as a result of redrawing or
	             * as a result of a picking operation.
	             * @type {Number}
	             * @readonly
	             */
	            this.timestamp = Date.now();

	            /**
	             * The [time stamp]{@link DrawContext#timestamp} of the last visible frame, in milliseconds. This indicates
	             * the time stamp that was current during the World Window's last frame, ignoring frames associated with a
	             * picking operation. The difference between the previous redraw time stamp and the current time stamp
	             * indicates the duration between visible frames, e.g. <code style='white-space:nowrap'>timeStamp - previousRedrawTimestamp</code>.
	             * @type {Number}
	             * @readonly
	             */
	            this.previousRedrawTimestamp = this.timestamp;

	            /**
	             * Indicates whether a redraw has been requested during the current frame. When true, this causes the World
	             * Window associated with this draw context to redraw after the current frame.
	             * @type {Boolean}
	             */
	            this.redrawRequested = false;

	            /**
	             * The globe being rendered.
	             * @type {Globe}
	             */
	            this.globe = null;

	            /**
	             * A copy of the current globe's state key. Provided here to avoid having to recompute it every time
	             * it's needed.
	             * @type {String}
	             */
	            this.globeStateKey = null;

	            /**
	             * The layers being rendered.
	             * @type {Layer[]}
	             */
	            this.layers = null;

	            /**
	             * The layer being rendered.
	             * @type {Layer}
	             */
	            this.currentLayer = null;

	            /**
	             * The current state of the associated navigator.
	             * @type {NavigatorState}
	             */
	            this.navigatorState = null;

	            /**
	             * The current eye position.
	             * @type {Position}
	             */
	            this.eyePosition = new Position(0, 0, 0);

	            /**
	             * The current screen projection matrix.
	             * @type {Matrix}
	             */
	            this.screenProjection = Matrix.fromIdentity();

	            /**
	             * The terrain for the current frame.
	             * @type {Terrain}
	             */
	            this.terrain = null;

	            /**
	             * The current vertical exaggeration.
	             * @type {Number}
	             */
	            this.verticalExaggeration = 1;

	            /**
	             * The number of milliseconds over which to fade shapes that support fading. Fading is most typically
	             * used during decluttering.
	             * @type {Number}
	             * @default 500
	             */
	            this.fadeTime = 500;

	            /**
	             * The opacity to apply to terrain and surface shapes. Should be a number between 0 and 1.
	             * @type {Number}
	             * @default 1
	             */
	            this.surfaceOpacity = 1;

	            /**
	             * Frame statistics.
	             * @type {FrameStatistics}
	             */
	            this.frameStatistics = null;

	            /**
	             * Indicates whether the frame is being drawn for picking.
	             * @type {Boolean}
	             */
	            this.pickingMode = false;

	            /**
	             * Indicates that picking will return only the terrain object, if the pick point is over the terrain.
	             * @type {Boolean}
	             * @default false
	             */
	            this.pickTerrainOnly = false;

	            /**
	             * Indicates that picking will return all objects at the pick point, if any. The top-most object will have
	             * its isOnTop flag set to true. If [deep picking]{@link WorldWindow#deepPicking} is false, the default,
	             * only the top-most object is returned, plus the picked-terrain object if the pick point is over the
	             * terrain.
	             * @type {Boolean}
	             * @default false
	             */
	            this.deepPicking = false;

	            /**
	             * Indicates that picking will return all objects that intersect the pick region, if any. Visible objects
	             * will have the isOnTop flag set to true.
	             * @type {Boolean}
	             * @default false
	             */
	            this.regionPicking = false;

	            /**
	             * The current pick point, in screen coordinates.
	             * @type {Vec2}
	             */
	            this.pickPoint = null;

	            /**
	             * The current pick rectangle, in WebGL (lower-left origin) screen coordinates.
	             * @type {Rectangle}
	             */
	            this.pickRectangle = null;

	            /**
	             * The off-screen WebGL framebuffer used during picking.
	             * @type {FramebufferTexture}
	             * @readonly
	             */
	            this.pickFramebuffer = null;

	            /**
	             * The current pick frustum, created anew each picking frame.
	             * @type {Frustum}
	             * @readonly
	             */
	            this.pickFrustum = null;

	            // Internal. Keeps track of the current pick color.
	            this.pickColor = new Color(0, 0, 0, 1);

	            /**
	             * The objects at the current pick point.
	             * @type {PickedObjectList}
	             * @readonly
	             */
	            this.objectsAtPickPoint = new PickedObjectList();

	            // Intentionally not documented.
	            this.pixelScale = 1;
	        };

	        // Internal use. Intentionally not documented.
	        DrawContext.unitCubeKey = "DrawContextUnitCubeKey";
	        DrawContext.unitCubeElementsKey = "DrawContextUnitCubeElementsKey";
	        DrawContext.unitQuadKey = "DrawContextUnitQuadKey";
	        DrawContext.unitQuadKey3 = "DrawContextUnitQuadKey3";

	        /**
	         * Prepare this draw context for the drawing of a new frame.
	         */
	        DrawContext.prototype.reset = function () {
	            // Reset the draw context's internal properties.
	            this.screenCreditController.clear();
	            this.surfaceRenderables = []; // clears the surface renderables array
	            this.orderedRenderingMode = false;
	            this.orderedRenderables = []; // clears the ordered renderables array
	            this.screenRenderables = [];
	            this.orderedRenderablesCounter = 0;

	            // Advance the per-frame timestamp.
	            var previousTimestamp = this.timestamp;
	            this.timestamp = Date.now();
	            if (this.timestamp === previousTimestamp)
	                ++this.timestamp;

	            // Reset properties set by the World Window every frame.
	            this.redrawRequested = false;
	            this.globe = null;
	            this.globeStateKey = null;
	            this.layers = null;
	            this.currentLayer = null;
	            this.navigatorState = null;
	            this.terrain = null;
	            this.verticalExaggeration = 1;
	            this.frameStatistics = null;
	            this.accumulateOrderedRenderables = true;

	            // Reset picking properties that may be set by the World Window.
	            this.pickingMode = false;
	            this.pickTerrainOnly = false;
	            this.deepPicking = false;
	            this.regionPicking = false;
	            this.pickPoint = null;
	            this.pickRectangle = null;
	            this.pickFrustum = null;
	            this.pickColor = new Color(0, 0, 0, 1);
	            this.objectsAtPickPoint.clear();
	        };

	        /**
	         * Computes any values necessary to render the upcoming frame. Called after all draw context state for the
	         * frame has been set.
	         */
	        DrawContext.prototype.update = function () {
	            var gl = this.currentGlContext,
	                eyePoint = this.navigatorState.eyePoint;

	            this.globeStateKey = this.globe.stateKey;
	            this.globe.computePositionFromPoint(eyePoint[0], eyePoint[1], eyePoint[2], this.eyePosition);
	            this.screenProjection.setToScreenProjection(gl.drawingBufferWidth, gl.drawingBufferHeight);
	        };

	        /**
	         * Notifies this draw context that the current WebGL rendering context has been lost. This function removes all
	         * cached WebGL resources and resets all properties tracking the current WebGL state.
	         */
	        DrawContext.prototype.contextLost = function () {
	            // Remove all cached WebGL resources, which are now invalid.
	            this.gpuResourceCache.clear();
	            this.pickFramebuffer = null;
	            // Reset properties tracking the current WebGL state, which are now invalid.
	            this.currentFramebuffer = null;
	            this.currentProgram = null;
	        };

	        /**
	         * Notifies this draw context that the current WebGL rendering context has been restored. This function prepares
	         * this draw context to resume rendering.
	         */
	        DrawContext.prototype.contextRestored = function () {
	            // Remove all cached WebGL resources. This cache is already cleared when the context is lost, but
	            // asynchronous load operations that complete between context lost and context restored populate the cache
	            // with invalid entries.
	            this.gpuResourceCache.clear();
	        };

	        /**
	         * Binds a specified WebGL framebuffer. This function also makes the framebuffer the active framebuffer.
	         * @param {FramebufferTexture} framebuffer The framebuffer to bind. May be null or undefined, in which case the
	         * default WebGL framebuffer is made active.
	         */
	        DrawContext.prototype.bindFramebuffer = function (framebuffer) {
	            if (this.currentFramebuffer != framebuffer) {
	                this.currentGlContext.bindFramebuffer(this.currentGlContext.FRAMEBUFFER,
	                    framebuffer ? framebuffer.framebufferId : null);
	                this.currentFramebuffer = framebuffer;
	            }
	        };

	        /**
	         * Binds a specified WebGL program. This function also makes the program the current program.
	         * @param {GpuProgram} program The program to bind. May be null or undefined, in which case the currently
	         * bound program is unbound.
	         */
	        DrawContext.prototype.bindProgram = function (program) {
	            if (this.currentProgram != program) {
	                this.currentGlContext.useProgram(program ? program.programId : null);
	                this.currentProgram = program;
	            }
	        };

	        /**
	         * Binds a potentially cached WebGL program, creating and caching it if it isn't already cached.
	         * This function also makes the program the current program.
	         * @param {function} programConstructor The constructor to use to create the program.
	         * @returns {GpuProgram} The bound program.
	         * @throws {ArgumentError} If the specified constructor is null or undefined.
	         */
	        DrawContext.prototype.findAndBindProgram = function (programConstructor) {
	            if (!programConstructor) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "DrawContext", "findAndBindProgram",
	                        "The specified program constructor is null or undefined."));
	            }

	            var program = this.gpuResourceCache.resourceForKey(programConstructor.key);
	            if (program) {
	                this.bindProgram(program);
	            } else {
	                try {
	                    program = new programConstructor(this.currentGlContext);
	                    this.bindProgram(program);
	                    this.gpuResourceCache.putResource(programConstructor.key, program, program.size);
	                } catch (e) {
	                    Logger.log(Logger.LEVEL_SEVERE, "Error attempting to create GPU program.")
	                }
	            }

	            return program;
	        };

	        /**
	         * Adds a surface renderable to this draw context's surface renderable list.
	         * @param {SurfaceRenderable} surfaceRenderable The surface renderable to add. May be null, in which case the
	         * current surface renderable list remains unchanged.
	         */
	        DrawContext.prototype.addSurfaceRenderable = function (surfaceRenderable) {
	            if (surfaceRenderable) {
	                this.surfaceRenderables.push(surfaceRenderable);
	            }
	        };

	        /**
	         * Returns the surface renderable at the head of the surface renderable list without removing it from the list.
	         * @returns {SurfaceRenderable} The first surface renderable in this draw context's surface renderable list, or
	         * null if the surface renderable list is empty.
	         */
	        DrawContext.prototype.peekSurfaceRenderable = function () {
	            if (this.surfaceRenderables.length > 0) {
	                return this.surfaceRenderables[this.surfaceRenderables.length - 1];
	            } else {
	                return null;
	            }
	        };

	        /**
	         * Returns the surface renderable at the head of the surface renderable list and removes it from the list.
	         * @returns {SurfaceRenderable} The first surface renderable in this draw context's surface renderable list, or
	         * null if the surface renderable list is empty.
	         */
	        DrawContext.prototype.popSurfaceRenderable = function () {
	            if (this.surfaceRenderables.length > 0) {
	                return this.surfaceRenderables.pop();
	            } else {
	                return null;
	            }
	        };

	        /**
	         * Reverses the surface renderable list in place. After this function completes, the functions
	         * peekSurfaceRenderable and popSurfaceRenderable return renderables in the order in which they were added to
	         * the surface renderable list.
	         */
	        DrawContext.prototype.reverseSurfaceRenderables = function () {
	            this.surfaceRenderables.reverse();
	        };

	        /**
	         * Adds an ordered renderable to this draw context's ordered renderable list.
	         * @param {OrderedRenderable} orderedRenderable The ordered renderable to add. May be null, in which case the
	         * current ordered renderable list remains unchanged.
	         * @param {Number} eyeDistance An optional argument indicating the ordered renderable's eye distance.
	         * If this parameter is not specified then the ordered renderable must have an eyeDistance property.
	         */
	        DrawContext.prototype.addOrderedRenderable = function (orderedRenderable, eyeDistance) {
	            if (orderedRenderable) {
	                var ore = {
	                    orderedRenderable: orderedRenderable,
	                    insertionOrder: this.orderedRenderablesCounter++,
	                    eyeDistance: eyeDistance || orderedRenderable.eyeDistance,
	                    globeStateKey: this.globeStateKey
	                };

	                if (this.globe.continuous) {
	                    ore.globeOffset = this.globe.offset;
	                }

	                if (ore.eyeDistance === 0) {
	                    this.screenRenderables.push(ore);
	                } else {
	                    this.orderedRenderables.push(ore);
	                }
	            }
	        };

	        /**
	         * Adds an ordered renderable to the end of this draw context's ordered renderable list, denoting it as the
	         * most distant from the eye point.
	         * @param {OrderedRenderable} orderedRenderable The ordered renderable to add. May be null, in which case the
	         * current ordered renderable list remains unchanged.
	         */
	        DrawContext.prototype.addOrderedRenderableToBack = function (orderedRenderable) {
	            if (orderedRenderable) {
	                var ore = {
	                    orderedRenderable: orderedRenderable,
	                    insertionOrder: this.orderedRenderablesCounter++,
	                    eyeDistance: Number.MAX_VALUE,
	                    globeStateKey: this.globeStateKey
	                };

	                if (this.globe.continuous) {
	                    ore.globeOffset = this.globe.offset;
	                }

	                this.orderedRenderables.push(ore);
	            }
	        };

	        /**
	         * Returns the ordered renderable at the head of the ordered renderable list without removing it from the list.
	         * @returns {OrderedRenderable} The first ordered renderable in this draw context's ordered renderable list, or
	         * null if the ordered renderable list is empty.
	         */
	        DrawContext.prototype.peekOrderedRenderable = function () {
	            if (this.orderedRenderables.length > 0) {
	                return this.orderedRenderables[this.orderedRenderables.length - 1].orderedRenderable;
	            } else {
	                return null;
	            }
	        };

	        /**
	         * Returns the ordered renderable at the head of the ordered renderable list and removes it from the list.
	         * @returns {OrderedRenderable} The first ordered renderable in this draw context's ordered renderable list, or
	         * null if the ordered renderable list is empty.
	         */
	        DrawContext.prototype.popOrderedRenderable = function () {
	            if (this.orderedRenderables.length > 0) {
	                var ore = this.orderedRenderables.pop();
	                this.globeStateKey = ore.globeStateKey;

	                if (this.globe.continuous) {
	                    // Restore the globe state to that when the ordered renderable was created.
	                    this.globe.offset = ore.globeOffset;
	                }

	                return ore.orderedRenderable;
	            } else {
	                return null;
	            }
	        };

	        /**
	         * Returns the ordered renderable at the head of the ordered renderable list and removes it from the list.
	         * @returns {OrderedRenderable} The first ordered renderable in this draw context's ordered renderable list, or
	         * null if the ordered renderable list is empty.
	         */
	        DrawContext.prototype.nextScreenRenderable = function () {
	            if (this.screenRenderables.length > 0) {
	                var ore = this.screenRenderables.shift();
	                this.globeStateKey = ore.globeStateKey;

	                if (this.globe.continuous) {
	                    // Restore the globe state to that when the ordered renderable was created.
	                    this.globe.offset = ore.globeOffset;
	                }

	                return ore.orderedRenderable;
	            } else {
	                return null;
	            }
	        };

	        /**
	         * Sorts the ordered renderable list from nearest to the eye point to farthest from the eye point.
	         */
	        DrawContext.prototype.sortOrderedRenderables = function () {
	            // Sort the ordered renderables by eye distance from front to back and then by insertion time. The ordered
	            // renderable peek and pop access the back of the ordered renderable list, thereby causing ordered renderables to
	            // be processed from back to front.

	            this.orderedRenderables.sort(function (oreA, oreB) {
	                var eA = oreA.eyeDistance,
	                    eB = oreB.eyeDistance;

	                if (eA < eB) { // orA is closer to the eye than orB; sort orA before orB
	                    return -1;
	                } else if (eA > eB) { // orA is farther from the eye than orB; sort orB before orA
	                    return 1;
	                } else { // orA and orB are the same distance from the eye; sort them based on insertion time
	                    var tA = oreA.insertionOrder,
	                        tB = oreB.insertionOrder;

	                    if (tA > tB) {
	                        return -1;
	                    } else if (tA < tB) {
	                        return 1;
	                    } else {
	                        return 0;
	                    }
	                }
	            });
	        };

	        /**
	         * Reads the color from the current render buffer at a specified point. Used during picking to identify the item most
	         * recently affecting the pixel at the specified point.
	         * @param {Vec2} pickPoint The current pick point.
	         * @returns {Color} The color at the pick point.
	         */
	        DrawContext.prototype.readPickColor = function (pickPoint) {
	            var glPickPoint = this.navigatorState.convertPointToViewport(pickPoint, new Vec2(0, 0)),
	                colorBytes = new Uint8Array(4);

	            this.currentGlContext.readPixels(glPickPoint[0], glPickPoint[1], 1, 1, this.currentGlContext.RGBA,
	                this.currentGlContext.UNSIGNED_BYTE, colorBytes);

	            if (this.clearColor.equalsBytes(colorBytes)) {
	                return null;
	            }

	            return Color.colorFromByteArray(colorBytes);
	        };

	        /**
	         * Reads the current pick buffer colors in a specified rectangle. Used during region picking to identify
	         * the items not occluded.
	         * @param {Rectangle} pickRectangle The rectangle for which to read the colors.
	         * @returns {{}} An object containing the unique colors in the specified rectangle, excluding the current
	         * clear color. The colors are referenced by their byte string
	         * (see [Color.toByteString]{@link Color#toByteString}.
	         */
	        DrawContext.prototype.readPickColors = function (pickRectangle) {
	            var gl = this.currentGlContext,
	                colorBytes = new Uint8Array(pickRectangle.width * pickRectangle.height * 4),
	                uniqueColors = {},
	                color,
	                blankColor = new Color(0, 0, 0, 0),
	                packAlignment = gl.getParameter(gl.PACK_ALIGNMENT);

	            gl.pixelStorei(gl.PACK_ALIGNMENT, 1); // read byte aligned
	            this.currentGlContext.readPixels(pickRectangle.x, pickRectangle.y,
	                pickRectangle.width, pickRectangle.height,
	                gl.RGBA, gl.UNSIGNED_BYTE, colorBytes);
	            gl.pixelStorei(gl.PACK_ALIGNMENT, packAlignment); // restore the pack alignment

	            for (var i = 0, len = pickRectangle.width * pickRectangle.height; i < len; i++) {
	                var k = i * 4;
	                color = Color.colorFromBytes(colorBytes[k], colorBytes[k + 1], colorBytes[k + 2], colorBytes[k + 3]);
	                if (color.equals(this.clearColor) || color.equals(blankColor))
	                    continue;
	                uniqueColors[color.toByteString()] = color;
	            }

	            return uniqueColors;
	        };

	        /**
	         * Determines whether a specified picked object is under the pick point, and if it is adds it to this draw
	         * context's list of picked objects. This method should be called by shapes during ordered rendering
	         * after the shape is drawn. If this draw context is in single-picking mode, the specified pickable object
	         * is added to the list of picked objects whether or not it is under the pick point.
	         * @param pickableObject
	         * @returns {null}
	         */
	        DrawContext.prototype.resolvePick = function (pickableObject) {
	            if (!(pickableObject.userObject instanceof SurfaceShape) && this.deepPicking && !this.regionPicking) {
	                var color = this.readPickColor(this.pickPoint);
	                if (!color) { // getPickColor returns null if the pick point selects the clear color
	                    return null;
	                }

	                if (pickableObject.color.equals(color)) {
	                    this.addPickedObject(pickableObject);
	                }
	            } else {
	                // Don't resolve. Just add the object to the pick list. It will be resolved later.
	                this.addPickedObject(pickableObject);
	            }
	        };

	        /**
	         * Adds an object to the current picked-object list. The list identifies objects that are at the pick point
	         * but not necessarily the top-most object.
	         * @param  {PickedObject} pickedObject The object to add.
	         */
	        DrawContext.prototype.addPickedObject = function (pickedObject) {
	            if (pickedObject) {
	                this.objectsAtPickPoint.add(pickedObject);
	            }
	        };

	        /**
	         * Computes a unique color to use as a pick color.
	         * @returns {Color} A unique color.
	         */
	        DrawContext.prototype.uniquePickColor = function () {
	            var color = this.pickColor.nextColor().clone();

	            return color.equals(this.clearColor) ? color.nextColor() : color;
	        };

	        /**
	         * Creates an off-screen WebGL framebuffer for use during picking and stores it in this draw context. The
	         * framebuffer width and height match the WebGL rendering context's drawingBufferWidth and drawingBufferHeight.
	         */
	        DrawContext.prototype.makePickFramebuffer = function () {
	            var gl = this.currentGlContext,
	                width = gl.drawingBufferWidth,
	                height = gl.drawingBufferHeight;

	            if (!this.pickFramebuffer ||
	                this.pickFramebuffer.width != width ||
	                this.pickFramebuffer.height != height) {

	                this.pickFramebuffer = new FramebufferTexture(gl, width, height, true); // enable depth buffering
	            }

	            return this.pickFramebuffer;
	        };

	        /**
	         * Creates a pick frustum for the current pick point and stores it in this draw context. If this context's
	         * pick rectangle is null or undefined then a pick rectangle is also computed and assigned to this context.
	         * If the existing pick rectangle extends beyond the viewport then it is truncated by this method to fit
	         * within the viewport.
	         * This method assumes that this draw context's pick point or pick rectangle has been set. It returns
	         * false if neither one of these exists.
	         *
	         * @returns {Boolean} <code>true</code> if the pick frustum could be created, otherwise <code>false</code>.
	         */
	        DrawContext.prototype.makePickFrustum = function () {
	            if (!this.pickPoint && !this.pickRectangle) {
	                return false;
	            }

	            var lln, llf, lrn, lrf, uln, ulf, urn, urf, // corner points of frustum
	                nl, nr, nt, nb, nn, nf, // normal vectors of frustum planes
	                l, r, t, b, n, f, // frustum planes
	                va, vb = new Vec3(0, 0, 0), // vectors formed by the corner points
	                apertureRadius = 2, // radius of pick window in screen coordinates
	                screenPoint = new Vec3(0, 0, 0),
	                pickPoint,
	                pickRectangle = this.pickRectangle,
	                viewport = this.navigatorState.viewport;

	            // Compute the pick rectangle if necessary.
	            if (!pickRectangle) {
	                pickPoint = this.navigatorState.convertPointToViewport(this.pickPoint, new Vec2(0, 0));
	                pickRectangle = new Rectangle(
	                    pickPoint[0] - apertureRadius,
	                    pickPoint[1] - apertureRadius,
	                    2 * apertureRadius,
	                    2 * apertureRadius);
	            }

	            // Clamp the pick rectangle to the viewport.

	            var xl = pickRectangle.x,
	                xr = pickRectangle.x + pickRectangle.width,
	                yb = pickRectangle.y,
	                yt = pickRectangle.y + pickRectangle.height;

	            if (xr < 0 || yt < 0 || xl > viewport.x + viewport.width || yb > viewport.y + viewport.height) {
	                return false; // pick rectangle is outside the viewport.
	            }

	            pickRectangle.x = WWMath.clamp(xl, viewport.x, viewport.x + viewport.width);
	            pickRectangle.y = WWMath.clamp(yb, viewport.y, viewport.y + viewport.height);
	            pickRectangle.width = WWMath.clamp(xr, viewport.x, viewport.x + viewport.width) - pickRectangle.x;
	            pickRectangle.height = WWMath.clamp(yt, viewport.y, viewport.y + viewport.height) - pickRectangle.y;
	            this.pickRectangle = pickRectangle;

	            // Compute the pick frustum.

	            screenPoint[0] = pickRectangle.x;
	            screenPoint[1] = pickRectangle.y;
	            screenPoint[2] = 0;
	            this.navigatorState.unProject(screenPoint, lln = new Vec3(0, 0, 0));

	            screenPoint[0] = pickRectangle.x;
	            screenPoint[1] = pickRectangle.y;
	            screenPoint[2] = 1;
	            this.navigatorState.unProject(screenPoint, llf = new Vec3(0, 0, 0));

	            screenPoint[0] = pickRectangle.x + pickRectangle.width;
	            screenPoint[1] = pickRectangle.y;
	            screenPoint[2] = 0;
	            this.navigatorState.unProject(screenPoint, lrn = new Vec3(0, 0, 0));

	            screenPoint[0] = pickRectangle.x + pickRectangle.width;
	            screenPoint[1] = pickRectangle.y;
	            screenPoint[2] = 1;
	            this.navigatorState.unProject(screenPoint, lrf = new Vec3(0, 0, 0));

	            screenPoint[0] = pickRectangle.x;
	            screenPoint[1] = pickRectangle.y + pickRectangle.height;
	            screenPoint[2] = 0;
	            this.navigatorState.unProject(screenPoint, uln = new Vec3(0, 0, 0));

	            screenPoint[0] = pickRectangle.x;
	            screenPoint[1] = pickRectangle.y + pickRectangle.height;
	            screenPoint[2] = 1;
	            this.navigatorState.unProject(screenPoint, ulf = new Vec3(0, 0, 0));

	            screenPoint[0] = pickRectangle.x + pickRectangle.width;
	            screenPoint[1] = pickRectangle.y + pickRectangle.height;
	            screenPoint[2] = 0;
	            this.navigatorState.unProject(screenPoint, urn = new Vec3(0, 0, 0));

	            screenPoint[0] = pickRectangle.x + pickRectangle.width;
	            screenPoint[1] = pickRectangle.y + pickRectangle.height;
	            screenPoint[2] = 1;
	            this.navigatorState.unProject(screenPoint, urf = new Vec3(0, 0, 0));

	            va = new Vec3(ulf[0] - lln[0], ulf[1] - lln[1], ulf[2] - lln[2]);
	            vb.set(uln[0] - llf[0], uln[1] - llf[1], uln[2] - llf[2]);
	            nl = va.cross(vb);
	            l = new Plane(nl[0], nl[1], nl[2], -nl.dot(lln));
	            l.normalize();

	            va = new Vec3(urn[0] - lrf[0], urn[1] - lrf[1], urn[2] - lrf[2]);
	            vb.set(urf[0] - lrn[0], urf[1] - lrn[1], urf[2] - lrn[2]);
	            nr = va.cross(vb);
	            r = new Plane(nr[0], nr[1], nr[2], -nr.dot(lrn));
	            r.normalize();

	            va = new Vec3(ulf[0] - urn[0], ulf[1] - urn[1], ulf[2] - urn[2]);
	            vb.set(urf[0] - uln[0], urf[1] - uln[1], urf[2] - uln[2]);
	            nt = va.cross(vb);
	            t = new Plane(nt[0], nt[1], nt[2], -nt.dot(uln));
	            t.normalize();

	            va = new Vec3(lrf[0] - lln[0], lrf[1] - lln[1], lrf[2] - lln[2]);
	            vb.set(llf[0] - lrn[0], llf[1] - lrn[1], llf[2] - lrn[2]);
	            nb = va.cross(vb);
	            b = new Plane(nb[0], nb[1], nb[2], -nb.dot(lrn));
	            b.normalize();

	            va = new Vec3(uln[0] - lrn[0], uln[1] - lrn[1], uln[2] - lrn[2]);
	            vb.set(urn[0] - lln[0], urn[1] - lln[1], urn[2] - lln[2]);
	            nn = va.cross(vb);
	            n = new Plane(nn[0], nn[1], nn[2], -nn.dot(lln));
	            n.normalize();

	            va = new Vec3(urf[0] - llf[0], urf[1] - llf[1], urf[2] - llf[2]);
	            vb.set(ulf[0] - lrf[0], ulf[1] - lrf[1], ulf[2] - lrf[2]);
	            nf = va.cross(vb);
	            f = new Plane(nf[0], nf[1], nf[2], -nf.dot(llf));
	            f.normalize();

	            this.pickFrustum = new Frustum(l, r, b, t, n, f);

	            return true;
	        };

	        /**
	         * Indicates whether an extent is smaller than a specified number of pixels.
	         * @param {BoundingBox} extent The extent to test.
	         * @param {Number} numPixels The number of pixels below which the extent is considered small.
	         * @returns {Boolean} True if the extent is smaller than the specified number of pixels, otherwise false.
	         * Returns false if the extent is null or undefined.
	         */
	        DrawContext.prototype.isSmall = function (extent, numPixels) {
	            if (!extent) {
	                return false;
	            }

	            var distance = this.navigatorState.eyePoint.distanceTo(extent.center),
	                pixelSize = this.navigatorState.pixelSizeAtDistance(distance);

	            return (2 * extent.radius) < (numPixels * pixelSize); // extent diameter less than size of num pixels
	        };

	        /**
	         * Returns the VBO ID of an array buffer containing a unit cube expressed as eight 3D vertices at (0, 1, 0),
	         * (0, 0, 0), (1, 1, 0), (1, 0, 0), (0, 1, 1), (0, 0, 1), (1, 1, 1) and (1, 0, 1). The buffer is created on
	         * first use and cached. Subsequent calls to this method return the cached buffer.
	         * @returns {Object} The VBO ID identifying the array buffer.
	         */
	        DrawContext.prototype.unitCubeBuffer = function () {
	            var vboId = this.gpuResourceCache.resourceForKey(DrawContext.unitCubeKey);

	            if (!vboId) {
	                var gl = this.currentGlContext,
	                    points = new Float32Array(24),
	                    i = 0;

	                points[i++] = 0; // upper left corner, z = 0
	                points[i++] = 1;
	                points[i++] = 0;
	                points[i++] = 0; // lower left corner, z = 0
	                points[i++] = 0;
	                points[i++] = 0;
	                points[i++] = 1; // upper right corner, z = 0
	                points[i++] = 1;
	                points[i++] = 0;
	                points[i++] = 1; // lower right corner, z = 0
	                points[i++] = 0;
	                points[i++] = 0;

	                points[i++] = 0; // upper left corner, z = 1
	                points[i++] = 1;
	                points[i++] = 1;
	                points[i++] = 0; // lower left corner, z = 1
	                points[i++] = 0;
	                points[i++] = 1;
	                points[i++] = 1; // upper right corner, z = 1
	                points[i++] = 1;
	                points[i++] = 1;
	                points[i++] = 1; // lower right corner, z = 1
	                points[i++] = 0;
	                points[i] = 1;

	                vboId = gl.createBuffer();
	                gl.bindBuffer(gl.ARRAY_BUFFER, vboId);
	                gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);
	                gl.bindBuffer(gl.ARRAY_BUFFER, null);
	                this.frameStatistics.incrementVboLoadCount(1);

	                this.gpuResourceCache.putResource(DrawContext.unitCubeKey, vboId, points.length * 4);
	            }

	            return vboId;
	        };

	        /**
	         * Returns the VBO ID of a element array buffer containing the tessellation of a unit cube expressed as
	         * a single buffer containing both triangle indices and line indices. This is intended for use in conjunction
	         * with <code>unitCubeBuffer</code>. The unit cube's interior and outline may be rasterized as shown in the
	         * following WebGL pseudocode:
	         * <code><pre>
	         * // Assumes that the VBO returned by unitCubeBuffer is used as the source of vertex positions.
	         * bindBuffer(ELEMENT_ARRAY_BUFFER, drawContext.unitCubeElements());
	         * drawElements(TRIANGLES, 36, UNSIGNED_SHORT, 0); // draw the unit cube interior
	         * drawElements(LINES, 24, UNSIGNED_SHORT, 72); // draw the unit cube outline
	         * </pre></code>
	         * The buffer is created on first use
	         * and cached. Subsequent calls to this method return the cached buffer.
	         * @returns {Object} The VBO ID identifying the element array buffer.
	         */
	        DrawContext.prototype.unitCubeElements = function () {
	            var vboId = this.gpuResourceCache.resourceForKey(DrawContext.unitCubeElementsKey);

	            if (!vboId) {
	                var gl = this.currentGlContext,
	                    elems = new Int16Array(60),
	                    i = 0;

	                // interior

	                elems[i++] = 1; // -z face
	                elems[i++] = 0;
	                elems[i++] = 3;
	                elems[i++] = 3;
	                elems[i++] = 0;
	                elems[i++] = 2;

	                elems[i++] = 4; // +z face
	                elems[i++] = 5;
	                elems[i++] = 6;
	                elems[i++] = 6;
	                elems[i++] = 5;
	                elems[i++] = 7;

	                elems[i++] = 5; // -y face
	                elems[i++] = 1;
	                elems[i++] = 7;
	                elems[i++] = 7;
	                elems[i++] = 1;
	                elems[i++] = 3;

	                elems[i++] = 6; // +y face
	                elems[i++] = 2;
	                elems[i++] = 4;
	                elems[i++] = 4;
	                elems[i++] = 2;
	                elems[i++] = 0;

	                elems[i++] = 4; // -x face
	                elems[i++] = 0;
	                elems[i++] = 5;
	                elems[i++] = 5;
	                elems[i++] = 0;
	                elems[i++] = 1;

	                elems[i++] = 7; // +x face
	                elems[i++] = 3;
	                elems[i++] = 6;
	                elems[i++] = 6;
	                elems[i++] = 3;
	                elems[i++] = 2;

	                // outline

	                elems[i++] = 0; // left, -z
	                elems[i++] = 1;
	                elems[i++] = 1; // bottom, -z
	                elems[i++] = 3;
	                elems[i++] = 3; // right, -z
	                elems[i++] = 2;
	                elems[i++] = 2; // top, -z
	                elems[i++] = 0;

	                elems[i++] = 4; // left, +z
	                elems[i++] = 5;
	                elems[i++] = 5; // bottom, +z
	                elems[i++] = 7;
	                elems[i++] = 7; // right, +z
	                elems[i++] = 6;
	                elems[i++] = 6; // top, +z
	                elems[i++] = 4;

	                elems[i++] = 0; // upper left
	                elems[i++] = 4;
	                elems[i++] = 5; // lower left
	                elems[i++] = 1;
	                elems[i++] = 2; // upper right
	                elems[i++] = 6;
	                elems[i++] = 7; // lower right
	                elems[i] = 3;

	                vboId = gl.createBuffer();
	                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vboId);
	                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, elems, gl.STATIC_DRAW);
	                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
	                this.frameStatistics.incrementVboLoadCount(1);

	                this.gpuResourceCache.putResource(DrawContext.unitCubeElementsKey, vboId, elems.length * 2);
	            }

	            return vboId;
	        };

	        /**
	         * Returns the VBO ID of a buffer containing a unit quadrilateral expressed as four 2D vertices at (0, 1),
	         * (0, 0), (1, 1) and (1, 0). The four vertices are in the order required by a triangle strip. The buffer is
	         * created on first use and cached. Subsequent calls to this method return the cached buffer.
	         * @returns {Object} The VBO ID identifying the vertex buffer.
	         */
	        DrawContext.prototype.unitQuadBuffer = function () {
	            var vboId = this.gpuResourceCache.resourceForKey(DrawContext.unitQuadKey);

	            if (!vboId) {
	                var gl = this.currentGlContext,
	                    points = new Float32Array(8);

	                points[0] = 0; // upper left corner
	                points[1] = 1;
	                points[2] = 0; // lower left corner
	                points[3] = 0;
	                points[4] = 1; // upper right corner
	                points[5] = 1;
	                points[6] = 1; // lower right corner
	                points[7] = 0;

	                vboId = gl.createBuffer();
	                gl.bindBuffer(gl.ARRAY_BUFFER, vboId);
	                gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);
	                gl.bindBuffer(gl.ARRAY_BUFFER, null);
	                this.frameStatistics.incrementVboLoadCount(1);

	                this.gpuResourceCache.putResource(DrawContext.unitQuadKey, vboId, points.length * 4);
	            }

	            return vboId;
	        };

	        /**
	         * Returns the VBO ID of a buffer containing a unit quadrilateral expressed as four 3D vertices at (0, 1, 0),
	         * (0, 0, 0), (1, 1, 0) and (1, 0, 0).
	         * The four vertices are in the order required by a triangle strip. The buffer is created
	         * on first use and cached. Subsequent calls to this method return the cached buffer.
	         * @returns {Object} The VBO ID identifying the vertex buffer.
	         */
	        DrawContext.prototype.unitQuadBuffer3 = function () {
	            var vboId = this.gpuResourceCache.resourceForKey(DrawContext.unitQuadKey3);

	            if (!vboId) {
	                var gl = this.currentGlContext,
	                    points = new Float32Array(12);

	                points[0] = 0; // upper left corner
	                points[1] = 1;
	                points[2] = 0;
	                points[3] = 0; // lower left corner
	                points[4] = 0;
	                points[5] = 0;
	                points[6] = 1; // upper right corner
	                points[7] = 1;
	                points[8] = 0;
	                points[9] = 1; // lower right corner
	                points[10] = 0;
	                points[11] = 0;

	                vboId = gl.createBuffer();
	                gl.bindBuffer(gl.ARRAY_BUFFER, vboId);
	                gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);
	                gl.bindBuffer(gl.ARRAY_BUFFER, null);
	                this.frameStatistics.incrementVboLoadCount(1);

	                this.gpuResourceCache.putResource(DrawContext.unitQuadKey3, vboId, points.length * 4);
	            }

	            return vboId;
	        };

	        /**
	         * Computes a Cartesian point at a location on the surface of this terrain according to a specified
	         * altitude mode. If there is no current terrain, this function approximates the returned point by assuming
	         * the terrain is the globe's ellipsoid.
	         * @param {Number} latitude The location's latitude.
	         * @param {Number} longitude The location's longitude.
	         * @param {Number} offset Distance above the terrain, in meters relative to the specified altitude mode, at
	         * which to compute the point.
	         * @param {String} altitudeMode The altitude mode to use to compute the point. Recognized values are
	         * WorldWind.ABSOLUTE, WorldWind.CLAMP_TO_GROUND and
	         * WorldWind.RELATIVE_TO_GROUND. The mode WorldWind.ABSOLUTE is used if the
	         * specified mode is null, undefined or unrecognized, or if the specified location is outside this terrain.
	         * @param {Vec3} result A pre-allocated Vec3 in which to return the computed point.
	         * @returns {Vec3} The specified result parameter, set to the coordinates of the computed point.
	         * @throws {ArgumentError} If the specified result argument is null or undefined.
	         */
	        DrawContext.prototype.surfacePointForMode = function (latitude, longitude, offset, altitudeMode, result) {
	            if (!result) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "DrawContext", "surfacePointForMode", "missingResult"));
	            }

	            if (this.terrain) {
	                this.terrain.surfacePointForMode(latitude, longitude, offset, altitudeMode, result);
	            } else {
	                var h = offset + this.globe.elevationAtLocation(latitude, longitude) * this.verticalExaggeration;
	                this.globe.computePointFromPosition(latitude, longitude, h, result);
	            }

	            return result;
	        };

	        return DrawContext;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports PickedObjectList
	 * @version $Id: PickedObjectList.js 2940 2015-03-30 17:58:36Z tgaskins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	        "use strict";

	        /**
	         * Constructs a picked-object list.
	         * @alias PickedObjectList
	         * @constructor
	         * @classdesc Holds a collection of picked objects.
	         */
	        var PickedObjectList = function () {
	            /**
	             * The picked objects.
	             * @type {Array}
	             */
	            this.objects = [];
	        };

	        /**
	         * Indicates whether this list contains picked objects that are not terrain.
	         * @returns {Boolean} true if this list contains objects that are not terrain,
	         * otherwise false.
	         */
	        PickedObjectList.prototype.hasNonTerrainObjects = function () {
	            return this.objects.length > 1 || (this.objects.length === 1 && this.terrainObject() == null);
	        };

	        /**
	         * Returns the terrain object within this list, if this list contains a terrain object.
	         * @returns {PickedObject} The terrain object, or null if this list does not contain a terrain object.
	         */
	        PickedObjectList.prototype.terrainObject = function () {
	            for (var i = 0, len = this.objects.length; i < len; i++) {
	                if (this.objects[i].isTerrain) {
	                    return this.objects[i];
	                }
	            }

	            return null;
	        };

	        /**
	         * Adds a picked object to this list.
	         * If the picked object is a terrain object and the list already contains a terrain object, the terrain
	         * object in the list is replaced by the specified one.
	         * @param {PickedObject} pickedObject The picked object to add. If null, this list remains unchanged.
	         */
	        PickedObjectList.prototype.add = function (pickedObject) {
	            if (pickedObject) {
	                if (pickedObject.isTerrain) {
	                    var terrainObjectIndex = this.objects.length;

	                    for (var i = 0, len = this.objects.length; i < len; i++) {
	                        if (this.objects[i].isTerrain) {
	                            terrainObjectIndex = i;
	                            break;
	                        }
	                    }

	                    this.objects[terrainObjectIndex] = pickedObject;
	                } else {
	                    this.objects.push(pickedObject);
	                }
	            }
	        };

	        /**
	         * Removes all items from this list.
	         */
	        PickedObjectList.prototype.clear = function () {
	            this.objects = [];
	        };

	        /**
	         * Returns the top-most picked object in this list.
	         * @returns {PickedObject} The top-most picked object in this list, or null if this list is empty.
	         */
	        PickedObjectList.prototype.topPickedObject = function () {
	            var size = this.objects.length;

	            if (size > 1) {
	                for (var i = 0; i < size; i++) {
	                    if (this.objects[[i].isOnTop]) {
	                        return this.objects[i];
	                    }
	                }
	            }

	            if (size > 0) {
	                return this.objects[0];
	            }

	            return null;
	        };

	        return PickedObjectList;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2015 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports FramebufferTexture
	 * @version $Id: FramebufferTexture.js 3345 2015-07-28 20:28:35Z dcollins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(30),
	        __webpack_require__(32),
	        __webpack_require__(36)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
	              Logger) {
	        "use strict";

	        /**
	         * Constructs a framebuffer texture with the specified dimensions and an optional depth buffer. Use the
	         * [DrawContext.bindFramebuffer]{@link DrawContext#bindFramebuffer} function to make the program current during rendering.
	         *
	         * @alias FramebufferTexture
	         * @constructor
	         * @classdesc Represents an off-screen WebGL framebuffer. The framebuffer has color buffer stored in a 32
	         * bit RGBA texture, and has an optional depth buffer of at least 16 bits. Applications typically do not
	         * interact with this class. WebGL framebuffers are created by instances of this class and made current when the
	         * DrawContext.bindFramebuffer function is invoked.
	         * @param {WebGLRenderingContext} gl The current WebGL rendering context.
	         * @param {Number} width The width of the framebuffer, in pixels.
	         * @param {Number} height The height of the framebuffer, in pixels.
	         * @param {Boolean} depth true to configure the framebuffer with a depth buffer of at least 16 bits, false to
	         * disable depth buffering.
	         * @throws {ArgumentError} If the specified draw context is null or undefined, or if the width or height is less
	         * than zero.
	         */
	        var FramebufferTexture = function (gl, width, height, depth) {
	            if (!gl) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "FramebufferTexture", "constructor",
	                    "missingGlContext"));
	            }

	            if (width < 0 || height < 0) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "FramebufferTexture", "constructor",
	                    "The framebuffer width or height is less than zero."));
	            }

	            /**
	             * The width of this framebuffer, in pixels.
	             * @type {Number}
	             * @readonly
	             */
	            this.width = width;

	            /**
	             * The height of this framebuffer, in pixels.
	             * @type {Number}
	             * @readonly
	             */
	            this.height = height;

	            /**
	             * Indicates whether or not this framebuffer has a depth buffer.
	             * @type {Boolean}
	             * @readonly
	             */
	            this.depth = depth;

	            /**
	             * Indicates the size of this framebuffer's WebGL resources, in bytes.
	             * @type {Number}
	             * @readonly
	             */
	            this.size = (width * height * 4) + (depth ? width * height * 2 : 0);

	            /**
	             * Indicates the WebGL framebuffer object object associated with this framebuffer texture.
	             * @type {WebGLFramebuffer}
	             * @readonly
	             */
	            this.framebufferId = gl.createFramebuffer();
	            gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebufferId);

	            // Internal. Intentionally not documented. Configure this framebuffer's color buffer.
	            this.texture = gl.createTexture();
	            gl.bindTexture(gl.TEXTURE_2D, this.texture);
	            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER,
	                gl.LINEAR);
	            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER,
	                gl.LINEAR);
	            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S,
	                gl.CLAMP_TO_EDGE);
	            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T,
	                gl.CLAMP_TO_EDGE);
	            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0,
	                gl.RGBA, gl.UNSIGNED_BYTE, null);
	            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0,
	                gl.TEXTURE_2D, this.texture, 0);

	            // Internal. Intentionally not documented. Configure this framebuffer's optional depth buffer.
	            this.depthBuffer = null;
	            if (depth) {
	                this.depthBuffer = gl.createRenderbuffer();
	                gl.bindRenderbuffer(gl.RENDERBUFFER, this.depthBuffer);
	                gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16,
	                    width, height);
	                gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT,
	                    gl.RENDERBUFFER, this.depthBuffer);
	            }

	            var e = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
	            if (e != gl.FRAMEBUFFER_COMPLETE) {
	                Logger.logMessage(Logger.LEVEL_WARNING, "FramebufferTexture", "constructor",
	                    "Error creating framebuffer: " + e);
	                this.framebufferId = null;
	                this.texture = null;
	                this.depthBuffer = null;
	            }

	            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
	            gl.bindRenderbuffer(gl.RENDERBUFFER, null);
	            gl.bindTexture(gl.TEXTURE_2D, null);
	        };

	        /**
	         * Binds this off-screen framebuffer's texture in the current WebGL graphics context. This texture contains
	         * color fragments resulting from WebGL operations executed when this framebuffer is bound by a call to
	         * [FramebufferTexture.bindFramebuffer]{@link FramebufferTexture#bindFramebuffer}.
	         *
	         * @param {DrawContext} dc The current draw context.
	         * @returns {Boolean} true if this framebuffer's texture was bound successfully, otherwise false.
	         */
	        FramebufferTexture.prototype.bind = function (dc) {
	            if (this.texture) {
	                dc.currentGlContext.bindTexture(gl.TEXTURE_2D, this.texture);
	            }

	            return !!this.texture;
	        };

	        return FramebufferTexture;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2015 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports FramebufferTileController
	 * @version $Id: FramebufferTileController.js 3130 2015-05-29 18:20:15Z dcollins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(30),
	        __webpack_require__(125),
	        __webpack_require__(100),
	        __webpack_require__(28),
	        __webpack_require__(32),
	        __webpack_require__(53),
	        __webpack_require__(75),
	        __webpack_require__(77)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
	              FramebufferTile,
	              LevelSet,
	              Location,
	              Logger,
	              MemoryCache,
	              Sector,
	              Tile) {
	        "use strict";

	        /**
	         * Constructs a framebuffer tile controller.
	         * @alias FramebufferTileController
	         * @constructor
	         * @classdesc Provides access to a multi-resolution WebGL framebuffer arranged as adjacent tiles in a pyramid.
	         * World Wind shapes use this class internally to draw on the terrain surface. Applications typically do not
	         * interact with this class.
	         */
	        var FramebufferTileController = function () {

	            /**
	             * The width in pixels of framebuffers associated with this controller's tiles.
	             * @type {Number}
	             * @readonly
	             */
	            this.tileWidth = 256;

	            /**
	             * The height in pixels of framebuffers associated with this controller's tiles.
	             * @type {Number}
	             * @readonly
	             */
	            this.tileHeight = 256;

	            /**
	             * Controls the level of detail switching for this controller. The next highest resolution level is
	             * used when an image's texel size is greater than this number of pixels.
	             * @type {Number}
	             * @default 1.75
	             */
	            this.detailControl = 1.75;

	            // Internal. Intentionally not documented.
	            this.levels = new LevelSet(Sector.FULL_SPHERE, new Location(45, 45), 16, this.tileWidth, this.tileHeight);

	            // Internal. Intentionally not documented.
	            this.topLevelTiles = [];

	            // Internal. Intentionally not documented.
	            this.currentTiles = [];

	            // Internal. Intentionally not documented.
	            this.currentTimestamp = null;

	            // Internal. Intentionally not documented.
	            this.currentGlobeStateKey = null;

	            // Internal. Intentionally not documented.
	            this.tileCache = new MemoryCache(500000, 400000);

	            // Internal. Intentionally not documented.
	            this.key = "FramebufferTileController " + ++FramebufferTileController.keyPool;
	        };

	        // Internal. Intentionally not documented.
	        FramebufferTileController.keyPool = 0; // source of unique ids

	        /**
	         * Returns a set of multi-resolution [FramebufferTile]{@link FramebufferTile} instances appropriate for the
	         * current draw context that overlap a specified sector.
	         * @param {DrawContext} dc The current draw context.
	         * @param {Sector} sector The geographic region of interest.
	         * @returns {Array} The set of multi-resolution framebuffer tiles that overlap the sector.
	         * @throws {ArgumentError} If the specified sector is null.
	         */
	        FramebufferTileController.prototype.selectTiles = function (dc, sector) {
	            if (!sector) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "FramebufferTileController",
	                    "selectTiles", "missingSector"));
	            }

	            // Assemble a set of global tiles appropriate for the draw context.
	            this.assembleTiles(dc);

	            // Collect the tiles that overlap the specified sector and mark them as selected.
	            var tiles = [];
	            for (var i = 0, len = this.currentTiles.length; i < len; i++) {
	                var tile = this.currentTiles[i];
	                if (tile.sector.overlaps(sector)) {
	                    tile.selected = true;
	                    tiles.push(tile);
	                }
	            }

	            return tiles;
	        };

	        /**
	         * Draws this multi-resolution framebuffer on the terrain surface then clears the framebuffer. This has no
	         * effect if the framebuffer is unchanged since the last call to render.
	         * @param {DrawContext} dc The current draw context.
	         */
	        FramebufferTileController.prototype.render = function (dc) {
	            // Exit immediately if there are no framebuffer tiles. This can happen when there ar eno surface shapes in
	            // the scene, for example.
	            if (this.currentTiles.length == 0) {
	                return;
	            }

	            // Collect the tiles that have changed since the last call to render.
	            var tiles = [];
	            for (var i = 0, len = this.currentTiles.length; i < len; i++) {
	                var tile = this.currentTiles[i];
	                if (tile.selected) {
	                    tiles.push(tile);
	                }
	            }

	            // Draw the changed tiles on the terrain surface.
	            dc.surfaceTileRenderer.renderTiles(dc, tiles, 1);

	            // Clear the changed tile's WebGL framebuffers.
	            var gl = dc.currentGlContext,
	                framebuffer = dc.currentFramebuffer;
	            try {
	                gl.clearColor(0, 0, 0, 0);
	                for (i = 0, len = tiles.length; i < len; i++) {
	                    tile = tiles[i];
	                    tile.selected = false;
	                    tile.bindFramebuffer(dc);
	                    gl.clear(gl.COLOR_BUFFER_BIT);
	                }
	            } finally {
	                dc.bindFramebuffer(framebuffer);
	            }
	        };

	        // Internal. Intentionally not documented.
	        FramebufferTileController.prototype.assembleTiles = function (dc) {
	            var timestamp = dc.timestamp,
	                globeStateKey = dc.globeStateKey;

	            if (this.currentTimestamp != timestamp ||
	                this.currentGlobeStateKey != globeStateKey) {

	                this.doAssembleTiles(dc);

	                this.currentTimestamp = timestamp;
	                this.currentGlobeStateKey = globeStateKey;
	            }
	        };

	        // Internal. Intentionally not documented.
	        FramebufferTileController.prototype.doAssembleTiles = function (dc) {
	            this.currentTiles = [];

	            if (!dc.terrain) {
	                return;
	            }

	            if (this.topLevelTiles.length == 0) {
	                this.createTopLevelTiles();
	            }

	            for (var i = 0, len = this.topLevelTiles.length; i < len; i++) {
	                var tile = this.topLevelTiles[i];
	                tile.update(dc);

	                if (this.isTileVisible(dc, tile)) {
	                    this.addTileOrDescendants(dc, tile);
	                }
	            }
	        };

	        // Internal. Intentionally not documented.
	        FramebufferTileController.prototype.createTile = function (sector, level, row, column) {
	            var tileKey = this.key + " " + level.levelNumber + "." + row + "." + column;
	            return new FramebufferTile(sector, level, row, column, tileKey);
	        };

	        // Internal. Intentionally not documented.
	        FramebufferTileController.prototype.createTopLevelTiles = function () {
	            Tile.createTilesForLevel(this.levels.firstLevel(), this, this.topLevelTiles);
	        };

	        // Internal. Intentionally not documented.
	        FramebufferTileController.prototype.addTileOrDescendants = function (dc, tile) {
	            if (this.tileMeetsRenderingCriteria(dc, tile)) {
	                this.addTile(tile);
	                return;
	            }

	            var subTiles = tile.subdivideToCache(tile.level.nextLevel(), this, this.tileCache);
	            for (var i = 0, len = subTiles.length; i < len; i++) {
	                var child = subTiles[i];
	                child.update(dc);

	                if (this.isTileVisible(dc, child)) {
	                    this.addTileOrDescendants(dc, child);
	                }
	            }
	        };

	        // Internal. Intentionally not documented.
	        FramebufferTileController.prototype.addTile = function (tile) {
	            this.currentTiles.push(tile);
	        };

	        // Internal. Intentionally not documented.
	        FramebufferTileController.prototype.isTileVisible = function (dc, tile) {
	            if (dc.globe.projectionLimits && !tile.sector.overlaps(dc.globe.projectionLimits)) {
	                return false;
	            }

	            if (dc.pickingMode) {
	                return tile.extent.intersectsFrustum(dc.pickFrustum);
	            }

	            return tile.extent.intersectsFrustum(dc.navigatorState.frustumInModelCoordinates);
	        };

	        // Internal. Intentionally not documented.
	        FramebufferTileController.prototype.tileMeetsRenderingCriteria = function (dc, tile) {
	            var s = this.detailControl;
	            if (tile.sector.minLatitude >= 75 || tile.sector.maxLatitude <= -75) {
	                s *= 1.2;
	            }

	            return tile.level.isLastLevel() || !tile.mustSubdivide(dc, s);
	        };

	        return FramebufferTileController;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2015 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports FramebufferTile
	 * @version $Id: FramebufferTile.js 3345 2015-07-28 20:28:35Z dcollins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(30),
	        __webpack_require__(123),
	        __webpack_require__(32),
	        __webpack_require__(63),
	        __webpack_require__(37),
	        __webpack_require__(76)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
	              FramebufferTexture,
	              Logger,
	              Matrix,
	              Rectangle,
	              TextureTile) {
	        "use strict";

	        /**
	         * Constructs a framebuffer tile.
	         * @alias FramebufferTile
	         * @constructor
	         * @augments TextureTile
	         * @classdesc Represents a WebGL framebuffer applied to a portion of a globe's terrain. The framebuffer's width
	         * and height in pixels are equal to this tile's [tileWidth]{@link FramebufferTile#tileWidth} and
	         * [tileHeight]{@link FramebufferTile#tileHeight}, respectively. The framebuffer can be made active by calling
	         * [bindFramebuffer]{@link FramebufferTile#bindFramebuffer}. Color fragments written to this
	         * tile's framebuffer can then be drawn on the terrain surface using a
	         * [SurfaceTileRenderer]{@link SurfaceTileRenderer}.
	         * <p>
	         * This class is meant to be used internally. Applications typically do not interact with this class.
	         * @param {Sector} sector The sector this tile covers.
	         * @param {Level} level The level this tile is associated with.
	         * @param {Number} row This tile's row in the associated level.
	         * @param {Number} column This tile's column in the associated level.
	         * @param {String} cacheKey A string uniquely identifying this tile relative to other tiles.
	         * @throws {ArgumentError} If the specified sector or level is null or undefined, the row or column arguments
	         * are less than zero, or the cache name is null, undefined or empty.
	         */
	        var FramebufferTile = function (sector, level, row, column, cacheKey) {
	            if (!cacheKey || (cacheKey.length < 1)) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "FramebufferTile", "constructor",
	                        "The specified cache name is null, undefined or zero length."));
	            }

	            TextureTile.call(this, sector, level, row, column); // args are checked in the superclass' constructor

	            // Assign the cacheKey as the gpuCacheKey (inherited from TextureTile).
	            this.gpuCacheKey = cacheKey;

	            // Internal. Intentionally not documented.
	            this.textureTransform = Matrix.fromIdentity().setToUnitYFlip();

	            // Internal. Intentionally not documented.
	            this.mustClear = true;
	        };

	        FramebufferTile.prototype = Object.create(TextureTile.prototype);

	        /**
	         * Causes this tile to clear any color fragments written to its off-screen framebuffer.
	         * @param dc The current draw context.
	         */
	        FramebufferTile.prototype.clearFramebuffer = function (dc) {
	            this.mustClear = true;
	        };

	        /**
	         * Causes this tile's off-screen framebuffer as the current WebGL framebuffer. WebGL operations that affect the
	         * framebuffer now affect this tile's framebuffer, rather than the default WebGL framebuffer.
	         * Color fragments are written to this tile's WebGL texture, which can be made active by calling
	         * [SurfaceTile.bind]{@link SurfaceTile#bind}.
	         *
	         * @param {DrawContext} dc The current draw context.
	         * @returns {Boolean} true if the framebuffer was bound successfully, otherwise false.
	         */
	        FramebufferTile.prototype.bindFramebuffer = function (dc) {
	            var framebuffer = dc.gpuResourceCache.resourceForKey(this.gpuCacheKey);

	            if (!framebuffer) {
	                framebuffer = this.createFramebuffer(dc);
	            }

	            dc.bindFramebuffer(framebuffer);

	            if (this.mustClear) {
	                this.doClearFramebuffer(dc);
	                this.mustClear = false;
	            }

	            return true;
	        };

	        // Internal. Intentionally not documented.
	        FramebufferTile.prototype.createFramebuffer = function (dc) {
	            var framebuffer = new FramebufferTexture(dc.currentGlContext, this.tileWidth, this.tileHeight, false);
	            dc.gpuResourceCache.putResource(this.gpuCacheKey, framebuffer, framebuffer.size);

	            return framebuffer;
	        };

	        // Internal. Intentionally not documented.
	        FramebufferTile.prototype.doClearFramebuffer = function (dc) {
	            var gl = dc.currentGlContext;
	            gl.clearColor(0, 0, 0, 0);
	            gl.clear(gl.COLOR_BUFFER_BIT);
	        };

	        /**
	         * Applies the appropriate texture transform to display this tile's WebGL texture.
	         * @param {DrawContext} dc The current draw context.
	         * @param {Matrix} matrix The matrix to apply the transform to.
	         */
	        FramebufferTile.prototype.applyInternalTransform = function (dc, matrix) {
	            matrix.multiplyMatrix(this.textureTransform);
	        };

	        return FramebufferTile;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports Layer
	 * @version $Id: Layer.js 3414 2015-08-20 19:09:19Z tgaskins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(32)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Logger) {
	        "use strict";

	        /**
	         * Constructs a layer. This constructor is meant to be called by subclasses and not directly by an application.
	         * @alias Layer
	         * @constructor
	         * @classdesc Provides an abstract base class for layer implementations. This class is not meant to be instantiated
	         * directly.
	         */
	        var Layer = function (displayName) {

	            /**
	             * This layer's display name.
	             * @type {String}
	             * @default "Layer"
	             */
	            this.displayName = displayName ? displayName : "Layer";

	            /**
	             * Indicates whether to display this layer.
	             * @type {Boolean}
	             * @default true
	             */
	            this.enabled = true;

	            /**
	             * Indicates whether this layer is pickable.
	             * @type {Boolean}
	             * @default true
	             */
	            this.pickEnabled = true;

	            /**
	             * This layer's opacity, which is combined with the opacity of shapes within layers.
	             * Opacity is in the range [0, 1], with 1 indicating fully opaque.
	             * @type {Number}
	             * @default 1
	             */
	            this.opacity = 1;

	            /**
	             * The eye altitude above which this layer is displayed, in meters.
	             * @type {Number}
	             * @default -Number.MAX_VALUE (always displayed)
	             */
	            this.minActiveAltitude = -Number.MAX_VALUE;

	            /**
	             * The eye altitude below which this layer is displayed, in meters.
	             * @type {Number}
	             * @default Number.MAX_VALUE (always displayed)
	             */
	            this.maxActiveAltitude = Number.MAX_VALUE;

	            /**
	             * Indicates whether elements of this layer were drawn in the most recently generated frame.
	             * @type {Boolean}
	             * @readonly
	             */
	            this.inCurrentFrame = false;

	            /**
	             * The time to display. This property selects the layer contents that represents the specified time.
	             * If null, layer-type dependent contents are displayed.
	             * @type {Date}
	             */
	            this.time = null;
	        };

	        /**
	         * Refreshes the data associated with this layer. The behavior of this function varies with the layer
	         * type. For image layers, it causes the images to be re-retrieved from their origin.
	         */
	        Layer.prototype.refresh = function () {
	            // Default implementation does nothing.
	        };

	        /**
	         * Displays this layer. Subclasses should generally not override this method but should instead override the
	         * [doRender]{@link Layer#doRender} method. This method calls that method after verifying that the layer is
	         * enabled, the eye point is within this layer's active altitudes and the layer is in view.
	         * @param {DrawContext} dc The current draw context.
	         */
	        Layer.prototype.render = function (dc) {
	            this.inCurrentFrame = false;

	            if (!this.enabled)
	                return;

	            if (dc.pickingMode && !this.pickEnabled)
	                return;

	            if (!this.withinActiveAltitudes(dc))
	                return;

	            if (!this.isLayerInView(dc))
	                return;

	            this.doRender(dc);
	        };

	        /**
	         * Subclass method called to display this layer. Subclasses should implement this method rather than the
	         * [render]{@link Layer#render} method, which determines enable, pick and active altitude status and does not
	         * call this doRender method if the layer should not be displayed.
	         * @param {DrawContext} dc The current draw context.
	         * @protected
	         */
	        Layer.prototype.doRender = function (dc) {
	            // Default implementation does nothing.
	        };

	        /* INTENTIONALLY NOT DOCUMENTED
	         * Indicates whether the current eye distance is within this layer's active-altitude range.
	         * @param {DrawContext} dc The current draw context.
	         * @returns {boolean} true If the eye distance is greater than or equal to this layer's minimum active
	         * altitude and less than or equal to this layer's maximum active altitude, otherwise false.
	         * @protected
	         */
	        Layer.prototype.withinActiveAltitudes = function (dc) {
	            var eyePosition = dc.eyePosition;
	            if (!eyePosition)
	                return false;

	            return eyePosition.altitude >= this.minActiveAltitude && eyePosition.altitude <= this.maxActiveAltitude;
	       };

	        /**
	         * Indicates whether this layer is within the current view. Subclasses may override this method and
	         * when called determine whether the layer contents are visible in the current view frustum. The default
	         * implementation always returns true.
	         * @param {DrawContext} dc The current draw context.
	         * @returns {boolean} true If this layer is within the current view, otherwise false.
	         * @protected
	         */
	        Layer.prototype.isLayerInView = function (dc) {
	            return true; // default implementation always returns true
	        };

	        return Layer;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2015 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports ScreenCreditController
	 * @version $Id: ScreenCreditController.js 3345 2015-07-28 20:28:35Z dcollins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(30),
	        __webpack_require__(129),
	        __webpack_require__(52),
	        __webpack_require__(128),
	        __webpack_require__(32),
	        __webpack_require__(63),
	        __webpack_require__(45),
	        __webpack_require__(87),
	        __webpack_require__(130),
	        __webpack_require__(35),
	        __webpack_require__(36)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
	              BasicTextureProgram,
	              Color,
	              Font,
	              Logger,
	              Matrix,
	              Offset,
	              PickedObject,
	              Renderable,
	              Vec3,
	              WWMath) {
	        "use strict";

	        /**
	         * Constructs a screen credit controller.
	         * @alias ScreenCreditController
	         * @constructor
	         * @classdesc Collects and displays screen credits.
	         */
	        var ScreenCreditController = function () {
	            // Internal. Intentionally not documented.
	            this.imageUrls = [];

	            // Internal. Intentionally not documented.
	            this.stringCredits = [];

	            // Internal. Intentionally not documented.
	            this.imageCreditSize = 64;

	            // Internal. Intentionally not documented.
	            this.margin = 5;

	            // Internal. Intentionally not documented.
	            this.opacity = 0.5;

	            // Internal. Intentionally not documented.
	            this.creditFont = new Font(14);
	        };

	        // Internal use only. Intentionally not documented.
	        ScreenCreditController.scratchMatrix = Matrix.fromIdentity(); // scratch variable
	        ScreenCreditController.imageTransform = Matrix.fromIdentity(); // scratch variable
	        ScreenCreditController.texCoordMatrix = Matrix.fromIdentity(); // scratch variable

	        /**
	         * Clears all credits from this controller.
	         */
	        ScreenCreditController.prototype.clear = function () {
	            this.imageUrls = [];
	            this.stringCredits = [];
	        };

	        /**
	         * Adds an image credit to this controller.
	         * @param {String} imageUrl The URL of the image to display in the credits area.
	         * @throws {ArgumentError} If the specified URL is null or undefined.
	         */
	        ScreenCreditController.prototype.addImageCredit = function (imageUrl) {
	            if (!imageUrl) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "ScreenCreditController", "addImageCredit", "missingUrl"));
	            }

	            if (this.imageUrls.indexOf(imageUrl) === -1) {
	                this.imageUrls.push(imageUrl);
	            }
	        };

	        /**
	         * Adds a string credit to this controller.
	         * @param {String} stringCredit The string to display in the credits area.
	         * @param (Color} color The color with which to draw the string.
	         * @throws {ArgumentError} If either the specified string or color is null or undefined.
	         */
	        ScreenCreditController.prototype.addStringCredit = function (stringCredit, color) {
	            if (!stringCredit) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "ScreenCreditController", "addStringCredit", "missingText"));
	            }

	            if (!color) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "ScreenCreditController", "addStringCredit", "missingColor"));
	            }

	            if (this.stringCredits.indexOf(stringCredit) === -1) {
	                this.stringCredits.push({
	                    text: stringCredit,
	                    color: color || Color.WHITE
	                });
	            }
	        };

	        // Internal use only. Intentionally not documented.
	        ScreenCreditController.prototype.drawCredits = function (dc) {
	            // Check to see if there's anything to draw.
	            if ((this.imageUrls.length === 0 && this.stringCredits.length === 0)) {
	                return;
	            }

	            // Picking not provided.
	            if (dc.pickingMode) {
	                return;
	            }

	            // Want to draw only once per frame.
	            if (dc.timestamp == this.lastFrameTimestamp) {
	                return;
	            }
	            this.lastFrameTimestamp = dc.timestamp;

	            this.beginDrawingCredits(dc);

	            // Draw the image credits in a row along the bottom of the window from right to left.
	            var imageX = dc.navigatorState.viewport.width - (this.margin + this.imageCreditSize),
	                imageHeight, maxImageHeight = 0;

	            for (var i = 0; i < this.imageUrls.length; i++) {
	                imageHeight = this.drawImageCredit(dc, this.imageUrls[i], imageX, this.margin);
	                if (imageHeight > 0) {
	                    imageX -= (this.margin + this.imageCreditSize);
	                    maxImageHeight = WWMath.max(imageHeight, maxImageHeight);
	                }
	            }

	            // Draw the string credits above the image credits and progressing from bottom to top.
	            var stringY = maxImageHeight + this.margin;
	            for (var j = 0; j < this.stringCredits.length; j++) {
	                this.drawStringCredit(dc, this.stringCredits[j], stringY);
	                stringY += this.margin + 15; // margin + string height
	            }

	            this.endDrawingCredits(dc);
	        };

	        // Internal use only. Intentionally not documented.
	        ScreenCreditController.prototype.beginDrawingCredits = function (dc) {
	            var gl = dc.currentGlContext,
	                program;

	            dc.findAndBindProgram(BasicTextureProgram);

	            // Configure GL to use the draw context's unit quad VBOs for both model coordinates and texture coordinates.
	            // Most browsers can share the same buffer for vertex and texture coordinates, but Internet Explorer requires
	            // that they be in separate buffers, so the code below uses the 3D buffer for vertex coords and the 2D
	            // buffer for texture coords.
	            program = dc.currentProgram;
	            gl.bindBuffer(gl.ARRAY_BUFFER, dc.unitQuadBuffer3());
	            gl.vertexAttribPointer(program.vertexPointLocation, 3, gl.FLOAT, false, 0, 0);
	            gl.bindBuffer(gl.ARRAY_BUFFER, dc.unitQuadBuffer());
	            gl.vertexAttribPointer(program.vertexTexCoordLocation, 2, gl.FLOAT, false, 0, 0);
	            gl.enableVertexAttribArray(program.vertexPointLocation);
	            gl.enableVertexAttribArray(program.vertexTexCoordLocation);

	            // Tell the program which texture unit to use.
	            program.loadTextureUnit(gl, gl.TEXTURE0);
	            program.loadModulateColor(gl, false);

	            // Turn off depth testing.
	            // tag, 6/17/15: It's not clear why this call was here. It was carried over from WWJ.
	            //gl.disable(WebGLRenderingContext.DEPTH_TEST);
	        };

	        // Internal use only. Intentionally not documented.
	        ScreenCreditController.prototype.endDrawingCredits = function (dc) {
	            var gl = dc.currentGlContext,
	                program = dc.currentProgram;

	            // Clear the vertex attribute state.
	            gl.disableVertexAttribArray(program.vertexPointLocation);
	            gl.disableVertexAttribArray(program.vertexTexCoordLocation);

	            // Clear GL bindings.
	            gl.bindBuffer(gl.ARRAY_BUFFER, null);
	            gl.bindTexture(gl.TEXTURE_2D, null);

	            // Re-enable depth testing.
	            gl.enable(gl.DEPTH_TEST);
	        };

	        // Internal use only. Intentionally not documented.
	        ScreenCreditController.prototype.drawImageCredit = function (dc, creditUrl, x, y) {
	            var imageWidth, imageHeight, scale, activeTexture, gl, program;

	            activeTexture = dc.gpuResourceCache.resourceForKey(creditUrl);
	            if (!activeTexture) {
	                dc.gpuResourceCache.retrieveTexture(dc.currentGlContext, creditUrl);
	                return 0;
	            }

	            // Scale the image to fit within a constrained size.
	            imageWidth = activeTexture.imageWidth;
	            imageHeight = activeTexture.imageHeight;
	            if (imageWidth <= this.imageCreditSize && this.imageHeight <= this.imageCreditSize) {
	                scale = 1;
	            } else if (imageWidth >= imageHeight) {
	                scale = this.imageCreditSize / imageWidth;
	            } else {
	                scale = this.imageCreditSize / imageHeight;
	            }

	            ScreenCreditController.imageTransform.setTranslation(x, y, 0);
	            ScreenCreditController.imageTransform.setScale(scale * imageWidth, scale * imageHeight, 1);

	            gl = dc.currentGlContext;
	            program = dc.currentProgram;

	            // Compute and specify the MVP matrix.
	            ScreenCreditController.scratchMatrix.copy(dc.screenProjection);
	            ScreenCreditController.scratchMatrix.multiplyMatrix(ScreenCreditController.imageTransform);
	            program.loadModelviewProjection(gl, ScreenCreditController.scratchMatrix);

	            program.loadTextureEnabled(gl, true);
	            program.loadColor(gl, Color.WHITE);
	            program.loadOpacity(gl, this.opacity);

	            ScreenCreditController.texCoordMatrix.setToIdentity();
	            ScreenCreditController.texCoordMatrix.multiplyByTextureTransform(activeTexture);
	            program.loadTextureMatrix(gl, ScreenCreditController.texCoordMatrix);

	            if (activeTexture.bind(dc)) { // returns false if active texture cannot be bound
	                // Draw the image quad.
	                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
	            }

	            return imageHeight;
	        };

	        // Internal use only. Intentionally not documented.
	        ScreenCreditController.prototype.drawStringCredit = function (dc, credit, y) {
	            var imageWidth, imageHeight, activeTexture, textureKey, gl, program, x;

	            textureKey = credit.text + this.creditFont.toString();
	            activeTexture = dc.gpuResourceCache.resourceForKey(textureKey);
	            if (!activeTexture) {
	                activeTexture = dc.textSupport.createTexture(dc, credit.text, this.creditFont, false);
	                dc.gpuResourceCache.putResource(textureKey, activeTexture, activeTexture.size);
	            }

	            imageWidth = activeTexture.imageWidth;
	            imageHeight = activeTexture.imageHeight;

	            x = dc.navigatorState.viewport.width - (imageWidth + this.margin);
	            ScreenCreditController.imageTransform.setTranslation(x, y, 0);
	            ScreenCreditController.imageTransform.setScale(imageWidth, imageHeight, 1);

	            gl = dc.currentGlContext;
	            program = dc.currentProgram;

	            // Compute and specify the MVP matrix.
	            ScreenCreditController.scratchMatrix.copy(dc.screenProjection);
	            ScreenCreditController.scratchMatrix.multiplyMatrix(ScreenCreditController.imageTransform);
	            program.loadModelviewProjection(gl, ScreenCreditController.scratchMatrix);

	            program.loadTextureEnabled(gl, true);
	            program.loadColor(gl, credit.color);
	            program.loadOpacity(gl, this.opacity);

	            ScreenCreditController.texCoordMatrix.setToIdentity();
	            ScreenCreditController.texCoordMatrix.multiplyByTextureTransform(activeTexture);
	            program.loadTextureMatrix(gl, ScreenCreditController.texCoordMatrix);

	            if (activeTexture.bind(dc)) { // returns false if active texture cannot be bound
	                // Draw the image quad.
	                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
	            }

	            return true;
	        };

	        return ScreenCreditController;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2015 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports Font
	 * @version $Id: Font.js 2660 2015-01-20 19:20:11Z danm $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(30),
	        __webpack_require__(52),
	        __webpack_require__(32)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
	              Color,
	              Logger) {
	        "use strict";

	        /**
	         * Construct a font descriptor. See the individual attribute descriptions below for possible parameter values.
	         * @param {Number} size The size of font.
	         * @param {String} style The style of the font.
	         * @param {String} variant The variant of the font.
	         * @param {String} weight The weight of the font.
	         * @param {String} family The family of the font.
	         * @param {String} horizontalAlignment The vertical alignment of the font.
	         * @alias Font
	         * @constructor
	         * @classdesc Holds attributes controlling the style, size and other attributes of {@link Text} shapes and
	         * the textual features of {@link Placemark} and other shapes. The values used for these attributes are those
	         * defined by the [CSS Font property]{@link http://www.w3schools.com/cssref/pr_font_font.asp}.
	         */
	        var Font = function (size, style, variant, weight, family, horizontalAlignment) {
	            /*
	             * All properties of Font are intended to be private and must be accessed via public getters and setters.
	             */

	            if (!size) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "Font", "constructor",
	                    "missingSize"));
	            }
	            else if (size <= 0) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "Font", "constructor",
	                    "invalidSize"));
	            }
	            else {
	                this._size = size;
	            }

	            this.style = style || "normal";
	            this.variant = variant || "normal";
	            this.weight = weight || "normal";
	            this.family = family || "sans-serif";
	            this.horizontalAlignment = horizontalAlignment || "center";
	        };

	        Object.defineProperties(Font.prototype, {
	            /**
	             * The font size.
	             * @memberof Font.prototype
	             * @type Number
	             */
	            size: {
	                get: function () {
	                    return this._size;
	                },
	                set: function (value) {
	                    this._fontString = null;
	                    this._size = value;
	                }
	            },
	            /**
	             * The font style.
	             * See [CSS font-style]{@link http://www.w3schools.com/cssref/pr_font_font-style.asp} for defined values.
	             * @memberof Font.prototype
	             * @type {String}
	             * @default "normal"
	             */
	            style: {
	                get: function () {
	                    return this._style;
	                },
	                set: function (value) {
	                    this._fontString = null;
	                    this._style = value;
	                }
	            },
	            /**
	             * The font variant.
	             * See [CSS font-variant]{@link http://www.w3schools.com/cssref/pr_font_font-variant.asp} for defined values.
	             * @memberof Font.prototype
	             * @type {String}
	             * @default "normal"
	             */
	            variant: {
	                get: function () {
	                    return this._variant;
	                },
	                set: function (value) {
	                    this._fontString = null;
	                    this._variant = value;
	                }
	            },
	            /**
	             * The font weight.
	             * See [CSS font-weight]{@link http://www.w3schools.com/cssref/pr_font_weight.asp} for defined values.
	             * @memberof Font.prototype
	             * @type {String}
	             * @default "normal"
	             */
	            weight: {
	                get: function () {
	                    return this._weight;
	                },
	                set: function (value) {
	                    this._fontString = null;
	                    this._weight = value;
	                }
	            },
	            /**
	             * The font family.
	             * See [CSS font-family]{@link http://www.w3schools.com/cssref/pr_font_font-family.asp} for defined values.
	             * @memberof Font.prototype
	             * @type {String}
	             * @default "sans-serif"
	             */
	            family: {
	                get: function () {
	                    return this._family;
	                },
	                set: function (value) {
	                    this._fontString = null;
	                    this._family = value;
	                }
	            },
	            /**
	             * The horizontal alignment of the font.
	             * Recognized values are "left", "center" and "right".
	             * @memberof Font.prototype
	             * @type {String}
	             * @default "center"
	             */
	            horizontalAlignment: {
	                get: function () {
	                    return this._horizontalAlignment;
	                },
	                set: function (value) {
	                    this._toString = null;
	                    this._horizontalAlignment = value;
	                }
	            },

	            /**
	             * A string representing this font's style, weight, size and family properties, suitable for
	             * passing directly to a 2D canvas context.
	             * @memberof Font.prototype
	             */
	            fontString: {
	                get: function () {
	                    if (!this._fontString) {
	                        this._fontString =
	                            this._style + " " +
	                            this.variant + " " +
	                            this._weight + " " +
	                            this._size.toString() + "px " +
	                            this._family;
	                    }
	                    return this._fontString;
	                }
	            }
	        });

	        /**
	         * Returns a string representation of this object.
	         * @returns {String} A string representation of this object.
	         */
	        Font.prototype.toString = function () {
	            if (!this._toString || !this._fontString) {
	                this._toString = this.fontString + " " + this.horizontalAlignment;
	            }
	            return this._toString;
	        };

	        return Font;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports BasicTextureProgram
	 * @version $Id: BasicTextureProgram.js 3327 2015-07-21 19:03:39Z dcollins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(30),
	        __webpack_require__(52),
	        __webpack_require__(81),
	        __webpack_require__(32)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
	              Color,
	              GpuProgram,
	              Logger) {
	        "use strict";

	        /**
	         * Constructs a new program.
	         * Initializes, compiles and links this GLSL program with the source code for its vertex and fragment shaders.
	         * <p>
	         * This method creates WebGL shaders for the program's shader sources and attaches them to a new GLSL program. This
	         * method then compiles the shaders and then links the program if compilation is successful. Use the bind method to make the
	         * program current during rendering.
	         *
	         * @alias BasicTextureProgram
	         * @constructor
	         * @augments GpuProgram
	         * @classdesc BasicTextureProgram is a GLSL program that draws textured or untextured geometry.
	         * @param {WebGLRenderingContext} gl The current WebGL context.
	         * @throws {ArgumentError} If the shaders cannot be compiled, or if linking of
	         * the compiled shaders into a program fails.
	         */
	        var BasicTextureProgram = function (gl) {
	            var vertexShaderSource =
	                    'attribute vec4 vertexPoint;\n' +
	                    'attribute vec4 vertexTexCoord;\n' +
	                    'attribute vec4 normalVector;\n' +
	                    'uniform mat4 mvpMatrix;\n' +
	                    'uniform mat4 mvInverseMatrix;\n' +
	                    'uniform mat4 texCoordMatrix;\n' +
	                    'uniform bool applyLighting;\n' +
	                    'varying vec2 texCoord;\n' +
	                    'varying vec4 normal;\n' +
	                    'void main() {gl_Position = mvpMatrix * vertexPoint;\n' +
	                    'texCoord = (texCoordMatrix * vertexTexCoord).st;\n' +
	                    'if (applyLighting) {normal = mvInverseMatrix * normalVector;}\n' +
	                    '}',
	                fragmentShaderSource =
	                    'precision mediump float;\n' +
	                    'uniform float opacity;\n' +
	                    'uniform vec4 color;\n' +
	                    'uniform bool enableTexture;\n' +
	                    'uniform bool modulateColor;\n' +
	                    'uniform sampler2D textureSampler;\n' +
	                    'uniform bool applyLighting;\n' +
	                    'varying vec2 texCoord;\n' +
	                    'varying vec4 normal;\n' +
	                    'void main() {\n' +
	                    'vec4 textureColor = texture2D(textureSampler, texCoord);\n' +
	                    'float ambient = 0.15; vec4 lightDirection = vec4(0, 0, 1, 0);\n' +
	                    'if (enableTexture && !modulateColor)\n' +
	                    '    gl_FragColor = textureColor * color * opacity;\n' +
	                    'else if (enableTexture && modulateColor)\n' +
	                    '    gl_FragColor = color * floor(textureColor.a + 0.5);\n' +
	                    'else\n' +
	                    '    gl_FragColor = color * opacity;\n' +
	                    'if (gl_FragColor.a == 0.0) {discard;}\n' +
	                    'if (applyLighting) {\n' +
	                    '    vec4 n = normal * (gl_FrontFacing ? 1.0 : -1.0);\n' +
	                    '    gl_FragColor.rgb *= clamp(ambient + dot(lightDirection, n), 0.0, 1.0);\n' +
	                    '}\n' +
	                    '}';

	            // Specify bindings to avoid the WebGL performance warning that's generated when normalVector gets
	            // bound to location 0.
	            var bindings = ["vertexPoint", "normalVector", "vertexTexCoord"];

	            // Call to the superclass, which performs shader program compiling and linking.
	            GpuProgram.call(this, gl, vertexShaderSource, fragmentShaderSource, bindings);

	            /**
	             * The WebGL location for this program's 'vertexPoint' attribute.
	             * @type {Number}
	             * @readonly
	             */
	            this.vertexPointLocation = this.attributeLocation(gl, "vertexPoint");

	            /**
	             * The WebGL location for this program's 'normalVector' attribute.
	             * @type {Number}
	             * @readonly
	             */
	            this.normalVectorLocation = this.attributeLocation(gl, "normalVector");

	            /**
	             * The WebGL location for this program's 'vertexTexCoord' attribute.
	             * @type {Number}
	             * @readonly
	             */
	            this.vertexTexCoordLocation = this.attributeLocation(gl, "vertexTexCoord");

	            /**
	             * The WebGL location for this program's 'mvpMatrix' uniform.
	             * @type {WebGLUniformLocation}
	             * @readonly
	             */
	            this.mvpMatrixLocation = this.uniformLocation(gl, "mvpMatrix");

	            /**
	             * The WebGL location for this program's 'mvInverseMatrix' uniform.
	             * @type {WebGLUniformLocation}
	             * @readonly
	             */
	            this.mvInverseMatrixLocation = this.uniformLocation(gl, "mvInverseMatrix");

	            /**
	             * The WebGL location for this program's 'color' uniform.
	             * @type {WebGLUniformLocation}
	             * @readonly
	             */
	            this.colorLocation = this.uniformLocation(gl, "color");

	            /**
	             * The WebGL location for this program's 'enableTexture' uniform.
	             * @type {WebGLUniformLocation}
	             * @readonly
	             */
	            this.textureEnabledLocation = this.uniformLocation(gl, "enableTexture");

	            /**
	             * The WebGL location for this program's 'modulateColor' uniform.
	             * @type {WebGLUniformLocation}
	             * @readonly
	             */
	            this.modulateColorLocation = this.uniformLocation(gl, "modulateColor");

	            /**
	             * The WebGL location for this program's 'textureSampler' uniform.
	             * @type {WebGLUniformLocation}
	             * @readonly
	             */
	            this.textureUnitLocation = this.uniformLocation(gl, "textureSampler");

	            /**
	             * The WebGL location for this program's 'texCoordMatrix' uniform.
	             * @type {WebGLUniformLocation}
	             * @readonly
	             */
	            this.textureMatrixLocation = this.uniformLocation(gl, "texCoordMatrix");

	            /**
	             * The WebGL location for this program's 'opacity' uniform.
	             * @type {WebGLUniformLocation}
	             * @readonly
	             */
	            this.opacityLocation = this.uniformLocation(gl, "opacity");

	            /**
	             * The WegGL location for this program's 'enableLighting' uniform.
	             * @type {WebGLUniformLocation}
	             * @readonly
	             */
	            this.applyLightingLocation = this.uniformLocation(gl, "applyLighting");
	        };

	        /**
	         * A string that uniquely identifies this program.
	         * @type {string}
	         * @readonly
	         */
	        BasicTextureProgram.key = "WorldWindGpuBasicTextureProgram";

	        // Inherit from GpuProgram.
	        BasicTextureProgram.prototype = Object.create(GpuProgram.prototype);

	        /**
	         * Loads the specified matrix as the value of this program's 'mvInverseMatrix' uniform variable.
	         *
	         * @param {WebGLRenderingContext} gl The current WebGL context.
	         * @param {Matrix} matrix The matrix to load.
	         * @throws {ArgumentError} If the specified matrix is null or undefined.
	         */
	        BasicTextureProgram.prototype.loadModelviewInverse = function (gl, matrix) {
	            if (!matrix) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "BasicTextureProgram", "loadModelviewInverse", "missingMatrix"));
	            }

	            this.loadUniformMatrix(gl, matrix, this.mvInverseMatrixLocation);
	        };

	        /**
	         * Loads the specified matrix as the value of this program's 'mvpMatrix' uniform variable.
	         *
	         * @param {WebGLRenderingContext} gl The current WebGL context.
	         * @param {Matrix} matrix The matrix to load.
	         * @throws {ArgumentError} If the specified matrix is null or undefined.
	         */
	        BasicTextureProgram.prototype.loadModelviewProjection = function (gl, matrix) {
	            if (!matrix) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "BasicTextureProgram", "loadModelviewProjection", "missingMatrix"));
	            }

	            this.loadUniformMatrix(gl, matrix, this.mvpMatrixLocation);
	        };

	        /**
	         * Loads the specified color as the value of this program's 'color' uniform variable.
	         *
	         * @param {WebGLRenderingContext} gl The current WebGL context.
	         * @param {Color} color The color to load.
	         * @throws {ArgumentError} If the specified color is null or undefined.
	         */
	        BasicTextureProgram.prototype.loadColor = function (gl, color) {
	            if (!color) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "BasicTextureProgram", "loadColor", "missingColor"));
	            }

	            this.loadUniformColor(gl, color, this.colorLocation);
	        };

	        /**
	         * Loads the specified boolean as the value of this program's 'enableTexture' uniform variable.
	         * @param {WebGLRenderingContext} gl The current WebGL context.
	         * @param {Boolean} enable true to enable texturing, false to disable texturing.
	         */
	        BasicTextureProgram.prototype.loadTextureEnabled = function (gl, enable) {
	            gl.uniform1i(this.textureEnabledLocation, enable ? 1 : 0);
	        };

	        /**
	         * Loads the specified boolean as the value of this program's 'modulateColor' uniform variable. When this
	         * value is true and the value of the textureEnabled variable is true, the color uniform of this shader is
	         * multiplied by the rounded alpha component of the texture color at each fragment. This causes the color
	         * to be either fully opaque or fully transparent depending on the value of the texture color's alpha value.
	         * This is used during picking to replace opaque or mostly opaque texture colors with the pick color, and
	         * to make all other texture colors transparent.
	         * @param {WebGLRenderingContext} gl The current WebGL context.
	         * @param {Boolean} enable true to enable modulation, false to disable modulation.
	         */
	        BasicTextureProgram.prototype.loadModulateColor = function (gl, enable) {
	            gl.uniform1i(this.modulateColorLocation, enable ? 1 : 0);
	        };

	        /**
	         * Loads the specified number as the value of this program's 'textureSampler' uniform variable.
	         * @param {WebGLRenderingContext} gl The current WebGL context.
	         * @param {Number} unit The texture unit.
	         */
	        BasicTextureProgram.prototype.loadTextureUnit = function (gl, unit) {
	            gl.uniform1i(this.textureUnitLocation, unit - gl.TEXTURE0);
	        };

	        /**
	         * Loads the specified matrix as the value of this program's 'texCoordMatrix' uniform variable.
	         * @param {WebGLRenderingContext} gl The current WebGL context.
	         * @param {Matrix} matrix The texture coordinate matrix.
	         */
	        BasicTextureProgram.prototype.loadTextureMatrix = function (gl, matrix) {
	            this.loadUniformMatrix(gl, matrix, this.textureMatrixLocation);
	        };

	        /**
	         * Loads the specified number as the value of this program's 'opacity' uniform variable.
	         * @param {WebGLRenderingContext} gl The current WebGL context.
	         * @param {Number} opacity The opacity in the range [0, 1].
	         */
	        BasicTextureProgram.prototype.loadOpacity = function (gl, opacity) {
	            gl.uniform1f(this.opacityLocation, opacity);
	        };

	        /**
	         * Loads the specified boolean as the value of this program's 'applyLighting' uniform variable.
	         * @param {WebGLRenderingContext} gl The current WebGL context.
	         * @param {Number} applyLighting true to apply lighting, otherwise false.
	         */
	        BasicTextureProgram.prototype.loadApplyLighting = function (gl, applyLighting) {
	            gl.uniform1i(this.applyLightingLocation, applyLighting);
	        };

	        return BasicTextureProgram;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports Renderable
	 * @version $Id: Renderable.js 2951 2015-03-31 23:31:08Z tgaskins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(32),
	        __webpack_require__(66)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Logger,
	              UnsupportedOperationError) {
	        "use strict";

	        /**
	         * Constructs a base renderable.
	         * @alias Renderable
	         * @constructor
	         * @classdesc Represents a shape or other object that can be rendered. This is an abstract class and is not
	         * meant to be instantiated directly.
	         */
	        var Renderable = function () {

	            /**
	             * The display name of the renderable.
	             * @type {String}
	             * @default "Renderable"
	             */
	            this.displayName = "Renderable";

	            /**
	             * Indicates whether to display this renderable.
	             * @type {Boolean}
	             * @default true
	             */
	            this.enabled = true;

	            /**
	             * Indicates the object to return as the userObject of this shape when picked. If null,
	             * then this shape is returned as the userObject.
	             * @type {Object}
	             * @default null
	             * @see  [PickedObject.userObject]{@link PickedObject#userObject}
	             */
	            this.pickDelegate = null;

	            /**
	             * An application defined object associated with this renderable. A typical use case is to associate
	             * application defined data with a picked renderable.
	             * @type {Object}
	             * @default An empty object
	             */
	            this.userProperties = {};
	        };

	        /**
	         * Render this renderable. Some shapes actually draw themselves during this call, others only add themselves
	         * to the draw context's ordered rendering list for subsequent drawing when their renderOrdered method is called.
	         * This method is intended to be called by layers such as {@link RenderableLayer} and not by applications.
	         * @param {DrawContext} dc The current draw context.
	         */
	        Renderable.prototype.render = function (dc) {
	            throw new UnsupportedOperationError(
	                Logger.logMessage(Logger.LEVEL_SEVERE, "Renderable", "render", "abstractInvocation"));
	        };

	        return Renderable;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports SurfaceShape
	 * @version $Id: SurfaceShape.js 3191 2015-06-15 19:35:57Z tgaskins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(31),
	        __webpack_require__(29),
	        __webpack_require__(30),
	        __webpack_require__(28),
	        __webpack_require__(32),
	        __webpack_require__(79),
	        __webpack_require__(87),
	        __webpack_require__(130),
	        __webpack_require__(75),
	        __webpack_require__(132),
	        __webpack_require__(66),
	        __webpack_require__(36)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (AbstractError,
	              Angle,
	              ArgumentError,
	              Location,
	              Logger,
	              NotYetImplementedError,
	              PickedObject,
	              Renderable,
	              Sector,
	              ShapeAttributes,
	              UnsupportedOperationError,
	              WWMath) {
	        "use strict";

	        /**
	         * Constructs a surface shape with an optionally specified bundle of default attributes.
	         * @alias SurfaceShape
	         * @constructor
	         * @augments Renderable
	         * @abstract
	         * @classdesc Represents a surface shape. This is an abstract base class and is meant to be instantiated
	         * only by subclasses.
	         * <p>
	         * Surface shapes other than SurfacePolyline {@link SurfacePolyline} have an interior and an outline and utilize
	         * the corresponding attributes in their associated ShapeAttributes {@link ShapeAttributes}. They do not
	         * utilize image-related attributes.
	         *
	         * @param {ShapeAttributes} attributes The attributes to apply to this shape. May be null, in which case
	         * attributes must be set directly before the shape is drawn.
	         */
	        var SurfaceShape = function (attributes) {

	            Renderable.call(this);

	            // All these are documented with their property accessors below.
	            this._displayName = "Surface Shape";
	            this._attributes = attributes ? attributes : new ShapeAttributes(null);
	            this._highlightAttributes = null;
	            this._highlighted = false;
	            this._enabled = true;
	            this._pathType = WorldWind.GREAT_CIRCLE;
	            this._maximumNumEdgeIntervals = SurfaceShape.DEFAULT_NUM_EDGE_INTERVALS;
	            this._polarThrottle = SurfaceShape.DEFAULT_POLAR_THROTTLE;
	            this._sector = null;

	            /**
	             * Indicates the object to return as the owner of this shape when picked.
	             * @type {Object}
	             * @default null
	             */
	            this.pickDelegate = null;

	            /*
	             * The bounding sectors for this tile, which may be needed for crossing the dateline.
	             * @type {Sector[]}
	             * @protected
	             */
	            this._sectors = [];

	            /*
	             * The raw collection of locations defining this shape and are explicitly specified by the client of this class.
	             * @type {Location[]}
	             * @protected
	             */
	            this._locations = null;

	            /*
	             * Boundaries that are either the user specified locations or locations that are algorithmically generated.
	             * @type {Location[]}
	             * @protected
	             */
	            this._boundaries = null;

	            /*
	             * The collection of locations that describes a closed curve which can be filled.
	             * @type {Location[][]}
	             * @protected
	             */
	            this._interiorGeometry = null;

	            /*
	             * The collection of locations that describe the outline of the shape.
	             * @type {Location[][]}
	             * @protected
	             */
	            this._outlineGeometry = null;

	            /*
	             * Internal use only.
	             * Inhibit the filling of the interior. This is to be used ONLY by polylines.
	             * @type {Boolean}
	             * @protected
	             */
	            this._isInteriorInhibited = false;

	            /*
	             * Indicates whether this object's state key is invalid. Subclasses must set this value to true when their
	             * attributes change. The state key will be automatically computed the next time it's requested. This flag
	             * will be set to false when that occurs.
	             * @type {Boolean}
	             * @protected
	             */
	            this.stateKeyInvalid = true;

	            // Internal use only. Intentionally not documented.
	            this._attributesStateKey = null;

	            // Internal use only. Intentionally not documented.
	            this.isPrepared = false;

	            // Internal use only. Intentionally not documented.
	            this.layer = null;

	            // Internal use only. Intentionally not documented.
	            this.pickColor = null;
	        };

	        SurfaceShape.prototype = Object.create(Renderable.prototype);

	        Object.defineProperties(SurfaceShape.prototype, {
	            stateKey: {
	                /**
	                 * A hash key of the total visible external state of the surface shape.
	                 * @memberof SurfaceShape.prototype
	                 * @type {String}
	                 */
	                get: function() {
	                    // If we don't have a state key for the shape attributes, consider this state key to be invalid.
	                    if (!this._attributesStateKey) {
	                        // Update the state key for the appropriate attributes for future
	                        if (this._highlighted) {
	                            if (!!this._highlightAttributes) {
	                                this._attributesStateKey = this._highlightAttributes.stateKey;
	                            }
	                        } else {
	                            if (!!this._attributes) {
	                                this._attributesStateKey = this._attributes.stateKey;
	                            }
	                        }

	                        // If we now actually have a state key for the attributes, it was previously invalid.
	                        if (!!this._attributesStateKey) {
	                            this.stateKeyInvalid = true;
	                        }
	                    } else {
	                        // Detect a change in the appropriate attributes.
	                        var currentAttributesStateKey = null;

	                        if (this._highlighted) {
	                            // If there are highlight attributes associated with this shape, ...
	                            if (!!this._highlightAttributes) {
	                                currentAttributesStateKey = this._highlightAttributes.stateKey;
	                            }
	                        } else {
	                            if (!!this._attributes) {
	                                currentAttributesStateKey = this._attributes.stateKey;
	                            }
	                        }

	                        // If the attributes state key changed, ...
	                        if (currentAttributesStateKey != this._attributesStateKey) {
	                            this._attributesStateKey = currentAttributesStateKey;
	                            this.stateKeyInvalid = true;
	                        }
	                    }

	                    if (this.stateKeyInvalid) {
	                        this._stateKey = this.computeStateKey();
	                    }

	                    return this._stateKey;
	                }
	            },

	            /**
	             * The shape's display name and label text.
	             * @memberof SurfaceShape.prototype
	             * @type {String}
	             * @default Surface Shape
	             */
	            displayName: {
	                get: function() {
	                    return this._displayName;
	                },
	                set: function(value) {
	                    this.stateKeyInvalid = true;
	                    this._displayName = value;
	                }
	            },

	            /**
	             * The shape's attributes. If null and this shape is not highlighted, this shape is not drawn.
	             * @memberof SurfaceShape.prototype
	             * @type {ShapeAttributes}
	             * @default see [ShapeAttributes]{@link ShapeAttributes}
	             */
	            attributes: {
	                get: function() {
	                    return this._attributes;
	                },
	                set: function(value) {
	                    this.stateKeyInvalid = true;
	                    this._attributes = value;
	                    this._attributesStateKey = value.stateKey;
	                }
	            },

	            /**
	             * The attributes used when this shape's highlighted flag is true. If null and the
	             * highlighted flag is true, this shape's normal attributes are used. If they, too, are null, this
	             * shape is not drawn.
	             * @memberof SurfaceShape.prototype
	             * @type {ShapeAttributes}
	             * @default null
	             */
	            highlightAttributes: {
	                get: function() {
	                    return this._highlightAttributes;
	                },
	                set: function(value) {
	                    this.stateKeyInvalid = true;
	                    this._highlightAttributes = value;
	                }
	            },

	            /**
	             * Indicates whether this shape displays with its highlight attributes rather than its normal attributes.
	             * @memberof SurfaceShape.prototype
	             * @type {Boolean}
	             * @default false
	             */
	            highlighted: {
	                get: function() {
	                    return this._highlighted;
	                },
	                set: function(value) {
	                    this.stateKeyInvalid = true;
	                    this._highlighted = value;
	                }
	            },

	            /**
	             * Indicates whether this shape is drawn.
	             * @memberof SurfaceShape.prototype
	             * @type {Boolean}
	             * @default true
	             */
	            enabled: {
	                get: function() {
	                    return this._enabled;
	                },
	                set: function(value) {
	                    this.stateKeyInvalid = true;
	                    this._enabled = value;
	                }
	            },

	            /**
	             * The path type to used to interpolate between locations on this shape. Recognized values are:
	             * <ul>
	             * <li>WorldWind.GREAT_CIRCLE</li>
	             * <li>WorldWind.RHUMB_LINE</li>
	             * <li>WorldWind.LINEAR</li>
	             * </ul>
	             * @memberof SurfaceShape.prototype
	             * @type {String}
	             * @default WorldWind.GREAT_CIRCLE
	             */
	            pathType: {
	                get: function() {
	                    return this._pathType;
	                },
	                set: function(value) {
	                    this.stateKeyInvalid = true;
	                    this._pathType = value;
	                }
	            },

	            /**
	             * The maximum number of intervals an edge will be broken into. This is the number of intervals that an
	             * edge that spans to opposite side of the globe would be broken into. This is strictly an upper bound
	             * and the number of edge intervals may be lower if this resolution is not needed.
	             * @memberof SurfaceShape.prototype
	             * @type {Number}
	             * @default SurfaceShape.DEFAULT_NUM_EDGE_INTERVALS
	             */
	            maximumNumEdgeIntervals: {
	                get: function() {
	                    return this._maximumNumEdgeIntervals;
	                },
	                set: function(value) {
	                    this.stateKeyInvalid = true;
	                    this._maximumNumEdgeIntervals = value;
	                }
	            },

	            /**
	             * A dimensionless number that controls throttling of edge traversal near the poles where edges need to be
	             * sampled more closely together.
	             * A value of 0 indicates that no polar throttling is to be performed.
	             * @memberof SurfaceShape.prototype
	             * @type {Number}
	             * @default SurfaceShape.DEFAULT_POLAR_THROTTLE
	             */
	            polarThrottle: {
	                get: function () {
	                    return this._polarThrottle;
	                },
	                set: function (value) {
	                    this.stateKeyInvalid = true;
	                    this._polarThrottle = value;
	                }
	            },

	            /**
	             * Defines the extent of the shape in latitude and longitude.
	             * This sector only has valid data once the boundary is defined. Prior to this, it is null.
	             * @memberof SurfaceShape.prototype
	             * @type {Sector}
	             */
	            sector: {
	                get: function() {
	                    return this._sector;
	                }
	            }
	        });

	        SurfaceShape.staticStateKey = function(shape) {
	            shape.stateKeyInvalid = false;

	            if (shape.highlighted) {
	                if (!shape._highlightAttributes) {
	                    if (!shape._attributes) {
	                        shape._attributesStateKey = null;
	                    } else {
	                        shape._attributesStateKey = shape._attributes.stateKey;
	                    }
	                } else {
	                    shape._attributesStateKey = shape._highlightAttributes.stateKey;
	                }
	            } else {
	                if (!shape._attributes) {
	                    shape._attributesStateKey = null;
	                } else {
	                    shape._attributesStateKey = shape._attributes.stateKey;
	                }
	            }

	            return   "dn " + shape.displayName +
	                    " at " + (!shape._attributesStateKey ? "null" : shape._attributesStateKey) +
	                    " hi " + shape.highlighted +
	                    " en " + shape.enabled +
	                    " pt " + shape.pathType +
	                    " ne " + shape.maximumNumEdgeIntervals +
	                    " po " + shape.polarThrottle +
	                    " se " + "[" +
	                        shape.sector.minLatitude + "," +
	                        shape.sector.maxLatitude + "," +
	                        shape.sector.minLongitude + "," +
	                        shape.sector.maxLongitude +
	                    "]";
	        };

	        SurfaceShape.prototype.computeStateKey = function() {
	            return SurfaceShape.staticStateKey(this);
	        };

	        /**
	         * Returns this shape's area in square meters.
	         * @param {Globe} globe The globe on which to compute the area.
	         * @param {Boolean} terrainConformant If true, the returned area is that of the terrain,
	         * including its hillsides and other undulations. If false, the returned area is the shape's
	         * projected area.
	         */
	        SurfaceShape.prototype.area = function (globe, terrainConformant) {
	            throw new NotYetImplementedError(
	                Logger.logMessage(Logger.LEVEL_SEVERE, "SurfaceShape", "area", "notYetImplemented"));
	        };

	        // Internal function. Intentionally not documented.
	        SurfaceShape.prototype.computeBoundaries = function(globe) {
	            // This method is in the base class and should be overridden if the boundaries are generated.
	            // It should be called only if the geometry has been provided by the user and does not need to be generated.
	            // assert(!this._boundaries);

	            throw new AbstractError(
	                Logger.logMessage(Logger.LEVEL_SEVERE, "SurfaceShape", "computeBoundaries", "abstractInvocation"));
	        };

	        // Internal function. Intentionally not documented.
	        SurfaceShape.prototype.render = function(dc) {
	            if (!this.enabled) {
	                return;
	            }

	            this.layer = dc.currentLayer;

	            this.prepareBoundaries(dc);

	            dc.surfaceShapeTileBuilder.insertSurfaceShape(this);
	        };

	        // Internal function. Intentionally not documented.
	        SurfaceShape.prototype.interpolateLocations = function(locations) {
	            var first  = locations[0],
	                next = first,
	                prev,
	                isNextFirst = true,
	                isPrevFirst = true,// Don't care initially, this will get set in first iteration.
	                countFirst = 0,
	                isInterpolated = true,
	                idx, len;

	            this._locations = [first];

	            for (idx = 1, len = locations.length; idx < len; idx += 1) {
	                // Advance to next location, retaining previous location.
	                prev = next;
	                isPrevFirst = isNextFirst;

	                next = locations[idx];

	                // Detect whether the next location and the first location are the same.
	                isNextFirst = next.latitude == first.latitude && next.longitude == first.longitude;

	                // Inhibit interpolation if either endpoint if the first location,
	                // except for the first segement which will be the actual first location or that location
	                // as the polygon closes the first time.
	                // All subsequent encounters of the first location are used to connected secondary domains with the
	                // primary domain in multiply-connected geometry (an outer ring with multiple inner rings).
	                isInterpolated = true;
	                if (isNextFirst || isPrevFirst) {
	                    countFirst += 1;

	                    if (countFirst > 2) {
	                        isInterpolated = false;
	                    }
	                }

	                if (isInterpolated) {
	                    this.interpolateEdge(prev, next, this._locations);
	                }

	                this._locations.push(next);

	                prev = next;
	            }

	            // Force the closing of the border.
	            if (!this._isInteriorInhibited) {
	                // Avoid duplication if the first endpoint was already emitted.
	                if (prev.latitude != first.latitude || prev.longitude != first.longitude) {
	                    this.interpolateEdge(prev, first, this._locations);
	                    this._locations.push(first);
	                }
	            }
	        };

	        // Internal function. Intentionally not documented.
	        SurfaceShape.prototype.interpolateEdge = function(start, end, locations) {
	            var distanceRadians = Location.greatCircleDistance(start, end),
	                steps = Math.round(this._maximumNumEdgeIntervals * distanceRadians / Math.PI),
	                dt,
	                location;

	            if (steps > 0) {
	                dt = 1 / steps;
	                location = start;

	                for (var t = this.throttledStep(dt, location); t < 1; t += this.throttledStep(dt, location)) {
	                    location = new Location(0, 0);
	                    Location.interpolateAlongPath(this._pathType, t, start, end, location);
	                    locations.push(location);
	                }
	            }
	        };

	        // Internal function. Intentionally not documented.
	        // Return a throttled step size when near the poles.
	        SurfaceShape.prototype.throttledStep = function(dt, location) {
	            var cosLat = Math.cos(location.latitude * Angle.DEGREES_TO_RADIANS);
	            cosLat *= cosLat; // Square cos to emphasize poles and de-emphasize equator.

	            // Remap polarThrotle:
	            //  0 .. INF => 0 .. 1
	            // This acts as a weight between no throttle and fill throttle.
	            var weight = this._polarThrottle / (1 + this._polarThrottle);

	            return dt * ((1 - weight) + weight * cosLat);
	        };

	        // Internal function. Intentionally not documented.
	        SurfaceShape.prototype.prepareBoundaries = function(dc) {
	            if (this.isPrepared) return;

	            // Some shapes generate boundaries, such as ellipses and sectors;
	            // others don't, such as polylines and polygons.
	            // Handle the latter below.
	            if (!this._boundaries) {
	                this.computeBoundaries(dc);
	            }

	            if (!this._locations) {
	                this.interpolateLocations(this._boundaries);
	            }

	            this.prepareGeometry(dc);

	            this.prepareSectors();

	            this.isPrepared = true;
	        };

	        /**
	         * Computes the bounding sectors for the shape. There will be more than one if the shape crosses the date line,
	         * but does not enclose a pole.
	         *
	         * @param {DrawContext} dc The drawing context containing a globe.
	         *
	         * @return {Sector[]}  Bounding sectors for the shape.
	         */
	        SurfaceShape.prototype.computeSectors = function(dc) {
	            // Return a previously computed value if it already exists.
	            if (this._sectors && this._sectors.length > 0) {
	                return this._sectors;
	            }

	            this.prepareBoundaries(dc);

	            return this._sectors;
	        };

	        // Internal function. Intentionally not documented.
	        SurfaceShape.prototype.prepareSectors = function() {
	            var boundaries = this._boundaries;
	            if (!boundaries) {
	                return;
	            }

	            this._sector = new Sector(-90, 90, -180, 180);
	            this._sector.setToBoundingSector(boundaries);

	            var pole = this.containsPole(boundaries);
	            if (pole != Location.poles.NONE) {
	                // If the shape contains a pole, then the bounding sector is defined by the shape's extreme latitude, the
	                // latitude of the pole, and the full range of longitude.
	                if (pole == Location.poles.NORTH) {
	                    this._sector = new Sector(this._sector.minLatitude, 90, -180, 180);
	                }
	                else {
	                    this._sector = new Sector(-90, this._sector.maxLatitude, -180, 180);
	                }

	                this._sectors = [this._sector];
	            }
	            else if (Location.locationsCrossDateLine(boundaries)) {
	                this._sectors = Sector.splitBoundingSectors(boundaries);
	            }
	            else {
	                 if (!this._sector.isEmpty()) {
	                    this._sectors = [this._sector];
	                }
	            }

	            if (!this._sectors) {
	                return;
	            }

	            // Great circle paths between two latitudes may result in a latitude which is greater or smaller than either of
	            // the two latitudes. All other path types are bounded by the defining locations.
	            if (this._pathType === WorldWind.GREAT_CIRCLE) {
	                for (var idx = 0, len = this._sectors.length; idx < len; idx += 1) {
	                    var sector = this._sectors[idx];

	                    var extremes = Location.greatCircleArcExtremeLocations(boundaries);

	                    var minLatitude = Math.min(sector.minLatitude, extremes[0].latitude);
	                    var maxLatitude = Math.max(sector.maxLatitude, extremes[1].latitude);

	                    this._sectors[idx] = new Sector(minLatitude, maxLatitude, sector.minLongitude, sector.maxLongitude);
	                }
	            }
	        };

	        // Internal function. Intentionally not documented.
	        SurfaceShape.prototype.prepareGeometry = function(dc) {
	            var datelineLocations;

	            this._interiorGeometry = [];
	            this._outlineGeometry = [];

	            var locations = this._locations;

	            var pole = this.containsPole(locations);
	            if (pole != Location.poles.NONE) {
	                // Wrap the shape interior around the pole and along the anti-meridian. See WWJ-284.
	                var poleLocations = this.cutAlongDateLine(locations, pole, dc.globe);
	                this._interiorGeometry.push(poleLocations);

	                // The outline need only compensate for dateline crossing. See WWJ-452.
	                datelineLocations = this.repeatAroundDateline(locations);
	                this._outlineGeometry.push(datelineLocations[0]);
	                if (datelineLocations.length > 1) {
	                    this._outlineGeometry.push(datelineLocations[1]);
	                }
	            }
	            else if (Location.locationsCrossDateLine(locations)) {
	                datelineLocations = this.repeatAroundDateline(locations);
	                this._interiorGeometry.push(datelineLocations[0]); //this._interiorGeometry.addAll(datelineLocations);
	                this._interiorGeometry.push(datelineLocations[1]); //this._interiorGeometry.addAll(datelineLocations);
	                this._outlineGeometry.push(datelineLocations[0]); //this._outlineGeometry.addAll(datelineLocations);
	                this._outlineGeometry.push(datelineLocations[1]); //this._outlineGeometry.addAll(datelineLocations);
	            }
	            else {
	                this._interiorGeometry.push(locations);
	                this._outlineGeometry.push(locations);
	            }
	        };

	        /**
	         * Determine if a list of geographic locations encloses either the North or South pole. The list is treated as a
	         * closed loop. (If the first and last positions are not equal the loop will be closed for purposes of this
	         * computation.)
	         *
	         * @param {Location[]} locations Locations to test.
	         *
	         * @return {Number} Location.poles.NORTH if the North Pole is enclosed,
	         *                  Location.poles.SOUTH if the South Pole is enclosed, or
	         *                  Location.poles.NONE if neither pole is enclosed.
	         *                  Always returns Location.poles.NONE if {@link #canContainPole()} returns false.
	         *
	         * TODO: handle a shape that contains both poles.
	         */
	        SurfaceShape.prototype.containsPole = function(locations) {
	            // Determine how many times the path crosses the date line. Shapes that include a pole will cross an odd number of times.
	            var containsPole = false;

	            var minLatitude = 90.0;
	            var maxLatitude = -90.0;

	            var prev = locations[0];
	            for (var idx = 1, len = locations.length; idx < len; idx += 1) {
	                var next = locations[idx];

	                if (Location.locationsCrossDateLine([prev, next])) {
	                    containsPole = !containsPole;
	                }

	                minLatitude = Math.min(minLatitude, next.latitude);
	                maxLatitude = Math.max(maxLatitude, next.latitude);

	                prev = next;
	            }

	            // Close the loop by connecting the last position to the first. If the loop is already closed then the following
	            // test will always fail, and will not affect the result.
	            var first = locations[0];
	            if (Location.locationsCrossDateLine([first, prev])) {
	                containsPole = !containsPole;
	            }

	            if (!containsPole) {
	                return Location.poles.NONE;
	            }

	            // Determine which pole is enclosed. If the shape is entirely in one hemisphere, then assume that it encloses
	            // the pole in that hemisphere. Otherwise, assume that it encloses the pole that is closest to the shape's
	            // extreme latitude.
	            if (minLatitude > 0) {
	                return Location.poles.NORTH; // Entirely in Northern Hemisphere.
	            }
	            else if (maxLatitude < 0) {
	                return Location.poles.SOUTH; // Entirely in Southern Hemisphere.
	            }
	            else if (Math.abs(maxLatitude) >= Math.abs(minLatitude)) {
	                return Location.poles.NORTH; // Spans equator, but more north than south.
	            }
	            else {
	                return Location.poles.SOUTH; // Spans equator, but more south than north.
	            }
	        };

	        /**
	         * Divide a list of locations that encloses a pole along the international date line. This method determines where
	         * the locations cross the date line, and inserts locations to the pole, and then back to the intersection position.
	         * This allows the shape to be "unrolled" when projected in a lat-lon projection.
	         *
	         * @param {Location[]} locations    Locations to cut at date line. This list is not modified.
	         * @param {Number} pole             Pole contained by locations, either AVKey.NORTH or AVKey.SOUTH.
	         * @param {Globe} globe             Current globe.
	         *
	         * @return {Location[]} New location list with locations added to correctly handle date line intersection.
	         */
	        SurfaceShape.prototype.cutAlongDateLine = function(locations, pole, globe)
	        {
	            // If the locations do not contain a pole, then there's nothing to do.
	            if (pole == Location.poles.NONE) {
	                return locations;
	            }

	            var newLocations = [];

	            var poleLat = pole == Location.poles.NORTH ? 90 : -90;

	            var prev = locations[locations.length - 1];
	            for (var idx = 0, len = locations.length; idx < len; idx += 1) {
	                var next = locations[idx];

	                newLocations.push(prev);
	                if (Location.locationsCrossDateLine([prev, next])) {
	                    // Determine where the segment crosses the date line.
	                    var latitude = Location.intersectionWithMeridian(prev, next, 180, globe);
	                    var sign = WWMath.signum(prev.longitude);

	                    var lat = latitude;
	                    var thisSideLon = 180 * sign;
	                    var otherSideLon = -thisSideLon;

	                    // Add locations that run from the intersection to the pole, then back to the intersection. Note
	                    // that the longitude changes sign when the path returns from the pole.
	                    //         . Pole
	                    //      2 ^ | 3
	                    //        | |
	                    //      1 | v 4
	                    // --->---- ------>
	                    newLocations.push(new Location(lat, thisSideLon));
	                    newLocations.push(new Location(poleLat, thisSideLon));
	                    newLocations.push(new Location(poleLat, otherSideLon));
	                    newLocations.push(new Location(lat, otherSideLon));
	                }

	                prev = next;
	            }
	            newLocations.push(prev);

	            return newLocations;
	        };

	        /**
	         * Returns a list containing two copies of the specified list of locations crossing the dateline: one that extends
	         * across the -180 longitude  boundary and one that extends across the +180 longitude boundary. If the list of
	         * locations does not cross the dateline this returns a list containing a copy of the original list.
	         *
	         * @param {Location[]} locations Locations to repeat. This is list not modified.
	         *
	         * @return {Location[][]} A list containing two new location lists, one copy for either side of the date line.
	         */
	        SurfaceShape.prototype.repeatAroundDateline = function(locations) {
	            var lonOffset = 0,
	                applyLonOffset = false;

	            var newLocations = [];

	            var prev= locations[0];
	            newLocations.push(prev);
	            for (var idx = 1, len = locations.length; idx < len; idx += 1) {
	                var next = locations[idx];

	                if (Location.locationsCrossDateLine([prev, next])) {
	                    if (lonOffset == 0) {
	                        lonOffset = prev.longitude < 0 ? -360 : 360;
	                    }

	                    applyLonOffset = !applyLonOffset;
	                }

	                if (applyLonOffset) {
	                    newLocations.push(new Location(next.latitude, next.longitude + lonOffset));
	                }
	                else {
	                    newLocations.push(next);
	                }

	                prev = next;
	            }

	            var locationGroup = [newLocations];

	            if (lonOffset != 0) {
	                var oldLocations = newLocations;
	                newLocations = [];

	                for (idx = 0, len = oldLocations.length; idx < len; idx += 1) {
	                    var cur = oldLocations[idx];

	                    newLocations.push(new Location(cur.latitude, cur.longitude - lonOffset));
	                }

	                locationGroup.push(newLocations);
	            }

	            return locationGroup;
	        };

	        // Internal use only. Intentionally not documented.
	        SurfaceShape.prototype.resetPickColor = function() {
	            this.pickColor = null;
	        };

	        /**
	         * Internal use only.
	         * Render the shape onto the texture map of the tile.
	         * @param {DrawContext} dc The draw context to render onto.
	         * @param {CanvasRenderingContext2D} ctx2D The rendering context for SVG.
	         * @param {Number} xScale The multiplicative scale factor in the horizontal direction.
	         * @param {Number} yScale The multiplicative scale factor in the vertical direction.
	         * @param {Number} dx The additive offset in the horizontal direction.
	         * @param {Number} dy The additive offset in the vertical direction.
	         */
	        SurfaceShape.prototype.renderToTexture = function(dc, ctx2D, xScale, yScale, dx, dy) {
	            var idx,
	                len,
	                path = [],
	                idxPath,
	                lenPath,
	                isPicking = dc.pickingMode,
	                attributes = (this._highlighted ? (this._highlightAttributes || this._attributes) : this._attributes);

	            if (isPicking && !this.pickColor) {
	                this.pickColor = dc.uniquePickColor();
	            }

	            // Fill the interior of the shape.
	            if (!this._isInteriorInhibited && attributes.drawInterior) {
	                ctx2D.fillStyle = isPicking ? this.pickColor.toRGBAString() : attributes.interiorColor.toRGBAString();

	                for (idx = 0, len = this._interiorGeometry.length; idx < len; idx += 1) {
	                    idxPath = 0;
	                    lenPath = this._outlineGeometry[idx].length * 2;
	                    path.splice(0, path.length);

	                    // Convert the geometry to a transformed path that can be drawn directly, and as a side effect,
	                    // detect if the path is smaller than a pixel. If it is, don't bother drawing it.
	                    if (this.transformPath(this._interiorGeometry[idx], xScale, yScale, dx, dy, path)) {
	                        ctx2D.beginPath();

	                        ctx2D.moveTo(path[idxPath++], path[idxPath++]);

	                        while (idxPath < lenPath) {
	                            ctx2D.lineTo(path[idxPath++], path[idxPath++]);
	                        }

	                        ctx2D.closePath();

	                        ctx2D.fill();
	                    }
	                }
	            }

	            // Draw the outline of the shape.
	            if (attributes.drawOutline && attributes.outlineWidth > 0) {
	                ctx2D.lineWidth = 4 * attributes.outlineWidth;
	                ctx2D.strokeStyle = isPicking ? this.pickColor.toRGBAString() : attributes.outlineColor.toRGBAString();

	                var pattern = this._attributes.outlineStipplePattern,
	                    factor = this._attributes.outlineStippleFactor;

	                for (idx = 0, len = this._outlineGeometry.length; idx < len; idx += 1) {
	                    path.splice(0, path.length);

	                    // Convert the geometry to a transformed path that can be drawn directly, and as a side effect,
	                    // detect if the path is smaller than a pixel. If it is, don't bother drawing it.
	                    if (this.transformPath(this._outlineGeometry[idx], xScale, yScale, dx, dy, path)) {
	                        // NOTE: this code used to be written as:
	                        //      a single beginPath() call,
	                        //      followed by a single moveTo() call,
	                        //      followed by as many lineTo() calls as there were vertices remaining in the path,
	                        //      followed by a stroke().
	                        // Performance was BAD!
	                        // The code was rewritten this way and it doesn't have any performance issues.
	                        // That shouldn't be the case, but it is.
	                        var xFirst = path[0],
	                            yFirst = path[1],
	                            xPrev = xFirst,
	                            yPrev = yFirst,
	                            xNext = xFirst,
	                            yNext = yFirst,
	                            isPrevFirst = true,
	                            isNextFirst = true,
	                            countFirst = 0;

	                        for (idxPath = 2, lenPath = path.length; idxPath < lenPath; ) {
	                            // Remember the previous point in the path.
	                            xPrev = xNext;
	                            yPrev = yNext;
	                            isPrevFirst = isNextFirst;

	                            // Extract the next point in the path.
	                            xNext = path[idxPath++];
	                            yNext = path[idxPath++];

	                            isNextFirst = xNext == xFirst && yNext == yFirst;

	                            // Avoid drawing virtual edges that reconnect to the first point
	                            // when drawing multiply connected domains.
	                            if (isPrevFirst || isNextFirst) {
	                                countFirst += 1;

	                                if (countFirst > 2) {
	                                    continue;
	                                }
	                            }

	                            // Draw the path one line segment at a time.
	                            ctx2D.beginPath();
	                            ctx2D.moveTo(xPrev, yPrev);

	                            ctx2D.lineTo(xNext, yNext);

	                            ctx2D.stroke();
	                        }
	                    }
	                }
	            }

	            if (isPicking) {
	                var po = new PickedObject(this.pickColor.clone(), this.pickDelegate ? this.pickDelegate : this,
	                    null, this.layer, false);
	                dc.resolvePick(po);
	            }
	        };

	        //
	        // Internal use only.
	        // Transform a path and compute its extrema.
	        // In the process of transforming it, optimize out line segments that are too short (shorter than some threshold).
	        // Return an indicator of the path is "big enough".
	        SurfaceShape.prototype.transformPath = function(path, xScale, yScale, xOffset, yOffset, result) {
	            var xPrev, yPrev,
	                xNext, yNext,
	                xFirst, yFirst,
	                xLast, yLast,
	                xMin, yMin,
	                xMax, yMax,
	                dx, dy, dr2,
	                dr2Min = 4, // Squared length of minimum length line that must be drawn.
	                isNextFirst,
	                location, idxResult, idxPath, lenPath;

	            idxResult = 0;

	            location = path[0];

	            xFirst = location.longitude * xScale + xOffset;
	            yFirst = location.latitude * yScale + yOffset;

	            isNextFirst = true;

	            xMin = xMax = xPrev = xNext = xFirst;
	            yMin = yMax = yPrev = yNext = yFirst;

	            result[idxResult++] = xNext;
	            result[idxResult++] = yNext;

	            for (idxPath = 1, lenPath = path.length; idxPath < lenPath; idxPath += 1) {
	                location = path[idxPath];

	                // Capture the last point even it it was optimized out.
	                xLast = xNext;
	                yLast = yNext;

	                xNext = location.longitude * xScale + xOffset;
	                yNext = location.latitude * yScale + yOffset;

	                // Detect whether the next point is the same as the first point.
	                isNextFirst = (xNext == xFirst) && (yNext == yFirst);

	                // Compute the length from the previous point that was emitted to the next point.
	                dx = xNext - xPrev;
	                dy = yNext - yPrev;
	                dr2 = dx * dx + dy * dy;

	                // If the line is smaller than a single pixel, accumulate more data before emitting,
	                // unless the point is the same as the first point, in which case it is always emitted.
	                if (isNextFirst || dr2 >= dr2Min) {
	                    xMin = Math.min(xMin, xNext);
	                    xMax = Math.max(xMax, xNext);
	                    yMin = Math.min(yMin, yNext);
	                    yMax = Math.max(yMax, yNext);

	                    // If the last point was optimized out because the line it contributed to was too short,
	                    // force it to be emitted.
	                    if (result[idxResult - 2] != xLast || result[idxResult - 1] != yLast) {
	                        result[idxResult++] = xLast;
	                        result[idxResult++] = yLast;
	                    }

	                    result[idxResult++] = xNext;
	                    result[idxResult++] = yNext;

	                    xPrev = xNext;
	                    yPrev = yNext;
	                }
	            }

	            return (xMax - xMin) >= 2 || (yMax - yMin) >= 2;
	        };

	        /**
	         * Default value for the maximum number of edge intervals. This results in a maximum error of 480 m for an arc
	         * that spans the entire globe.
	         *
	         * Other values for this parameter have the associated errors below:
	         * Intervals        Maximum error (meters)
	         *      2           1280253.5
	         *      4           448124.5
	         *      8           120837.6
	         *      16          30628.3
	         *      32          7677.9
	         *      64          1920.6
	         *      128         480.2
	         *      256         120.0
	         *      512         30.0
	         *      1024        7.5
	         *      2048        1.8
	         * The errors cited above are upper bounds and the actual error may be lower.
	         * @type {Number}
	         */
	        SurfaceShape.DEFAULT_NUM_EDGE_INTERVALS = 128;

	        /**
	         * The defualt value for the polar throttle, which slows edge traversal near the poles.
	         * @type {Number}
	         */
	        SurfaceShape.DEFAULT_POLAR_THROTTLE = 10;

	        return SurfaceShape;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports ShapeAttributes
	 * @version $Id: ShapeAttributes.js 3270 2015-06-26 01:09:56Z tgaskins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(52),
	        __webpack_require__(51)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Color,
	              ImageSource) {
	        "use strict";

	        /**
	         * Constructs a shape attributes bundle, optionally specifying a prototype set of attributes. Not all shapes
	         * use all the properties in the bundle. See the documentation of a specific shape to determine the properties
	         * it does use.
	         * @alias ShapeAttributes
	         * @constructor
	         * @classdesc Holds attributes applied to World Wind shapes.
	         * @param {ShapeAttributes} attributes An attribute bundle whose properties are used to initially populate
	         * the constructed attributes bundle. May be null, in which case the constructed attributes bundle is populated
	         * with default attributes.
	         */
	        var ShapeAttributes = function (attributes) {

	            // All these are documented with their property accessors below.
	            this._drawInterior = attributes ? attributes._drawInterior : true;
	            this._drawOutline = attributes ? attributes._drawOutline : true;
	            this._enableLighting = attributes ? attributes._enableLighting : false;
	            this._interiorColor = attributes ? attributes._interiorColor : Color.WHITE;
	            this._outlineColor = attributes ? attributes._outlineColor : Color.RED;
	            this._outlineWidth = attributes ? attributes._outlineWidth : 1.0;
	            this._outlineStippleFactor = attributes ? attributes._outlineStippleFactor : 0;
	            this._outlineStipplePattern = attributes ? attributes._outlineStipplePattern : 0xF0F0;
	            this._imageSource = attributes ? attributes._imageSource : null;
	            this._depthTest = attributes ? attributes._depthTest : true;
	            this._drawVerticals = attributes ? attributes._drawVerticals : false;
	            this._applyLighting = attributes ? attributes._applyLighting : false;

	            /**
	             * Indicates whether this object's state key is invalid. Subclasses must set this value to true when their
	             * attributes change. The state key will be automatically computed the next time it's requested. This flag
	             * will be set to false when that occurs.
	             * @type {Boolean}
	             * @protected
	             */
	            this.stateKeyInvalid = true;
	        };

	        /**
	         * Computes the state key for this attributes object. Subclasses that define additional attributes must
	         * override this method, call it from that method, and append the state of their attributes to its
	         * return value.
	         * @returns {String} The state key for this object.
	         * @protected
	         */
	        ShapeAttributes.prototype.computeStateKey = function () {
	            return "di " + this._drawInterior +
	                  " do " + this._drawOutline +
	                  " el " + this._enableLighting +
	                  " ic " + this._interiorColor.toHexString(true) +
	                  " oc " + this._outlineColor.toHexString(true) +
	                  " ow " + this._outlineWidth +
	                  " osf " + this._outlineStippleFactor +
	                  " osp " + this._outlineStipplePattern +
	                  " is " + (this._imageSource ?
	                        (this.imageSource instanceof ImageSource ? this.imageSource.key : this.imageSource) : "null") +
	                  " dt " + this._depthTest +
	                  " dv " + this._drawVerticals +
	                  " li " + this._applyLighting;
	        };

	        Object.defineProperties(ShapeAttributes.prototype, {
	            /**
	             * A string identifying the state of this attributes object. The string encodes the current values of all
	             * this object's properties. It's typically used to validate cached representations of shapes associated
	             * with this attributes object.
	             * @type {String}
	             * @readonly
	             * @memberof ShapeAttributes.prototype
	             */
	            stateKey: {
	                get: function () {
	                    if (this.stateKeyInvalid) {
	                        this._stateKey = this.computeStateKey();
	                        this.stateKeyInvalid = false;
	                    }
	                    return this._stateKey;
	                }
	            },

	            /**
	             * Indicates whether the interior of the associated shape is drawn.
	             * @type {Boolean}
	             * @default true
	             * @memberof ShapeAttributes.prototype
	             */
	            drawInterior: {
	                get: function () {
	                    return this._drawInterior;
	                },
	                set: function (value) {
	                    this._drawInterior = value;
	                    this.stateKeyInvalid = true;
	                }
	            },

	            /**
	             * Indicates whether the outline of the associated shape is drawn
	             * @type {Boolean}
	             * @default true
	             * @memberof ShapeAttributes.prototype
	             */
	            drawOutline: {
	                get: function () {
	                    return this._drawOutline;
	                },
	                set: function (value) {
	                    this._drawOutline = value;
	                    this.stateKeyInvalid = true;
	                }
	            },

	            /**
	             * Indicates whether lighting is applied to the associated shape.
	             * @type {Boolean}
	             * @default false
	             * @memberof ShapeAttributes.prototype
	             */
	            enableLighting: {
	                get: function () {
	                    return this._enableLighting;
	                },
	                set: function (value) {
	                    this._enableLighting = value;
	                    this.stateKeyInvalid = true;
	                }
	            },

	            /**
	             * Indicates the associated shape's interior color and opacity.
	             * @type {Color}
	             * @default Opaque white (red = 1, green = 1, blue = 1, alpha = 1)
	             * @memberof ShapeAttributes.prototype
	             */
	            interiorColor: {
	                get: function () {
	                    return this._interiorColor;
	                },
	                set: function (value) {
	                    this._interiorColor = value;
	                    this.stateKeyInvalid = true;
	                }
	            },

	            /**
	             * Indicates the associated shape's outline color and opacity.
	             * @type {Color}
	             * @default Opaque red (red = 1, green = 0, blue = 0, alpha = 1)
	             * @memberof ShapeAttributes.prototype
	             */
	            outlineColor: {
	                get: function () {
	                    return this._outlineColor;
	                },
	                set: function (value) {
	                    this._outlineColor = value;
	                    this.stateKeyInvalid = true;
	                }
	            },

	            /**
	             * Indicates the associated shape's outline width.
	             * @type {Number}
	             * @default 1.0
	             * @memberof ShapeAttributes.prototype
	             */
	            outlineWidth: {
	                get: function () {
	                    return this._outlineWidth;
	                },
	                set: function (value) {
	                    this._outlineWidth = value;
	                    this.stateKeyInvalid = true;
	                }
	            },

	            /**
	             * Indicates the associated shape's outline stipple pattern. Specifies a number whose lower 16 bits
	             * define a pattern of which pixels in the outline are rendered and which are suppressed. Each bit
	             * corresponds to a pixel in the shape's outline, and the pattern repeats after every n*16 pixels, where
	             * n is the [stipple factor]{@link ShapeAttributes#outlineStippleFactor}. For example, if the outline
	             * stipple factor is 3, each bit in the stipple pattern is repeated three times before using the next bit.
	             * <p>
	             * To disable outline stippling, either specify a stipple factor of 0 or specify a stipple pattern of
	             * all 1 bits, i.e., 0xFFFF.
	             * @type {Number}
	             * @default 0xF0F0
	             * @memberof ShapeAttributes.prototype
	             */
	            outlineStipplePattern: {
	                get: function () {
	                    return this._outlineStipplePattern;
	                },
	                set: function (value) {
	                    this._outlineStipplePattern = value;
	                    this.stateKeyInvalid = true;
	                }
	            },

	            /**
	             * Indicates the associated shape's outline stipple factor. Specifies the number of times each bit in the
	             * outline stipple pattern is repeated before the next bit is used. For example, if the outline stipple
	             * factor is 3, each bit is repeated three times before using the next bit. The specified factor must be
	             * either 0 or an integer greater than 0. A stipple factor of 0 indicates no stippling.
	             * @type {Number}
	             * @default 0
	             * @memberof ShapeAttributes.prototype
	             */
	            outlineStippleFactor: {
	                get: function () {
	                    return this._outlineStippleFactor;
	                },
	                set: function (value) {
	                    this._outlineStippleFactor = value;
	                    this.stateKeyInvalid = true;
	                }
	            },

	            /**
	             * Indicates the associated shape's image source. May be null, in which case no image is
	             * applied to the shape.
	             * @type {String|ImageSource}
	             * @memberof ShapeAttributes.prototype
	             * @default null
	             */
	            imageSource: {
	                get: function () {
	                    return this._imageSource;
	                },
	                set: function (value) {
	                    this._imageSource = value;
	                    this.stateKeyInvalid = true;
	                }
	            },

	            /**
	             * Indicates whether the shape should be depth-tested against other objects in the scene. If true,
	             * the shape may be occluded by terrain and other objects in certain viewing situations. If false,
	             * the shape will not be occluded by terrain and other objects.
	             * @type {Boolean}
	             * @default true
	             * @memberof ShapeAttributes.prototype
	             */
	            depthTest: {
	                get: function () {
	                    return this._depthTest;
	                },
	                set: function (value) {
	                    this._depthTest = value;
	                    this.stateKeyInvalid = true;
	                }
	            },

	            /**
	             * Indicates whether this shape should draw vertical lines extending from its specified positions to the
	             * ground.
	             * @type {Boolean}
	             * @default false
	             * @memberof ShapeAttributes.prototype
	             */
	            drawVerticals: {
	                get: function () {
	                    return this._drawVerticals;
	                },
	                set: function (value) {
	                    this._drawVerticals = value;
	                    this.stateKeyInvalid = true;
	                }
	            },

	            /**
	             * Indicates whether lighting is applied to the shape.
	             * @type {Boolean}
	             * @default false
	             * @memberof ShapeAttributes.prototype
	             */
	            applyLighting: {
	                get: function () {
	                    return this._applyLighting;
	                },
	                set: function (value) {
	                    this._applyLighting = value;
	                    this.stateKeyInvalid = true;
	                }
	            }
	        });

	        return ShapeAttributes;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
	;

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports SurfaceShapeTileBuilder
	 * @version $Id: SurfaceShapeTileBuilder.js 3048 2015-04-23 23:26:47Z danm $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(30),
	        __webpack_require__(121),
	        __webpack_require__(113),
	        __webpack_require__(81),
	        __webpack_require__(74),
	        __webpack_require__(100),
	        __webpack_require__(28),
	        __webpack_require__(32),
	        __webpack_require__(63),
	        __webpack_require__(53),
	        __webpack_require__(65),
	        __webpack_require__(79),
	        __webpack_require__(87),
	        __webpack_require__(37),
	        __webpack_require__(75),
	        __webpack_require__(131),
	        __webpack_require__(73),
	        __webpack_require__(115),
	        __webpack_require__(116),
	        __webpack_require__(117),
	        __webpack_require__(76),
	        __webpack_require__(77)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
	              DrawContext,
	              Globe,
	              GpuProgram,
	              Level,
	              LevelSet,
	              Location,
	              Logger,
	              Matrix,
	              MemoryCache,
	              NavigatorState,
	              NotYetImplementedError,
	              PickedObject,
	              Rectangle,
	              Sector,
	              SurfaceShape,
	              SurfaceShapeTile,
	              Terrain,
	              TerrainTile,
	              TerrainTileList,
	              TextureTile,
	              Tile) {
	        "use strict";

	        var SurfaceShapeTileBuilder = function() {
	            // Parameterize top level subdivision in one place.

	            // TilesInTopLevel describes the most coarse tile structure.
	            this.numRowsTilesInTopLevel = 4;
	            this.numColumnsTilesInTopLevel = 8;

	            // The maximum number of levels that will ever be tessellated.
	            this.maximumSubdivisionDepth = 15;

	            // tileWidth, tileHeight - the number of subdivisions a single tile has; this determines the sampling grid.
	            this.tileWidth = 256;
	            this.tileHeight = 256;

	            /**
	             * The collection of levels.
	             * @type {LevelSet}
	             */
	            this.levels = new LevelSet(
	                Sector.FULL_SPHERE,
	                new Location(
	                    180 / this.numRowsTilesInTopLevel,
	                    360 / this.numColumnsTilesInTopLevel),
	                this.maximumSubdivisionDepth,
	                this.tileWidth,
	                this.tileHeight);

	            /**
	             * The collection of surface shapes processed by this class.
	             * @type {SurfaceShape[]}
	             */
	            this.surfaceShapes = [];

	            /**
	             * The collection of surface shape tiles that actually contain surface shapes.
	             * @type {SurfaceShapeTile[]}
	             */
	            this.surfaceShapeTiles = [];

	            /**
	             * The collection of top level surface shape tiles, from which actual tiles are derived.
	             * @type {SurfaceShapeTile[]}
	             */
	            this.topLevelTiles = [];

	            /**
	             * Accumulator of all sectors for surface shapes
	             * @type {Sector}
	             */
	            this.sector = new Sector(-90, 90, -180, 180);

	            /**
	             * The default split scale. The split scale 2.9 has been empirically determined to render sharp lines and edges with
	             * the SurfaceShapes such as SurfacePolyline and SurfacePolygon.
	             *
	             * @type {Number}
	             */
	            this.detailControl = 1.25;

	            // Internal use only. Intentionally not documented.
	            this.tileCache = new MemoryCache(500000, 400000);
	        };

	        /**
	         * Clear all transient state from the surface shape tile builder.
	         */
	        SurfaceShapeTileBuilder.prototype.clear = function() {
	            this.surfaceShapeTiles.splice(0, this.surfaceShapeTiles.length);
	            this.surfaceShapes.splice(0, this.surfaceShapes.length);
	        };

	        /**
	         * Insert a surface shape to be rendered into the surface shape tile builder.
	         * 
	         * @param {SurfaceShape} surfaceShape A surfave shape to be processed.
	         */
	        SurfaceShapeTileBuilder.prototype.insertSurfaceShape = function(surfaceShape) {
	            this.surfaceShapes.push(surfaceShape);
	        };

	        /**
	         * Perform the rendering of any accumulated surface shapes by building the surface shape tiles that contain these
	         * shapes and then rendering those tiles.
	         * 
	         * @param {DrawContext} dc The drawing context.
	         */
	        SurfaceShapeTileBuilder.prototype.doRender = function(dc) {
	            if (dc.pickingMode) {
	                // Picking rendering strategy:
	                //  1) save all tiles created prior to picking,
	                //  2) construct and render new tiles with pick-based contents (colored with pick IDs),
	                //  3) restore all prior tiles.
	                // This has a big potential win for normal rendering, since there is a lot of coherence
	                // from frame to frame if no picking is occurring.
	                for (var idx = 0, len = this.surfaceShapes.length; idx < len; idx += 1) {
	                    this.surfaceShapes[idx].resetPickColor();
	                }

	                SurfaceShapeTileBuilder.pickSequence += 1;

	                var savedTiles = this.surfaceShapeTiles;
	                var savedTopLevelTiles = this.topLevelTiles;

	                this.surfaceShapeTiles = [];
	                this.topLevelTiles = [];

	                this.buildTiles(dc);

	                if (dc.deepPicking) {
	                    // Normally, we render all shapes together in one tile (or a small number, but this detail
	                    // doesn't matter). For deep picking, we need to render each shape individually.
	                    this.doDeepPickingRender(dc);

	                } else {
	                    dc.surfaceTileRenderer.renderTiles(dc, this.surfaceShapeTiles, 1);
	                }

	                this.surfaceShapeTiles = savedTiles;
	                this.topLevelTiles = savedTopLevelTiles;
	            } else {
	                this.buildTiles(dc);

	                dc.surfaceTileRenderer.renderTiles(dc, this.surfaceShapeTiles, 1);
	            }
	        };

	        SurfaceShapeTileBuilder.prototype.doDeepPickingRender = function (dc) {
	            var idxTile, lenTiles, idxShape, lenShapes, idxPick, lenPicks, po, shape, tile;

	            // Determine the shapes that were drawn during buildTiles. These shapes may not actually be
	            // at the pick point, but they are candidates for deep picking.
	            var deepPickShapes = [];
	            for (idxPick = 0, lenPicks = dc.objectsAtPickPoint.objects.length; idxPick < lenPicks; idxPick += 1) {
	                po = dc.objectsAtPickPoint.objects[idxPick];
	                if (po.userObject instanceof SurfaceShape) {
	                    shape = po.userObject;

	                    // If the shape was not already in the collection of deep picked shapes, ...
	                    if (deepPickShapes.indexOf(shape) < 0) {
	                        deepPickShapes.push(shape);

	                        // Delete the shape that was drawn during buildTiles from the pick list.
	                        dc.objectsAtPickPoint.objects.splice(idxPick, 1);

	                        // Update the index and length to reflect the deletion.
	                        idxPick -= 1;
	                        lenPicks -= 1;
	                    }
	                }
	            }

	            if (deepPickShapes.length <= 0) {
	                return;
	            }

	            // For all shapes,
	            //  1) force that shape to be the only shape in a tile,
	            //  2) re-render the tile, and
	            //  3) use the surfaceTileRenderer to render the tile on the terrain,
	            //  4) read the color to see if it is attributable to the current shape.
	            var resolvablePickObjects = [];
	            for (idxShape = 0, lenShapes = deepPickShapes.length; idxShape < lenShapes; idxShape += 1) {
	                shape = deepPickShapes[idxShape];
	                for (idxTile = 0, lenTiles = this.surfaceShapeTiles.length; idxTile < lenTiles; idxTile += 1) {
	                    tile = this.surfaceShapeTiles[idxTile];
	                    tile.setShapes([shape]);
	                    tile.updateTexture(dc);
	                }

	                dc.surfaceTileRenderer.renderTiles(dc, this.surfaceShapeTiles, 1);

	                var pickColor = dc.readPickColor(dc.pickPoint);
	                if (!!pickColor && shape.pickColor.equals(pickColor)) {
	                    po = new PickedObject(shape.pickColor.clone(),
	                        shape.pickDelegate ? shape.pickDelegate : shape, null, shape.layer, false);
	                    resolvablePickObjects.push(po);
	                }
	            }

	            // Flush surface shapes that have accumulated in the updateTexture pass just completed on all shapes.
	            for (idxPick = 0, lenPicks = dc.objectsAtPickPoint.objects.length; idxPick < lenPicks; idxPick += 1) {
	                po = dc.objectsAtPickPoint.objects[idxPick];
	                if (po.userObject instanceof SurfaceShape) {
	                    // Delete the shape that was picked in the most recent pass.
	                    dc.objectsAtPickPoint.objects.splice(idxPick, 1);

	                    // Update the index and length to reflect the deletion.
	                    idxPick -= 1;
	                    lenPicks -= 1;
	                }
	            }

	            // Add the resolvable pick objects for surface shapes that were actually visible at the pick point
	            // to the pick list.
	            for (idxPick = 0, lenPicks = resolvablePickObjects.length; idxPick < lenPicks; idxPick += 1) {
	                po = resolvablePickObjects[idxPick];
	                dc.objectsAtPickPoint.objects.push(po);
	            }
	        };

	        /**
	         * Assembles the surface tiles and draws any surface shapes that have been accumulated into those offscreen tiles. The
	         * surface tiles are assembled to meet the necessary resolution of to the draw context's. 
	         * <p/>
	         * This does nothing if there are no surface shapes associated with this builder.
	         *
	         * @param {DrawContext} dc The draw context to build tiles for.
	         *
	         * @throws {ArgumentError} If the draw context is null.
	         */
	        SurfaceShapeTileBuilder.prototype.buildTiles = function(dc) {
	            if (!dc) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "SurfaceShapeTileBuilder", "buildTiles", "missingDc"));
	            }

	            if (!this.surfaceShapes || this.surfaceShapes.length < 1) {
	                return;
	            }

	            // Assemble the current visible tiles and update their associated textures if necessary.
	            this.assembleTiles(dc);

	            // Clean up references to all surface shapes to avoid dangling references. The surface shape list is no
	            // longer needed, now that the shapes are held by each tile.
	            this.surfaceShapes.splice(0, this.surfaceShapes.length);
	            for (var idx = 0, len = this.surfaceShapeTiles.length; idx < len; idx += 1) {
	                var tile = this.surfaceShapeTiles[idx];
	                tile.clearShapes();
	            }
	        };

	        /**
	         * Assembles a set of surface tiles that are visible in the specified DrawContext and meet the tile builder's
	         * resolution criteria. Tiles are culled against the current surface shape list, against the DrawContext's view
	         * frustum during rendering mode, and against the DrawContext's pick frustums during picking mode. If a tile does
	         * not meet the tile builder's resolution criteria, it's split into four sub-tiles and the process recursively
	         * repeated on the sub-tiles.
	         * <p/>
	         * During assembly, each surface shape in {@link #surfaceShapes} is sorted into the tiles they
	         * intersect. The top level tiles are used as an index to quickly determine which tiles each shape intersects.
	         * Surface shapes are sorted into sub-tiles by simple intersection tests, and are added to each tile's surface
	         * renderable list at most once. See {@link SurfaceShapeTileBuilder.SurfaceShapeTile#addSurfaceShape(SurfaceShape,
	         * gov.nasa.worldwind.geom.Sector)}. Tiles that don't intersect any surface shapes are discarded.
	         *
	         * @param {DrawContext} dc The DrawContext to assemble tiles for.
	         */
	        SurfaceShapeTileBuilder.prototype.assembleTiles = function(dc) {
	            var tile, idxShape, lenShapes, idxTile, lenTiles, idxSector, lenSectors;

	            // Create a set of top level tiles only if that set doesn't exist yet.
	            if (this.topLevelTiles.length < 1) {
	                this.createTopLevelTiles();
	            }

	            // Store the top level tiles in a set to ensure that each top level tile is added only once. Store the tiles
	            // that intersect each surface shape in a set to ensure that each object is added to a tile at most once.
	            var intersectingTiles = {};

	            // Iterate over the current surface shapes, adding each surface shape to the top level tiles that it
	            // intersects. This produces a set of top level tiles containing the surface shapes that intersect each
	            // tile. We use the tile structure as an index to quickly determine the tiles a surface shape intersects,
	            // and add object to those tiles. This has the effect of quickly sorting the objects into the top level tiles.
	            // We collect the top level tiles in a HashSet to ensure there are no duplicates when multiple objects intersect
	            // the same top level tiles.
	            for (idxShape = 0, lenShapes = this.surfaceShapes.length; idxShape < lenShapes; idxShape += 1) {
	                var surfaceShape = this.surfaceShapes[idxShape];

	                var sectors = surfaceShape.computeSectors(dc);
	                if (!sectors) {
	                    continue;
	                }

	                for (idxSector = 0, lenSectors = sectors.length; idxSector < lenSectors; idxSector += 1) {
	                    var sector = sectors[idxSector];

	                    for (idxTile = 0, lenTiles = this.topLevelTiles.length; idxTile < lenTiles; idxTile += 1) {
	                        tile = this.topLevelTiles[idxTile];

	                        if (tile.sector.intersects(sector)) {
	                            var cacheKey = tile.tileKey;
	                            intersectingTiles[cacheKey] = tile;
	                            tile.addSurfaceShape(surfaceShape);
	                        }
	                    }
	                }
	            }

	            // Add each top level tile or its descendants to the current tile list.
	            //for (var idxTile = 0, lenTiles = this.topLevelTiles.length; idxTile < lenTiles; idxTile += 1) {
	            for (var key in intersectingTiles) {
	                if (intersectingTiles.hasOwnProperty(key)) {
	                    tile = intersectingTiles[key];

	                    this.addTileOrDescendants(dc, this.levels, null, tile);
	                }
	            }
	        };

	        /**
	         * Potentially adds the specified tile or its descendants to the tile builder's surface shape tile collection.
	         * The tile and its descendants are discarded if the tile is not visible or does not intersect any surface shapes in the
	         * parent's surface shape list.
	         * <p/>
	         * If the tile meet the tile builder's resolution criteria it's added to the tile builder's
	         * <code>currentTiles</code> list. Otherwise, it's split into four sub-tiles and each tile is recursively processed.
	         *
	         * @param {DrawContext} dc              The current DrawContext.
	         * @param {LevelSet} levels             The tile's LevelSet.
	         * @param {SurfaceShapeTile} parent     The tile's parent, or null if the tile is a top level tile.
	         * @param {SurfaceShapeTile} tile       The tile to add.
	         */
	        SurfaceShapeTileBuilder.prototype.addTileOrDescendants = function (dc, levels, parent, tile) {
	            // Ignore this tile if it falls completely outside the frustum. This may be the viewing frustum or the pick
	            // frustum, depending on the implementation.
	            if (!this.intersectsFrustum(dc, tile)) {
	                // This tile is not added to the current tile list, so we clear it's object list to prepare it for use
	                // during the next frame.
	                tile.clearShapes();
	                return;
	            }

	            // If the parent tile is not null, add any parent surface shapes that intersect this tile.
	            if (parent != null) {
	                this.addIntersectingShapes(dc, parent, tile);
	            }

	            // Ignore tiles that do not intersect any surface shapes.
	            if (!tile.hasShapes()) {
	                return;
	            }

	            // If this tile meets the current rendering criteria, add it to the current tile list. This tile's object list
	            // is cleared after the tile update operation.
	            if (this.meetsRenderCriteria(dc, levels, tile)) {
	                this.addTile(dc, tile);
	                return;
	            }

	            var nextLevel = levels.level(tile.level.levelNumber + 1);
	            var subTiles = dc.pickingMode ?
	                tile.subdivide(nextLevel, this) :
	                tile.subdivideToCache(nextLevel, this, this.tileCache);
	            for (var idxTile = 0, lenTiles = subTiles.length; idxTile < lenTiles; idxTile += 1) {
	                var subTile = subTiles[idxTile];
	                this.addTileOrDescendants(dc, levels, tile, subTile);
	            }

	            // This tile is not added to the current tile list, so we clear it's object list to prepare it for use during
	            // the next frame.
	            tile.clearShapes();
	        };

	        /**
	         * Adds surface shapes from the parent's object list to the specified tile's object list. If the tile's sector
	         * does not intersect the sector bounding the parent's object list, this does nothing. Otherwise, this adds any of
	         * the parent's surface shapes that intersect the tile's sector to the tile's object list.
	         *
	         * @param {DrawContext} dc              The current DrawContext.
	         * @param {SurfaceShapeTile} parent     The tile's parent.
	         * @param {SurfaceShapeTile} tile       The tile to add intersecting surface shapes to.
	         */
	        SurfaceShapeTileBuilder.prototype.addIntersectingShapes = function(dc, parent, tile) {
	            // If the parent has no objects, then there's nothing to add to this tile and we exit immediately.
	            if (!parent.hasShapes())
	                return;

	            // If this tile does not intersect the parent's object bounding sector, then none of the parent's objects
	            // intersect this tile. Therefore we exit immediately, and do not add any objects to this tile.
	            if (!tile.sector.intersects(parent.sector))
	                return;

	            // If this tile contains the parent's object bounding sector, then all of the parent's objects intersect this
	            // tile. Therefore we just add all of the parent's objects to this tile. Additionally, the parent's object
	            // bounding sector becomes this tile's object bounding sector.
	            if (tile.getSector().contains(parent.sector)) {
	                tile.addAllSurfaceShapes(parent.getShapes());
	            }
	            // Otherwise, the tile may intersect some of the parent's object list. Compute which objects intersect this
	            // tile, and compute this tile's bounding sector as the union of those object's sectors.
	            else {
	                var shapes = parent.getShapes();
	                for (var idxShape = 0, lenShapes = shapes.length; idxShape < lenShapes; idxShape += 1) {
	                    var shape = shapes[idxShape];

	                    var sectors = shape.computeSectors(dc);
	                    if (!sectors) {
	                        continue;
	                    }

	                    // Test intersection against each of the surface shape's sectors. We break after finding an
	                    // intersection to avoid adding the same object to the tile more than once.
	                    for (var idxSector = 0, lenSectors = sectors.length; idxSector < lenSectors; idxSector += 1) {
	                        var sector = sectors[idxSector];

	                        if (tile.getSector().intersects(sector)) {
	                            tile.addSurfaceShape(shape);
	                            break;
	                        }
	                    }
	                }
	            }
	        };

	        /**
	         * Adds the specified tile to this tile builder's surface tile collection.
	         *
	         * @param {DrawContext} dc The draw context.
	         * @param {SurfaceShapeTile} tile The tile to add.
	         */
	        SurfaceShapeTileBuilder.prototype.addTile = function(dc, tile) {
	            if (dc.pickingMode) {
	                tile.pickSequence = SurfaceShapeTileBuilder.pickSequence;
	            }

	            if (tile.needsUpdate(dc)) {
	                tile.updateTexture(dc);
	            }

	            this.surfaceShapeTiles.push(tile);
	        };

	        /**
	         * Internal use only.
	         *
	         * Returns a new SurfaceObjectTile corresponding to the specified {@code sector}, {@code level}, {@code row},
	         * and {@code column}.
	         *
	         * CAUTION: it is assumed that there exists a single SurfaceShapeTileBuilder. This algorithm might be invalid if there
	         * are more of them (or it might actually work, although it hasn't been tested in that context).
	         *
	         * @param {Sector} sector       The tile's Sector.
	         * @param {Level} level         The tile's Level in a {@link LevelSet}.
	         * @param {Number} row          The tile's row in the Level, starting from 0 and increasing to the right.
	         * @param {Number} column       The tile's column in the Level, starting from 0 and increasing upward.
	         *
	         * @return {SurfaceShapeTile} a new SurfaceShapeTile.
	         */
	        SurfaceShapeTileBuilder.prototype.createTile = function(sector, level, row, column) {
	            return new SurfaceShapeTile(sector, level, row, column);
	        };

	        SurfaceShapeTileBuilder.prototype.createTopLevelTiles = function() {
	            Tile.createTilesForLevel(this.levels.firstLevel(), this, this.topLevelTiles);
	        };

	        /**
	         * Test if the tile intersects the specified draw context's frustum. During picking mode, this tests intersection
	         * against all of the draw context's pick frustums. During rendering mode, this tests intersection against the draw
	         * context's viewing frustum.
	         *
	         * @param {DrawContext} dc   The draw context the surface shape is related to.
	         * @param {SurfaceShapeTile} tile The tile to test for intersection.
	         *
	         * @return {Boolean} true if the tile intersects the draw context's frustum; false otherwise.
	         */
	        SurfaceShapeTileBuilder.prototype.intersectsFrustum = function(dc, tile) {
	            if (dc.globe.projectionLimits && !tile.sector.overlaps(dc.globe.projectionLimits)) {
	                return false;
	            }

	            tile.update(dc);

	            return tile.extent.intersectsFrustum(dc.pickingMode ? dc.pickFrustum : dc.navigatorState.frustumInModelCoordinates);
	        };

	        /**
	         * Tests if the specified tile meets the rendering criteria on the specified draw context. This returns true if the
	         * tile is from the level set's final level, or if the tile achieves the desired resolution on the draw context.
	         *
	         * @param {DrawContext} dc          The current draw context.
	         * @param {LevelSet} levels         The level set the tile belongs to.
	         * @param {SurfaceShapeTile} tile   The tile to test.
	         *
	         * @return {Boolean} true if the tile meets the rendering criteria; false otherwise.
	         */
	        SurfaceShapeTileBuilder.prototype.meetsRenderCriteria = function(dc, levels, tile) {
	            return tile.level.levelNumber == levels.lastLevel().levelNumber || !tile.mustSubdivide(dc, this.detailControl);
	        };

	        /**
	         * Internal use only.
	         * Count of pick operations. This is used to give a surface shape tile a unique pick sequence number if it is
	         * participating in picking.
	         * @type {Number}
	         */
	        SurfaceShapeTileBuilder.pickSequence = 0;

	        return SurfaceShapeTileBuilder;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports TextSupport
	 * @version $Id: TextSupport.js 3302 2015-07-06 22:20:36Z dcollins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(30),
	        __webpack_require__(129),
	        __webpack_require__(52),
	        __webpack_require__(32),
	        __webpack_require__(63),
	        __webpack_require__(54),
	        __webpack_require__(46)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
	              BasicTextureProgram,
	              Color,
	              Logger,
	              Matrix,
	              Texture,
	              Vec2) {
	        "use strict";

	        /**
	         * Constructs a TextSupport instance.
	         * @alias TextSupport
	         * @constructor
	         * @classdesc Provides methods useful for displaying text. An instance of this class is attached to the
	         * World Window {@link DrawContext} and is not intended to be used independently of that. Applications typically do
	         * not create instances of this class.
	         */
	        var TextSupport = function () {

	            // Internal use only. Intentionally not documented.
	            this.canvas2D = document.createElement("canvas");

	            // Internal use only. Intentionally not documented.
	            this.ctx2D = this.canvas2D.getContext("2d");

	            // Internal use only. Intentionally not documented.
	            this.lineSpacing = 0.15; // fraction of font size

	            // Internal use only. Intentionally not documented.
	            this.strokeStyle = "rgba(0, 0, 0, " + 0.5 + ")";

	            // Internal use only. Intentionally not documented.
	            this.strokeWidth = 4;
	        };

	        /**
	         * Returns the width and height of a specified text string upon applying a specified font and optional outline.
	         * @param {string} text The text string.
	         * @param {Font} font The font to apply when drawing the text.
	         * @param {Boolean} outline Indicates whether the text includes an outline, which increases its width and height.
	         * @returns {Vec2} A vector indicating the text's width and height, respectively, in pixels.
	         */
	        TextSupport.prototype.textSize = function (text, font, outline) {
	            if (text.length === 0) {
	                return new Vec2(0, 0);
	            }

	            this.ctx2D.font = font.fontString;

	            var lines = text.split("\n"),
	                height = lines.length * (font.size * (1 + this.lineSpacing)),
	                maxWidth = 0;

	            for (var i = 0; i < lines.length; i++) {
	                maxWidth = Math.max(maxWidth, this.ctx2D.measureText(lines[i]).width);
	            }

	            if (outline) {
	                maxWidth += this.strokeWidth;
	                height += this.strokeWidth;
	            }

	            return new Vec2(maxWidth, height);
	        };

	        /**
	         * Creates a texture for a specified text string, a specified font and an optional outline.
	         * @param {DrawContext} dc The current draw context.
	         * @param {String} text The text string.
	         * @param {Font} font The font to use.
	         * @param {Boolean} outline Indicates whether the text is drawn with a thin black outline.
	         * @returns {Texture} A texture for the specified text string and font.
	         */
	        TextSupport.prototype.createTexture = function (dc, text, font, outline) {
	            var gl = dc.currentGlContext,
	                ctx2D = this.ctx2D,
	                canvas2D = this.canvas2D,
	                textSize = this.textSize(text, font, outline),
	                lines = text.split("\n"),
	                strokeOffset = outline ? this.strokeWidth / 2 : 0,
	                pixelScale = dc.pixelScale,
	                x, y;

	            canvas2D.width = Math.ceil(textSize[0]) * pixelScale;
	            canvas2D.height = Math.ceil(textSize[1]) * pixelScale;

	            ctx2D.scale(pixelScale, pixelScale);
	            ctx2D.font = font.fontString;
	            ctx2D.textBaseline = "top";
	            ctx2D.textAlign = font.horizontalAlignment;
	            ctx2D.fillStyle = Color.WHITE.toHexString(false);
	            ctx2D.strokeStyle = this.strokeStyle;
	            ctx2D.lineWidth = this.strokeWidth;
	            ctx2D.lineCap = "round";
	            ctx2D.lineJoin = "round";

	            if (font.horizontalAlignment === "left") {
	                ctx2D.translate(strokeOffset, 0);
	            } else if (font.horizontalAlignment === "right") {
	                ctx2D.translate(textSize[0] - strokeOffset, 0);
	            } else {
	                ctx2D.translate(textSize[0] / 2, 0);
	            }

	            for (var i = 0; i < lines.length; i++) {
	                if (outline) {
	                    ctx2D.strokeText(lines[i], 0, 0);
	                }
	                ctx2D.fillText(lines[i], 0, 0);
	                ctx2D.translate(0, font.size * (1 + this.lineSpacing) + strokeOffset);
	            }

	            return new Texture(gl, canvas2D);
	        };

	        /**
	         * Calculates maximum line height based on a font
	         * @param {Font} font The font to use.
	         * @returns {Vec2} A vector indicating the text's width and height, respectively, in pixels based on the passed font.
	         */
	        TextSupport.prototype.getMaxLineHeight = function(font)
	        {
	            // Check underscore + capital E with acute accent
	            return this.textSize("_\u00c9", font, 0)[1];
	        };

	        /**
	         * Wraps the text based on width and height using new linew delimiter
	         * @param {String} text The text to wrap.
	         * @param {Number} width The width in pixels.
	         * @param {Number} height The height in pixels.
	         * @param {Font} font The font to use.
	         * @returns {String} The wrapped text.
	         */
	        TextSupport.prototype.wrap = function(text, width, height, font)
	        {
	            if (!text) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.WARNING, "TextSupport", "wrap", "missing text"));
	            }

	            var i;

	            var lines = text.split("\n");
	            var wrappedText = "";

	            // Wrap each line
	            for (i = 0; i < lines.length; i++)
	            {
	                lines[i] = this.wrapLine(lines[i], width, font);
	            }
	            // Concatenate all lines in one string with new line separators
	            // between lines - not at the end
	            // Checks for height limit.
	            var currentHeight = 0;
	            var heightExceeded = false;
	            var maxLineHeight = this.getMaxLineHeight(font);
	            for (i = 0; i < lines.length && !heightExceeded; i++)
	            {
	                var subLines = lines[i].split("\n");
	                for (var j = 0; j < subLines.length && !heightExceeded; j++)
	                {
	                    if (height <= 0 || currentHeight + maxLineHeight <= height)
	                    {
	                        wrappedText += subLines[j];
	                        currentHeight += maxLineHeight + this.lineSpacing;
	                        if (j < subLines.length - 1) {
	                            wrappedText += '\n';
	                        }
	                    }
	                    else
	                    {
	                        heightExceeded = true;
	                    }
	                }

	                if (i < lines.length - 1 && !heightExceeded) {
	                    wrappedText += '\n';
	                }
	            }
	            // Add continuation string if text truncated
	            if (heightExceeded)
	            {
	                if (wrappedText.length > 0) {
	                    wrappedText = wrappedText.substring(0, wrappedText.length - 1);
	                }

	                wrappedText += "...";
	            }

	            return wrappedText;
	        };

	        /**
	         * Wraps a line of text based on width and height
	         * @param {String} text The text to wrap.
	         * @param {Number} width The width in pixels.
	         * @param {Font} font The font to use.
	         * @returns {String} The wrapped text.
	         */
	        TextSupport.prototype.wrapLine = function(text, width, font)
	        {
	            var wrappedText = "";

	            // Single line - trim leading and trailing spaces
	            var source = text.trim();
	            var lineBounds = this.textSize(source, font, 0);
	            if (lineBounds[0] > width)
	            {
	                // Split single line to fit preferred width
	                var line = "";
	                var start = 0;
	                var end = source.indexOf(' ', start + 1);
	                while (start < source.length)
	                {
	                    if (end == -1) {
	                        end = source.length;   // last word
	                    }

	                    // Extract a 'word' which is in fact a space and a word
	                    var word = source.substring(start, end);
	                    var linePlusWord = line + word;
	                    if (this.textSize(linePlusWord, font, 0)[0] <= width)
	                    {
	                        // Keep adding to the current line
	                        line += word;
	                    }
	                    else
	                    {
	                        // Width exceeded
	                        if (line.length != 0)
	                        {
	                            // Finish current line and start new one
	                            wrappedText += line;
	                            wrappedText += '\n';
	                            line = "";
	                            line += word.trim();  // get read of leading space(s)
	                        }
	                        else
	                        {
	                            // Line is empty, force at least one word
	                            line += word.trim();
	                        }
	                    }
	                    // Move forward in source string
	                    start = end;
	                    if (start < source.length - 1)
	                    {
	                        end = source.indexOf(' ', start + 1);
	                    }
	                }
	                // Gather last line
	                wrappedText += line;
	            }
	            else
	            {
	                // Line doesn't need to be wrapped
	                wrappedText += source;
	            }

	            return wrappedText;
	        };

	        return TextSupport;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

	
	// все расширения это функции, принимающие на вход экземпляр ww
	// выполняются один раз при старте

	var extensions = [
	    __webpack_require__(136),
	    __webpack_require__(137),
	    __webpack_require__(139),
	    __webpack_require__(199),
	    __webpack_require__(200),
	    __webpack_require__(201),
	    __webpack_require__(235),
	    __webpack_require__(251),
	    __webpack_require__(252),
	    __webpack_require__(253)
	];

	module.exports = function (earth) {
	    extensions.forEach(function (extension) {
	        extension(earth);
	    });
	};

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

	var Events = __webpack_require__(5);

	var rotationInterval;
	var directions = ['up', 'down', 'left', 'right'];

	module.exports = function (engine) {

	    Events.listen(Events.CONTROLS, function(state) {

	        var loc = engine.navigator.lookAtLocation;
	        var param = state.parameter;

	        if (directions.indexOf(param) > -1) {
	            handleArrow();
	        } else {
	            engine.navigator[param] = state.value;
	            engine.redraw();
	        }

	        function handleArrow() {

	            var amount = 0.07 * engine.navigator.range / 1e6;
	            var sign = 'up' === param || 'right' === param ? 1 : -1;
	            var horizontal = 'left' === param || 'right' === param;

	            if (state.value) {
	                clearInterval(rotationInterval);
	                rotationInterval = setInterval(rotate, 25);
	            } else {
	                clearInterval(rotationInterval);
	            }

	            function rotate() {
	                loc[horizontal ? 'longitude' : 'latitude'] += sign * amount;
	                engine.redraw();
	            }
	        }
	    });
	};



/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

	var Watcher = __webpack_require__(138);
	var Events = __webpack_require__(5);

	module.exports = function (engine) {

	    Watcher(engine.navigator, 'heading', navigatorStateChanged);
	    Watcher(engine.navigator, 'tilt', navigatorStateChanged);
	    Watcher(engine.navigator, 'range', navigatorStateChanged);

	    Watcher(engine.navigator.lookAtLocation, 'latitude', locationChanged);
	    Watcher(engine.navigator.lookAtLocation, 'longitude', locationChanged);

	    var supressNavigatorEvents;

	    Events.listen(Events._BLOCK_NAVIGATOR_EVENTS_LISTENERS, function(isBlocked){
	        supressNavigatorEvents = isBlocked;
	        if (!supressNavigatorEvents && !engine.drawContext.pickingMode) {
	            post(Events.LOCATION_CHANGED, engine.navigator.lookAtLocation.latitude, 'latitude');
	            post(Events.LOCATION_CHANGED, engine.navigator.lookAtLocation.longitude, 'longitude');
	            post(Events.NAVIGATOR_STATE_CHANGED, engine.navigator.heading, 'heading');
	            post(Events.NAVIGATOR_STATE_CHANGED, engine.navigator.tilt, 'tilt');
	            post(Events.NAVIGATOR_STATE_CHANGED, engine.navigator.range, 'range');
	        }
	    });

	    function locationChanged(value, parameter) {
	        post(Events.LOCATION_CHANGED, value, parameter);
	    }

	    function navigatorStateChanged(value, parameter) {
	        post(Events.NAVIGATOR_STATE_CHANGED, value, parameter);
	    }

	    function post(event, value, parameter) {
	        Events.post(Events._BLOCK_TILE_LOADING);
	        if (supressNavigatorEvents) {
	            return;
	        }
	        var state = {};
	        state[parameter] = value;
	        Events.post(event, state);
	    }
	};


/***/ }),
/* 138 */
/***/ (function(module, exports) {

	module.exports = function watch(object, propertyName, callback) {

	    var oldValue = object[propertyName];

	    var newValue = oldValue;

	    Object.defineProperty(object, propertyName, {
	        get: getter,
	        set: setter
	    });

	    function getter() {
	        return newValue;
	    }

	    function setter(val) {
	        oldValue = newValue;
	        if (oldValue !== val) {
	            callback(val, propertyName);
	        }
	        return newValue = val;
	    }
	};

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

	var RenderableLayer = __webpack_require__(140);
	var Color = __webpack_require__(52);
	var GeoJsonObjectsFactory = __webpack_require__(141);
	var ModelFactory = __webpack_require__(189);
	var TextFactory = __webpack_require__(182);
	var BillboardFactory = __webpack_require__(198);
	var Events = __webpack_require__(5);

	var found = [];
	var layers = {};
	var objects = {};
	var earth;
	var color;

	module.exports = function(e) {
	    earth = e;
	};

	listenToCreateEvent(Events.CREATE_GEO_JSON_OBJECT, {create: createGeoJson});
	listenToCreateEvent(Events.CREATE_MODEL, ModelFactory);
	listenToCreateEvent(Events.CREATE_TEXT, TextFactory);
	listenToCreateEvent(Events.CREATE_BILLBOARD, BillboardFactory);

	Events.listen(Events.GET_OBJECT, getObject);
	Events.listen(Events.GET_OBJECT_PROPERTIES, getObjectProperties);
	Events.listen(Events.GET_OBJECT_PROPERTY, getObjectProperty);
	Events.listen(Events.GET_OBJECT_GEOMETRY, getObjectGeometry);
	Events.listen(Events.SET_OBJECT_PROPERTIES, setObjectProperties);
	Events.listen(Events.SET_OBJECT_GEOMETRY, setObjectGeometry);
	Events.listen(Events.DESTROY_OBJECT, destroyObject);
	Events.listen(Events.SEARCH_OBJECT, searchObject);

	Events.listen(Events.CREATE_LAYER, createLayer);
	Events.listen(Events.CLEAR_LAYER, clearLayer);
	Events.listen(Events.DESTROY_LAYER, destroyLayer);
	Events.listen(Events.HAS_LAYER, hasLayer);
	Events.listen(Events.GET_LAYER_CONTENTS, getLayerContents);
	Events.listen(Events.SET_LAYER_PROPERTY, setLayerProperty);
	Events.listen(Events._GET_LAYER, getLayer);

	function setLayerProperty(p) {
	    var layer = getLayer(p.id);
	    if (layer) {
	        p.hasOwnProperty('visible') && (layer.enabled = p.visible);
	        p.hasOwnProperty('opacity') && (layer.opacity = p.opacity);
	    }
	    Events.post(Events.REDRAW);
	}

	function hasLayer(id) {
	    return layers.hasOwnProperty(layerId(id));
	}

	function clearLayer(layerName){
	    var layer = getLayer(layerName);
	    if (layer) {
	        layer.removeAllRenderables();
	        earth.redraw();
	    }
	}

	function doDelete(id) {
	    var exists = objects.hasOwnProperty(id);
	    if (exists) {
	        var group = null;
	        objects[id].forEach(function (obj) {
	            obj.layer.removeRenderable(obj);
	            group = group || obj.source.properties.group;
	        });
	        deleteGroup(group);
	        delete objects[id];
	        earth.redraw();
	    }
	    return exists;
	}

	function deleteGroup(group) {
	    if (!group) return;
	    for (var id in objects) {
	        if (!objects.hasOwnProperty(id)) continue;
	        var deleted = false;
	        objects[id].forEach(function(obj) {
	            deleted |= obj.source.properties.group === group;
	            if (deleted) {
	                obj.layer.removeRenderable(obj);
	            }
	        });
	        deleted && delete objects[id];
	    }
	}

	function destroyObject(id){
	    if (Array.isArray(id))
	        id.forEach(doDelete);
	    else doDelete(id);
	}

	function createGeoJson(geoJson) {
	    var objects = [];

	    if (geoJson.type === 'Feature') {
	        doCreate(geoJson);
	    } else if (geoJson.type === 'FeatureCollection') {
	        geoJson.features.forEach(function (feature) {
	            doCreate(feature);
	        });
	    }

	    earth.redraw();

	    return objects;

	    function doCreate(json) {
	        var features = GeoJsonObjectsFactory.create(json);
	        if (!features){
	            return;
	        }
	        features.forEach(function (object) {
	            objects.push(object);
	        });
	    }
	}

	function getObject(id) {
	    var object = objects[id];
	    return object.length ? object[0].source : null;
	}

	function getObjectProperties(id) {
	    return get(id, 'properties');
	}

	function getObjectProperty(obj) {
	    var object = getObject(obj.id);
	    if (object) {
	        var result = {};
	        result[obj.property] = object.properties[obj.property];
	        return result;
	    }
	}

	function getObjectGeometry(id) {
	    return get(id, 'geometry');
	}

	function setObjectGeometry(obj) {
	    var object = objects[obj.id];
	    if (!object || !obj.geometry) {
	        return;
	    }
	    object.source.geometry = obj.geometry;
	    object.update();
	    earth.redraw();
	}

	function setObjectProperties(obj) {
	    var object = objects[obj.id];
	    if (!object || !obj.properties || object.source)
	        return;
	    for (var p in obj.properties) {
	        if (obj.properties.hasOwnProperty(p)) {
	            object.forEach(function(objectPart) {
	                objectPart.source.properties[p] = obj.properties[p];
	            });
	        }
	    }
	    object.forEach(function(objectPart) {
	        objectPart.update && objectPart.update();
	    });
	    earth.redraw();
	}

	function listenToCreateEvent(event, factory) {
	    Events.listen(event, function (desc) {
	        var renderables = factory.create(desc, add);
	        renderables && add(renderables);
	    });
	}

	function destroyLayer(layerName) {
	    earth.removeLayer(getLayer(layerName));
	    earth.redraw();
	}

	function createLayer(layerName) {
	    var layer = new RenderableLayer(layerName);
	    layers[layerId(layerName)] = layer;
	    earth.addLayer(layer);
	    return layer;
	}

	function add(renderables) {
	    if (!renderables) return;
	    renderables.forEach(function (renderable) {
	        var layerName = renderable.source.properties.layer || "default";
	        var layer = getLayer(layerName);
	        if (!layer) layer = createLayer(layerName);
	        if (renderable.source.id) {
	            if (!objects.hasOwnProperty(renderable.source.id)) {
	                objects[renderable.source.id] = [];
	            }
	            objects[renderable.source.id].push(renderable);
	        }
	        renderable.layer = layer;
	        layer.addRenderable(renderable);
	    });
	    Events.post(Events.REDRAW);
	}

	function layerId(id) {
	    return 'layer-' + id;
	}

	function getLayer(id) {
	    return layers[layerId(id)];
	}

	function get(id, property) {
	    var object = getObject(id);
	    if (object) {
	        return object[property];
	    }
	}

	function getLayerContents(id) {
	    return getLayer(id).renderables.map(function (renderable) {
	        return renderable.source.id;
	    });
	}

	function resetSearchState() {
	    found.forEach(function(sign) {
	        sign.forEach(function(o) {
	            var att = o.attributes;
	            if (att) {
	                if (att.oldOutlineColor && att.outlineColor) {
	                    att.outlineColor = att.oldOutlineColor;
	                    delete att.oldOutlineColor;
	                }
	                if (att.oldInteriorColor && att.interiorColor) {
	                    att.interiorColor = att.oldInteriorColor;
	                    delete att.oldInteriorColor;
	                }
	                if (att._oldImageSource && att._imageSource) {
	                    att._imageSource = att._oldImageSource;
	                    delete att._oldImageSource;
	                }
	                if (att._labelAttributes && att._labelAttributes.oldColor) {
	                    att._labelAttributes.color = att._labelAttributes.oldColor;
	                    delete att._labelAttributes.oldColor;
	                }
	            }
	            if (o.oldColor && o.color) {
	                o.color = o.oldColor;
	                delete o.oldColor;
	            }
	        });
	    });
	    window.removeEventListener('mousedown', resetSearchState);
	    Events.post(Events.REDRAW);
	}

	function highlightFoundSign(index, color, rotate) {
	    resetSearchState();
	    var object = found[index];
	    var position = object[0].referencePosition || object[0].position;
	    if (rotate) {
	        //obj.altitude && (position.alt = obj.altitude);
	        Events.post(Events.ROTATE_TO, position);
	    }
	    if (color) {
	        var c = Color.colorFromHex(color);
	        object.forEach(function(o) {
	            var att = o.attributes;
	            if (att) {
	                if (att.outlineColor) {
	                    att.oldOutlineColor = att.outlineColor;
	                    att.outlineColor = c;
	                }
	                if (att.interiorColor) {
	                    att.oldInteriorColor = att.interiorColor;
	                    att.interiorColor = c;
	                }
	                if (att._imageSource) {
	                    att._oldImageSource = att._imageSource;
	                    att._imageSource = att._whiteImageSource;
	                    att._imageColor = c;
	                }
	                if (att._labelAttributes) {
	                    att._labelAttributes.oldColor = att._labelAttributes.color;
	                    att._labelAttributes.color = c;
	                }
	            }
	            if (o.color) {
	                o.oldColor = o.color;
	                o.color = c;
	            }
	        });
	        Events.post(Events.REDRAW);

	        window.addEventListener('mousedown', resetSearchState);

	    }
	    return position
	}

	function searchObject(obj) {
	    Events.post(Events.HIDE_FORM, 'search-form');
	    color = obj.color;
	    resetSearchState();
	    found = [];

	    if (typeof obj == "number") {
	        addById(obj);
	    } else if (obj.id) {
	        addById(obj.id);
	    } else if (obj.ids) {
	        obj.ids.forEach(addById);
	    }

	    if (found.length === 1) {
	        return highlightFoundSign(0, obj.color || 'ffff00ff', obj.rotate);
	    } else if (found.length > 1){
	        Events.post(Events._SHOW_SEARCH_RESULT, found.map(function (sign) {
	            return sign[0].source.id;
	        }));
	    }

	    function addById(id){
	        objects.hasOwnProperty(id) && found.push(objects[id])
	    }
	}

	Events.listen(Events._HIGHLIGHT_FOUND, function (index) {
	    highlightFoundSign(index, color, true);
	});

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports RenderableLayer
	 * @version $Id: RenderableLayer.js 3334 2015-07-22 19:15:43Z tgaskins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(30),
	        __webpack_require__(126),
	        __webpack_require__(32)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
	              Layer,
	              Logger) {
	        "use strict";

	        /**
	         * Constructs a layer that contains shapes and other renderables.
	         * @alias RenderableLayer
	         * @constructor
	         * @augments Layer
	         * @classdesc Provides a layer that contains shapes and other renderables.
	         * @param {String} displayName This layer's display name.
	         */
	        var RenderableLayer = function (displayName) {
	            Layer.call(this, displayName);

	            /**
	             * The array of renderables;
	             * @type {Array}
	             * @readonly
	             */
	            this.renderables = [];
	        };

	        RenderableLayer.prototype = Object.create(Layer.prototype);

	        /**
	         * Adds a renderable to this layer.
	         * @param {Renderable} renderable The renderable to add.
	         * @throws {ArgumentError} If the specified renderable is null or undefined.
	         */
	        RenderableLayer.prototype.addRenderable = function (renderable) {
	            if (!renderable) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "RenderableLayer", "addRenderable",
	                    "missingRenderable"));
	            }

	            this.renderables.push(renderable);
	        };

	        /**
	         * Adds an array of renderables to this layer.
	         * @param {Renderable[]} renderables The renderables to add.
	         * @throws {ArgumentError} If the specified renderables array is null or undefined.
	         */
	        RenderableLayer.prototype.addRenderables = function (renderables) {
	            if (!renderables) {
	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "RenderableLayer", "addRenderables",
	                    "The renderables array is null or undefined."));
	            }

	            for (var i = 0, len = renderables.length; i < len; i++) {
	                this.addRenderable(renderables[i]);
	            }
	        };

	        /**
	         * Removes a renderable from this layer.
	         * @param {Renderable} renderable The renderable to remove.
	         */
	        RenderableLayer.prototype.removeRenderable = function (renderable) {
	            var index = this.renderables.indexOf(renderable);
	            if (index >= 0) {
	                this.renderables.splice(index, 1);
	            }
	        };

	        /**
	         * Removes all renderables from this layer. Does not call dispose on those renderables.
	         */
	        RenderableLayer.prototype.removeAllRenderables = function () {
	            this.renderables = [];
	        };

	        // Documented in superclass.
	        RenderableLayer.prototype.doRender = function (dc) {
	            var numOrderedRenderablesAtStart = dc.orderedRenderables.length;

	            for (var i = 0, len = this.renderables.length; i < len; i++) {
	                try {
	                    this.renderables[i].render(dc);
	                } catch (e) {
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "RenderableLayer", "doRender",
	                        "Error while rendering shape " + this.renderables[i].displayName + ".\n" + e.toString());
	                    // Keep going. Render the rest of the shapes.
	                }
	            }

	            if (dc.orderedRenderables.length > numOrderedRenderablesAtStart) {
	                this.inCurrentFrame = true;
	            }
	        };

	        return RenderableLayer;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

	var factories = {
	    LineString: __webpack_require__(142),
	    Polygon: __webpack_require__(164),
	    Point: __webpack_require__(182),
	    GeometryCollection: __webpack_require__(188)
	};

	module.exports = {
	    create: createGeoJsonObject
	};

	function createGeoJsonObject(geoJson) {
	    var key = geoJson.geometry.type.split("Multi");
	    var factory = factories[key.pop()];
	    if (factory) {
	        var allShapesInSign = factory.create(geoJson, !key.length);
	        Array.isArray(allShapesInSign) && allShapesInSign.forEach(function(obj) {
	            obj.allShapesInSign = allShapesInSign;
	            obj.surfacePrimitive && (obj.surfacePrimitive.allShapesInSign = allShapesInSign);
	        });
	        return allShapesInSign;
	    }
	}


/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

	var AttributesFactory = __webpack_require__(143);
	var Path = __webpack_require__(145);
	var PatternedPath = __webpack_require__(156);
	var ObjectFactory = __webpack_require__(162);
	var LegacyPath = __webpack_require__(163);
	var ScreenSpacePath = __webpack_require__(150);
	var Utils = __webpack_require__(144);

	var defaultProperties = {
	    outline: 'ffffffff',
	    interior: 'ffffffaf',
	    outlineHover: 'ffffffff',
	    interiorHover: 'ffffff7f',
	    legacy: true
	};

	module.exports = {
	    create: ObjectFactory(createLine, Utils.geoJsonCoordinatesToPositions, defaultProperties)
	};

	function createLine(positions, geoJson) {
	    var cocoImpl = geoJson && geoJson.properties && geoJson.properties.api === 'coco';
	    if (cocoImpl && geoJson.properties.pen) {
	        return PatternedPath.create(positions, geoJson.properties.pen).map(newPath);
	    }
	    var nicImpl = geoJson && geoJson.properties && geoJson.properties.api === 'nic';
	    if (nicImpl) {
	        var color = geoJson.geometry.properties.color || geoJson.properties.color;
	        var screenSpacePath = new ScreenSpacePath(positions, color, 5);
	        screenSpacePath.source = geoJson;
	        return screenSpacePath;
	    }
	    return cocoImpl ? newPath(positions, geoJson.geometry.properties || {}) : legacyPath(positions);

	    function newPath(points, props) {
	        var width = (geoJson.properties.width || 10) * (props.widthMultiplier || 1);
	        return configurePath(new Path(points, null, null, width), geoJson);
	    }

	    function legacyPath(points) {
	        return configurePath(new LegacyPath(points, null), geoJson);
	    }
	}

	function configurePath(path, geoJson) {
	    path.source = geoJson;
	    updateLine(path);
	    path.update = updateLine.bind(null, path);
	    return path;
	}

	function updateLine(path) {
	    var props = path.source.geometry.properties ||  path.source.properties || {};
	    path.enabled = props.visible !== false;
	    path.extrude = props.extrude || false;
	    AttributesFactory.fill(path, props);
	}


/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

	var ShapeAttributes = __webpack_require__(132);
	var Color = __webpack_require__(52);
	var Utils = __webpack_require__(144);

	module.exports = {
	    createDefaultAttributes: createDefaultAttributes,
	    fill: function (shape, props) {
	        shape.attributes = shape.highlightAttributes = createDefaultAttributes(null, props);
	        shape.update && shape.update();
	    }
	};

	function createDefaultAttributes(source, props) {
	    var attributes = new ShapeAttributes(source);
	    attributes.outlineColor = Utils.extractColor(props, props.color ? Color.WHITE : 'stroke', 1);
	    attributes.interiorColor = Utils.extractColor(props, props.color ? Color.WHITE : 'fill', 1);
	    attributes.drawOutline = false !== props.outline;
	    attributes.drawInterior = false !== props.interior;
	    //attributes.outlineWidth = props.width || 1;
	    attributes.drawVerticals = props.verticals || false;
	    return attributes;
	}


/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

	var Location = __webpack_require__(28);
	var Position = __webpack_require__(47);
	var Color = __webpack_require__(52);

	module.exports = {
	    geoJsonCoordinatesToPositions: geoJsonCoordinatesToPositions,
	    position: position,
	    location: location,
	    array: array,
	    extractColor: extractColor
	};

	function extractColor(props, propertyName, defaultOpacity) {
	    if (!props) {
	        return Color.WHITE;
	    }

	    var property = props[propertyName || 'color'];

	    var color = Color.colorFromHex(property || 'ffffff');

	    if (props.opacity || 0 === props.opacity) {
	        color.alpha = props.opacity;
	    }

	    if (isNaN(color.alpha)) {
	        color.alpha = defaultOpacity || 1;
	    }

	    return color;
	}

	function array(pt) {
	    var arr = [pt.latitude, pt.longitude];
	    if (pt.altitude) arr.push(pt.altitude);
	    return arr;
	}

	function geoJsonCoordinatesToPositions(array, alt) {
	    return array.map(function (pt) {
	        if (!pt[2] && alt !== null) pt[2] = alt;
	        return position(pt);
	    });
	}

	function location(pt) {
	    return new Location(lat(pt), lon(pt));
	}

	function position(pt) {
	    return new Position(lat(pt), lon(pt), alt(pt) || 0);
	}

	function lat(pt) {
	    return Array.isArray(pt) ? pt[0] : pt.lat ? pt.lat : pt.latitude;
	}

	function lon(pt) {
	    return Array.isArray(pt) ? pt[1] : pt.lon ? pt.lon : pt.longitude;
	}

	function alt(pt) {
	    return Array.isArray(pt) ? pt[2] : pt.alt ? pt.alt : pt.altitude;
	}

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

	var AbstractPrimitive = __webpack_require__(146);
	var BoundingBox = __webpack_require__(78);
	var Location = __webpack_require__(28);
	var PickedObject = __webpack_require__(87);
	var Position = __webpack_require__(47);
	var Vec3 = __webpack_require__(35);
	var SurfacePolyline = __webpack_require__(149);
	var ShapeAttributes = __webpack_require__(132);
	var ScreenSpacePath = __webpack_require__(150);
	var PrimitiveUtils = __webpack_require__(154);
	var WebGL = __webpack_require__(155);
	// var ExtrudePolyline = require('extrude-polyline');
	//var SimplifyLine = require('simplify-js');
	var Utils = __webpack_require__(144);
	var PrimitivesMath = __webpack_require__(152);

	var Path = function (positions, attributes, highlightAttributes, width) {
	    this._positions = positions;
	    this.minHeight = Number.MAX_VALUE;
	    this.height = positions[0].altitude;
	    this.width = width / 111200 / 2;
	    //this.useSurfaceShapeFor2D = true;
	    // this.stroke = ExtrudePolyline({
	    //     thickness: width || 0.01
	    // });
	    AbstractPrimitive.call(this, attributes, highlightAttributes);
	};

	Path.prototype = Object.create(AbstractPrimitive.prototype);

	Path.prototype.positionsAsArray = function () {
	    return this._positions;
	};

	Path.prototype.makeSurfacePrimitive = function () {
	    var attrs = new ShapeAttributes(this._attributes);
	    attrs.outlineWidth = 1;
	    var surfacePolyline = new SurfacePolyline(this._positions, attrs);
	    surfacePolyline._highlightAttributes = new ShapeAttributes(this._highlightAttributes);
	    return surfacePolyline;
	};



	Path.prototype.doMakeOrderedRenderable = function (dc) {

	    // Set the transformation matrix to correspond to the reference position.
	    var refPt = this.currentData.referencePoint;
	    dc.surfacePointForMode(
	        this.referencePosition.latitude,
	        this.referencePosition.longitude,
	        this.referencePosition.altitude,
	        this._altitudeMode,
	        refPt
	    );
	    this.currentData.transformationMatrix.setToTranslation(refPt[0], refPt[1], refPt[2]);

	    var elevationAtReferencePoint = this.getElevationAtReferencePoint(dc);

	    // See if the current shape data can be re-used.
	    if (this.currentData.array &&
	        elevationAtReferencePoint === this.elevationAtReferencePoint
	    ) return this;

	    this.elevationAtReferencePoint = elevationAtReferencePoint;
	    // create vertices array
	    var array = this.makeTessellatedPositions(dc);
	    array = this.makePolygonalLine(array);
	    array = this.makeLineWithSides(array, dc);

	    this.currentData.groundPoints = WebGL.pointsAsFloat32array(array.map(function (pt) {
	        return [pt.altitude];
	    }), 1);

	    array = array.map(mapper);

	    this.currentData.array = WebGL.pointsAsFloat32array(array, 3);

	    this.currentData.drawInterior = this.activeAttributes.drawInterior;
	    this.currentData.drawVerticals = this.activeAttributes.drawVerticals;
	    this.resetExpiration(this.currentData);
	    this.currentData.fillVbo = true;
	    // if (!this.currentData.extent) {
	        this.currentData.extent = new BoundingBox();
	        this.currentData.extent.setToPoints(this.currentData.array);
	        this.currentData.extent.translate(refPt);
	    // }
	    return this;

	    function mapper(p) {
	        return dc.surfacePointForMode(
	            p.latitude, p.longitude, p.altitude,
	            WorldWind.RELATIVE_TO_GROUND,
	            new Vec3(0,0,0)
	        ).subtract(refPt);
	    }
	};

	Path.prototype.makeLineWithSides = function (array, dc) {
	    var self = this;
	    var sides = [];
	    var end = array.length - 1;
	    for (var i = end; i >= 0; i-=2) {
	        addTwoPoints(i);
	    }
	    for (i = 0; i < array.length; i += 2) {
	        addTwoPoints(i);
	    }
	    addTwoPoints(end);
	    return array.concat(sides);

	    function addTwoPoints(index) {
	        var vertex = array[index];
	        if (self.minHeight > vertex.altitude - self.height) {
	            self.minHeight = vertex.altitude - self.height;
	        }
	        sides.push(vertex);
	        sides.push(PrimitiveUtils.clampedToGround(vertex));
	    }
	};

	function isClosed(points) {
	    if (points.length > 2) {
	        var s = points[0];
	        var e = points[points.length - 1];
	        return s.latitude === e.latitude && s.longitude === e.longitude;
	    }
	}

	Path.prototype.extrudePolyline = function (points) {
	    var closed = isClosed(points);
	    var width = this.width;
	    var polygonal = [];
	    var end = points.length - 2;
	    for (var i = 0; i <= end; i++) {
	        var p = closed && i === 0 ? getPoint(end) : getPoint(i - 1); // previous line left point (null for first line in segment)
	        var s = getPoint(i);     // current line start point
	        var e = getPoint(i + 1); // current line end point
	        var n = closed && i === end ? getPoint(1) : getPoint(i + 2); // next line right point (null for last line in segment)

	        var pd = lineDir(p, s); // previous line direction  (null for first line in segment)
	        var cd = lineDir(s, e); // current line direction
	        var nd = lineDir(e, n); // next line direction (null for last line in segment)

	        // calc points shift direction in angles (shifting performed by shader)
	        var sl = ptShiftDir(pd, cd, true);  // start left point shift direction
	        var sr = invertDir(sl);             // start right point shift direction
	        var el = ptShiftDir(cd, nd, false); // end left point shift direction
	        var er = invertDir(el);             // end right point shift direction

	      //  if (i !== end) handleLineJoin(nd, cd, e, sl, er, 45, true);

	        addPoint(s, sl, 1);
	        addPoint(s, sr, 1);
	        addPoint(e, el, 1);
	        addPoint(e, er, 1);

	      //  if (i !== 0) handleLineJoin(cd, pd, s, el, sr, 45, false);

	    }
	    return polygonal;

	    function getPoint(index) {
	        if (index >= 0 && index < points.length)
	            return points[index];
	    }

	    function addPoint(pt, angle, amount) {
	        angle = angle / 180 * Math.PI;
	        polygonal.push([
	            pt[0] + Math.cos(angle) * amount * width,
	            pt[1] + Math.sin(angle) * amount * width / Math.cos(pt[0]/ 180 * Math.PI)
	        ]);
	    }

	    function lineDir(p, s) {
	        return PrimitivesMath.lineDirection(p, s);
	    }

	    function ptShiftDir(d0, d1, isLeft) {
	        return PrimitivesMath.pointShiftDirection(d0, d1, isLeft);
	    }

	    function invertDir(d){
	        return PrimitivesMath.invertDirection(d);
	    }

	    function dirAngle(d0, d1){
	        return PrimitivesMath.angleBetweenDirections(d0, d1);
	    }
	};

	Path.prototype.makePolygonalLine = function (positions) {
	    var pointsArray = positions.map(Utils.array);
	    pointsArray = this.extrudePolyline(pointsArray);
	    var result = [];
	    for (var i = 0; i + 1 < pointsArray.length; i +=2) {
	        var ptA = Utils.position(pointsArray[i]);
	        var ptB = Utils.position(pointsArray[i + 1]);

	        //var elevA = PrimitiveUtils.elevationAtPosition(ptA);
	        //var elevB = PrimitiveUtils.elevationAtPosition(ptB);

	        var max = this.heightFactor;//Math.max(elevA, elevB);

	        ptA.altitude = positions[0].altitude + max;
	        ptB.altitude = positions[0].altitude + max;

	        result.push(ptA);
	        result.push(ptB);
	    }
	    return result;
	};

	Path.prototype.makeTessellatedPositions = function (dc) {

	    var tessellatedPositions = [],
	        navState = dc.navigatorState,
	        ptA = new Vec3(0, 0, 0),
	        ptB = new Vec3(0, 0, 0),
	        posA = this._positions[0],
	        posB,
	        eyeDistance,
	        pixelSize;

	    tessellatedPositions.push(posA);
	    dc.surfacePointForMode(posA.latitude, posA.longitude, posA.altitude, this._altitudeMode, ptA);

	    for (var i = 1, len = this._positions.length; i < len; i++) {
	        posB = this._positions[i];
	        dc.surfacePointForMode(posB.latitude, posB.longitude, posB.altitude, this._altitudeMode, ptB);
	        eyeDistance = navState.eyePoint.distanceTo(ptA);
	        pixelSize = navState.pixelSizeAtDistance(eyeDistance);
	        if (ptA.distanceTo(ptB) < pixelSize * 8) {
	            tessellatedPositions.push(posB); // distance is short so no need for sub-segments
	        } else {
	            this.makeSegment(dc, posA, posB, ptA, ptB, tessellatedPositions, eyeDistance, pixelSize);
	        }
	        posA = posB;
	        ptA.copy(ptB);
	    }
	    return tessellatedPositions;
	};

	Path.prototype.doRenderOrdered = function (dc) {
	    var gl = dc.currentGlContext;
	    var program = dc.currentProgram;

	    this.applyMvpMatrix(dc);

	    WebGL.createOrLoadVBO(dc, this.currentData, 'capVboKey', 'array');
	    gl.vertexAttribPointer(program.vertexPointLocation, 3, gl.FLOAT, false, 0, 0);

	    gl.enableVertexAttribArray(program.groundPointsLocation);
	    WebGL.createOrLoadVBO(dc, this.currentData, 'groundPointsVboCacheKey', 'groundPoints');
	    gl.vertexAttribPointer(program.groundPointsLocation, 1, gl.FLOAT, false, 0, 0);

	    if (dc.pickingMode) {
	        var pickColor = dc.uniquePickColor();
	    }

	    //var gl = dc.currentProgram;
	    //if (!this.emptyTexture){
	    //    this.emptyTexture = gl.createTexture();
	    //}
	    //gl.bindTexture(gl.TEXTURE_2D, this.emptyTexture);
	    // dc.currentProgram.loadModelviewInverse(gl, dc.navigatorState.modelviewNormalTransform);
	    WebGL.loadShaderVariables(dc,
	        this.activeAttributes.outlineColor,
	        pickColor,
	        this.layer.opacity);
	    // WebGL.glDrawTriangleStrip(dc, this.currentData.array.length / 3);
	    gl.drawArrays(gl.TRIANGLE_STRIP, 0, this.currentData.array.length / 3);

	    //gl.loadColor(dc.currentGlContext, dc.uniquePickColor());
	    //WebGL.glDrawLineStrip(dc, this.currentData.array.length / 3);
	    //  WebGL.glDrawLineStrip(dc, this.currentData.array.length / 6, 0, 24, 0);
	    this.currentData.fillVbo = false;

	    if (dc.pickingMode) {
	        dc.resolvePick(new PickedObject(pickColor, this.pickDelegate || this, null, dc.currentLayer, false));
	    }

	   // this.currentData.extent.render(dc)
	};

	module.exports = Path;




/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

	var AbstractShape = __webpack_require__(147);
	var Vec3 = __webpack_require__(35);
	var BasicTextureProgram = __webpack_require__(129);
	var Location = __webpack_require__(28);
	var Position = __webpack_require__(47);
	var Generalization = __webpack_require__(148);

	var AbstractPrimitive = function (attributes, highlightAttributes) {
	    AbstractShape.call(this, attributes);
	    this.highlightAttributes = highlightAttributes;
	    this.updateReferencePosition();
	    this.scratchPoint = new Vec3(0, 0, 0); // scratch variable
	    this.expiryTime = 0;
	    this.surfaceFallbackEyeDistance = 1e5;
	    this.heightFactor = Math.random()*0.5;
	    this.update();
	};

	AbstractPrimitive.prototype = Object.create(AbstractShape.prototype);

	AbstractPrimitive.prototype.makeSegment = function (dc, posA, posB, ptA, ptB, tessellatedPositions) {
	    var navState = dc.navigatorState,
	        eyePoint = navState.eyePoint,
	        pos = new Location(0, 0),
	        height = 0,
	        arcLength, segmentAzimuth, segmentDistance, s, p, distance;

	    // Compute the segment length.
	    segmentDistance = Location.greatCircleDistance(posA, posB);
	    if (this._altitudeMode !== WorldWind.CLAMP_TO_GROUND) {
	        height = 0.5 * (posA.altitude + posB.altitude);
	    }
	    arcLength = segmentDistance * (dc.globe.equatorialRadius + height * dc.verticalExaggeration);
	    if (arcLength <= 0) { // segment is 0 length
	        return;
	    }

	    // Compute the azimuth to apply while tessellating the segment.
	    segmentAzimuth = Location.greatCircleAzimuth(posA, posB);
	    for (s = 0, p = 0; s < 1;) {
	        var step = 20 * navState.pixelSizeAtDistance(this.scratchPoint.distanceTo(eyePoint));
	        step = step < 20 ? 20 : step;
	        p += step;
	        // Stop adding intermediate positions when we reach the arc length, or the remaining distance is in
	        // millimeters on Earth.
	        if (arcLength < p || arcLength - p < 1e-9) break;
	        s = p / arcLength;
	        distance = s * segmentDistance;
	        Location.greatCircleLocation(posA, segmentAzimuth, distance, pos);
	        pos.altitude = (1 - s) * posA.altitude + s * posB.altitude;
	        tessellatedPositions.push(new Position(pos.latitude, pos.longitude, pos.altitude));
	        dc.surfacePointForMode(pos.latitude, pos.longitude, pos.altitude, WorldWind.CLAMP_TO_GROUND, this.scratchPoint);
	    }
	    tessellatedPositions.push(posB);
	};

	AbstractPrimitive.prototype.update = function () {
	    this.surfacePrimitive = this.makeSurfacePrimitive();
	    this.surfacePrimitive.source = this.source;
	};

	AbstractPrimitive.prototype.updateReferencePosition = function () {
	    var boundaries = this.positionsAsArray();
	    this.referencePosition = boundaries.length > 0 ? boundaries[0] : null;
	};

	AbstractPrimitive.prototype.positionsAsArray = function () {
	    throw new Error('not implemented');
	};

	AbstractPrimitive.prototype.makeSurfacePrimitive = function () {
	    throw new Error('not implemented');
	};

	AbstractPrimitive.prototype.updateEyeDistance = function(dc) {
	    if (this.expiryTime && this.expiryTime > Date.now()) {
	        return;
	    }
	    var distanceToEye = Number.MAX_VALUE;
	    var pt = this.scratchPoint;
	    this.positionsAsArray().forEach(function(p) {
	        dc.surfacePointForMode(p.latitude, p.longitude, p.altitude, this._altitudeMode, pt);
	        distanceToEye = Math.min(distanceToEye, dc.navigatorState.eyePoint.distanceTo(pt));
	    });
	    this.distanceToEye = distanceToEye;
	};

	AbstractPrimitive.prototype.getElevationAtReferencePoint = function (dc) {
	    return dc.globe.elevationAtLocation(this.referencePosition.latitude, this.referencePosition.longitude);
	};

	AbstractPrimitive.prototype.render = function (dc) {
	    this.updateEyeDistance(dc);
	    if (this.isHidden())
	        return;
	    if (this.distanceToEye > this.surfaceFallbackEyeDistance)
	        return this.surfacePrimitive.render(dc);
	    AbstractShape.prototype.render.call(this, dc);
	};

	AbstractPrimitive.prototype.isHidden = function () {
	    if (!this.generalization)
	        this.generalization = new Generalization(this.source.properties.generalization);
	    return !this.generalization.isVisible(this.distanceToEye);
	};

	AbstractPrimitive.prototype.mustGenerateGeometry = function (dc) {
	    var expired = this.expiryTime  < Date.now();
	    if (expired) {
	        this.expiryTime = Date.now() + (5 + Math.random()) * 5000;
	    }
	    return expired;
	};

	AbstractPrimitive.prototype.beginDrawing = function (dc) {
	    var gl = dc.currentGlContext;
	    gl.disable(gl.CULL_FACE);
	    dc.findAndBindProgram(dc.globe.projection.shader);
	    // dc.findAndBindProgram(BasicTextureProgram);
	    gl.enableVertexAttribArray(dc.currentProgram.vertexPointLocation);
	    // gl.enableVertexAttribArray(dc.currentProgram.normalVectorLocation);
	    var applyLighting = !dc.pickMode && this.activeAttributes.applyLighting;
	    if (applyLighting) {
	        dc.currentProgram.loadModelviewInverse(gl, dc.navigatorState.modelviewNormalTransform);
	    }

	};

	AbstractPrimitive.prototype.endDrawing = function (dc) {
	    var gl = dc.currentGlContext;
	    var p = dc.currentProgram;
	    p.vertexPointLocation > -1 && gl.disableVertexAttribArray(p.vertexPointLocation);
	    p.normalVectorLocation > -1 && gl.disableVertexAttribArray(p.normalVectorLocation);
	    p.groundPointsLocation > -1 && gl.disableVertexAttribArray(p.groundPointsLocation);
	    gl.depthMask(true);
	    gl.lineWidth(1);
	    // gl.getParameter(gl.POLYGON_OFFSET_FACTOR); // 2
	    // gl.getParameter(gl.POLYGON_OFFSET_UNITS);
	    gl.enable(gl.CULL_FACE);
	};




	module.exports = AbstractPrimitive;


/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports AbstractShape
	 * @version $Id: AbstractShape.js 3259 2015-06-25 00:53:55Z tgaskins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(30),
	        __webpack_require__(32),
	        __webpack_require__(63),
	        __webpack_require__(53),
	        __webpack_require__(130),
	        __webpack_require__(132),
	        __webpack_require__(66),
	        __webpack_require__(35)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
	              Logger,
	              Matrix,
	              MemoryCache,
	              Renderable,
	              ShapeAttributes,
	              UnsupportedOperationError,
	              Vec3) {
	        "use strict";

	        /**
	         * Constructs an abstract shape instance. Meant to be called only by subclasses.
	         * @alias AbstractShape
	         * @constructor
	         * @augments Renderable
	         * @protected
	         * @classdesc Provides a base class for shapes other than surface shapes. Implements common attribute handling
	         * and rendering flow. This is an abstract class and is meant to be instantiated only by subclasses.
	         * <p>
	         *     In order to support simultaneous use of this shape by multiple windows and 2D globes, this shape
	         *     maintains a cache of data computed relative to the globe displayed in each window. During rendering,
	         *     the data for the currently active globe, as indicated in the draw context, is made current.
	         *     Subsequently called methods rely on the existence of this data cache entry.
	         *
	         * @param {ShapeAttributes} attributes The attributes to associate with this shape. May be null, in which case
	         * default attributes are associated.
	         */
	        var AbstractShape = function (attributes) {

	            Renderable.call(this);

	            // Documented with its property accessor below.
	            this._attributes = attributes ? attributes : new ShapeAttributes(null);

	            // Documented with its property accessor below.
	            this._highlightAttributes = null;

	            /**
	             * Indicates whether this shape uses its normal attributes or its highlight attributes when displayed.
	             * If true, the highlight attributes are used, otherwise the normal attributes are used. The normal
	             * attributes are also used if no highlight attributes have been specified.
	             * @type {Boolean}
	             * @default false
	             */
	            this.highlighted = false;

	            // Private. See defined property below for documentation.
	            this._altitudeMode = WorldWind.ABSOLUTE;

	            // Internal use only. Intentionally not documented.
	            // A position used to compute relative coordinates for the shape.
	            this.referencePosition = null;

	            // Internal use only. Intentionally not documented.
	            // Holds the per-globe data generated during makeOrderedRenderable.
	            this.shapeDataCache = new MemoryCache(3, 2);

	            // Internal use only. Intentionally not documented.
	            // The shape-data-cache data that is for the currently active globe. This field is made current prior to
	            // calls to makeOrderedRenderable and doRenderOrdered.
	            this.currentData = null;

	            // Internal use only. Intentionally not documented.
	            this.activeAttributes = null;

	            /**
	             * Indicates how long to use terrain-specific shape data before regenerating it, in milliseconds. A value
	             * of zero specifies that shape data should be regenerated every frame. While this causes the shape to
	             * adapt more frequently to the terrain, it decreases performance.
	             * @type {Number}
	             * @default 2000 (milliseconds)
	             */
	            this.expirationInterval = 2000;

	            /**
	             * Indicates whether to use a surface shape to represent this shape when drawn on a 2D globe.
	             * @type {Boolean}
	             * @default false
	             */
	            this.useSurfaceShapeFor2D = false;

	            this.scratchMatrix = Matrix.fromIdentity(); // scratch variable
	        };

	        AbstractShape.prototype = Object.create(Renderable.prototype);

	        Object.defineProperties(AbstractShape.prototype, {
	            /**
	             * This shape's normal (non-highlight) attributes.
	             * @type {ShapeAttributes}
	             * @memberof AbstractShape.prototype
	             */
	            attributes: {
	                get: function () {
	                    return this._attributes;
	                },
	                set: function (value) {
	                    this._attributes = value;

	                    if (this.surfaceShape) {
	                        this.surfaceShape.attributes = this._attributes;
	                    }
	                }
	            },

	            /**
	             * This shape's highlight attributes. If null or undefined and this shape's highlight flag is true, this
	             * shape's normal attributes are used. If they in turn are null or undefined, this shape is not drawn.
	             * @type {ShapeAttributes}
	             * @default null
	             * @memberof AbstractShape.prototype
	             */
	            highlightAttributes: {
	                get: function () {
	                    return this._highlightAttributes;
	                },
	                set: function (value) {
	                    this._highlightAttributes = value;

	                    if (this.surfaceShape) {
	                        this.surfaceShape.highlightAttributes = this._highlightAttributes;
	                    }
	                }
	            },

	            /**
	             * The altitude mode to use when drawing this shape. Recognized values are:
	             * <ul>
	             *     <li>[WorldWind.ABSOLUTE]{@link WorldWind#ABSOLUTE}</li>
	             *     <li>[WorldWind.RELATIVE_TO_GROUND]{@link WorldWind#RELATIVE_TO_GROUND}</li>
	             *     <li>[WorldWind.CLAMP_TO_GROUND]{@link WorldWind#CLAMP_TO_GROUND}</li>
	             * </ul>
	             * @type {String}
	             * @default WorldWind.ABSOLUTE
	             * @memberof AbstractShape.prototype
	             */
	            altitudeMode: {
	                get: function () {
	                    return this._altitudeMode;
	                },
	                set: function (altitudeMode) {
	                    if (!altitudeMode) {
	                        throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "AbstractShape",
	                            "altitudeMode", "missingAltitudeMode"));
	                    }

	                    this._altitudeMode = altitudeMode;
	                    this.reset();
	                }
	            }
	        });

	        /**
	         * Clears this shape's data cache. Should be called by subclasses when state changes invalidate
	         * cached data.
	         * @protected
	         */
	        AbstractShape.prototype.reset = function () {
	            this.shapeDataCache.clear(false);
	            this.surfaceShape = null;
	        };

	        AbstractShape.prototype.updateSurfaceShape = function () {
	            // Synchronize this AbstractShape's properties with its SurfaceShape's properties. Note that the attributes
	            // and the highlightAttributes are synchronized separately.
	            this.surfaceShape.displayName = this.displayName;
	            this.surfaceShape.highlighted = this.highlighted;
	            this.surfaceShape.enabled = this.enabled;
	            this.surfaceShape.pathType = this.pathType;
	            this.surfaceShape.pickDelegate = this.pickDelegate ? this.pickDelegate : this;
	        };

	        AbstractShape.prototype.createSurfaceShape = function () {
	            return null;
	        };

	        AbstractShape.prototype.render = function (dc) {
	            if (!this.enabled) {
	                return;
	            }

	            if (!dc.accumulateOrderedRenderables) {
	                return;
	            }

	            if (dc.globe.is2D() && this.useSurfaceShapeFor2D) {
	                if (!this.surfaceShape) {
	                    this.surfaceShape = this.createSurfaceShape();
	                    if (this.surfaceShape) {
	                        this.surfaceShape.attributes = this._attributes;
	                        this.surfaceShape.highlightAttributes = this._highlightAttributes;
	                    }
	                }

	                if (this.surfaceShape) {
	                    this.updateSurfaceShape();
	                    this.surfaceShape.render(dc);
	                    return;
	                }
	            }

	            if (!dc.terrain && (this.altitudeMode != WorldWind.ABSOLUTE)) {
	                return;
	            }

	            this.establishCurrentData(dc);

	            if (dc.globe.projectionLimits && !this.isWithinProjectionLimits(dc)) {
	                return;
	            }

	            // Use the last computed extent to see if this shape is out of view.
	            if (this.currentData.extent && !this.intersectsFrustum(dc)) {
	                return;
	            }

	            this.determineActiveAttributes(dc);
	            if (!this.activeAttributes) {
	                return;
	            }

	            var orderedRenderable = this.makeOrderedRenderable(dc);
	            if (orderedRenderable) {

	                // Use the updated extent to see if this shape is out of view.
	                if (!this.intersectsFrustum(dc)) {
	                    return;
	                }

	                if (dc.isSmall(this.currentData.extent, 1)) {
	                    return;
	                }

	                orderedRenderable.layer = dc.currentLayer;
	                dc.addOrderedRenderable(orderedRenderable, this.currentData.eyeDistance);
	            }
	        };

	        /**
	         * Draws this shape during ordered rendering. Implements the {@link OrderedRenderable} interface.
	         * This method is called by the World Window and is not intended to be called by applications.
	         * @param {DrawContext} dc The current draw context.
	         */
	        AbstractShape.prototype.renderOrdered = function (dc) {
	            this.currentData = this.shapeDataCache.entryForKey(dc.globeStateKey);

	            this.beginDrawing(dc);
	            try {
	                this.doRenderOrdered(dc);
	            } finally {
	                this.endDrawing(dc);
	            }
	        };

	        // Internal. Intentionally not documented.
	        AbstractShape.prototype.makeOrderedRenderable = function (dc) {
	            var or = this.doMakeOrderedRenderable(dc);
	            this.currentData.verticalExaggeration = dc.verticalExaggeration;

	            return or;
	        };

	        /**
	         * Called during rendering. Subclasses must override this method with one that creates and enques an
	         * ordered renderable for this shape if this shape is to be displayed. Applications do not call this method.
	         * @param {DrawContext} dc The current draw context.
	         * @protected
	         */
	        AbstractShape.prototype.doMakeOrderedRenderable = function (dc) {
	            throw new UnsupportedOperationError(
	                Logger.logMessage(Logger.LEVEL_SEVERE, "AbstractShape", "makeOrderedRenderable", "abstractInvocation"));
	        };

	        /**
	         * Called during ordered rendering. Subclasses must override this method to render the shape using the current
	         * shape data.
	         * @param {DrawContext} dc The current draw context.
	         * @protected
	         */
	        AbstractShape.prototype.doRenderOrdered = function (dc) {
	            throw new UnsupportedOperationError(
	                Logger.logMessage(Logger.LEVEL_SEVERE, "AbstractShape", "doRenderOrdered", "abstractInvocation"));
	        };

	        /**
	         * Called during ordered rendering. Subclasses may override this method in order to perform operations prior
	         * to drawing the shape. Applications do not call this method.
	         * @param {DrawContext} dc The current draw context.
	         * @protected
	         */
	        AbstractShape.prototype.beginDrawing = function (dc) {
	        };

	        /**
	         * Called during ordered rendering. Subclasses may override this method in order to perform operations after
	         * the shape is drawn. Applications do not call this method.
	         * @param {DrawContext} dc The current draw context.
	         * @protected
	         */
	        AbstractShape.prototype.endDrawing = function (dc) {
	        };

	        // Internal. Intentionally not documented.
	        AbstractShape.prototype.intersectsFrustum = function (dc) {
	            if (this.currentData && this.currentData.extent) {
	                if (dc.pickingMode) {
	                    return this.currentData.extent.intersectsFrustum(dc.pickFrustum);
	                } else {
	                    return this.currentData.extent.intersectsFrustum(dc.navigatorState.frustumInModelCoordinates);
	                }
	            } else {
	                return true;
	            }
	        };

	        // Internal. Intentionally not documented.
	        AbstractShape.prototype.establishCurrentData = function (dc) {
	            this.currentData = this.shapeDataCache.entryForKey(dc.globeStateKey);
	            if (!this.currentData) {
	                this.currentData = this.createShapeDataObject();
	                this.resetExpiration(this.currentData);
	                this.shapeDataCache.putEntry(dc.globeStateKey, this.currentData, 1);
	            }

	            this.currentData.isExpired = !this.isShapeDataCurrent(dc, this.currentData);
	        };

	        /**
	         * Creates a new shape data object for the current globe state. Subclasses may override this method to
	         * modify the shape data object that this method creates, but must also call this method on this base class.
	         * Applications do not call this method.
	         * @returns {Object} The shape data object.
	         * @protected
	         */
	        AbstractShape.prototype.createShapeDataObject = function () {
	            return {
	                transformationMatrix: Matrix.fromIdentity(),
	                referencePoint: new Vec3(0, 0, 0)
	            };
	        };

	        // Intentionally not documented.
	        AbstractShape.prototype.resetExpiration = function (shapeData) {
	            // The random addition in the line below prevents all shapes from regenerating during the same frame.
	            shapeData.expiryTime = Date.now() + this.expirationInterval + 1e3 * Math.random();
	        };

	        /**
	         * Indicates whether a specified shape data object is current. Subclasses may override this method to add
	         * criteria indicating whether the shape data object is current, but must also call this method on this base
	         * class. Applications do not call this method.
	         * @param {DrawContext} dc The current draw context.
	         * @param {Object} shapeData The object to validate.
	         * @returns {Boolean} true if the object is current, otherwise false.
	         * @protected
	         */
	        AbstractShape.prototype.isShapeDataCurrent = function (dc, shapeData) {
	            return shapeData.verticalExaggeration === dc.verticalExaggeration
	                && shapeData.expiryTime > Date.now();
	        };

	        // Internal. Intentionally not documented.
	        AbstractShape.prototype.determineActiveAttributes = function (dc) {
	            if (this.highlighted && this._highlightAttributes) {
	                this.activeAttributes = this.highlightAttributes;
	            } else {
	                this.activeAttributes = this._attributes;
	            }
	        };

	        /**
	         * Indicates whether this shape is within the current globe's projection limits. Subclasses may implement
	         * this method to perform the test. The default implementation returns true. Applications do not call this
	         * method.
	         * @param {DrawContext} dc The current draw context.
	         * @returns {Boolean} true if this shape is is within or intersects the current globe's projection limits,
	         * otherwise false.
	         * @protected
	         */
	        AbstractShape.prototype.isWithinProjectionLimits = function (dc) {
	            return true;
	        };

	        /**
	         * Apply the current navigator's model-view-projection matrix.
	         * @param {DrawContext} dc The current draw context.
	         * @protected
	         */
	        AbstractShape.prototype.applyMvpMatrix = function (dc) {
	            this.scratchMatrix.copy(dc.navigatorState.modelviewProjection);
	            this.scratchMatrix.multiplyMatrix(this.currentData.transformationMatrix);
	            dc.currentProgram.loadModelviewProjection(dc.currentGlContext, this.scratchMatrix);
	        };

	        /**
	         * Apply the current navigator's model-view-projection matrix with an offset to make this shape's outline
	         * stand out.
	         * @param {DrawContext} dc The current draw context.
	         * @protected
	         */
	        AbstractShape.prototype.applyMvpMatrixForOutline = function (dc) {
	            // Causes the outline to stand out from the interior.
	            this.scratchMatrix.copy(dc.navigatorState.projection);
	            this.scratchMatrix.offsetProjectionDepth(-0.001);
	            this.scratchMatrix.multiplyMatrix(dc.navigatorState.modelview);
	            this.scratchMatrix.multiplyMatrix(this.currentData.transformationMatrix);
	            dc.currentProgram.loadModelviewProjection(dc.currentGlContext, this.scratchMatrix);
	        };

	        return AbstractShape;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 148 */
/***/ (function(module, exports) {

	
	var Generalization = function (generalization) {
	    if (generalization) {
	        this.interpolate = generalization.interpolate;
	        this.scales = generalization.scales;
	        this.baseScale = generalization.baseScale;
	    }
	};

	module.exports = Generalization;

	Generalization.prototype.isVisible = function (eyeDistance) {
	    if (!this.scales) return true;
	    var range = this.findRange(eyeDistance);
	    return range[0].visible || range[1].visible;
	};

	Generalization.prototype.getScale = function(eyeDistance) {
	    if (!this.scales) return 1;
	    var range = this.findRange(eyeDistance);
	    var amount = (eyeDistance - range[0].scale)/(range[1].scale - range[0].scale);
	    return lerp(amount === Infinity ? 1 : amount, range[0].ratio, range[1].ratio);
	};

	Generalization.prototype.findRange = function(eyeDistance) {
	    var from = this.scales[0];
	    var to = this.scales[this.scales.length - 1];
	    this.scales.forEach(function (s) {
	        if (s.scale < eyeDistance && s.scale > from.scale) from = s;
	        if (s.scale > eyeDistance && s.scale < to.scale) to = s;
	    });
	    return [from, to];
	};

	function lerp(amount, value1, value2) {
	    return (1 - amount) * value1 + amount * value2;
	}

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports SurfacePolyline
	 * @version $Id: SurfacePolyline.js 3014 2015-04-14 01:06:17Z danm $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(30),
	        __webpack_require__(32),
	        __webpack_require__(132),
	        __webpack_require__(131)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
	              Logger,
	              ShapeAttributes,
	              SurfaceShape) {
	        "use strict";

	        /**
	         * Constructs a surface polyline.
	         * @alias SurfacePolyline
	         * @constructor
	         * @augments SurfaceShape
	         * @classdesc Represents a polyline draped over the terrain surface.
	         * <p>
	         * SurfacePolyline uses the following attributes from its associated shape attributes bundle:
	         * <ul>
	         *         <li>Draw outline</li>
	         *         <li>Outline color</li>
	         *         <li>Outline width</li>
	         *         <li>Outline stipple factor</li>
	         *         <li>Outline stipple pattern</li>
	         * </ul>
	         * @param {Location[]} locations This polyline's locations.
	         * @param {ShapeAttributes} attributes The attributes to apply to this shape. May be null, in which case
	         * attributes must be set directly before the shape is drawn.
	         * @throws {ArgumentError} If the specified locations are null or undefined.
	         */
	        var SurfacePolyline = function (locations, attributes) {
	            if (!locations) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "SurfacePolyline", "constructor",
	                        "The specified locations array is null or undefined."));
	            }

	            SurfaceShape.call(this, attributes);

	            /**
	             * This shape's locations, specified as an array locations.
	             * @type {Array}
	             */
	            this._boundaries = locations;

	            // Internal use only.
	            this._isInteriorInhibited = true;
	        };

	        SurfacePolyline.prototype = Object.create(SurfaceShape.prototype);

	        // Internal use only. Intentionally not documented.
	        SurfacePolyline.staticStateKey = function(shape) {
	            var shapeStateKey = SurfaceShape.staticStateKey(shape);

	            return shapeStateKey;
	        };

	        // Internal use only. Intentionally not documented.
	        SurfacePolyline.prototype.computeStateKey = function() {
	            return SurfacePolyline.staticStateKey(this);
	        };

	        return SurfacePolyline;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

	var Renderable = __webpack_require__(130);
	var Color = __webpack_require__(52);
	var Offset = __webpack_require__(45);
	var Position = __webpack_require__(47);
	var Location = __webpack_require__(28);
	var Vec3 = __webpack_require__(35);
	var Matrix = __webpack_require__(63);
	var ScreenSpaceLineProgram = __webpack_require__(151);
	var PrimitivesMath = __webpack_require__(152);

	var CocoMath = __webpack_require__(153);
	var Events = __webpack_require__(5);

	var pixelPerSegment = 8;
	var scratchPosition = new Position(0, 0, 0);
	var overlayHeight, accumulatedSegments = {};
	var engineCanvas = document.getElementById('canvas');
	var overlaySvg = document.getElementById('overlaySvg');

	adjust();

	window.addEventListener('resize', adjust);

	engine._redrawCallbacks.push(function(earth, type) {
	    if (type === WorldWind.BEFORE_REDRAW) {
	        //overlaySvg.innerHTML = '';
	        accumulatedSegments = {};
	    } else if (type === WorldWind.AFTER_REDRAW) {
	        drawAccumulatedSegments(earth.drawContext);
	    }
	});

	var ScreenSpacePath = function (points, color, width, lineJoin, miterLimit) {
	    Renderable.call(this);
	    this.enabled = true;
	    this.positions = points;
	    this.expirationPeriod = 2000;
	    this.tessellated = null;
	    this.timestamp = null;
	    this.properties = {
	        opacity: 1,
	        color: color ? Color.colorFromHex(color + 'ff') : Color.WHITE,
	        width: width || 1,
	        lineJoin: lineJoin || null,
	        miterLimit: miterLimit || 3
	    }
	};

	ScreenSpacePath.prototype = Object.create(Renderable.prototype);

	ScreenSpacePath.prototype.makeTessellatedPositionsIfNeeded = function (dc) {

	    if (Date.now() - this.timestamp < this.expirationPeriod) return;

	    this.tessellated = [];
	    this.timestamp = Date.now();
	    var ns = dc.navigatorState;
	    var posA = this.positions[0], posB;
	    var ptA = new Vec3(0, 0, 0);
	    var ptB = new Vec3(0, 0, 0);

	    blh2xyz(dc, posA, ptA);

	    for (var i = 1; i < this.positions.length; i++) {
	        posB = this.positions[i];
	        blh2xyz(dc, posB, ptB);
	        var radius = dc.globe.radiusAt(posB.latitude, posB.longitude);
	        var radians = Location.greatCircleDistance(posA, posB);
	        var distance = radians * radius;
	        var currentPosition = 0;
	        if (this.tessellated.length === 0) {
	            this.tessellated.push(posA); // only needed for first segment
	        }
	        if (distance > pixelSizeAt(ptB) * pixelPerSegment) {
	            var nextPt = ptA;
	            while (currentPosition < distance) {
	                currentPosition += pixelSizeAt(nextPt) * pixelPerSegment;
	                var nextPos = new Position(0, 0, 0);
	                Location.interpolateGreatCircle(currentPosition/distance, posA, posB, nextPos);
	                this.tessellated.push(nextPos);
	                blh2xyz(dc, nextPos, nextPt);
	            }
	        } else {
	            this.tessellated.push(posB); // close if no tessellation needed
	        }
	        this.tessellated[this.tessellated.length - 1].isLast = true;
	        posA = posB;
	    }

	    function pixelSizeAt(pt) {
	        return ns.pixelSizeAtDistance(ns.eyePoint.distanceTo(pt));
	    }
	};

	ScreenSpacePath.prototype.render = function (dc) {
	    var pts = this.positions;
	    if (!this.enabled || this.opacity <= 0 || dc.pickingMode || !Array.isArray(pts) || pts.length < 2) {
	        return;
	    }
	    if (!this.tessellated || Date.now() - this.timestamp > this.expirationPeriod) {
	        this.makeTessellatedPositionsIfNeeded(dc);
	    }
	    var segments = [];
	    var currentSegment = [];
	    for (var i = 0; i < this.tessellated.length; i++) {
	        addPoint(this.tessellated[i]);
	    }
	    pushSegment();
	    accumulateSegments(segments, this.properties);

	    function addPoint(point) {
	        var pos = getScreenSpacePointPosition(dc, point);
	        if (pos) {
	            if (currentSegment.length > 0) {
	                var prev = currentSegment[currentSegment.length - 1];
	                var dist = distanceBetweenPoints2D(prev, pos);
	                if (!point.isLast && dist < pixelPerSegment / 2) {
	                    return;
	                }
	            }
	            currentSegment.push(pos);
	        } else {
	            pushSegment();
	        }
	    }

	    function pushSegment() {
	        if (currentSegment.length >= 2) {
	            segments.push(currentSegment);
	        }
	        currentSegment = [];
	    }
	};

	module.exports = ScreenSpacePath;

	function drawAccumulatedSegments(dc) {
	    for (var key in accumulatedSegments) {
	        if (accumulatedSegments.hasOwnProperty(key)) {
	            //drawBucket(dc, accumulatedSegments[key]);
	            drawBucketGL(dc, accumulatedSegments[key]);
	        }
	    }
	}

	function accumulateSegments(segments, props) {
	    var key =
	        props.color.red + '_' +
	        props.color.green + '_' +
	        props.color.blue + '_' +
	        props.width + '_' +
	        props.lineJoin + '_' +
	        props.miterLimit;

	    if (!accumulatedSegments.hasOwnProperty(key)) {
	        accumulatedSegments[key] = {
	            segments: [],
	            width: props.width,
	            lineJoin: props.lineJoin,
	            miterLimit: props.miterLimit,
	            color: props.color,
	            key: key
	        }
	    }
	    var bucket = accumulatedSegments[key];
	    bucket.segments = bucket.segments.concat(segments);
	}

	function distanceBetweenPoints2D(p, q) {
	    var dx = p[0] - q[0];
	    var dy = p[1] - q[1];
	    return Math.sqrt( dx*dx + dy*dy );
	}

	function blh2xyz(dc, blh, xyz) {
	    return dc.surfacePointForMode(blh.latitude, blh.longitude, blh.altitude, WorldWind.RELATIVE_TO_GROUND, xyz);
	}

	function getScreenSpacePointPosition(dc, pt) {
	    if (!pt) return;
	    var result = [];
	    if (pt.latitude) {
	        var alt = dc.globe.elevationAtLocation(pt.latitude, pt.longitude);
	        dc.globe.computePointFromPosition(pt.latitude, pt.longitude, pt.altitude || alt, scratchPosition);
	    } else {
	        scratchPosition = pt;
	    }
	    var ns = dc.navigatorState;
	    var frustum = ns.frustumInModelCoordinates;
	    if (!frustum.containsPoint(scratchPosition))
	        return;
	    if (CocoMath.isHorizonOccluded(dc, scratchPosition)) return;
	    if (!ns.project(scratchPosition, result)) return;
	    return result;
	}

	function adjust(){
	    var h = engineCanvas.clientHeight;
	    var w = engineCanvas.clientWidth;
	    overlayHeight = h;
	    overlaySvg.setAttribute('width', w);
	    overlaySvg.setAttribute('height', h);
	    overlaySvg.setAttribute('viewBox', '0 0 ' + w + ' ' + h);
	}

	/////// svg

	function drawBucket(dc, bucket) {
	    var d = '';

	    bucket.segments.forEach(function (segment) {
	        for (var x = 0; x < segment.length; x++) {
	            d += pt2svgCmd(x === 0, segment[x]);
	        }
	    });

	    if (d.length) {
	        overlaySvg.innerHTML += '<path fill="none" ' +
	            'stroke-width="' + bucket.width + '" ' +
	            'stroke="#' + bucket.color + '" ' +
	            'd="' + d + '"/>';
	    }
	}

	function pt2svgCmd(move, pt) {
	    var cmd = move ? ' M' : ' L';
	    var X = pt[0].toFixed(2);
	    var Y = (overlayHeight - pt[1]).toFixed(2);
	    return cmd + X + ',' + Y;
	}

	/////// webgl

	var scratchMatrix = Matrix.fromIdentity();

	function drawBucketGL(dc, bucket){
	    beginDrawing(dc);
	    try {
	        renderBucket(dc, bucket);
	    } finally {
	        endDrawing(dc);
	    }
	}

	function beginDrawing(dc) {
	    var gl = dc.currentGlContext;
	    dc.findAndBindProgram(ScreenSpaceLineProgram);
	    var program = dc.currentProgram;
	    gl.bindBuffer(gl.ARRAY_BUFFER, dc.unitQuadBuffer());
	    gl.enableVertexAttribArray(program.vertexPointLocation);

	    gl.enable(gl.BLEND);
	    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
	}

	function endDrawing(dc) {
	    var gl = dc.currentGlContext;
	    gl.disableVertexAttribArray(dc.currentProgram.vertexPointLocation);
	    gl.bindBuffer(gl.ARRAY_BUFFER, null);
	}

	function renderBucket(dc, bucket) {
	    var gl = dc.currentGlContext;
	    var program = dc.currentProgram;

	    var imageTransform = Matrix.fromIdentity();

	    var w = dc.navigatorState.viewport.width;
	    var h = dc.navigatorState.viewport.height;

	    imageTransform.setScale(w, h, 1);

	    var vertexCount = bindVertexBufferData(dc, bucket);
	    if (!vertexCount) return;
	    gl.vertexAttribPointer(program.vertexPointLocation, 4, gl.FLOAT, false, 0, 0);

	    scratchMatrix.copy(dc.screenProjection);
	    scratchMatrix.multiplyMatrix(imageTransform);

	    program.loadModelviewProjection(gl, scratchMatrix);
	    program.loadColor(gl, bucket.color);
	    program.loadOpacity(gl, bucket.opacity);
	    program.loadAspectRatio(gl, w/h);

	    gl.drawArrays(gl.TRIANGLES, 0, vertexCount);

	    // debug
	    // program.loadColor(gl, Color.WHITE);
	    // gl.drawArrays(gl.LINES, 0, vertexCount);
	}

	function bindVertexBufferData(dc, bucket) {
	    var gl = dc.currentGlContext;
	    var points = convertLineBucketToSetOfTriangles(dc, bucket);
	    var pointsArray = new Float32Array(points.length * 4);
	    var index = 0;
	    points.forEach(function(pt) {
	        pointsArray[index] = pt[0];     // x
	        pointsArray[index + 1] = pt[1]; // y
	        pointsArray[index + 2] = pt[2]; // angle
	        pointsArray[index + 3] = pt[3]; // amount
	        index += 4;
	    });
	    gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
	    gl.bufferData(gl.ARRAY_BUFFER, pointsArray, gl.STATIC_DRAW);
	    return points.length;
	}

	function getPoint(segment, index) {
	    if (index >= 0 && index < segment.length) return segment[index];
	}

	function lineDir(p, s) {
	    return PrimitivesMath.lineDirection(p, s);
	}

	function ptShiftDir(d0, d1, isLeft) {
	    return PrimitivesMath.pointShiftDirection(d0, d1, isLeft);
	}

	function invertDir(d){
	    return PrimitivesMath.invertDirection(d);
	}

	function dirAngle(d0, d1){
	    return PrimitivesMath.angleBetweenDirections(d0, d1);
	}

	function convertLineBucketToSetOfTriangles(dc, bucket) {
	    var lineJoin = bucket.lineJoin;
	    var points = [];
	    bucket.segments.forEach(handleSegment);
	    return points;

	    function addPoint(pt, angle, amount) {
	        points.push([
	            pt[0] / dc.navigatorState.viewport.width, // x
	            pt[1] / dc.navigatorState.viewport.height, // y
	            angle, // угол поворота вектора смещения точки, если больше 360 точка не смещается
	            amount // дистанция на которую сместится точка (доля от радиуса)
	        ]);
	    }

	    function addTriangle(pt, d1, d2, shift) {
	        addPoint(pt, 0, 0);
	        addPoint(pt, d1, 1);
	        addPoint(pt, d2, shift);
	    }

	    function addSector(pt, dFrom, dTo) {
	        var from = Math.min(dFrom, dTo);
	        var to = Math.max(dFrom, dTo);
	        if (to - from > 180) {
	            from += 360;
	            // swap variables
	            from = from ^ to;
	            to = from ^ to;
	            from = from ^ to;
	        }
	        for (var i = from; i < to; i += 10) {
	            var dir = i + 10;
	            dir = dir > to ? to : dir;
	            addTriangle(pt, i, dir, 1);
	        }
	    }

	    function join(point, segmentSideDir, bisectDir, isLeft) {
	        if (lineJoin === 'round') {
	            addSector(point, segmentSideDir, bisectDir, 1);
	        } else if (lineJoin !== null) {
	            var deg = dirAngle(segmentSideDir, bisectDir);
	            if (deg > 90) deg = 180 - deg;
	            if (deg < -90) deg = - 180 - deg;
	            var alpha = PrimitivesMath.deg2rad(deg);
	            var cosAlpha = Math.cos(alpha);
	            if (lineJoin === 'bevel') {
	                addTriangle(point, segmentSideDir, bisectDir, cosAlpha);
	            }
	            if (lineJoin === 'miter') {
	                var m = 2;
	                if (1/cosAlpha > m) {
	                    var sign = isLeft ? 1 : -1;
	                    if (sign + Math.sign(alpha) === 0) {
	                        sign *= -1;
	                    }

	                    var x = Math.tan(Math.PI/2 - alpha)*(1/Math.cos(alpha) - m);
	                    x = Math.sqrt(x*x + m*m);
	                    var d2 = bisectDir - sign * PrimitivesMath.rad2deg(Math.acos(m/x));

	                    addTriangle(point, segmentSideDir, d2, x);
	                    addPoint(point, 0, 0);
	                    addPoint(point, bisectDir, m);
	                    addPoint(point, d2, x);

	                } else {
	                    addTriangle(point, segmentSideDir, bisectDir, 1/cosAlpha);
	                }
	            }
	        }
	    }

	    function handleLineJoin(seg0dir, seg1dir, point, ptLeftDir, ptRightDir, maxAngle, isLeft) {
	        var slope = dirAngle(seg0dir, seg1dir);

	        if (Math.abs(slope) > maxAngle) {
	            var direction = ptShiftDir(seg1dir, seg0dir);
	            if (slope > maxAngle) join(point, ptLeftDir, direction, isLeft);
	            if (slope < -maxAngle) join(point, ptRightDir, invertDir(direction), isLeft);
	        }
	    }

	    function handleSegment(segment) {
	        var end = segment.length - 2;
	        for (var i = 0; i <= end; i++) {
	            var p = getPoint(segment, i - 1); // previous line left point (null for first line in segment)
	            var s = getPoint(segment, i);     // current line start point
	            var e = getPoint(segment, i + 1); // current line end point
	            var n = getPoint(segment, i + 2); // next line right point (null for last line in segment)

	            var pd = lineDir(p, s); // previous line direction  (null for first line in segment)
	            var cd = lineDir(s, e); // current line direction
	            var nd = lineDir(e, n); // next line direction (null for last line in segment)

	            // calc points shift direction in angles (shifting performed by shader)
	            var sl = ptShiftDir(pd, cd, true);  // start left point shift direction
	            var sr = invertDir(sl);             // start right point shift direction
	            var el = ptShiftDir(cd, nd, false); // end left point shift direction
	            var er = invertDir(el);             // end right point shift direction

	            if (i !== end) handleLineJoin(nd, cd, e, sl, er, 45, true);
	                                                                         // el  el er
	            addPoint(s, sl, 1); addPoint(s, sr, 1); addPoint(e, el, 1);  //  *   *-*
	                                                                         //  |\   \|
	            addPoint(s, sr, 1); addPoint(e, el, 1); addPoint(e, er, 1);  //  *-*   *
	                                                                         // sl sr  sr
	            if (i !== 0) handleLineJoin(cd, pd, s, el, sr, 45, false);
	        }
	    }
	}

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

	var ArgumentError = __webpack_require__(30);
	var Color = __webpack_require__(52);
	var GpuProgram = __webpack_require__(81);
	var Logger = __webpack_require__(32);

	var vertexShaderSource =
	    'attribute vec4 vertexPoint;\n' + // x, y, dir, shift
	    'uniform mat4 mvpMatrix;\n' +
	    'uniform float aspectRatio;\n' +
	    //'varying float distance;\n' +
	    'varying float join;\n' +
	    'const float width = 0.002;\n' +
	    'void main() {\n' +
	    '   vec4 p = vertexPoint;\n' +
	    '   float angle = p.z / 180.0 * 3.1416;\n' +
	    '   float shift = p.w;\n' +
	    '   p.z = 0.0;\n' +
	    '   p.w = 1.0;\n' +
	    //'   distance = sign(angle) * 1.0;\n' +
	    '   join = 1.0;\n' +
	    '   if (shift > 0.0) {\n' +
	    '       join = 0.0;\n' +
	    '       p.x += cos(angle) * width * shift;\n' +
	    '       p.y += sin(angle) * width * shift * aspectRatio;\n' +
	    '   }\n' +
	    '   gl_Position = mvpMatrix * p;\n' +
	    '}';

	var fragmentShaderSource =
	        'precision mediump float;\n' +
	        'uniform float opacity;\n' +
	        'varying float distance;\n' +
	        'varying float join;\n' +
	        'uniform vec4 color;\n' +
	        'void main() {\n' +
	        '   gl_FragColor = color;\n' +
	        //'   if (join > 0.0) {gl_FragColor.b = 1.0;gl_FragColor.r = 0.0;} gl_FragColor.a = 0.9;\n' +
	        '   if (opacity == 0.0) {discard;}\n' +
	        //'   gl_FragColor.a = opacity * (1.0 - abs(distance));\n' +
	        '}';

	var ScreenSpaceLineProgram = function (gl) {
	    var bindings = ["vertexPoint"];
	    GpuProgram.call(this, gl, vertexShaderSource, fragmentShaderSource, bindings);
	    // тут третий компонент содержит угол поворота вектора смещения точки в экранной плоскости
	    this.vertexPointLocation = this.attributeLocation(gl, "vertexPoint");
	    this.mvpMatrixLocation = this.uniformLocation(gl, "mvpMatrix");
	    this.colorLocation = this.uniformLocation(gl, "color");
	    this.opacityLocation = this.uniformLocation(gl, "opacity");
	    this.aspectRatioLocation = this.uniformLocation(gl, "aspectRatio");
	};

	ScreenSpaceLineProgram.prototype = Object.create(GpuProgram.prototype);

	ScreenSpaceLineProgram.key = "ScreenSpaceLineGpuProgram";

	ScreenSpaceLineProgram.prototype.loadModelviewProjection = function (gl, matrix) {
	    this.loadUniformMatrix(gl, matrix, this.mvpMatrixLocation);
	};

	ScreenSpaceLineProgram.prototype.loadColor = function (gl, color) {
	    this.loadUniformColor(gl, color, this.colorLocation);
	};

	ScreenSpaceLineProgram.prototype.loadOpacity = function (gl, opacity) {
	    gl.uniform1f(this.opacityLocation, opacity);
	};

	ScreenSpaceLineProgram.prototype.loadAspectRatio = function (gl, aspectRatio) {
	    gl.uniform1f(this.aspectRatioLocation, aspectRatio);
	};

	module.exports = ScreenSpaceLineProgram;

/***/ }),
/* 152 */
/***/ (function(module, exports) {

	module.exports = {
	    lineDirection: lineDirection,
	    pointShiftDirection: pointShiftDirection,
	    invertDirection: invertDirection,
	    angleBetweenDirections: angleBetweenDirections,
	    normalizeAngle: normalizeAngle,
	    deg2rad: deg2rad,
	    rad2deg: rad2deg
	};

	function normalizeAngle(angle) {
	    if (angle < -180) return angle + 360;
	    if (angle > 180) return angle - 360;
	    return angle;
	}

	function angleBetweenDirections(d0, d1) {
	    return normalizeAngle(d1 - d0);
	}

	function invertDirection(d) {
	    return d > 0 ? d - 180 : d + 180;
	}

	// clamped from -180 to 180
	function lineDirection(a, b) {
	    if (!a || !b) return null;
	    var x = b[0] - a[0];
	    var y = b[1] - a[1];
	    return rad2deg(Math.atan2(y, x));
	}

	// угол поворота вектора смещения точки
	function pointShiftDirection(d0, d1, isLeft) {
	    var result;
	    if (isLeft != null && Math.abs(angleBetweenDirections(d1, d0)) > 45)
	        result = (isLeft ? d1 : d0) + 90;
	    else if (d0 === null) result = d1 + 90;
	    else if (d1 === null) result = d0 + 90;
	    else result = calc() + 90;
	    return normalizeAngle(result);

	    function calc() {
	        d0 *= Math.PI / 180;
	        d1 *= Math.PI / 180;
	        var x = Math.cos(d0) + Math.cos(d1);
	        var y = Math.sin(d0) + Math.sin(d1);
	        return lineDirection([0, 0], [x, y]);
	    }
	}

	function deg2rad(deg) {
	    return deg / 180 * Math.PI;
	}

	function rad2deg(rad) {
	    return rad / Math.PI * 180;
	}



/***/ }),
/* 153 */
/***/ (function(module, exports) {

	module.exports = {
	    isHorizonOccluded: isHorizonOccluded
	};

	// https://cesiumjs.org/2013/04/25/Horizon-culling/
	function isHorizonOccluded(dc, position) {

	    if(dc.navigatorState.eyePoint.distanceTo(position) < 1e5){
	        return false;
	    }

	    if (dc.globe.projection.displayName !== 'WGS84'){
	        return false;
	    }

	    var cameraPosition = dc.navigatorState.eyePoint;

	    var rX = dc.globe.equatorialRadius; // 6378137.0;
	    var rY = dc.globe.equatorialRadius; // 6378137.0;
	    var rZ = dc.globe.polarRadius; // 6356752.3142451793;

	    // Vector CV
	    var cvX = cameraPosition[0]/ rX;
	    var cvY = cameraPosition[1] / rY;
	    var cvZ = cameraPosition[2] / rZ;
	    var vhMagnitudeSquared = cvX * cvX + cvY * cvY + cvZ * cvZ - 1.0;

	    // Target position, transformed to scaled space
	    var tX = position[0] / rX;
	    var tY = position[1] / rY;
	    var tZ = position[2] / rZ;

	    // Vector VT
	    var vtX = tX - cvX;
	    var vtY = tY - cvY;
	    var vtZ = tZ - cvZ;
	    var vtMagnitudeSquared = vtX * vtX + vtY * vtY + vtZ * vtZ;

	    // VT dot VC is the inverse of VT dot CV
	    var vtDotVc = -(vtX * cvX + vtY * cvY + vtZ * cvZ);

	    var isOccluded = vtDotVc > vhMagnitudeSquared && vtDotVc * vtDotVc / vtMagnitudeSquared > vhMagnitudeSquared;

	    return isOccluded;
	}


/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

	var Position = __webpack_require__(47);
	var Engine = __webpack_require__(40);

	module.exports = {
	    elevationAtPosition: function (pos) {
	       return elevation(pos.latitude, pos.longitude);
	    },

	    terrainRelativePosition: function (pos) {
	        return terrainRelative(pos.latitude, pos.longitude, pos.altitude);
	    },

	    terrainRelative: terrainRelative,

	    elevationAtLocation: elevation,

	    clampedToGround: function (position) {
	        return new Position(position.latitude, position.longitude, 0);
	    }

	};

	function elevation(lat, lon) {
	    return Engine.globe.elevationAtLocation(lat, lon);
	}

	function terrainRelative(lat, lon, alt) {
	    var e = elevation(lat, lon);
	    return new Position(lat, lon, alt + e);
	}

/***/ }),
/* 155 */
/***/ (function(module, exports) {

	module.exports = {
	    glDrawTriangleStrip: function (dc, count, first, stride, offset) {
	        draw(dc, dc.currentGlContext.TRIANGLE_STRIP, count, first, stride, offset);
	    },

	    glDrawLineStrip: function (dc, count, first, stride, offset) {
	        draw(dc, dc.currentGlContext.LINE_STRIP, count, first, stride, offset);
	    },

	    loadShaderVariables : function (dc, color, pickColor, layerOpacity) {
	        var gl = dc.currentGlContext;
	        var shader = dc.currentProgram;
	        var opacity = color.alpha * layerOpacity;
	        gl.depthMask(opacity >= 1 || dc.pickingMode);
	        shader.loadTextureEnabled(gl, false);
	        shader.loadApplyLighting(gl, false);
	        shader.loadColor(gl, dc.pickingMode ? pickColor : color);
	        shader.loadOpacity(gl, dc.pickingMode ? (opacity > 0 ? 1 : 0) : opacity);
	        // shader.loadReferencePoint(gl, referencePoint);
	        // if (undefined !== height) shader.loadHeight(gl, height);
	        // shader.loadMinHeight(gl, minHeight || 0);
	    },

	    createOrLoadVBO: function (dc, currentData, vboCacheKey, arrayPointer) {
	        if (!currentData[vboCacheKey]) {
	            currentData[vboCacheKey] = dc.gpuResourceCache.generateCacheKey();
	        }

	        var gl = dc.currentGlContext;
	        var key = currentData[vboCacheKey];
	        var vboId = dc.gpuResourceCache.resourceForKey(key);
	        var array = currentData[arrayPointer];

	        if (!vboId) {
	            vboId = gl.createBuffer();
	            dc.gpuResourceCache.putResource(key, vboId, array.length * 4 );// 4 bytes in float32
	            currentData.fillVbo = true;
	        }

	        // Bind and if necessary fill the VBO. We fill the VBO here rather than in doMakeOrderedRenderable so that
	        // there's no possibility of the VBO being ejected from the cache between the time it's filled and
	        // the time it's used.
	        gl.bindBuffer(gl.ARRAY_BUFFER, vboId);
	        if (currentData.fillVbo) {
	            gl.bufferData(gl.ARRAY_BUFFER, array, gl.STATIC_DRAW);
	            dc.frameStatistics.incrementVboLoadCount(1);
	        }
	    },

	    pointsAsFloat32array: function (points, numberOfComponents) {
	        var numPoints = points.length;
	        var array = new Float32Array(numPoints * numberOfComponents);

	        for (var i = 0; i < points.length; i++) {
	            var p = points[i];
	            var k = numberOfComponents * i;

	            array[k] = p[0];
	            if (numberOfComponents > 1)
	                array[k + 1] = p[1];
	            if (numberOfComponents > 2)
	                array[k + 2] = p[2];
	        }
	        return array;
	    }
	};

	function draw(dc, elementType, count, first, stride, offset) {
	    var gl = dc.currentGlContext;
	    var index = dc.currentProgram.vertexPointLocation;
	    var size = 3; // xyz
	    var type = gl.FLOAT;
	    var normalized = false;
	    gl.vertexAttribPointer(index, size, type, normalized, stride, offset || 0);
	    gl.drawArrays(elementType, first || 0, count);
	    return gl;
	}

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

	var GeoUtils = __webpack_require__(157);

	// шаблоны сегментов
	var penHandlers = {
	    comb: __webpack_require__(158), // расческа
	    dash: __webpack_require__(159), // пунктир
	    cross: __webpack_require__(160), // пунктир
	    space: __webpack_require__(161) // пробел
	};

	// разбивает линию на сегменты
	module.exports = {
	    create: function (points, pen) {
	        var context = createContext(pen);
	        for (var i = 0; i < points.length - 1; i++) {
	            context.enclosingSegment = i === points.length - 2;
	            handleSegment(points[i], points[i + 1], context);
	        }
	        return context.paths;
	    }
	};

	// заполняет один сегмент линии по шаблону(шаблонам)
	function handleSegment(p1, p2, context) {
	    var segmentLength = GeoUtils.distance(p1, p2);
	    var azimuth = GeoUtils.azimuth(p1, p2);
	    var startOffset = 0; // начало шаблона от 0.0(p1) до 1.0(p2)
	    while (true) {
	        var currentPen = context.currentPen();
	        if (currentPen.length < 10) throw new Error('pen length must be greater than 10 meters');
	        var currentPenLength = currentPen.length / segmentLength;
	        var needToGo = currentPenLength - context.remainDistance / segmentLength;
	        var segmentStart = GeoUtils.lerp(startOffset, p1, p2);
	        if (startOffset + needToGo > 1) {
	            context.remainDistance += segmentLength - startOffset * segmentLength;
	            context.remainPoints.push(segmentStart);
	            break;
	        }
	        var segmentEnd = GeoUtils.lerp(startOffset + needToGo, p1, p2);
	        penHandlers[currentPen.type].handle(context, segmentStart, segmentEnd, azimuth);
	        context.nextPen();
	        startOffset += needToGo;
	    }
	    if (context.enclosingSegment) {
	        context.remainPoints.push(p2);
	        context.paths.push(context.remainPoints);
	    }
	}

	function createContext(pens) {

	    var multiplePenMode = Array.isArray(pens);
	    var pen = 0;

	    var context = {
	        paths: [],
	        remainDistance: 0,
	        remainPoints: [],
	        nextPen: nextPen,
	        currentPen: currentPen
	    };

	    return context;

	    function nextPen() {
	        context.remainDistance = 0;
	        context.remainPoints = [];
	        pen = pen === pens.length - 1 ? 0 : pen + 1
	    }

	    function currentPen() {
	        return multiplePenMode ? pens[pen] : pens;
	    }
	}


/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

	var Location = __webpack_require__(28);
	var Position = __webpack_require__(47);
	var Engine = __webpack_require__(40);

	module.exports = {

	    turn: function (from, angle, length) {
	        return Location.greatCircleLocation(from, angle, length / radiusAt(from), pos(from));
	    },

	    lerp: function (amount, from, to) {
	        return Location.interpolateGreatCircle(amount, from, to, pos(from));
	    },

	    distance: function (from, to) {
	        return Location.greatCircleDistance(from, to) * radiusAt(from);
	    },

	    azimuth: function (from, to) {
	        return Location.greatCircleAzimuth(from, to);
	    }
	};

	function pos(pt) {
	    return new Position(0, 0, pt.altitude);
	}

	function radiusAt(pt) {
	    return Engine.globe.radiusAt(pt.latitude, pt.longitude)
	}


/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

	var GeoUtils = __webpack_require__(157);

	module.exports = {
	    handle: handleCombPattern
	};

	function handleCombPattern(context, start, end, azimuth) {
	    var combPen = context.currentPen();
	    var turn = combPen.left ? -90 : 90;
	    var comb = GeoUtils.turn(end, azimuth + turn, combPen.comb);
	    var path = context.remainDistance ? context.remainPoints : [];
	    path = path.concat([start, end, comb]);
	    context.paths.push(path);
	}


/***/ }),
/* 159 */
/***/ (function(module, exports) {

	
	module.exports = {
	    handle: handleDashPattern
	};

	function handleDashPattern(context, start, end) {
	    var result = [start, end];
	    if (context.remainDistance) {
	        result = context.remainPoints.concat(result);
	    }
	    context.paths.push(result);
	}

/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

	var GeoUtils = __webpack_require__(157);

	module.exports = {
	    handle: handleCrossPattern
	};

	function handleCrossPattern(context, start, end, azimuth) {

	    var len = context.currentPen().length;

	    var center = context.remainDistance ?
	        findCenter(context.remainPoints.concat([start, end])) :
	            GeoUtils.lerp(0.5, start, end);

	    diagonal(+1);
	    diagonal(-1);

	    function diagonal(sign) {
	        var start = GeoUtils.turn(center, azimuth + 135 * sign, len / 2);
	        var end = GeoUtils.turn(start, azimuth - 45 * sign, len);
	        context.paths.push([start, end]);
	    }

	    function findCenter(pts) {
	        var amount = 0.5;
	        for (var i = 0; i < pts.length - 1; i++) {
	            var distance = GeoUtils.distance(pts[i], pts[i + 1]) / len;
	            if (amount - distance < 0) {
	                return GeoUtils.lerp(amount, pts[i], pts[i + 1]);
	            }
	            amount -= distance;
	        }
	    }
	}



/***/ }),
/* 161 */
/***/ (function(module, exports) {

	module.exports = {
	    handle: handleSpacePattern
	};

	function handleSpacePattern(context, start, end, azimuth) {

	}

/***/ }),
/* 162 */
/***/ (function(module, exports) {

	
	module.exports = function (createObjectFunction, createPositionsFunction, defaultProperties) {
	    return function (geoJson, single) {
	        if (!geoJson.properties) {
	            geoJson.properties = defaultProperties || {};
	        }
	        var objects = [];
	        if (single) {
	            add(geoJson.geometry.coordinates);
	        } else {
	            geoJson.geometry.coordinates.forEach(add);
	        }
	        return objects;


	        function add(coordinates, index) {
	            var alt = geoJson.properties.altitude || 0;
	            var positions = createPositionsFunction(coordinates, alt);
	            var object = createObjectFunction(positions, geoJson, index);
	            if (Array.isArray(object)) {
	                object.forEach(function(o){
	                    objects.push(o);
	                });
	            } else {
	                objects.push(object);
	            }
	        }
	    }
	};

/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports Path
	 * @version $Id: Path.js 3345 2015-07-28 20:28:35Z dcollins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(147),
	        __webpack_require__(30),
	        __webpack_require__(129),
	        __webpack_require__(78),
	        __webpack_require__(52),
	        __webpack_require__(28),
	        __webpack_require__(32),
	        __webpack_require__(63),
	        __webpack_require__(87),
	        __webpack_require__(47),
	        __webpack_require__(132),
	        __webpack_require__(149),
	        __webpack_require__(46),
	        __webpack_require__(35)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (AbstractShape,
	              ArgumentError,
	              BasicTextureProgram,
	              BoundingBox,
	              Color,
	              Location,
	              Logger,
	              Matrix,
	              PickedObject,
	              Position,
	              ShapeAttributes,
	              SurfacePolyline,
	              Vec2,
	              Vec3) {
	        "use strict";

	        /**
	         * Constructs a path.
	         * @alias Path
	         * @constructor
	         * @augments AbstractShape
	         * @classdesc Represents a line, curve or curtain between specified positions. The path is drawn between input
	         * positions to achieve a specified path type, which can be one of the following:
	         * <ul>
	         *     <li>[WorldWind.GREAT_CIRCLE]{@link WorldWind#GREAT_CIRCLE}</li>
	         *     <li>[WorldWind.RHUMB_LINE]{@link WorldWind#RHUMB_LINE}</li>
	         *     <li>[WorldWind.LINEAR]{@link WorldWind#LINEAR}</li>
	         * </ul>
	         * <p>
	         *     Paths conform to the terrain if the path's [followTerrain]{@link Path#followTerrain} property is true.
	         * <p>
	         *     Altitudes within the path's positions are interpreted according to the path's altitude mode, which
	         *     can be one of the following:
	         * <ul>
	         *     <li>[WorldWind.ABSOLUTE]{@link WorldWind#ABSOLUTE}</li>
	         *     <li>[WorldWind.RELATIVE_TO_GROUND]{@link WorldWind#RELATIVE_TO_GROUND}</li>
	         *     <li>[WorldWind.CLAMP_TO_GROUND]{@link WorldWind#CLAMP_TO_GROUND}</li>
	         * </ul>
	         * If the latter, the path positions' altitudes are ignored.
	         * <p>
	         *     Paths have separate attributes for normal display and highlighted display. They use the interior and
	         *     outline attributes of {@link ShapeAttributes} but do not use the image attributes.
	         * <p>
	         *     A path displays as a curtain if its [extrude]{@link Path#extrude} property is true. A curtain extends
	         *     from the line formed by the path positions to the ground.
	         * <p>
	         *     This shape uses a {@link SurfacePolyline} when drawing on 2D globes and this shape's
	         *     [useSurfaceShapeFor2D]{@link AbstractShape#useSurfaceShapeFor2D} is true.
	         *
	         * @param {Position[]} positions An array containing the path positions.
	         * @param {ShapeAttributes} attributes The attributes to associate with this path. May be null, in which case
	         * default attributes are associated.
	         * @throws {ArgumentError} If the specified positions array is null or undefined.
	         */
	        var Path = function (positions, attributes) {
	            if (!positions) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Path", "constructor", "missingPositions"));
	            }

	            AbstractShape.call(this, attributes);

	            // Private. Documentation is with the defined property below.
	            this._positions = positions;

	            // Private. Documentation is with the defined property below.
	            this._pathType = WorldWind.GREAT_CIRCLE;

	            // Private. Documentation is with the defined property below.
	            this._terrainConformance = 10;

	            // Private. Documentation is with the defined property below.
	            this._numSubSegments = 10;

	            this.referencePosition = this.determineReferencePosition(this._positions);

	            this.scratchPoint = new Vec3(0, 0, 0); // scratch variable
	        };

	        Path.prototype = Object.create(AbstractShape.prototype);

	        Object.defineProperties(Path.prototype, {
	            /**
	             * This path's positions.
	             * @type {Position[]}
	             * @memberof Path.prototype
	             */
	            positions: {
	                get: function () {
	                    return this._positions;
	                },
	                set: function (positions) {
	                    if (!positions) {
	                        throw new ArgumentError(
	                            Logger.logMessage(Logger.LEVEL_SEVERE, "Path", "constructor", "missingPositions"));
	                    }

	                    this._positions = positions;
	                    this.referencePosition = this.determineReferencePosition(this._positions);
	                    this.reset();
	                }
	            },

	            /**
	             * Indicates whether this path should conform to the terrain.
	             * @type {Boolean}
	             * @default false
	             * @memberof Path.prototype
	             */
	            followTerrain: {
	                get: function () {
	                    return this._followTerrain;
	                },
	                set: function (followTerrain) {
	                    this._followTerrain = followTerrain;
	                    this.reset();
	                }
	            },

	            /**
	             * Specifies how accurately this path must adhere to the terrain when the path is terrain following. The value
	             * specifies the maximum number of pixels between tessellation points. Lower values increase accuracy but decrease
	             * performance.
	             * @type {Number}
	             * @default 10
	             * @memberof Path.prototype
	             */
	            terrainConformance: {
	                get: function () {
	                    return this._terrainConformance;
	                },
	                set: function (terrainConformance) {
	                    this._terrainConformance = terrainConformance;
	                    this.reset();
	                }
	            },

	            /**
	             * Specifies the number of segments used between specified positions to achieve this path's path type. Higher values
	             * cause the path to conform more closely to the path type but decrease performance.
	             * <p/>
	             * Note: The sub-segments number is ignored when the path follows terrain or when the path type is
	             * WorldWind.LINEAR.
	             * @type {Number}
	             * @default 10
	             * @memberof Path.prototype
	             */
	            numSubSegments: {
	                get: function () {
	                    return this._numSubSegments;
	                },
	                set: function (numSubSegments) {
	                    this._numSubSegments = numSubSegments >= 0 ? numSubSegments : 0;
	                    this.reset();
	                }
	            },

	            /**
	             * The type of path to follow when drawing the path. Recognized values are:
	             * <ul>
	             * <li>[WorldWind.GREAT_CIRCLE]{@link WorldWind#GREAT_CIRCLE}</li>
	             * <li>[WorldWind.RHUMB_LINE]{@link WorldWind#RHUMB_LINE}</li>
	             * <li>[WorldWind.LINEAR]{@link WorldWind#LINEAR}</li>
	             * </ul>
	             * @type {String}
	             * @default WorldWind.GREAT_CIRCLE
	             * @memberof Path.prototype
	             */
	            pathType: {
	                get: function () {
	                    return this._pathType;
	                },
	                set: function (pathType) {
	                    this._pathType = pathType;
	                    this.reset();
	                }
	            },

	            /**
	             * Specifies whether to extrude this path to the ground by drawing a filled interior from the path to the
	             * terrain. The filled interior uses this path's interior attributes.
	             * @type {Boolean}
	             * @default false
	             * @memberof Path.prototype
	             */
	            extrude: {
	                get: function () {
	                    return this._extrude;
	                },
	                set: function (extrude) {
	                    this._extrude = extrude;
	                    this.reset();
	                }
	            }
	        });

	        // Intentionally not documented.
	        Path.prototype.determineReferencePosition = function (positions) {
	            // Assign the first position as the reference position.
	            return (positions.length > 0) ? positions[0] : null;
	        };

	        // Internal. Determines whether this shape's geometry must be re-computed.
	        Path.prototype.mustGenerateGeometry = function (dc) {
	            if (!this.currentData.tessellatedPoints) {
	                return true;
	            }

	            if (this.currentData.drawInterior !== this.activeAttributes.drawInterior
	                || this.currentData.drawVerticals !== this.activeAttributes.drawVerticals) {
	                return true;
	            }

	            if (!this.followTerrain && this.currentData.numSubSegments !== this.numSubSegments) {
	                return true;
	            }

	            if (this.followTerrain && this.currentData.terrainConformance !== this.terrainConformance) {
	                return true;
	            }

	            if (this.altitudeMode === WorldWind.ABSOLUTE) {
	                return false;
	            }

	            return this.currentData.isExpired
	        };

	        Path.prototype.createSurfaceShape = function () {
	            return new SurfacePolyline(this.positions, null);
	        };

	        // Overridden from AbstractShape base class.
	        Path.prototype.doMakeOrderedRenderable = function (dc) {
	            // A null reference position is a signal that there are no positions to render.
	            if (!this.referencePosition) {
	                return null;
	            }

	            // See if the current shape data can be re-used.
	            if (!this.mustGenerateGeometry(dc)) {
	                return this;
	            }

	            // Set the transformation matrix to correspond to the reference position.
	            var refPt = this.currentData.referencePoint;
	            dc.surfacePointForMode(this.referencePosition.latitude, this.referencePosition.longitude,
	                this.referencePosition.altitude, this._altitudeMode, refPt);
	            this.currentData.transformationMatrix.setToTranslation(refPt[0], refPt[1], refPt[2]);

	            // Tessellate the path in geographic coordinates.
	            var tessellatedPositions = this.makeTessellatedPositions(dc);
	            if (tessellatedPositions.length < 2) {
	                return null;
	            }

	            // Convert the tessellated geographic coordinates to the Cartesian coordinates that will be rendered.
	            var tessellatedPoints = this.computeRenderedPath(dc, tessellatedPositions);

	            this.currentData.tessellatedPoints = tessellatedPoints;
	            this.currentData.drawInterior = this.activeAttributes.drawInterior;
	            this.currentData.drawVerticals = this.activeAttributes.drawVerticals;
	            this.currentData.numSubSegments = this.numSubSegments;
	            this.currentData.terrainConformance = this.terrainConformance;
	            this.resetExpiration(this.currentData);
	            this.currentData.fillVbo = true;

	            // Create the extent from the Cartesian points. Those points are relative to this path's reference point, so
	            // translate the computed extent to the reference point.
	            if (!this.currentData.extent) {
	                this.currentData.extent = new BoundingBox();
	            }
	            this.currentData.extent.setToPoints(tessellatedPoints);
	            this.currentData.extent.translate(this.currentData.referencePoint);

	            return this;
	        };

	        // Private. Intentionally not documented.
	        Path.prototype.makeTessellatedPositions = function (dc) {
	            var tessellatedPositions = [],
	                navState = dc.navigatorState,
	                showVerticals = this.mustDrawVerticals(dc),
	                ptA = new Vec3(0, 0, 0),
	                ptB = new Vec3(0, 0, 0),
	                posA = this._positions[0],
	                posB, eyeDistance, pixelSize;

	            if (showVerticals) {
	                this.currentData.verticalIndices = new Int16Array(this.positions.length * 2);
	                this.currentData.verticalIndices[0] = 0;
	                this.currentData.verticalIndices[1] = 1;
	            }

	            tessellatedPositions.push(posA);

	            dc.surfacePointForMode(posA.latitude, posA.longitude, posA.altitude, this._altitudeMode, ptA);

	            for (var i = 1, len = this._positions.length; i < len; i++) {
	                posB = this._positions[i];
	                dc.surfacePointForMode(posB.latitude, posB.longitude, posB.altitude, this._altitudeMode, ptB);
	                eyeDistance = navState.eyePoint.distanceTo(ptA);
	                pixelSize = navState.pixelSizeAtDistance(eyeDistance);
	                if (ptA.distanceTo(ptB) < pixelSize * 8 && this.altitudeMode !== WorldWind.ABSOLUTE) {
	                    tessellatedPositions.push(posB); // distance is short so no need for sub-segments
	                } else {
	                    this.makeSegment(dc, posA, posB, ptA, ptB, tessellatedPositions);
	                }

	                posA = posB;
	                ptA.copy(ptB);

	                if (showVerticals) {
	                    var k = 2 * (tessellatedPositions.length - 1);
	                    this.currentData.verticalIndices[i * 2] = k;
	                    this.currentData.verticalIndices[i * 2 + 1] = k + 1;
	                }
	            }

	            return tessellatedPositions;
	        };

	        // Private. Intentionally not documented.
	        Path.prototype.makeSegment = function (dc, posA, posB, ptA, ptB, tessellatedPositions) {
	            var navState = dc.navigatorState,
	                eyePoint = navState.eyePoint,
	                pos = new Location(0, 0),
	                height = 0,
	                arcLength, segmentAzimuth, segmentDistance, s, p, distance;

	            // If it's just a straight line and not terrain following, then the segment is just two points.
	            if (this._pathType === WorldWind.LINEAR && !this._followTerrain) {
	                if (!ptA.equals(ptB)) {
	                    tessellatedPositions.push(posB);
	                }
	                return;
	            }

	            // Compute the segment length.

	            if (this._pathType === WorldWind.LINEAR) {
	                segmentDistance = Location.linearDistance(posA, posB);
	            } else if (this._pathType === WorldWind.RHUMB_LINE) {
	                segmentDistance = Location.rhumbDistance(posA, posB);
	            } else {
	                segmentDistance = Location.greatCircleDistance(posA, posB);
	            }

	            if (this._altitudeMode !== WorldWind.CLAMP_TO_GROUND) {
	                height = 0.5 * (posA.altitude + posB.altitude);
	            }

	            arcLength = segmentDistance * (dc.globe.equatorialRadius + height * dc.verticalExaggeration);

	            if (arcLength <= 0) { // segment is 0 length
	                return;
	            }

	            // Compute the azimuth to apply while tessellating the segment.

	            if (this._pathType === WorldWind.LINEAR) {
	                segmentAzimuth = Location.linearAzimuth(posA, posB);
	            } else if (this._pathType === WorldWind.RHUMB_LINE) {
	                segmentAzimuth = Location.rhumbAzimuth(posA, posB);
	            } else {
	                segmentAzimuth = Location.greatCircleAzimuth(posA, posB);
	            }

	            this.scratchPoint.copy(ptA);
	            for (s = 0, p = 0; s < 1;) {
	                if (this._followTerrain) {
	                    p += this._terrainConformance * navState.pixelSizeAtDistance(this.scratchPoint.distanceTo(eyePoint));
	                } else {
	                    p += arcLength / this._numSubSegments;
	                }

	                // Stop adding intermediate positions when we reach the arc length, or the remaining distance is in
	                // millimeters on Earth.
	                if (arcLength < p || arcLength - p < 1e-9)
	                    break;

	                s = p / arcLength;
	                distance = s * segmentDistance;

	                if (this._pathType === WorldWind.LINEAR) {
	                    Location.linearLocation(posA, segmentAzimuth, distance, pos);
	                } else if (this._pathType === WorldWind.RHUMB_LINE) {
	                    Location.rhumbLocation(posA, segmentAzimuth, distance, pos);
	                } else {
	                    Location.greatCircleLocation(posA, segmentAzimuth, distance, pos);
	                }

	                pos.altitude = (1 - s) * posA.altitude + s * posB.altitude;
	                tessellatedPositions.push(new Position(pos.latitude, pos.longitude, pos.altitude));

	                if (this._followTerrain) {
	                    // Compute a new reference point for eye distance.
	                    dc.surfacePointForMode(pos.latitude, pos.longitude, pos.altitude,
	                        WorldWind.CLAMP_TO_GROUND, this.scratchPoint);
	                }
	            }

	            tessellatedPositions.push(posB);
	        };

	        // Private. Intentionally not documented.
	        Path.prototype.computeRenderedPath = function (dc, tessellatedPositions) {
	            var capturePoles = this.mustDrawInterior(dc) || this.mustDrawVerticals(dc),
	                eyeDistSquared = Number.MAX_VALUE,
	                eyePoint = dc.navigatorState.eyePoint,
	                numPoints = (capturePoles ? 2 : 1) * tessellatedPositions.length,
	                tessellatedPoints = new Float32Array(numPoints * 3),
	                stride = capturePoles ? 6 : 3,
	                pt = new Vec3(0, 0, 0),
	                altitudeMode, pos, k, dSquared;

	            if (this._followTerrain && this.altitudeMode !== WorldWind.CLAMP_TO_GROUND) {
	                altitudeMode = WorldWind.RELATIVE_TO_GROUND;
	            } else {
	                altitudeMode = this.altitudeMode;
	            }

	            for (var i = 0, len = tessellatedPositions.length; i < len; i++) {
	                pos = tessellatedPositions[i];

	                dc.surfacePointForMode(pos.latitude, pos.longitude, pos.altitude, altitudeMode, pt);

	                dSquared = pt.distanceToSquared(eyePoint);
	                if (dSquared < eyeDistSquared) {
	                    eyeDistSquared = dSquared;
	                }

	                pt.subtract(this.currentData.referencePoint);

	                k = stride * i;
	                tessellatedPoints[k] = pt[0];
	                tessellatedPoints[k + 1] = pt[1];
	                tessellatedPoints[k + 2] = pt[2];

	                if (capturePoles) {
	                    dc.surfacePointForMode(pos.latitude, pos.longitude, 0, WorldWind.CLAMP_TO_GROUND, pt);

	                    dSquared = pt.distanceToSquared(eyePoint);
	                    if (dSquared < eyeDistSquared) {
	                        eyeDistSquared = dSquared;
	                    }

	                    pt.subtract(this.currentData.referencePoint);

	                    tessellatedPoints[k + 3] = pt[0];
	                    tessellatedPoints[k + 4] = pt[1];
	                    tessellatedPoints[k + 5] = pt[2];
	                }
	            }

	            this.currentData.pointBufferHasExtrusionPoints = capturePoles;
	            this.currentData.eyeDistance = Math.sqrt(eyeDistSquared);

	            return tessellatedPoints;
	        };

	        // Private. Intentionally not documented.
	        Path.prototype.mustDrawInterior = function (dc) {
	            return this.activeAttributes.drawInterior
	                && this._extrude
	                && this._altitudeMode !== WorldWind.CLAMP_TO_GROUND;
	        };

	        // Private. Intentionally not documented.
	        Path.prototype.mustDrawVerticals = function (dc) {
	            return this.activeAttributes.drawOutline && this.activeAttributes.drawVerticals
	                && this.altitudeMode !== WorldWind.CLAMP_TO_GROUND;
	        };

	        // Overridden from AbstractShape base class.
	        Path.prototype.doRenderOrdered = function (dc) {
	            var gl = dc.currentGlContext,
	                program = dc.currentProgram,
	                currentData = this.currentData,
	                numPoints = currentData.tessellatedPoints.length / 3,
	                vboId, opacity, color, pickColor, stride, nPts;

	            this.applyMvpMatrix(dc);

	            if (!currentData.vboCacheKey) {
	                currentData.vboCacheKey = dc.gpuResourceCache.generateCacheKey();
	            }

	            vboId = dc.gpuResourceCache.resourceForKey(currentData.vboCacheKey);
	            if (!vboId) {
	                vboId = gl.createBuffer();
	                dc.gpuResourceCache.putResource(this.currentData.vboCacheKey, vboId,
	                    currentData.tessellatedPoints.length * 4);
	                currentData.fillVbo = true;
	            }

	            // Bind and if necessary fill the VBO. We fill the VBO here rather than in doMakeOrderedRenderable so that
	            // there's no possibility of the VBO being ejected from the cache between the time it's filled and
	            // the time it's used.
	            gl.bindBuffer(gl.ARRAY_BUFFER, vboId);
	            if (currentData.fillVbo) {
	                gl.bufferData(gl.ARRAY_BUFFER, currentData.tessellatedPoints,
	                    gl.STATIC_DRAW);
	                dc.frameStatistics.incrementVboLoadCount(1);
	            }

	            program.loadTextureEnabled(gl, false);

	            if (dc.pickingMode) {
	                pickColor = dc.uniquePickColor();
	            }

	            if (this.mustDrawInterior(dc)) {
	                color = this.activeAttributes.interiorColor;
	                opacity = color.alpha * dc.currentLayer.opacity;
	                // Disable writing the shape's fragments to the depth buffer when the interior is semi-transparent.
	                if (opacity < 1 && !dc.pickingMode) {
	                    gl.depthMask(false);
	                }
	                program.loadColor(gl, dc.pickingMode ? pickColor : color);
	                program.loadOpacity(gl, dc.pickingMode ? (opacity > 0 ? 1 : 0) : opacity);

	                gl.vertexAttribPointer(program.vertexPointLocation, 3, gl.FLOAT, false, 0, 0);
	                gl.drawArrays(gl.TRIANGLE_STRIP, 0, numPoints);
	            }

	            if (this.activeAttributes.drawOutline) {
	                if ((this.mustDrawVerticals(dc) && this.mustDrawInterior(dc))
	                    || this.altitudeMode === WorldWind.CLAMP_TO_GROUND) {
	                    // Make the verticals stand out from the interior, or the outline stand out from the terrain.
	                    this.applyMvpMatrixForOutline(dc);
	                }

	                color = this.activeAttributes.outlineColor;
	                opacity = color.alpha * dc.currentLayer.opacity;
	                // Disable writing the shape's fragments to the depth buffer when the interior is semi-transparent.
	                if (opacity < 1 && !dc.pickingMode) {
	                    gl.depthMask(false);
	                }
	                program.loadColor(gl, dc.pickingMode ? pickColor : color);
	                program.loadOpacity(gl, dc.pickingMode ? 1 : opacity);

	                gl.lineWidth(this.activeAttributes.outlineWidth);

	                if (this.currentData.pointBufferHasExtrusionPoints) {
	                    stride = 24;
	                    nPts = numPoints / 2;
	                } else {
	                    stride = 12;
	                    nPts = numPoints;
	                }

	                gl.vertexAttribPointer(program.vertexPointLocation, 3, gl.FLOAT, false, stride, 0);
	                gl.drawArrays(gl.LINE_STRIP, 0, nPts);

	                if (this.mustDrawVerticals(dc)) {
	                    if (!currentData.verticalIndicesVboCacheKey) {
	                        currentData.verticalIndicesVboCacheKey = dc.gpuResourceCache.generateCacheKey();
	                    }

	                    vboId = dc.gpuResourceCache.resourceForKey(currentData.verticalIndicesVboCacheKey);
	                    if (!vboId) {
	                        vboId = gl.createBuffer();
	                        dc.gpuResourceCache.putResource(currentData.verticalIndicesVboCacheKey, vboId,
	                            currentData.verticalIndices.length * 4);
	                        currentData.fillVbo = true;
	                    }

	                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vboId);
	                    if (currentData.fillVbo) {
	                        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, currentData.verticalIndices,
	                            gl.STATIC_DRAW);
	                        dc.frameStatistics.incrementVboLoadCount(1);
	                    }

	                    gl.vertexAttribPointer(program.vertexPointLocation, 3, gl.FLOAT, false, 0, 0);
	                    gl.drawElements(gl.LINES, currentData.verticalIndices.length,
	                        gl.UNSIGNED_SHORT, 0);
	                }
	            }
	            currentData.fillVbo = false;

	            if (dc.pickingMode) {
	                var po = new PickedObject(pickColor, this.pickDelegate ? this.pickDelegate : this, null, dc.currentLayer,
	                    false);
	                dc.resolvePick(po);
	            }
	        };

	        // Overridden from AbstractShape base class.
	        Path.prototype.beginDrawing = function (dc) {
	            var gl = dc.currentGlContext;

	            if (this.mustDrawInterior(dc)) {
	                gl.disable(gl.CULL_FACE);
	            }

	            dc.findAndBindProgram(BasicTextureProgram);
	            gl.enableVertexAttribArray(dc.currentProgram.vertexPointLocation);
	        };

	        // Overridden from AbstractShape base class.
	        Path.prototype.endDrawing = function (dc) {
	            var gl = dc.currentGlContext;

	            gl.disableVertexAttribArray(dc.currentProgram.vertexPointLocation);
	            gl.depthMask(true);
	            gl.lineWidth(1);
	            gl.enable(gl.CULL_FACE);
	        };

	        return Path;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

	var AttributesFactory = __webpack_require__(143);
	var ObjectFactory = __webpack_require__(162);
	var LegacyPolygon = __webpack_require__(165);
	var Polygon = __webpack_require__(168);
	var Utils = __webpack_require__(144);

	var defaultProperties = {
	    outline: 'ffffffff',
	    interior: 'ffffffff',
	    outlineHover: 'ffffffff',
	    interiorHover: 'ffffff7f',
	    altitude: 3000
	};


	module.exports = {
	    create: ObjectFactory(createPolygon, getBoundaries, defaultProperties)
	};

	function createPolygon(boundaries, geoJson, index) {
	    var newImpl = geoJson && geoJson.properties && geoJson.properties.api === 'coco';
	    var polygon = newImpl ? new Polygon(boundaries) : new LegacyPolygon(boundaries, null);
	    polygon.altitudeMode = WorldWind.RELATIVE_TO_GROUND;
	    polygon.source = geoJson;
	    updatePolygon(polygon);
	    polygon.update = updatePolygon.bind(null, polygon);
	    return polygon;
	}

	function updatePolygon(polygon) {
	    var props = polygon.source.geometry.properties || polygon.source.properties || {};
	    polygon.extrude = props.extrude || true;
	    polygon.enabled = props.visible !== false;
	    AttributesFactory.fill(polygon, props);
	    polygon.attributes.drawOutline = props.hasOwnProperty('stroke');
	    polygon.highlightAttributes.drawOutline = props.hasOwnProperty('stroke');
	}

	function getBoundaries(coordinates, altitude) {
	    return coordinates.map(function (array) {
	        return Utils.geoJsonCoordinatesToPositions(array, altitude);
	    });
	}

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports Polygon
	 * @version $Id: Polygon.js 3345 2015-07-28 20:28:35Z dcollins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(147),
	        __webpack_require__(30),
	        __webpack_require__(129),
	        __webpack_require__(78),
	        __webpack_require__(52),
	        __webpack_require__(51),
	        __webpack_require__(28),
	        __webpack_require__(32),
	        __webpack_require__(63),
	        __webpack_require__(87),
	        __webpack_require__(47),
	        __webpack_require__(132),
	        __webpack_require__(166),
	        __webpack_require__(46),
	        __webpack_require__(35),
	        __webpack_require__(167)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (AbstractShape,
	              ArgumentError,
	              BasicTextureProgram,
	              BoundingBox,
	              Color,
	              ImageSource,
	              Location,
	              Logger,
	              Matrix,
	              PickedObject,
	              Position,
	              ShapeAttributes,
	              SurfacePolygon,
	              Vec2,
	              Vec3,
	              libtessDummy) {
	        "use strict";

	        /**
	         * Constructs a Polygon.
	         * @alias Polygon
	         * @constructor
	         * @augments AbstractShape
	         * @classdesc Represents a 3D polygon. The polygon may be extruded to the ground to form a prism. It may have
	         * multiple boundaries defining empty portions. See also {@link SurfacePolygon}.
	         * <p>
	         *     Altitudes within the polygon's positions are interpreted according to the polygon's altitude mode, which
	         *     can be one of the following:
	         * <ul>
	         *     <li>[WorldWind.ABSOLUTE]{@link WorldWind#ABSOLUTE}</li>
	         *     <li>[WorldWind.RELATIVE_TO_GROUND]{@link WorldWind#RELATIVE_TO_GROUND}</li>
	         *     <li>[WorldWind.CLAMP_TO_GROUND]{@link WorldWind#CLAMP_TO_GROUND}</li>
	         * </ul>
	         * If the latter, the polygon positions' altitudes are ignored. (If the polygon should be draped onto the
	         * terrain, you might want to use {@link SurfacePolygon} instead.)
	         * <p>
	         *     Polygons have separate attributes for normal display and highlighted display. They use the interior and
	         *     outline attributes of {@link ShapeAttributes}. If those attributes identify an image, that image is
	         *     applied to the polygon.
	         * <p>
	         *     A polygon displays as a vertical prism if its [extrude]{@link Polygon#extrude} property is true. A
	         *     curtain is formed around its boundaries and extends from the polygon's edges to the ground.
	         * <p>
	         *     A polygon can be textured, including its extruded boundaries. The textures are specified via the
	         *     [imageSource]{@link ShapeAttributes#imageSource} property of the polygon's attributes. If that
	         *     property is a single string or {@link ImageSource}, then it identifies the image source for the
	         *     polygon's texture. If that property is an array of strings, {@link ImageSource}s or a combination of
	         *     those, then the first entry in the array specifies the polygon's image source and subsequent entries
	         *     specify the image sources of the polygon's extruded boundaries. If the array contains two entries, the
	         *     first is the polygon's image source and the second is the common image source for all extruded
	         *     boundaries. If the array contains more than two entries, then the first entry is the polygon's image
	         *     source and each subsequent entry is the image source for consecutive extruded boundary segments. A null
	         *     value for any entry indicates that no texture is applied for the corresponding polygon or extruded edge
	         *     segment. If fewer image sources are specified then there are boundary segments, the last image source
	         *     specified is applied to the remaining segments. Texture coordinates for the polygon's texture are
	         *     specified via this polygon's [textureCoordinates]{@link Polygon#textureCoordinates} property. Texture
	         *     coordinates for extruded boundary segments are implicitly defined to fit the full texture to each
	         *     boundary segment.
	         * <p>
	         *     When displayed on a 2D globe, this polygon displays as a {@link SurfacePolygon} if its
	         *     [useSurfaceShapeFor2D]{@link AbstractShape#useSurfaceShapeFor2D} property is true.
	         *
	         * @param {Position[][] | Position[]} boundaries A two-dimensional array containing the polygon boundaries.
	         * Each entry of the array specifies the vertices of one boundary.
	         * This argument may also be a simple array of positions,
	         * in which case the polygon is assumed to have only one boundary.
	         * Each boundary is considered implicitly closed, so the last position of the boundary need not and should not
	         * duplicate the first position of the boundary.
	         * @param {ShapeAttributes} attributes The attributes to associate with this polygon. May be null, in which case
	         * default attributes are associated.
	         *
	         * @throws {ArgumentError} If the specified boundaries array is null or undefined.
	         */
	        var Polygon = function (boundaries, attributes) {
	            if (!boundaries) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Polygon", "constructor", "missingBoundaries"));
	            }

	            AbstractShape.call(this, attributes);

	            if (boundaries.length > 0 && boundaries[0].latitude) {
	                boundaries = [boundaries];
	                this._boundariesSpecifiedSimply = true;
	            }

	            // Private. Documentation is with the defined property below and the constructor description above.
	            this._boundaries = boundaries;

	            this._textureCoordinates = null;

	            this.referencePosition = this.determineReferencePosition(this._boundaries);

	            this._extrude = false;

	            this.scratchPoint = new Vec3(0, 0, 0); // scratch variable
	        };

	        Polygon.prototype = Object.create(AbstractShape.prototype);

	        Object.defineProperties(Polygon.prototype, {
	            /**
	             * This polygon's boundaries. A two-dimensional array containing the polygon boundaries. Each entry of the
	             * array specifies the vertices of one boundary. This property may also be a simple
	             * array of positions, in which case the polygon is assumed to have only one boundary.
	             * @type {Position[][] | Position[]}
	             * @memberof Polygon.prototype
	             */
	            boundaries: {
	                get: function () {
	                    return this._boundariesSpecifiedSimply ? this._boundaries[0] : this._boundaries;
	                },
	                set: function (boundaries) {
	                    if (!boundaries) {
	                        throw new ArgumentError(
	                            Logger.logMessage(Logger.LEVEL_SEVERE, "Polygon", "boundaries", "missingBoundaries"));
	                    }

	                    if (boundaries.length > 0 && boundaries[0].latitude) {
	                        boundaries = [boundaries];
	                        this._boundariesSpecifiedSimply = true;
	                    }

	                    this._boundaries = boundaries;
	                    this.referencePosition = this.determineReferencePosition(this._boundaries);
	                    this.reset();
	                }
	            },

	            /**
	             * This polygon's texture coordinates if this polygon is to be textured. A texture coordinate must be
	             * provided for each boundary position. The texture coordinates are specified as a two-dimensional array,
	             * each entry of which specifies the texture coordinates for one boundary. Each texture coordinate is a
	             * {@link Vec2} containing the s and t coordinates.
	             * @type {Vec2[][]}
	             * @default null
	             * @memberof Polygon.prototype
	             */
	            textureCoordinates: {
	                get: function () {
	                    return this._textureCoordinates;
	                },
	                set: function (value) {
	                    this._textureCoordinates = value;
	                    this.reset();
	                }
	            },

	            /**
	             * Specifies whether to extrude this polygon to the ground by drawing a filled interior from the polygon
	             * to the terrain. The filled interior uses this polygon's interior attributes.
	             * @type {Boolean}
	             * @default false
	             * @memberof Polygon.prototype
	             */
	            extrude: {
	                get: function () {
	                    return this._extrude;
	                },
	                set: function (extrude) {
	                    this._extrude = extrude;
	                    this.reset();
	                }
	            }
	        });

	        // Intentionally not documented.
	        Polygon.prototype.determineReferencePosition = function (boundaries) {
	            // Assign the first position as the reference position.
	            return (boundaries.length > 0 && boundaries[0].length > 2) ? boundaries[0][0] : null;
	        };

	        // Internal. Determines whether this shape's geometry must be re-computed.
	        Polygon.prototype.mustGenerateGeometry = function (dc) {
	            if (!this.currentData.boundaryPoints) {
	                return true;
	            }

	            if (this.currentData.drawInterior !== this.activeAttributes.drawInterior) {
	                return true;
	            }

	            if (this.altitudeMode === WorldWind.ABSOLUTE) {
	                return false;
	            }

	            return this.currentData.isExpired
	        };

	        // Internal. Indicates whether this polygon should be textured.
	        Polygon.prototype.hasCapTexture = function () {
	            return this.textureCoordinates && this.capImageSource();
	        };

	        // Internal. Determines source of this polygon's cap texture. See the class description above for the policy.
	        Polygon.prototype.capImageSource = function () {
	            if (!this.activeAttributes.imageSource) {
	                return null;
	            }

	            if ((typeof this.activeAttributes.imageSource) === "string"
	                || this.activeAttributes.imageSource instanceof ImageSource) {
	                return this.activeAttributes.imageSource;
	            }

	            if (Array.isArray(this.activeAttributes.imageSource)
	                && this.activeAttributes.imageSource[0]
	                && (typeof this.activeAttributes.imageSource[0] === "string"
	                || this.activeAttributes.imageSource instanceof ImageSource)) {
	                return this.activeAttributes.imageSource[0];
	            }

	            return null;
	        };

	        // Internal. Indicates whether this polygon has side textures defined.
	        Polygon.prototype.hasSideTextures = function () {
	            return this.activeAttributes.imageSource &&
	                Array.isArray(this.activeAttributes.imageSource) &&
	                this.activeAttributes.imageSource.length > 1;
	        };

	        // Internal. Determines the side texture for a specified side. See the class description above for the policy.
	        Polygon.prototype.sideImageSource = function (side) {
	            if (side === 0 || this.activeAttributes.imageSource.length === 2) {
	                return this.activeAttributes.imageSource[1];
	            }

	            var numSideTextures = this.activeAttributes.imageSource.length - 1;
	            side = Math.min(side + 1, numSideTextures);
	            return this.activeAttributes.imageSource[side];
	        };

	        Polygon.prototype.createSurfaceShape = function () {
	            return new SurfacePolygon(this.boundaries, null);
	        };

	        // Overridden from AbstractShape base class.
	        Polygon.prototype.doMakeOrderedRenderable = function (dc) {
	            // A null reference position is a signal that there are no boundaries to render.
	            if (!this.referencePosition) {
	                return null;
	            }

	            if (!this.activeAttributes.drawInterior && !this.activeAttributes.drawOutline) {
	                return null;
	            }

	            // See if the current shape data can be re-used.
	            if (!this.mustGenerateGeometry(dc)) {
	                return this;
	            }

	            var currentData = this.currentData;

	            // Set the transformation matrix to correspond to the reference position.
	            var refPt = currentData.referencePoint;
	            dc.surfacePointForMode(this.referencePosition.latitude, this.referencePosition.longitude,
	                this.referencePosition.altitude, this._altitudeMode, refPt);
	            currentData.transformationMatrix.setToTranslation(refPt[0], refPt[1], refPt[2]);

	            // Close the boundaries.
	            var fullBoundaries = [];
	            for (var b = 0; b < this._boundaries.length; b++) {
	                fullBoundaries[b] = this._boundaries[b].slice(0); // clones the array
	                fullBoundaries[b].push(this._boundaries[b][0]); // appends the first position to the boundary
	            }

	            // Convert the geographic coordinates to the Cartesian coordinates that will be rendered.
	            var boundaryPoints = this.computeBoundaryPoints(dc, fullBoundaries);

	            // Tessellate the polygon if its interior is to be drawn.
	            if (this.activeAttributes.drawInterior) {
	                var capVertices = this.tessellatePolygon(dc, boundaryPoints);
	                if (capVertices) {
	                    // Must copy the vertices to a typed array. (Can't use typed array to begin with because its size
	                    // is unknown prior to tessellation.)
	                    currentData.capTriangles = new Float32Array(capVertices.length);
	                    for (var i = 0, len = capVertices.length; i < len; i++) {
	                        currentData.capTriangles[i] = capVertices[i];
	                    }
	                }
	            }

	            currentData.boundaryPoints = boundaryPoints;
	            currentData.drawInterior = this.activeAttributes.drawInterior; // remember for validation
	            this.resetExpiration(currentData);
	            currentData.refreshBuffers = true; // causes VBOs to be reloaded

	            // Create the extent from the Cartesian points. Those points are relative to this path's reference point,
	            // so translate the computed extent to the reference point.
	            if (!currentData.extent) {
	                currentData.extent = new BoundingBox();
	            }
	            if (boundaryPoints.length === 1) {
	                currentData.extent.setToPoints(boundaryPoints[0]);
	            } else {
	                var allPoints = [];
	                for (b = 0; b < boundaryPoints.length; b++) {
	                    for (var p = 0; p < boundaryPoints[b].length; p++) {
	                        allPoints.push(boundaryPoints[b][p]);
	                    }
	                }
	                currentData.extent.setToPoints(allPoints);
	            }
	            currentData.extent.translate(currentData.referencePoint);

	            return this;
	        };

	        // Private. Intentionally not documented.
	        Polygon.prototype.computeBoundaryPoints = function (dc, boundaries) {
	            var eyeDistSquared = Number.MAX_VALUE,
	                eyePoint = dc.navigatorState.eyePoint,
	                boundaryPoints = [],
	                stride = this._extrude ? 6 : 3,
	                pt = new Vec3(0, 0, 0),
	                numBoundaryPoints, pos, k, dSquared;

	            for (var b = 0; b < boundaries.length; b++) {
	                numBoundaryPoints = (this._extrude ? 2 : 1) * boundaries[b].length;
	                boundaryPoints[b] = new Float32Array(numBoundaryPoints * 3);

	                for (var i = 0, len = boundaries[b].length; i < len; i++) {
	                    pos = boundaries[b][i];

	                    dc.surfacePointForMode(pos.latitude, pos.longitude, pos.altitude, this.altitudeMode, pt);

	                    dSquared = pt.distanceToSquared(eyePoint);
	                    if (dSquared < eyeDistSquared) {
	                        eyeDistSquared = dSquared;
	                    }

	                    pt.subtract(this.currentData.referencePoint);

	                    k = stride * i;
	                    boundaryPoints[b][k] = pt[0];
	                    boundaryPoints[b][k + 1] = pt[1];
	                    boundaryPoints[b][k + 2] = pt[2];

	                    if (this._extrude) {
	                        dc.surfacePointForMode(pos.latitude, pos.longitude, 0, WorldWind.CLAMP_TO_GROUND, pt);

	                        dSquared = pt.distanceToSquared(eyePoint);
	                        if (dSquared < eyeDistSquared) {
	                            eyeDistSquared = dSquared;
	                        }

	                        pt.subtract(this.currentData.referencePoint);

	                        boundaryPoints[b][k + 3] = pt[0];
	                        boundaryPoints[b][k + 4] = pt[1];
	                        boundaryPoints[b][k + 5] = pt[2];
	                    }
	                }
	            }

	            this.currentData.eyeDistance = Math.sqrt(eyeDistSquared);

	            return boundaryPoints;
	        };

	        Polygon.prototype.tessellatePolygon = function (dc, boundaryPoints) {
	            var triangles = [], // the output list of triangles
	                error = 0,
	                stride = this._extrude ? 6 : 3,
	                includeTextureCoordinates = this.hasCapTexture(),
	                coords, normal;

	            if (!this.polygonTessellator) {
	                this.polygonTessellator = new libtess.GluTesselator();

	                this.polygonTessellator.gluTessCallback(libtess.gluEnum.GLU_TESS_VERTEX_DATA,
	                    function (data, tris) {
	                        tris[tris.length] = data[0];
	                        tris[tris.length] = data[1];
	                        tris[tris.length] = data[2];

	                        if (includeTextureCoordinates) {
	                            tris[tris.length] = data[3];
	                            tris[tris.length] = data[4];
	                        }
	                    });

	                this.polygonTessellator.gluTessCallback(libtess.gluEnum.GLU_TESS_COMBINE,
	                    function (coords, data, weight) {
	                        var newCoords = [coords[0], coords[1], coords[2]];

	                        if (includeTextureCoordinates) {
	                            for (var i = 3; i <= 4; i++) {
	                                var value = 0;
	                                for (var w = 0; w < 4; w++) {
	                                    if (weight[w] > 0) {
	                                        value += weight[w] * data[w][i];
	                                    }
	                                }

	                                newCoords[i] = value;
	                            }
	                        }

	                        return newCoords;
	                    });

	                this.polygonTessellator.gluTessCallback(libtess.gluEnum.GLU_TESS_ERROR,
	                    function (errno) {
	                        error = errno;
	                        Logger.logMessage(Logger.LEVEL_WARNING, "Polygon", "tessellatePolygon",
	                            "Tessellation error " + errno + ".");
	                    });
	            }

	            // Compute a normal vector for the polygon.
	            normal = Vec3.computeBufferNormal(boundaryPoints[0], stride);
	            if (!normal) {
	                normal = new Vec3(0, 0, 0);
	                // The first boundary is colinear. Fall back to the surface normal.
	                dc.globe.surfaceNormalAtLocation(this.referencePosition.latitude, this.referencePosition.longitude,
	                    normal);
	            }
	            this.polygonTessellator.gluTessNormal(normal[0], normal[1], normal[2]);
	            this.currentData.capNormal = normal;

	            // Tessellate the polygon.
	            this.polygonTessellator.gluTessBeginPolygon(triangles);
	            for (var b = 0; b < boundaryPoints.length; b++) {
	                var t = 0;
	                this.polygonTessellator.gluTessBeginContour();
	                var contour = boundaryPoints[b];
	                for (var c = 0; c < contour.length; c += stride) {
	                    coords = [contour[c], contour[c + 1], contour[c + 2]];
	                    if (includeTextureCoordinates) {
	                        if (t < this.textureCoordinates[b].length) {
	                            coords[3] = this.textureCoordinates[b][t][0];
	                            coords[4] = this.textureCoordinates[b][t][1];
	                        } else {
	                            coords[3] = this.textureCoordinates[b][0][0];
	                            coords[4] = this.textureCoordinates[b][1][1];
	                        }
	                        ++t;
	                    }
	                    this.polygonTessellator.gluTessVertex(coords, coords);
	                }
	                this.polygonTessellator.gluTessEndContour();
	            }
	            this.polygonTessellator.gluTessEndPolygon();

	            return error === 0 ? triangles : null;
	        };

	        // Private. Intentionally not documented.
	        Polygon.prototype.mustDrawVerticals = function (dc) {
	            return this._extrude
	                && this.activeAttributes.drawOutline
	                && this.activeAttributes.drawVerticals
	                && this.altitudeMode !== WorldWind.CLAMP_TO_GROUND;
	        };

	        // Overridden from AbstractShape base class.
	        Polygon.prototype.doRenderOrdered = function (dc) {
	            var currentData = this.currentData,
	                pickColor;

	            if (dc.pickingMode) {
	                pickColor = dc.uniquePickColor();
	            }

	            // Draw the cap if the interior requested and we were able to tessellate the polygon.
	            if (this.activeAttributes.drawInterior && currentData.capTriangles && currentData.capTriangles.length > 0) {
	                this.drawCap(dc, pickColor);
	            }

	            if (this._extrude && this.activeAttributes.drawInterior) {
	                this.drawSides(dc, pickColor);
	            }

	            if (this.activeAttributes.drawOutline) {
	                this.drawOutline(dc, pickColor);
	            }

	            currentData.refreshBuffers = false;

	            if (dc.pickingMode) {
	                var po = new PickedObject(pickColor, this.pickDelegate ? this.pickDelegate : this, null,
	                    dc.currentLayer, false);
	                dc.resolvePick(po);
	            }
	        };

	        Polygon.prototype.drawCap = function (dc, pickColor) {
	            var gl = dc.currentGlContext,
	                program = dc.currentProgram,
	                currentData = this.currentData,
	                refreshBuffers = currentData.refreshBuffers,
	                hasCapTexture = !!this.hasCapTexture(),
	                applyLighting = this.activeAttributes.applyLighting,
	                numCapVertices = currentData.capTriangles.length / (hasCapTexture ? 5 : 3),
	                vboId, opacity, color, stride, textureBound, capBuffer;

	            // Assume no cap texture.
	            program.loadTextureEnabled(gl, false);

	            this.applyMvpMatrix(dc);

	            if (!currentData.capVboCacheKey) {
	                currentData.capVboCacheKey = dc.gpuResourceCache.generateCacheKey();
	            }

	            vboId = dc.gpuResourceCache.resourceForKey(currentData.capVboCacheKey);
	            if (!vboId) {
	                vboId = gl.createBuffer();
	                dc.gpuResourceCache.putResource(currentData.capVboCacheKey, vboId, currentData.capTriangles.length * 4);
	                refreshBuffers = true;
	            }

	            gl.bindBuffer(gl.ARRAY_BUFFER, vboId);
	            if (refreshBuffers) {
	                capBuffer = applyLighting ? this.makeCapBufferWithNormals() : currentData.capTriangles;
	                gl.bufferData(gl.ARRAY_BUFFER, capBuffer, gl.STATIC_DRAW);
	                dc.frameStatistics.incrementVboLoadCount(1);
	            }

	            color = this.activeAttributes.interiorColor;
	            opacity = color.alpha * dc.currentLayer.opacity;
	            // Disable writing the shape's fragments to the depth buffer when the interior is semi-transparent.
	            gl.depthMask(opacity >= 1 || dc.pickingMode);
	            program.loadColor(gl, dc.pickingMode ? pickColor : color);
	            program.loadOpacity(gl, dc.pickingMode ? (opacity > 0 ? 1 : 0) : opacity);

	            stride = 12 + (hasCapTexture ? 8 : 0) + (applyLighting ? 12 : 0);

	            if (hasCapTexture && !dc.pickingMode) {
	                this.activeTexture = dc.gpuResourceCache.resourceForKey(this.capImageSource());
	                if (!this.activeTexture) {
	                    this.activeTexture =
	                        dc.gpuResourceCache.retrieveTexture(dc.currentGlContext, this.capImageSource());
	                }

	                textureBound = this.activeTexture && this.activeTexture.bind(dc);
	                if (textureBound) {
	                    program.loadTextureEnabled(gl, true);
	                    gl.enableVertexAttribArray(program.vertexTexCoordLocation);
	                    gl.vertexAttribPointer(program.vertexTexCoordLocation, 2, gl.FLOAT, false, stride, 12);
	                    program.loadTextureUnit(gl, gl.TEXTURE0);
	                    program.loadModulateColor(gl, dc.pickingMode);
	                }
	            }

	            if (applyLighting && !dc.pickingMode) {
	                program.loadApplyLighting(gl, true);
	                gl.enableVertexAttribArray(program.normalVectorLocation);
	                gl.vertexAttribPointer(program.normalVectorLocation, 3, gl.FLOAT, false, stride, stride - 12);
	            }

	            gl.vertexAttribPointer(program.vertexPointLocation, 3, gl.FLOAT, false, stride, 0);
	            gl.drawArrays(gl.TRIANGLES, 0, numCapVertices);
	        };

	        Polygon.prototype.makeCapBufferWithNormals = function () {
	            var currentData = this.currentData,
	                normal = currentData.capNormal,
	                numFloatsIn = this.hasCapTexture() ? 5 : 3,
	                numFloatsOut = numFloatsIn + 3,
	                numVertices = currentData.capTriangles.length / numFloatsIn,
	                bufferIn = currentData.capTriangles,
	                bufferOut = new Float32Array(numVertices * numFloatsOut),
	                k = 0;

	            for (var i = 0; i < numVertices; i++) {
	                for (var j = 0; j < numFloatsIn; j++) {
	                    bufferOut[k++] = bufferIn[i * numFloatsIn + j];
	                }

	                bufferOut[k++] = normal[0];
	                bufferOut[k++] = normal[1];
	                bufferOut[k++] = normal[2];
	            }

	            return bufferOut;
	        };

	        Polygon.prototype.drawSides = function (dc, pickColor) {
	            var gl = dc.currentGlContext,
	                program = dc.currentProgram,
	                currentData = this.currentData,
	                refreshBuffers = currentData.refreshBuffers,
	                hasSideTextures = this.hasSideTextures(),
	                applyLighting = this.activeAttributes.applyLighting,
	                numFloatsPerVertex = 3 + (hasSideTextures ? 2 : 0) + (applyLighting ? 3 : 0),
	                numBytesPerVertex = 4 * numFloatsPerVertex,
	                vboId, opacity, color, textureBound, sidesBuffer, numSides;

	            numSides = 0;
	            for (var b = 0; b < currentData.boundaryPoints.length; b++) { // for each boundary}
	                numSides += (currentData.boundaryPoints[b].length / 6) - 1; // 6 floats per boundary point: top + bottom
	            }

	            if (!currentData.sidesVboCacheKey) {
	                currentData.sidesVboCacheKey = dc.gpuResourceCache.generateCacheKey();
	            }

	            vboId = dc.gpuResourceCache.resourceForKey(currentData.sidesVboCacheKey);
	            if (!vboId || refreshBuffers) {
	                sidesBuffer = this.makeSidesBuffer(numSides);
	                currentData.numSideVertices = sidesBuffer.length / numFloatsPerVertex;

	                if (!vboId) {
	                    vboId = gl.createBuffer();
	                }

	                dc.gpuResourceCache.putResource(currentData.sidesVboCacheKey, vboId, sidesBuffer.length * 4);
	                gl.bindBuffer(gl.ARRAY_BUFFER, vboId);
	                gl.bufferData(gl.ARRAY_BUFFER, sidesBuffer, gl.STATIC_DRAW);
	                dc.frameStatistics.incrementVboLoadCount(1);
	            } else {
	                gl.bindBuffer(gl.ARRAY_BUFFER, vboId);
	            }

	            color = this.activeAttributes.interiorColor;
	            opacity = color.alpha * dc.currentLayer.opacity;
	            // Disable writing the shape's fragments to the depth buffer when the interior is semi-transparent.
	            gl.depthMask(opacity >= 1 || dc.pickingMode);
	            program.loadColor(gl, dc.pickingMode ? pickColor : color);
	            program.loadOpacity(gl, dc.pickingMode ? (opacity > 0 ? 1 : 0) : opacity);

	            if (hasSideTextures && !dc.pickingMode) {
	                this.activeTexture = dc.gpuResourceCache.resourceForKey(this.capImageSource());
	                if (!this.activeTexture) {
	                    this.activeTexture =
	                        dc.gpuResourceCache.retrieveTexture(dc.currentGlContext, this.capImageSource());
	                }

	                if (applyLighting) {
	                    program.loadApplyLighting(gl, true);
	                    gl.enableVertexAttribArray(program.normalVectorLocation);
	                } else {
	                    program.loadApplyLighting(gl, false);
	                }

	                // Step through the sides buffer rendering each side independently but from the same buffer.
	                for (var side = 0; side < numSides; side++) {
	                    var sideImageSource = this.sideImageSource(side),
	                        sideTexture = dc.gpuResourceCache.resourceForKey(sideImageSource),
	                        coordByteOffset = side * 6 * numBytesPerVertex; // 6 vertices (2 triangles) per side

	                    if (sideImageSource && !sideTexture) {
	                        sideTexture = dc.gpuResourceCache.retrieveTexture(dc.currentGlContext, sideImageSource);
	                    }

	                    textureBound = sideTexture && sideTexture.bind(dc);
	                    if (textureBound) {
	                        program.loadTextureEnabled(gl, true);
	                        program.loadTextureUnit(gl, gl.TEXTURE0);
	                        gl.enableVertexAttribArray(program.vertexTexCoordLocation);
	                        gl.vertexAttribPointer(program.vertexTexCoordLocation, 2, gl.FLOAT, false, numBytesPerVertex,
	                            coordByteOffset + 12);
	                    } else {
	                        program.loadTextureEnabled(gl, false);
	                        gl.disableVertexAttribArray(program.vertexTexCoordLocation);
	                    }

	                    if (applyLighting) {
	                        gl.vertexAttribPointer(program.normalVectorLocation, 3, gl.FLOAT, false, numBytesPerVertex,
	                            coordByteOffset + 20);
	                    }

	                    gl.vertexAttribPointer(program.vertexPointLocation, 3, gl.FLOAT, false, numBytesPerVertex,
	                        coordByteOffset);
	                    gl.drawArrays(gl.TRIANGLES, 0, 6); // 6 vertices per side
	                }
	            } else {
	                program.loadTextureEnabled(gl, false);

	                if (applyLighting && !dc.pickingMode) {
	                    program.loadApplyLighting(gl, true);
	                    gl.enableVertexAttribArray(program.normalVectorLocation);
	                    gl.vertexAttribPointer(program.normalVectorLocation, 3, gl.FLOAT, false, numBytesPerVertex,
	                        numBytesPerVertex - 12);
	                } else {
	                    program.loadApplyLighting(gl, false);
	                }

	                gl.vertexAttribPointer(program.vertexPointLocation, 3, gl.FLOAT, false, numBytesPerVertex, 0);
	                gl.drawArrays(gl.TRIANGLES, 0, currentData.numSideVertices);
	            }
	        };

	        Polygon.prototype.makeSidesBuffer = function (numSides) {
	            var currentData = this.currentData,
	                hasSideTextures = this.hasSideTextures(),
	                applyLighting = this.activeAttributes.applyLighting,
	                numFloatsPerVertex = 3 + (hasSideTextures ? 2 : 0) + (applyLighting ? 3 : 0),
	                sidesBuffer, sidesBufferIndex, numBufferFloats, v0, v1, v2, v3, t0, t1, t2, t3;

	            numBufferFloats = numSides * 2 * 3 * numFloatsPerVertex; // 2 triangles per side, 3 vertices per triangle
	            sidesBuffer = new Float32Array(numBufferFloats);
	            sidesBufferIndex = 0;

	            v0 = new Vec3(0, 0, 0);
	            v1 = new Vec3(0, 0, 0);
	            v2 = new Vec3(0, 0, 0);
	            v3 = new Vec3(0, 0, 0);

	            if (hasSideTextures) {
	                t0 = new Vec2(0, 1);
	                t1 = new Vec2(0, 0);
	                t2 = new Vec2(1, 1);
	                t3 = new Vec2(1, 0);
	            } else {
	                t0 = t1 = t2 = t3 = null;
	            }

	            for (var b = 0; b < currentData.boundaryPoints.length; b++) { // for each boundary}
	                var boundaryPoints = currentData.boundaryPoints[b],
	                    sideNormal;

	                for (var i = 0; i < boundaryPoints.length - 6; i += 6) {
	                    v0[0] = boundaryPoints[i];
	                    v0[1] = boundaryPoints[i + 1];
	                    v0[2] = boundaryPoints[i + 2];

	                    v1[0] = boundaryPoints[i + 3];
	                    v1[1] = boundaryPoints[i + 4];
	                    v1[2] = boundaryPoints[i + 5];

	                    v2[0] = boundaryPoints[i + 6];
	                    v2[1] = boundaryPoints[i + 7];
	                    v2[2] = boundaryPoints[i + 8];

	                    v3[0] = boundaryPoints[i + 9];
	                    v3[1] = boundaryPoints[i + 10];
	                    v3[2] = boundaryPoints[i + 11];

	                    sideNormal = applyLighting ? Vec3.computeTriangleNormal(v0, v1, v2) : null;

	                    // First triangle.
	                    this.addVertexToBuffer(v0, t0, sideNormal, sidesBuffer, sidesBufferIndex);
	                    sidesBufferIndex += numFloatsPerVertex;

	                    this.addVertexToBuffer(v1, t1, sideNormal, sidesBuffer, sidesBufferIndex);
	                    sidesBufferIndex += numFloatsPerVertex;

	                    this.addVertexToBuffer(v2, t2, sideNormal, sidesBuffer, sidesBufferIndex);
	                    sidesBufferIndex += numFloatsPerVertex;

	                    // Second triangle.
	                    this.addVertexToBuffer(v1, t1, sideNormal, sidesBuffer, sidesBufferIndex);
	                    sidesBufferIndex += numFloatsPerVertex;

	                    this.addVertexToBuffer(v3, t3, sideNormal, sidesBuffer, sidesBufferIndex);
	                    sidesBufferIndex += numFloatsPerVertex;

	                    this.addVertexToBuffer(v2, t2, sideNormal, sidesBuffer, sidesBufferIndex);
	                    sidesBufferIndex += numFloatsPerVertex;
	                }
	            }

	            return sidesBuffer;
	        };

	        Polygon.prototype.addVertexToBuffer = function (v, texCoord, normal, buffer, bufferIndex) {
	            buffer[bufferIndex++] = v[0];
	            buffer[bufferIndex++] = v[1];
	            buffer[bufferIndex++] = v[2];

	            if (texCoord) {
	                buffer[bufferIndex++] = texCoord[0];
	                buffer[bufferIndex++] = texCoord[1];
	            }

	            if (normal) {
	                buffer[bufferIndex++] = normal[0];
	                buffer[bufferIndex++] = normal[1];
	                buffer[bufferIndex] = normal[2];
	            }
	        };

	        Polygon.prototype.drawOutline = function (dc, pickColor) {
	            var gl = dc.currentGlContext,
	                program = dc.currentProgram,
	                currentData = this.currentData,
	                refreshBuffers = currentData.refreshBuffers,
	                numBoundaryPoints, vboId, opacity, color, stride, nPts, textureBound;

	            program.loadTextureEnabled(gl, false);
	            program.loadApplyLighting(gl, false);

	            if (this.hasCapTexture()) {
	                gl.disableVertexAttribArray(program.vertexTexCoordLocation); // we're not texturing the outline
	            }

	            if (this.activeAttributes.applyLighting) {
	                gl.disableVertexAttribArray(program.normalVectorLocation); // we're not lighting the outline
	            }

	            if (!currentData.boundaryVboCacheKeys) {
	                this.currentData.boundaryVboCacheKeys = [];
	            }

	            // Make the outline stand out from the interior.
	            this.applyMvpMatrixForOutline(dc);

	            program.loadTextureEnabled(gl, false);
	            gl.disableVertexAttribArray(program.vertexTexCoordLocation);

	            for (var b = 0; b < currentData.boundaryPoints.length; b++) { // for each boundary}
	                numBoundaryPoints = currentData.boundaryPoints[b].length / 3;

	                if (!currentData.boundaryVboCacheKeys[b]) {
	                    currentData.boundaryVboCacheKeys[b] = dc.gpuResourceCache.generateCacheKey();
	                }

	                vboId = dc.gpuResourceCache.resourceForKey(currentData.boundaryVboCacheKeys[b]);
	                if (!vboId) {
	                    vboId = gl.createBuffer();
	                    dc.gpuResourceCache.putResource(currentData.boundaryVboCacheKeys[b], vboId, numBoundaryPoints * 12);
	                    refreshBuffers = true;
	                }

	                gl.bindBuffer(gl.ARRAY_BUFFER, vboId);
	                if (refreshBuffers) {
	                    gl.bufferData(gl.ARRAY_BUFFER, currentData.boundaryPoints[b], gl.STATIC_DRAW);
	                    dc.frameStatistics.incrementVboLoadCount(1);
	                }

	                color = this.activeAttributes.outlineColor;
	                opacity = color.alpha * dc.currentLayer.opacity;
	                // Disable writing the shape's fragments to the depth buffer when the outline is
	                // semi-transparent.
	                gl.depthMask(opacity >= 1 || dc.pickingMode);
	                program.loadColor(gl, dc.pickingMode ? pickColor : color);
	                program.loadOpacity(gl, dc.pickingMode ? 1 : opacity);

	                gl.lineWidth(this.activeAttributes.outlineWidth);

	                if (this._extrude) {
	                    stride = 24;
	                    nPts = numBoundaryPoints / 2;
	                } else {
	                    stride = 12;
	                    nPts = numBoundaryPoints;
	                }

	                gl.vertexAttribPointer(program.vertexPointLocation, 3, gl.FLOAT, false, stride, 0);
	                gl.drawArrays(gl.LINE_STRIP, 0, nPts);

	                if (this.mustDrawVerticals(dc)) {
	                    gl.vertexAttribPointer(program.vertexPointLocation, 3, gl.FLOAT, false, 0, 0);
	                    gl.drawArrays(gl.LINES, 0, numBoundaryPoints - 2);
	                }
	            }
	        };

	        // Overridden from AbstractShape base class.
	        Polygon.prototype.beginDrawing = function (dc) {
	            var gl = dc.currentGlContext;

	            if (this.activeAttributes.drawInterior) {
	                gl.disable(gl.CULL_FACE);
	            }

	            dc.findAndBindProgram(BasicTextureProgram);
	            gl.enableVertexAttribArray(dc.currentProgram.vertexPointLocation);

	            var applyLighting = !dc.pickMode && this.activeAttributes.applyLighting;
	            if (applyLighting) {
	                dc.currentProgram.loadModelviewInverse(gl, dc.navigatorState.modelviewNormalTransform);
	            }
	        };

	        // Overridden from AbstractShape base class.
	        Polygon.prototype.endDrawing = function (dc) {
	            var gl = dc.currentGlContext;

	            gl.disableVertexAttribArray(dc.currentProgram.vertexPointLocation);
	            gl.disableVertexAttribArray(dc.currentProgram.normalVectorLocation);
	            gl.depthMask(true);
	            gl.lineWidth(1);
	            gl.enable(gl.CULL_FACE);
	        };

	        return Polygon;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports SurfacePolygon
	 * @version $Id: SurfacePolygon.js 3193 2015-06-15 22:29:13Z tgaskins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(30),
	        __webpack_require__(32),
	        __webpack_require__(132),
	        __webpack_require__(131)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
	              Logger,
	              ShapeAttributes,
	              SurfaceShape) {
	        "use strict";

	        /**
	         * Constructs a surface polygon.
	         * @alias SurfacePolygon
	         * @constructor
	         * @augments SurfaceShape
	         * @classdesc Represents a polygon draped over the terrain surface. The polygon may have multiple boundaries in
	         * order to define holes or empty regions.
	         * <p>
	         * SurfacePolygon uses the following attributes from its associated shape attributes bundle:
	         * <ul>
	         *         <li>Draw interior</li>
	         *         <li>Draw outline</li>
	         *         <li>Interior color</li>
	         *         <li>Outline color</li>
	         *         <li>Outline width</li>
	         *         <li>Outline stipple factor</li>
	         *         <li>Outline stipple pattern</li>
	         * </ul>
	         * @param {Array} boundaries The polygons boundary locations. If this argument is an array of
	         * [Locations]{@link Location} they define this polygon's outer boundary. If it is an array of arrays of
	         * Locations then each array entry defines one of this polygon's boundaries.
	         * @param {ShapeAttributes} attributes The attributes to apply to this shape. May be null, in which case
	         * attributes must be set directly before the shape is drawn.
	         *
	         * @throws {ArgumentError} If the specified boundaries are null or undefined.
	         */
	        var SurfacePolygon = function (boundaries, attributes) {
	            if (!boundaries) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "SurfacePolygon", "constructor",
	                        "The specified boundary array is null or undefined."));
	            }

	            SurfaceShape.call(this, attributes);

	            // Convert the boundaries to the form SurfaceShape wants them.
	            // TODO: Eliminate this once the SurfaceShape code is rewritten to handle multiple boundaries in the
	            // form they were specified.
	            var newBoundaries = null;

	            // Determine whether we've been passed a boundary or a boundary list.
	            if (boundaries.length > 0 && boundaries[0].latitude !== undefined) {
	                newBoundaries = boundaries.slice(0);
	                newBoundaries.push(boundaries[0]);
	                this._boundariesSpecifiedSimply = true;
	            } else if (boundaries.length > 1) {
	                var lastLocation = null;

	                newBoundaries = [];

	                for (var b = 0; b < boundaries.length; b++) {
	                    var firstLocation = boundaries[b][0];

	                    for (var i = 0; i < boundaries[b].length; i++) {
	                        newBoundaries.push(boundaries[b][i]);
	                    }

	                    newBoundaries.push(firstLocation);

	                    // Close the polygon for secondary parts by returning back to the first point
	                    // (which coincides with the last point of the first part in a well-formed shapefile).
	                    if (!!lastLocation) {
	                        newBoundaries.push(lastLocation);
	                    }
	                    else {
	                        lastLocation = newBoundaries[newBoundaries.length - 1];
	                    }
	                }
	            } else if (boundaries.length === 1) {
	                newBoundaries = boundaries[0].slice(0);
	                newBoundaries.push(boundaries[0][0]);
	            }

	            this._boundaries = newBoundaries;
	        };

	        SurfacePolygon.prototype = Object.create(SurfaceShape.prototype);

	        Object.defineProperties(SurfacePolygon.prototype, {
	            ///**
	            // * This polygon's boundaries. A two-dimensional array containing the polygon boundaries. Each entry of the
	            // * array specifies the vertices for one boundary of the polygon. If the boundaries were specified to the
	            // * constructor as a simple array of locations, then this property returns them in that form.
	            // * @type {Position[][] | Position[]}
	            // * @memberof SurfacePolygon.prototype
	            // * @readonly
	            // */
	            //boundaries: {
	            //    // TODO: Make this property read/write once the boundaries are interpolated correctly.
	            //    get: function () {
	            //        return this._boundariesSpecifiedSimply ? this._boundaries[0] : this._boundaries;
	            //    }
	            //}
	        });

	        // Internal use only. Intentionally not documented.
	        SurfacePolygon.staticStateKey = function (shape) {
	            var shapeStateKey = SurfaceShape.staticStateKey(shape);

	            return shapeStateKey;
	        };

	        // Internal use only. Intentionally not documented.
	        SurfacePolygon.prototype.computeStateKey = function () {
	            return SurfacePolygon.staticStateKey(this);
	        };

	        return SurfacePolygon;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

	/*
	 * @license
	 * Copyright 2000, Silicon Graphics, Inc. All Rights Reserved.
	 * Copyright 2014, Google Inc. All Rights Reserved.
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to
	 * deal in the Software without restriction, including without limitation the
	 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
	 * sell copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 *
	 * The above copyright notice including the dates of first publication and
	 * either this permission notice or a reference to http://oss.sgi.com/projects/FreeB/
	 * shall be included in all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
	 * SILICON GRAPHICS, INC. BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
	 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	 *
	 * Original Code. The Original Code is: OpenGL Sample Implementation,
	 * Version 1.2.1, released January 26, 2000, developed by Silicon Graphics,
	 * Inc. The Original Code is Copyright (c) 1991-2000 Silicon Graphics, Inc.
	 * Copyright in any portions created by third parties is as indicated
	 * elsewhere herein. All Rights Reserved.
	 */
	/*
	 * @author ericv@cs.stanford.edu (Eric Veach)
	 * @author bckenny@google.com (Brendan Kenny)
	 */

	/*
	 * Base namespace.
	 * @const
	 */
	var libtess = {};

	/**
	 * Whether to run asserts and extra debug checks.
	 * @define {boolean}
	 */
	libtess.DEBUG = false;

	/**
	 * Checks if the condition evaluates to true if libtess.DEBUG is true.
	 * @param {*} condition The condition to check.
	 * @param {string=} opt_message Error message in case of failure.
	 * @throws {Error} Assertion failed, the condition evaluates to false.
	 */
	libtess.assert = function(condition, opt_message) {
	  if (libtess.DEBUG && !condition) {
	    throw new Error('Assertion failed' +
	        (opt_message ? ': ' + opt_message : ''));
	  }
	};

	/**
	 * The maximum vertex coordinate size, 1e150. Anything larger will trigger a
	 * GLU_TESS_COORD_TOO_LARGE error callback and the vertex will be clamped to
	 * this value for all tessellation calculations.
	 * @const {number}
	 */
	libtess.GLU_TESS_MAX_COORD = 1e150;
	// NOTE(bckenny): value from glu.pl generator

	/**
	 * Normally the polygon is projected to a plane perpendicular to one of the
	 * three coordinate axes before tessellating in 2d. This helps numerical
	 * accuracy by forgoing a transformation step by simply dropping one coordinate
	 * dimension.
	 *
	 * However, this can affect the placement of intersection points for non-axis-
	 * aligned polygons. Setting TRUE_PROJECT to true will instead project onto a
	 * plane actually perpendicular to the polygon's normal.
	 *
	 * NOTE(bckenny): I can find no instances on the internet in which this mode has
	 * been used, but it's difficult to search for. This was a compile-time setting
	 * in the original, so setting this as constant. If this is exposed in the
	 * public API, remove the ignore coverage directives on
	 * libtess.normal.projectPolygon and libtess.normal.normalize_.
	 * @const {boolean}
	 */
	libtess.TRUE_PROJECT = false;

	/**
	 * We cache vertex data for single-contour polygons so that we can try a
	 * quick-and-dirty decomposition first.
	 * @const {number}
	 */
	libtess.TESS_MAX_CACHE = 100;

	/**
	 * The default tolerance for merging features, 0, meaning vertices are only
	 * merged if they are exactly coincident
	 * If a higher tolerance is needed, significant rewriting will need to occur.
	 * See libtess.sweep.TOLERANCE_NONZERO_ as a starting place.
	 * @const {number}
	 */
	libtess.GLU_TESS_DEFAULT_TOLERANCE = 0;

	/**
	 * The input contours parition the plane into regions. A winding
	 * rule determines which of these regions are inside the polygon.
	 *
	 * For a single contour C, the winding number of a point x is simply
	 * the signed number of revolutions we make around x as we travel
	 * once around C (where CCW is positive). When there are several
	 * contours, the individual winding numbers are summed. This
	 * procedure associates a signed integer value with each point x in
	 * the plane. Note that the winding number is the same for all
	 * points in a single region.
	 *
	 * The winding rule classifies a region as "inside" if its winding
	 * number belongs to the chosen category (odd, nonzero, positive,
	 * negative, or absolute value of at least two). The current GLU
	 * tesselator implements the "odd" rule. The "nonzero" rule is another
	 * common way to define the interior. The other three rules are
	 * useful for polygon CSG operations.
	 * @enum {number}
	 */
	libtess.windingRule = {
	  // NOTE(bckenny): values from enumglu.spec
	  GLU_TESS_WINDING_ODD: 100130,
	  GLU_TESS_WINDING_NONZERO: 100131,
	  GLU_TESS_WINDING_POSITIVE: 100132,
	  GLU_TESS_WINDING_NEGATIVE: 100133,
	  GLU_TESS_WINDING_ABS_GEQ_TWO: 100134
	};

	/**
	 * The type of primitive return from a "begin" callback. GL_LINE_LOOP is only
	 * returned when GLU_TESS_BOUNDARY_ONLY is true. GL_TRIANGLE_STRIP and
	 * GL_TRIANGLE_FAN are no longer returned since 1.1.0 (see release notes).
	 * @enum {number}
	 */
	libtess.primitiveType = {
	  GL_LINE_LOOP: 2,
	  GL_TRIANGLES: 4,
	  GL_TRIANGLE_STRIP: 5,
	  GL_TRIANGLE_FAN: 6
	};

	/**
	 * The types of errors provided in the error callback.
	 * @enum {number}
	 */
	libtess.errorType = {
	  // TODO(bckenny) doc types
	  // NOTE(bckenny): values from enumglu.spec
	  GLU_TESS_MISSING_BEGIN_POLYGON: 100151,
	  GLU_TESS_MISSING_END_POLYGON: 100153,
	  GLU_TESS_MISSING_BEGIN_CONTOUR: 100152,
	  GLU_TESS_MISSING_END_CONTOUR: 100154,
	  GLU_TESS_COORD_TOO_LARGE: 100155,
	  GLU_TESS_NEED_COMBINE_CALLBACK: 100156
	};

	/**
	 * Enum values necessary for providing settings and callbacks. See the readme
	 * for details.
	 * @enum {number}
	 */
	libtess.gluEnum = {
	  // TODO(bckenny): rename so not always typing libtess.gluEnum.*?

	  // NOTE(bckenny): values from enumglu.spec
	  GLU_TESS_BEGIN: 100100,
	  GLU_TESS_VERTEX: 100101,
	  GLU_TESS_END: 100102,
	  GLU_TESS_ERROR: 100103,
	  GLU_TESS_EDGE_FLAG: 100104,
	  GLU_TESS_COMBINE: 100105,
	  GLU_TESS_BEGIN_DATA: 100106,
	  GLU_TESS_VERTEX_DATA: 100107,
	  GLU_TESS_END_DATA: 100108,
	  GLU_TESS_ERROR_DATA: 100109,
	  GLU_TESS_EDGE_FLAG_DATA: 100110,
	  GLU_TESS_COMBINE_DATA: 100111,

	  GLU_TESS_MESH: 100112,  //  NOTE(bckenny): from tess.c
	  GLU_TESS_TOLERANCE: 100142,
	  GLU_TESS_WINDING_RULE: 100140,
	  GLU_TESS_BOUNDARY_ONLY: 100141,

	  // TODO(bckenny): move this to libtess.errorType?
	  GLU_INVALID_ENUM: 100900,
	  GLU_INVALID_VALUE: 100901
	};

	/** @typedef {number} */
	libtess.PQHandle;

	// TODO(bckenny): better typing on key?
	/** @typedef {Object} */
	libtess.PQKey;


	/* global libtess */

	/** @const */
	libtess.geom = {};

	/**
	 * Returns whether vertex u and vertex v are equal.
	 * @param {libtess.GluVertex} u
	 * @param {libtess.GluVertex} v
	 * @return {boolean}
	 */
	libtess.geom.vertEq = function(u, v) {
	  return u.s === v.s && u.t === v.t;
	};

	/**
	 * Returns whether vertex u is lexicographically less than or equal to vertex v.
	 * @param {libtess.GluVertex} u
	 * @param {libtess.GluVertex} v
	 * @return {boolean}
	 */
	libtess.geom.vertLeq = function(u, v) {
	  return (u.s < v.s) || (u.s === v.s && u.t <= v.t);
	};

	/**
	 * Given three vertices u,v,w such that geom.vertLeq(u,v) && geom.vertLeq(v,w),
	 * evaluates the t-coord of the edge uw at the s-coord of the vertex v.
	 * Returns v.t - (uw)(v.s), ie. the signed distance from uw to v.
	 * If uw is vertical (and thus passes thru v), the result is zero.
	 *
	 * The calculation is extremely accurate and stable, even when v
	 * is very close to u or w.  In particular if we set v.t = 0 and
	 * let r be the negated result (this evaluates (uw)(v.s)), then
	 * r is guaranteed to satisfy MIN(u.t,w.t) <= r <= MAX(u.t,w.t).
	 * @param {libtess.GluVertex} u
	 * @param {libtess.GluVertex} v
	 * @param {libtess.GluVertex} w
	 * @return {number}
	 */
	libtess.geom.edgeEval = function(u, v, w) {

	  var gapL = v.s - u.s;
	  var gapR = w.s - v.s;

	  if (gapL + gapR > 0) {
	    if (gapL < gapR) {
	      return (v.t - u.t) + (u.t - w.t) * (gapL / (gapL + gapR));
	    } else {
	      return (v.t - w.t) + (w.t - u.t) * (gapR / (gapL + gapR));
	    }
	  }

	  // vertical line
	  return 0;
	};

	/**
	 * Returns a number whose sign matches geom.edgeEval(u,v,w) but which
	 * is cheaper to evaluate.  Returns > 0, == 0 , or < 0
	 * as v is above, on, or below the edge uw.
	 * @param {libtess.GluVertex} u
	 * @param {libtess.GluVertex} v
	 * @param {libtess.GluVertex} w
	 * @return {number}
	 */
	libtess.geom.edgeSign = function(u, v, w) {

	  var gapL = v.s - u.s;
	  var gapR = w.s - v.s;

	  if (gapL + gapR > 0) {
	    return (v.t - w.t) * gapL + (v.t - u.t) * gapR;
	  }

	  // vertical line
	  return 0;
	};

	/**
	 * Version of VertLeq with s and t transposed.
	 * Returns whether vertex u is lexicographically less than or equal to vertex v.
	 * @param {libtess.GluVertex} u
	 * @param {libtess.GluVertex} v
	 * @return {boolean}
	 */
	libtess.geom.transLeq = function(u, v) {
	  return (u.t < v.t) || (u.t === v.t && u.s <= v.s);
	};

	/**
	 * Version of geom.edgeEval with s and t transposed.
	 * Given three vertices u,v,w such that geom.transLeq(u,v) &&
	 * geom.transLeq(v,w), evaluates the t-coord of the edge uw at the s-coord of
	 * the vertex v. Returns v.s - (uw)(v.t), ie. the signed distance from uw to v.
	 * If uw is vertical (and thus passes thru v), the result is zero.
	 *
	 * The calculation is extremely accurate and stable, even when v
	 * is very close to u or w.  In particular if we set v.s = 0 and
	 * let r be the negated result (this evaluates (uw)(v.t)), then
	 * r is guaranteed to satisfy MIN(u.s,w.s) <= r <= MAX(u.s,w.s).
	 * @param {libtess.GluVertex} u
	 * @param {libtess.GluVertex} v
	 * @param {libtess.GluVertex} w
	 * @return {number}
	 */
	libtess.geom.transEval = function(u, v, w) {

	  var gapL = v.t - u.t;
	  var gapR = w.t - v.t;

	  if (gapL + gapR > 0) {
	    if (gapL < gapR) {
	      return (v.s - u.s) + (u.s - w.s) * (gapL / (gapL + gapR));
	    } else {
	      return (v.s - w.s) + (w.s - u.s) * (gapR / (gapL + gapR));
	    }
	  }

	  // vertical line
	  return 0;
	};

	/**
	 * Version of geom.edgeSign with s and t transposed.
	 * Returns a number whose sign matches geom.transEval(u,v,w) but which
	 * is cheaper to evaluate.  Returns > 0, == 0 , or < 0
	 * as v is above, on, or below the edge uw.
	 * @param {libtess.GluVertex} u
	 * @param {libtess.GluVertex} v
	 * @param {libtess.GluVertex} w
	 * @return {number}
	 */
	libtess.geom.transSign = function(u, v, w) {

	  var gapL = v.t - u.t;
	  var gapR = w.t - v.t;

	  if (gapL + gapR > 0) {
	    return (v.s - w.s) * gapL + (v.s - u.s) * gapR;
	  }

	  // vertical line
	  return 0;
	};

	/**
	 * Returns whether edge is directed from right to left.
	 * @param {libtess.GluHalfEdge} e
	 * @return {boolean}
	 */
	libtess.geom.edgeGoesLeft = function(e) {
	  return libtess.geom.vertLeq(e.dst(), e.org);
	};

	/**
	 * Returns whether edge is directed from left to right.
	 * @param {libtess.GluHalfEdge} e
	 * @return {boolean}
	 */
	libtess.geom.edgeGoesRight = function(e) {
	  return libtess.geom.vertLeq(e.org, e.dst());
	};

	/**
	 * Calculates the L1 distance between vertices u and v.
	 * @param {libtess.GluVertex} u
	 * @param {libtess.GluVertex} v
	 * @return {number}
	 */
	libtess.geom.vertL1dist = function(u, v) {
	  return Math.abs(u.s - v.s) + Math.abs(u.t - v.t);
	};

	// NOTE(bckenny): vertCCW is called nowhere in libtess and isn't part of the
	// public API.
	/* istanbul ignore next */
	/**
	 * For almost-degenerate situations, the results are not reliable.
	 * Unless the floating-point arithmetic can be performed without
	 * rounding errors, *any* implementation will give incorrect results
	 * on some degenerate inputs, so the client must have some way to
	 * handle this situation.
	 * @param {!libtess.GluVertex} u
	 * @param {!libtess.GluVertex} v
	 * @param {!libtess.GluVertex} w
	 * @return {boolean}
	 */
	libtess.geom.vertCCW = function(u, v, w) {
	  return (u.s * (v.t - w.t) + v.s * (w.t - u.t) + w.s * (u.t - v.t)) >= 0;
	};

	/**
	 * Given parameters a,x,b,y returns the value (b*x+a*y)/(a+b),
	 * or (x+y)/2 if a==b==0. It requires that a,b >= 0, and enforces
	 * this in the rare case that one argument is slightly negative.
	 * The implementation is extremely stable numerically.
	 * In particular it guarantees that the result r satisfies
	 * MIN(x,y) <= r <= MAX(x,y), and the results are very accurate
	 * even when a and b differ greatly in magnitude.
	 * @private
	 * @param {number} a
	 * @param {number} x
	 * @param {number} b
	 * @param {number} y
	 * @return {number}
	 */
	libtess.geom.interpolate_ = function(a, x, b, y) {
	  // from Macro RealInterpolate:
	  //(a = (a < 0) ? 0 : a, b = (b < 0) ? 0 : b, ((a <= b) ? ((b == 0) ? ((x+y) / 2) : (x + (y-x) * (a/(a+b)))) : (y + (x-y) * (b/(a+b)))))
	  a = (a < 0) ? 0 : a;
	  b = (b < 0) ? 0 : b;

	  if (a <= b) {
	    if (b === 0) {
	      return (x + y) / 2;
	    } else {
	      return x + (y - x) * (a / (a + b));
	    }
	  } else {
	    return y + (x - y) * (b / (a + b));
	  }
	};

	/**
	 * Given edges (o1,d1) and (o2,d2), compute their point of intersection.
	 * The computed point is guaranteed to lie in the intersection of the
	 * bounding rectangles defined by each edge.
	 * @param {!libtess.GluVertex} o1
	 * @param {!libtess.GluVertex} d1
	 * @param {!libtess.GluVertex} o2
	 * @param {!libtess.GluVertex} d2
	 * @param {!libtess.GluVertex} v
	 */
	libtess.geom.edgeIntersect = function(o1, d1, o2, d2, v) {
	  // This is certainly not the most efficient way to find the intersection
	  // of two line segments, but it is very numerically stable.

	  // Strategy: find the two middle vertices in the VertLeq ordering,
	  // and interpolate the intersection s-value from these. Then repeat
	  // using the TransLeq ordering to find the intersection t-value.
	  var z1;
	  var z2;
	  var tmp;
	  if (!libtess.geom.vertLeq(o1, d1)) {
	    // Swap(o1, d1);
	    tmp = o1;
	    o1 = d1;
	    d1 = tmp;
	  }
	  if (!libtess.geom.vertLeq(o2, d2)) {
	    // Swap(o2, d2);
	    tmp = o2;
	    o2 = d2;
	    d2 = tmp;
	  }
	  if (!libtess.geom.vertLeq(o1, o2)) {
	    // Swap(o1, o2);
	    tmp = o1;
	    o1 = o2;
	    o2 = tmp;
	    // Swap(d1, d2);
	    tmp = d1;
	    d1 = d2;
	    d2 = tmp;
	  }

	  if (!libtess.geom.vertLeq(o2, d1)) {
	    // Technically, no intersection -- do our best
	    v.s = (o2.s + d1.s) / 2;

	  } else if (libtess.geom.vertLeq(d1, d2)) {
	    // Interpolate between o2 and d1
	    z1 = libtess.geom.edgeEval(o1, o2, d1);
	    z2 = libtess.geom.edgeEval(o2, d1, d2);
	    if (z1 + z2 < 0) { z1 = -z1; z2 = -z2; }
	    v.s = libtess.geom.interpolate_(z1, o2.s, z2, d1.s);

	  } else {
	    // Interpolate between o2 and d2
	    z1 = libtess.geom.edgeSign(o1, o2, d1);
	    z2 = -libtess.geom.edgeSign(o1, d2, d1);
	    if (z1 + z2 < 0) { z1 = -z1; z2 = -z2; }
	    v.s = libtess.geom.interpolate_(z1, o2.s, z2, d2.s);
	  }

	  // Now repeat the process for t
	  if (!libtess.geom.transLeq(o1, d1)) {
	    // Swap(o1, d1);
	    tmp = o1;
	    o1 = d1;
	    d1 = tmp;
	  }
	  if (!libtess.geom.transLeq(o2, d2)) {
	    // Swap(o2, d2);
	    tmp = o2;
	    o2 = d2;
	    d2 = tmp;
	  }
	  if (!libtess.geom.transLeq(o1, o2)) {
	    // Swap(o1, o2);
	    tmp = o1;
	    o1 = o2;
	    o2 = tmp;
	    // Swap(d1, d2);
	    tmp = d1;
	    d1 = d2;
	    d2 = tmp;
	  }

	  if (!libtess.geom.transLeq(o2, d1)) {
	    // Technically, no intersection -- do our best
	    v.t = (o2.t + d1.t) / 2;

	  } else if (libtess.geom.transLeq(d1, d2)) {
	    // Interpolate between o2 and d1
	    z1 = libtess.geom.transEval(o1, o2, d1);
	    z2 = libtess.geom.transEval(o2, d1, d2);
	    if (z1 + z2 < 0) { z1 = -z1; z2 = -z2; }
	    v.t = libtess.geom.interpolate_(z1, o2.t, z2, d1.t);

	  } else {
	    // Interpolate between o2 and d2
	    z1 = libtess.geom.transSign(o1, o2, d1);
	    z2 = -libtess.geom.transSign(o1, d2, d1);
	    if (z1 + z2 < 0) { z1 = -z1; z2 = -z2; }
	    v.t = libtess.geom.interpolate_(z1, o2.t, z2, d2.t);
	  }
	};



	/* global libtess */

	// TODO(bckenny): could maybe merge GluMesh and mesh.js since these are
	// operations on the mesh

	/** @const */
	libtess.mesh = {};

	/****************** Basic Edge Operations **********************/


	/**
	 * makeEdge creates one edge, two vertices, and a loop (face).
	 * The loop consists of the two new half-edges.
	 *
	 * @param {libtess.GluMesh} mesh [description].
	 * @return {libtess.GluHalfEdge} [description].
	 */
	libtess.mesh.makeEdge = function(mesh) {
	  // TODO(bckenny): probably move to GluMesh, but needs Make* methods with it

	  var e = libtess.mesh.makeEdgePair_(mesh.eHead);

	  // complete edge with vertices and face (see mesh.makeEdgePair_)
	  libtess.mesh.makeVertex_(e, mesh.vHead);
	  libtess.mesh.makeVertex_(e.sym, mesh.vHead);
	  libtess.mesh.makeFace_(e, mesh.fHead);

	  return e;
	};


	/**
	 * meshSplice(eOrg, eDst) is the basic operation for changing the
	 * mesh connectivity and topology. It changes the mesh so that
	 *  eOrg.oNext <- OLD( eDst.oNext )
	 *  eDst.oNext <- OLD( eOrg.oNext )
	 * where OLD(...) means the value before the meshSplice operation.
	 *
	 * This can have two effects on the vertex structure:
	 *  - if eOrg.org != eDst.org, the two vertices are merged together
	 *  - if eOrg.org == eDst.org, the origin is split into two vertices
	 * In both cases, eDst.org is changed and eOrg.org is untouched.
	 *
	 * Similarly (and independently) for the face structure,
	 *  - if eOrg.lFace == eDst.lFace, one loop is split into two
	 *  - if eOrg.lFace != eDst.lFace, two distinct loops are joined into one
	 * In both cases, eDst.lFace is changed and eOrg.lFace is unaffected.
	 *
	 * Some special cases:
	 * If eDst == eOrg, the operation has no effect.
	 * If eDst == eOrg.lNext, the new face will have a single edge.
	 * If eDst == eOrg.lPrev(), the old face will have a single edge.
	 * If eDst == eOrg.oNext, the new vertex will have a single edge.
	 * If eDst == eOrg.oPrev(), the old vertex will have a single edge.
	 *
	 * @param {libtess.GluHalfEdge} eOrg [description].
	 * @param {libtess.GluHalfEdge} eDst [description].
	 */
	libtess.mesh.meshSplice = function(eOrg, eDst) {
	  // TODO: more descriptive name?

	  var joiningLoops = false;
	  var joiningVertices = false;

	  if (eOrg === eDst) {
	    return;
	  }

	  if (eDst.org !== eOrg.org) {
	    // We are merging two disjoint vertices -- destroy eDst.org
	    joiningVertices = true;
	    libtess.mesh.killVertex_(eDst.org, eOrg.org);
	  }

	  if (eDst.lFace !== eOrg.lFace) {
	    // We are connecting two disjoint loops -- destroy eDst.lFace
	    joiningLoops = true;
	    libtess.mesh.killFace_(eDst.lFace, eOrg.lFace);
	  }

	  // Change the edge structure
	  libtess.mesh.splice_(eDst, eOrg);

	  if (!joiningVertices) {
	    // We split one vertex into two -- the new vertex is eDst.org.
	    // Make sure the old vertex points to a valid half-edge.
	    libtess.mesh.makeVertex_(eDst, eOrg.org);
	    eOrg.org.anEdge = eOrg;
	  }

	  if (!joiningLoops) {
	    // We split one loop into two -- the new loop is eDst.lFace.
	    // Make sure the old face points to a valid half-edge.
	    libtess.mesh.makeFace_(eDst, eOrg.lFace);
	    eOrg.lFace.anEdge = eOrg;
	  }
	};


	/**
	 * deleteEdge(eDel) removes the edge eDel. There are several cases:
	 * if (eDel.lFace != eDel.rFace()), we join two loops into one; the loop
	 * eDel.lFace is deleted. Otherwise, we are splitting one loop into two;
	 * the newly created loop will contain eDel.dst(). If the deletion of eDel
	 * would create isolated vertices, those are deleted as well.
	 *
	 * This function could be implemented as two calls to __gl_meshSplice
	 * plus a few calls to memFree, but this would allocate and delete
	 * unnecessary vertices and faces.
	 *
	 * @param {libtess.GluHalfEdge} eDel [description].
	 */
	libtess.mesh.deleteEdge = function(eDel) {
	  var eDelSym = eDel.sym;
	  var joiningLoops = false;

	  // First step: disconnect the origin vertex eDel.org.  We make all
	  // changes to get a consistent mesh in this "intermediate" state.
	  if (eDel.lFace !== eDel.rFace()) {
	    // We are joining two loops into one -- remove the left face
	    joiningLoops = true;
	    libtess.mesh.killFace_(eDel.lFace, eDel.rFace());
	  }

	  if (eDel.oNext === eDel) {
	    libtess.mesh.killVertex_(eDel.org, null);

	  } else {
	    // Make sure that eDel.org and eDel.rFace() point to valid half-edges
	    eDel.rFace().anEdge = eDel.oPrev();
	    eDel.org.anEdge = eDel.oNext;

	    libtess.mesh.splice_(eDel, eDel.oPrev());

	    if (!joiningLoops) {
	      // We are splitting one loop into two -- create a new loop for eDel.
	      libtess.mesh.makeFace_(eDel, eDel.lFace);
	    }
	  }

	  // Claim: the mesh is now in a consistent state, except that eDel.org
	  // may have been deleted.  Now we disconnect eDel.dst().
	  if (eDelSym.oNext === eDelSym) {
	    libtess.mesh.killVertex_(eDelSym.org, null);
	    libtess.mesh.killFace_(eDelSym.lFace, null);

	  } else {
	    // Make sure that eDel.dst() and eDel.lFace point to valid half-edges
	    eDel.lFace.anEdge = eDelSym.oPrev();
	    eDelSym.org.anEdge = eDelSym.oNext;
	    libtess.mesh.splice_(eDelSym, eDelSym.oPrev());
	  }

	  // Any isolated vertices or faces have already been freed.
	  libtess.mesh.killEdge_(eDel);
	};

	/******************** Other Edge Operations **********************/

	/* All these routines can be implemented with the basic edge
	 * operations above.  They are provided for convenience and efficiency.
	 */


	/**
	 * addEdgeVertex(eOrg) creates a new edge eNew such that
	 * eNew == eOrg.lNext, and eNew.dst() is a newly created vertex.
	 * eOrg and eNew will have the same left face.
	 *
	 * @param {libtess.GluHalfEdge} eOrg [description].
	 * @return {libtess.GluHalfEdge} [description].
	 */
	libtess.mesh.addEdgeVertex = function(eOrg) {
	  // TODO(bckenny): why is it named this?

	  var eNew = libtess.mesh.makeEdgePair_(eOrg);
	  var eNewSym = eNew.sym;

	  // Connect the new edge appropriately
	  libtess.mesh.splice_(eNew, eOrg.lNext);

	  // Set the vertex and face information
	  eNew.org = eOrg.dst();

	  libtess.mesh.makeVertex_(eNewSym, eNew.org);

	  eNew.lFace = eNewSym.lFace = eOrg.lFace;

	  return eNew;
	};


	/**
	 * splitEdge(eOrg) splits eOrg into two edges eOrg and eNew,
	 * such that eNew == eOrg.lNext. The new vertex is eOrg.dst() == eNew.org.
	 * eOrg and eNew will have the same left face.
	 *
	 * @param {libtess.GluHalfEdge} eOrg [description].
	 * @return {!libtess.GluHalfEdge} [description].
	 */
	libtess.mesh.splitEdge = function(eOrg) {
	  var tempHalfEdge = libtess.mesh.addEdgeVertex(eOrg);
	  var eNew = tempHalfEdge.sym;

	  // Disconnect eOrg from eOrg.dst() and connect it to eNew.org
	  libtess.mesh.splice_(eOrg.sym, eOrg.sym.oPrev());
	  libtess.mesh.splice_(eOrg.sym, eNew);

	  // Set the vertex and face information
	  eOrg.sym.org = eNew.org; // NOTE(bckenny): assignment to dst
	  eNew.dst().anEdge = eNew.sym;  // may have pointed to eOrg.sym
	  eNew.sym.lFace = eOrg.rFace(); // NOTE(bckenny): assignment to rFace
	  eNew.winding = eOrg.winding;  // copy old winding information
	  eNew.sym.winding = eOrg.sym.winding;

	  return eNew;
	};


	/**
	 * connect(eOrg, eDst) creates a new edge from eOrg.dst()
	 * to eDst.org, and returns the corresponding half-edge eNew.
	 * If eOrg.lFace == eDst.lFace, this splits one loop into two,
	 * and the newly created loop is eNew.lFace. Otherwise, two disjoint
	 * loops are merged into one, and the loop eDst.lFace is destroyed.
	 *
	 * If (eOrg == eDst), the new face will have only two edges.
	 * If (eOrg.lNext == eDst), the old face is reduced to a single edge.
	 * If (eOrg.lNext.lNext == eDst), the old face is reduced to two edges.
	 *
	 * @param {libtess.GluHalfEdge} eOrg [description].
	 * @param {libtess.GluHalfEdge} eDst [description].
	 * @return {!libtess.GluHalfEdge} [description].
	 */
	libtess.mesh.connect = function(eOrg, eDst) {
	  var joiningLoops = false;
	  var eNew = libtess.mesh.makeEdgePair_(eOrg);
	  var eNewSym = eNew.sym;

	  if (eDst.lFace !== eOrg.lFace) {
	    // We are connecting two disjoint loops -- destroy eDst.lFace
	    joiningLoops = true;
	    libtess.mesh.killFace_(eDst.lFace, eOrg.lFace);
	  }

	  // Connect the new edge appropriately
	  libtess.mesh.splice_(eNew, eOrg.lNext);
	  libtess.mesh.splice_(eNewSym, eDst);

	  // Set the vertex and face information
	  eNew.org = eOrg.dst();
	  eNewSym.org = eDst.org;
	  eNew.lFace = eNewSym.lFace = eOrg.lFace;

	  // Make sure the old face points to a valid half-edge
	  eOrg.lFace.anEdge = eNewSym;

	  if (!joiningLoops) {
	    // We split one loop into two -- the new loop is eNew.lFace
	    libtess.mesh.makeFace_(eNew, eOrg.lFace);
	  }
	  return eNew;
	};

	/******************** Other Operations **********************/


	/**
	 * zapFace(fZap) destroys a face and removes it from the
	 * global face list. All edges of fZap will have a null pointer as their
	 * left face. Any edges which also have a null pointer as their right face
	 * are deleted entirely (along with any isolated vertices this produces).
	 * An entire mesh can be deleted by zapping its faces, one at a time,
	 * in any order. Zapped faces cannot be used in further mesh operations!
	 *
	 * @param {libtess.GluFace} fZap [description].
	 */
	libtess.mesh.zapFace = function(fZap) {
	  var eStart = fZap.anEdge;

	  // walk around face, deleting edges whose right face is also NULL
	  var eNext = eStart.lNext;
	  var e;
	  do {
	    e = eNext;
	    eNext = e.lNext;

	    e.lFace = null;
	    if (e.rFace() === null) {
	      // delete the edge -- see mesh.deleteEdge above
	      if (e.oNext === e) {
	        libtess.mesh.killVertex_(e.org, null);

	      } else {
	        // Make sure that e.org points to a valid half-edge
	        e.org.anEdge = e.oNext;
	        libtess.mesh.splice_(e, e.oPrev());
	      }

	      var eSym = e.sym;

	      if (eSym.oNext === eSym) {
	        libtess.mesh.killVertex_(eSym.org, null);

	      } else {
	        // Make sure that eSym.org points to a valid half-edge
	        eSym.org.anEdge = eSym.oNext;
	        libtess.mesh.splice_(eSym, eSym.oPrev());
	      }
	      libtess.mesh.killEdge_(e);
	    }
	  } while (e !== eStart);

	  // delete from circular doubly-linked list
	  var fPrev = fZap.prev;
	  var fNext = fZap.next;
	  fNext.prev = fPrev;
	  fPrev.next = fNext;

	  // TODO(bckenny): memFree( fZap );
	  // TODO(bckenny): probably null at callsite
	};

	// TODO(bckenny): meshUnion isn't called within libtess and isn't part of the
	// public API. Could be useful if more mesh manipulation functions are exposed.
	/* istanbul ignore next */
	/**
	 * meshUnion() forms the union of all structures in
	 * both meshes, and returns the new mesh (the old meshes are destroyed).
	 *
	 * @param {!libtess.GluMesh} mesh1
	 * @param {!libtess.GluMesh} mesh2
	 * @return {!libtess.GluMesh}
	 */
	libtess.mesh.meshUnion = function(mesh1, mesh2) {
	  // TODO(bceknny): probably move to GluMesh method
	  var f1 = mesh1.fHead;
	  var v1 = mesh1.vHead;
	  var e1 = mesh1.eHead;

	  var f2 = mesh2.fHead;
	  var v2 = mesh2.vHead;
	  var e2 = mesh2.eHead;

	  // Add the faces, vertices, and edges of mesh2 to those of mesh1
	  if (f2.next !== f2) {
	    f1.prev.next = f2.next;
	    f2.next.prev = f1.prev;
	    f2.prev.next = f1;
	    f1.prev = f2.prev;
	  }

	  if (v2.next !== v2) {
	    v1.prev.next = v2.next;
	    v2.next.prev = v1.prev;
	    v2.prev.next = v1;
	    v1.prev = v2.prev;
	  }

	  if (e2.next !== e2) {
	    e1.sym.next.sym.next = e2.next;
	    e2.next.sym.next = e1.sym.next;
	    e2.sym.next.sym.next = e1;
	    e1.sym.next = e2.sym.next;
	  }

	  // TODO(bckenny): memFree(mesh2);
	  // TODO(bckenny): If function is kept, remove mesh2's data to enforce.
	  return mesh1;
	};


	/**
	 * deleteMesh(mesh) will free all storage for any valid mesh.
	 * @param {libtess.GluMesh} mesh [description].
	 */
	libtess.mesh.deleteMesh = function(mesh) {
	  // TODO(bckenny): unnecessary, I think.
	  // TODO(bckenny): might want to explicitly null at callsite
	  // lots of memFrees. see also DELETE_BY_ZAPPING
	};

	/************************ Utility Routines ************************/


	/**
	 * Creates a new pair of half-edges which form their own loop.
	 * No vertex or face structures are allocated, but these must be assigned
	 * before the current edge operation is completed.
	 *
	 * TODO(bckenny): warning about eNext strictly being first of pair? (see code)
	 *
	 * @private
	 * @param {libtess.GluHalfEdge} eNext [description].
	 * @return {libtess.GluHalfEdge} [description].
	 */
	libtess.mesh.makeEdgePair_ = function(eNext) {
	  var e = new libtess.GluHalfEdge();
	  var eSym = new libtess.GluHalfEdge();

	  // TODO(bckenny): how do we ensure this? see above comment in jsdoc
	  // Make sure eNext points to the first edge of the edge pair
	  // if (eNext->Sym < eNext ) { eNext = eNext->Sym; }

	  // NOTE(bckenny): check this for bugs in current implementation!

	  // Insert in circular doubly-linked list before eNext.
	  // Note that the prev pointer is stored in sym.next.
	  var ePrev = eNext.sym.next;
	  eSym.next = ePrev;
	  ePrev.sym.next = e;
	  e.next = eNext;
	  eNext.sym.next = eSym;

	  e.sym = eSym;
	  e.oNext = e;
	  e.lNext = eSym;

	  eSym.sym = e;
	  eSym.oNext = eSym;
	  eSym.lNext = e;

	  return e;
	};


	/**
	 * splice_ is best described by the Guibas/Stolfi paper or the
	 * CS348a notes. Basically, it modifies the mesh so that
	 * a.oNext and b.oNext are exchanged. This can have various effects
	 * depending on whether a and b belong to different face or vertex rings.
	 * For more explanation see mesh.meshSplice below.
	 *
	 * @private
	 * @param {libtess.GluHalfEdge} a [description].
	 * @param {libtess.GluHalfEdge} b [description].
	 */
	libtess.mesh.splice_ = function(a, b) {
	  var aONext = a.oNext;
	  var bONext = b.oNext;

	  aONext.sym.lNext = b;
	  bONext.sym.lNext = a;
	  a.oNext = bONext;
	  b.oNext = aONext;
	};


	/**
	 * makeVertex_(eOrig, vNext) attaches a new vertex and makes it the
	 * origin of all edges in the vertex loop to which eOrig belongs. "vNext" gives
	 * a place to insert the new vertex in the global vertex list.  We insert
	 * the new vertex *before* vNext so that algorithms which walk the vertex
	 * list will not see the newly created vertices.
	 *
	 * NOTE: unlike original, acutally allocates new vertex.
	 *
	 * @private
	 * @param {libtess.GluHalfEdge} eOrig [description].
	 * @param {libtess.GluVertex} vNext [description].
	 */
	libtess.mesh.makeVertex_ = function(eOrig, vNext) {
	  // insert in circular doubly-linked list before vNext
	  var vPrev = vNext.prev;
	  var vNew = new libtess.GluVertex(vNext, vPrev);
	  vPrev.next = vNew;
	  vNext.prev = vNew;

	  vNew.anEdge = eOrig;
	  // leave coords, s, t undefined
	  // TODO(bckenny): does above line mean 0 specifically, or does it matter?

	  // fix other edges on this vertex loop
	  var e = eOrig;
	  do {
	    e.org = vNew;
	    e = e.oNext;
	  } while (e !== eOrig);
	};


	/**
	 * makeFace_(eOrig, fNext) attaches a new face and makes it the left
	 * face of all edges in the face loop to which eOrig belongs. "fNext" gives
	 * a place to insert the new face in the global face list.  We insert
	 * the new face *before* fNext so that algorithms which walk the face
	 * list will not see the newly created faces.
	 *
	 * NOTE: unlike original, acutally allocates new face.
	 *
	 * @private
	 * @param {libtess.GluHalfEdge} eOrig [description].
	 * @param {libtess.GluFace} fNext [description].
	 */
	libtess.mesh.makeFace_ = function(eOrig, fNext) {
	  // insert in circular doubly-linked list before fNext
	  var fPrev = fNext.prev;
	  var fNew = new libtess.GluFace(fNext, fPrev);
	  fPrev.next = fNew;
	  fNext.prev = fNew;

	  fNew.anEdge = eOrig;

	  // The new face is marked "inside" if the old one was.  This is a
	  // convenience for the common case where a face has been split in two.
	  fNew.inside = fNext.inside;

	  // fix other edges on this face loop
	  var e = eOrig;
	  do {
	    e.lFace = fNew;
	    e = e.lNext;
	  } while (e !== eOrig);
	};


	/**
	 * killEdge_ destroys an edge (the half-edges eDel and eDel.sym),
	 * and removes from the global edge list.
	 *
	 * @private
	 * @param {libtess.GluHalfEdge} eDel [description].
	 */
	libtess.mesh.killEdge_ = function(eDel) {
	  // TODO(bckenny): in this case, no need to worry(?), but check when checking mesh.makeEdgePair_
	  // Half-edges are allocated in pairs, see EdgePair above
	  // if (eDel->Sym < eDel ) { eDel = eDel->Sym; }

	  // delete from circular doubly-linked list
	  var eNext = eDel.next;
	  var ePrev = eDel.sym.next;
	  eNext.sym.next = ePrev;
	  ePrev.sym.next = eNext;

	  // TODO(bckenny): memFree( eDel ); (which also frees eDel.sym)
	  // TODO(bckenny): need to null at callsites?
	};


	/**
	 * killVertex_ destroys a vertex and removes it from the global
	 * vertex list. It updates the vertex loop to point to a given new vertex.
	 *
	 * @private
	 * @param {libtess.GluVertex} vDel [description].
	 * @param {libtess.GluVertex} newOrg [description].
	 */
	libtess.mesh.killVertex_ = function(vDel, newOrg) {
	  var eStart = vDel.anEdge;

	  // change the origin of all affected edges
	  var e = eStart;
	  do {
	    e.org = newOrg;
	    e = e.oNext;
	  } while (e !== eStart);

	  // delete from circular doubly-linked list
	  var vPrev = vDel.prev;
	  var vNext = vDel.next;
	  vNext.prev = vPrev;
	  vPrev.next = vNext;

	  // TODO(bckenny): memFree( vDel );
	  // TODO(bckenny): need to null at callsites?
	};


	/**
	 * killFace_ destroys a face and removes it from the global face
	 * list. It updates the face loop to point to a given new face.
	 *
	 * @private
	 * @param {libtess.GluFace} fDel [description].
	 * @param {libtess.GluFace} newLFace [description].
	 */
	libtess.mesh.killFace_ = function(fDel, newLFace) {
	  var eStart = fDel.anEdge;

	  // change the left face of all affected edges
	  var e = eStart;
	  do {
	    e.lFace = newLFace;
	    e = e.lNext;
	  } while (e !== eStart);

	  // delete from circular doubly-linked list
	  var fPrev = fDel.prev;
	  var fNext = fDel.next;
	  fNext.prev = fPrev;
	  fPrev.next = fNext;

	  // TODO(bckenny): memFree( fDel );
	  // TODO(bckenny): need to null at callsites?
	};


	/* global libtess */

	/** @const */
	libtess.normal = {};

	// TODO(bckenny): Integrate SLANTED_SWEEP somehow?
	/* The "feature merging" is not intended to be complete. There are
	 * special cases where edges are nearly parallel to the sweep line
	 * which are not implemented. The algorithm should still behave
	 * robustly (ie. produce a reasonable tesselation) in the presence
	 * of such edges, however it may miss features which could have been
	 * merged. We could minimize this effect by choosing the sweep line
	 * direction to be something unusual (ie. not parallel to one of the
	 * coordinate axes).
	 * #if defined(SLANTED_SWEEP)
	 * #define S_UNIT_X  0.50941539564955385 // Pre-normalized
	 * #define S_UNIT_Y  0.86052074622010633
	 * #endif
	 */

	/**
	 * X coordinate of local basis for polygon projection.
	 * @private
	 * @const
	 */
	libtess.normal.S_UNIT_X_ = 1.0;

	/**
	 * Y coordinate of local basis for polygon projection.
	 * @private
	 * @const
	 */
	libtess.normal.S_UNIT_Y_ = 0.0;

	/**
	 * Determines a polygon normal and projects vertices onto the plane of the
	 * polygon.
	 * @param {!libtess.GluTesselator} tess
	 */
	libtess.normal.projectPolygon = function(tess) {
	  var computedNormal = false;

	  var norm = [
	    tess.normal[0],
	    tess.normal[1],
	    tess.normal[2]
	  ];
	  if (norm[0] === 0 && norm[1] === 0 && norm[2] === 0) {
	    libtess.normal.computeNormal_(tess, norm);
	    computedNormal = true;
	  }

	  var sUnit = tess.sUnit;
	  var tUnit = tess.tUnit;
	  var i = libtess.normal.longAxis_(norm);

	  // NOTE(bckenny): This branch is never taken. See comment on
	  // libtess.TRUE_PROJECT.
	  /* istanbul ignore if */
	  if (libtess.TRUE_PROJECT) {
	    // Choose the initial sUnit vector to be approximately perpendicular
	    // to the normal.
	    libtess.normal.normalize_(norm);

	    sUnit[i] = 0;
	    sUnit[(i + 1) % 3] = libtess.normal.S_UNIT_X_;
	    sUnit[(i + 2) % 3] = libtess.normal.S_UNIT_Y_;

	    // Now make it exactly perpendicular
	    var w = libtess.normal.dot_(sUnit, norm);
	    sUnit[0] -= w * norm[0];
	    sUnit[1] -= w * norm[1];
	    sUnit[2] -= w * norm[2];
	    libtess.normal.normalize_(sUnit);

	    // Choose tUnit so that (sUnit,tUnit,norm) form a right-handed frame
	    tUnit[0] = norm[1] * sUnit[2] - norm[2] * sUnit[1];
	    tUnit[1] = norm[2] * sUnit[0] - norm[0] * sUnit[2];
	    tUnit[2] = norm[0] * sUnit[1] - norm[1] * sUnit[0];
	    libtess.normal.normalize_(tUnit);

	  } else {
	    // Project perpendicular to a coordinate axis -- better numerically
	    sUnit[i] = 0;
	    sUnit[(i + 1) % 3] = libtess.normal.S_UNIT_X_;
	    sUnit[(i + 2) % 3] = libtess.normal.S_UNIT_Y_;

	    tUnit[i] = 0;
	    tUnit[(i + 1) % 3] = (norm[i] > 0) ?
	        -libtess.normal.S_UNIT_Y_ : libtess.normal.S_UNIT_Y_;
	    tUnit[(i + 2) % 3] = (norm[i] > 0) ?
	        libtess.normal.S_UNIT_X_ : -libtess.normal.S_UNIT_X_;
	  }

	  // Project the vertices onto the sweep plane
	  var vHead = tess.mesh.vHead;
	  for (var v = vHead.next; v !== vHead; v = v.next) {
	    v.s = libtess.normal.dot_(v.coords, sUnit);
	    v.t = libtess.normal.dot_(v.coords, tUnit);
	  }

	  if (computedNormal) {
	    libtess.normal.checkOrientation_(tess);
	  }
	};

	/**
	 * Computes the dot product of vectors u and v.
	 * @private
	 * @param {!Array.<number>} u
	 * @param {!Array.<number>} v
	 * @return {number}
	 */
	libtess.normal.dot_ = function(u, v) {
	  return u[0] * v[0] + u[1] * v[1] + u[2] * v[2];
	};

	// NOTE(bckenny): only called from within libtess.normal.projectPolygon's
	// TRUE_PROJECT branch, so ignoring for code coverage.
	/* istanbul ignore next */
	/**
	 * Normalize vector v.
	 * @private
	 * @param {!Array.<number>} v
	 */
	libtess.normal.normalize_ = function(v) {
	  var len = v[0] * v[0] + v[1] * v[1] + v[2] * v[2];

	  len = Math.sqrt(len);
	  v[0] /= len;
	  v[1] /= len;
	  v[2] /= len;
	};

	/**
	 * Returns the index of the longest component of vector v.
	 * @private
	 * @param {!Array.<number>} v
	 * @return {number}
	 */
	libtess.normal.longAxis_ = function(v) {
	  var i = 0;

	  if (Math.abs(v[1]) > Math.abs(v[0])) {
	    i = 1;
	  }
	  if (Math.abs(v[2]) > Math.abs(v[i])) {
	    i = 2;
	  }

	  return i;
	};

	/**
	 * Compute an approximate normal of the polygon from the vertices themselves.
	 * Result returned in norm.
	 * @private
	 * @param {!libtess.GluTesselator} tess
	 * @param {!Array.<number>} norm
	 */
	libtess.normal.computeNormal_ = function(tess, norm) {
	  var maxVal = [
	    -2 * libtess.GLU_TESS_MAX_COORD,
	    -2 * libtess.GLU_TESS_MAX_COORD,
	    -2 * libtess.GLU_TESS_MAX_COORD
	  ];
	  var minVal = [
	    2 * libtess.GLU_TESS_MAX_COORD,
	    2 * libtess.GLU_TESS_MAX_COORD,
	    2 * libtess.GLU_TESS_MAX_COORD
	  ];
	  var maxVert = [];
	  var minVert = [];

	  var v;
	  var vHead = tess.mesh.vHead;
	  for (v = vHead.next; v !== vHead; v = v.next) {
	    for (var i = 0; i < 3; ++i) {
	      var c = v.coords[i];
	      if (c < minVal[i]) { minVal[i] = c; minVert[i] = v; }
	      if (c > maxVal[i]) { maxVal[i] = c; maxVert[i] = v; }
	    }
	  }

	  // Find two vertices separated by at least 1/sqrt(3) of the maximum
	  // distance between any two vertices
	  var index = 0;
	  if (maxVal[1] - minVal[1] > maxVal[0] - minVal[0]) { index = 1; }
	  if (maxVal[2] - minVal[2] > maxVal[index] - minVal[index]) { index = 2; }
	  if (minVal[index] >= maxVal[index]) {
	    // All vertices are the same -- normal doesn't matter
	    norm[0] = 0; norm[1] = 0; norm[2] = 1;
	    return;
	  }

	  // Look for a third vertex which forms the triangle with maximum area
	  // (Length of normal == twice the triangle area)
	  var maxLen2 = 0;
	  var v1 = minVert[index];
	  var v2 = maxVert[index];
	  var tNorm = [0, 0, 0];
	  var d1 = [
	    v1.coords[0] - v2.coords[0],
	    v1.coords[1] - v2.coords[1],
	    v1.coords[2] - v2.coords[2]
	  ];
	  var d2 = [0, 0, 0];
	  for (v = vHead.next; v !== vHead; v = v.next) {
	    d2[0] = v.coords[0] - v2.coords[0];
	    d2[1] = v.coords[1] - v2.coords[1];
	    d2[2] = v.coords[2] - v2.coords[2];
	    tNorm[0] = d1[1] * d2[2] - d1[2] * d2[1];
	    tNorm[1] = d1[2] * d2[0] - d1[0] * d2[2];
	    tNorm[2] = d1[0] * d2[1] - d1[1] * d2[0];
	    var tLen2 = tNorm[0] * tNorm[0] + tNorm[1] * tNorm[1] + tNorm[2] * tNorm[2];
	    if (tLen2 > maxLen2) {
	      maxLen2 = tLen2;
	      norm[0] = tNorm[0];
	      norm[1] = tNorm[1];
	      norm[2] = tNorm[2];
	    }
	  }

	  if (maxLen2 <= 0) {
	    // All points lie on a single line -- any decent normal will do
	    norm[0] = norm[1] = norm[2] = 0;
	    norm[libtess.normal.longAxis_(d1)] = 1;
	  }
	};

	/**
	 * Check that the sum of the signed area of all projected contours is
	 * non-negative. If not, negate the t-coordinates to reverse the orientation and
	 * make it so.
	 * @private
	 * @param {!libtess.GluTesselator} tess
	 */
	libtess.normal.checkOrientation_ = function(tess) {
	  var area = 0;
	  var fHead = tess.mesh.fHead;
	  for (var f = fHead.next; f !== fHead; f = f.next) {
	    var e = f.anEdge;
	    if (e.winding <= 0) { continue; }
	    do {
	      area += (e.org.s - e.dst().s) * (e.org.t + e.dst().t);
	      e = e.lNext;
	    } while (e !== f.anEdge);
	  }

	  if (area < 0) {
	    // Reverse the orientation by flipping all the t-coordinates
	    var vHead = tess.mesh.vHead;
	    for (var v = vHead.next; v !== vHead; v = v.next) {
	      v.t = -v.t;
	    }
	    tess.tUnit[0] = -tess.tUnit[0];
	    tess.tUnit[1] = -tess.tUnit[1];
	    tess.tUnit[2] = -tess.tUnit[2];
	  }
	};


	/* global libtess */

	/** @const */
	libtess.render = {};

	/**
	 * Takes a mesh, breaks it into separate triangles, and renders them. The
	 * rendering output is provided as callbacks (see the API). Set flagEdges to
	 * true to get edgeFlag callbacks (tess.flagBoundary in original libtess).
	 * @param {!libtess.GluTesselator} tess
	 * @param {!libtess.GluMesh} mesh
	 * @param {boolean} flagEdges
	 */
	libtess.render.renderMesh = function(tess, mesh, flagEdges) {
	  var beginOrBeginDataCalled = false;

	  // TODO(bckenny): edgeState needs to be boolean, but !== on first call
	  // force edge state output for first vertex
	  var edgeState = -1;

	  // We examine all faces in an arbitrary order. Whenever we find
	  // an inside triangle f, we render f.
	  // NOTE(bckenny): go backwards through face list to match original libtess
	  // triangle order
	  for (var f = mesh.fHead.prev; f !== mesh.fHead; f = f.prev) {
	    if (f.inside) {
	      // We're going to emit a triangle, so call begin callback once
	      if (!beginOrBeginDataCalled) {
	        tess.callBeginOrBeginData(libtess.primitiveType.GL_TRIANGLES);
	        beginOrBeginDataCalled = true;
	      }

	      // check that face has only three edges
	      var e = f.anEdge;
	      // Loop once for each edge (there will always be 3 edges)
	      do {
	        if (flagEdges) {
	          // Set the "edge state" to true just before we output the
	          // first vertex of each edge on the polygon boundary.
	          var newState = !e.rFace().inside ? 1 : 0; // TODO(bckenny): total hack to get edgeState working. fix me.
	          if (edgeState !== newState) {
	            edgeState = newState;
	            // TODO(bckenny): edgeState should be boolean now
	            tess.callEdgeFlagOrEdgeFlagData(!!edgeState);
	          }
	        }

	        // emit vertex
	        tess.callVertexOrVertexData(e.org.data);

	        e = e.lNext;
	      } while (e !== f.anEdge);
	    }
	  }

	  // only call end callback if begin was called
	  if (beginOrBeginDataCalled) {
	    tess.callEndOrEndData();
	  }
	};

	/**
	 * Takes a mesh, and outputs one contour for each face marked "inside". The
	 * rendering output is provided as callbacks (see the API).
	 * @param {!libtess.GluTesselator} tess
	 * @param {!libtess.GluMesh} mesh
	 */
	libtess.render.renderBoundary = function(tess, mesh) {
	  for (var f = mesh.fHead.next; f !== mesh.fHead; f = f.next) {
	    if (f.inside) {
	      tess.callBeginOrBeginData(libtess.primitiveType.GL_LINE_LOOP);

	      var e = f.anEdge;
	      do {
	        tess.callVertexOrVertexData(e.org.data);
	        e = e.lNext;
	      } while (e !== f.anEdge);

	      tess.callEndOrEndData();
	    }
	  }
	};


	/* global libtess */

	// TODO(bckenny): a number of these never return null (as opposed to original) and should be typed appropriately

	/*
	 * Invariants for the Edge Dictionary.
	 * - each pair of adjacent edges e2=succ(e1) satisfies edgeLeq_(e1,e2)
	 *   at any valid location of the sweep event
	 * - if edgeLeq_(e2,e1) as well (at any valid sweep event), then e1 and e2
	 *   share a common endpoint
	 * - for each e, e.dst() has been processed, but not e.org
	 * - each edge e satisfies vertLeq(e.dst(),event) && vertLeq(event,e.org)
	 *   where "event" is the current sweep line event.
	 * - no edge e has zero length
	 *
	 * Invariants for the Mesh (the processed portion).
	 * - the portion of the mesh left of the sweep line is a planar graph,
	 *   ie. there is *some* way to embed it in the plane
	 * - no processed edge has zero length
	 * - no two processed vertices have identical coordinates
	 * - each "inside" region is monotone, ie. can be broken into two chains
	 *   of monotonically increasing vertices according to VertLeq(v1,v2)
	 *   - a non-invariant: these chains may intersect (very slightly)
	 *
	 * Invariants for the Sweep.
	 * - if none of the edges incident to the event vertex have an activeRegion
	 *   (ie. none of these edges are in the edge dictionary), then the vertex
	 *   has only right-going edges.
	 * - if an edge is marked "fixUpperEdge" (it is a temporary edge introduced
	 *   by ConnectRightVertex), then it is the only right-going edge from
	 *   its associated vertex.  (This says that these edges exist only
	 *   when it is necessary.)
	 */

	/** @const */
	libtess.sweep = {};


	/**
	 * Make the sentinel coordinates big enough that they will never be
	 * merged with real input features.  (Even with the largest possible
	 * input contour and the maximum tolerance of 1.0, no merging will be
	 * done with coordinates larger than 3 * libtess.GLU_TESS_MAX_COORD).
	 * @private
	 * @const
	 * @type {number}
	 */
	libtess.sweep.SENTINEL_COORD_ = 4 * libtess.GLU_TESS_MAX_COORD;


	/**
	 * Because vertices at exactly the same location are merged together
	 * before we process the sweep event, some degenerate cases can't occur.
	 * However if someone eventually makes the modifications required to
	 * merge features which are close together, the cases below marked
	 * TOLERANCE_NONZERO will be useful.  They were debugged before the
	 * code to merge identical vertices in the main loop was added.
	 * @private
	 * @const
	 * @type {boolean}
	 */
	libtess.sweep.TOLERANCE_NONZERO_ = false;


	/**
	 * computeInterior(tess) computes the planar arrangement specified
	 * by the given contours, and further subdivides this arrangement
	 * into regions. Each region is marked "inside" if it belongs
	 * to the polygon, according to the rule given by tess.windingRule.
	 * Each interior region is guaranteed be monotone.
	 *
	 * @param {libtess.GluTesselator} tess [description].
	 */
	libtess.sweep.computeInterior = function(tess) {
	  tess.fatalError = false;

	  // Each vertex defines an event for our sweep line. Start by inserting
	  // all the vertices in a priority queue. Events are processed in
	  // lexicographic order, ie.
	  // e1 < e2  iff  e1.x < e2.x || (e1.x == e2.x && e1.y < e2.y)
	  libtess.sweep.removeDegenerateEdges_(tess);
	  libtess.sweep.initPriorityQ_(tess);
	  libtess.sweep.initEdgeDict_(tess);

	  // TODO(bckenny): don't need the cast if pq's key is better typed
	  var v;
	  while ((v = /** @type {libtess.GluVertex} */(tess.pq.extractMin())) !== null) {
	    for (;;) {
	      var vNext = /** @type {libtess.GluVertex} */(tess.pq.minimum());
	      if (vNext === null || !libtess.geom.vertEq(vNext, v)) {
	        break;
	      }

	      /* Merge together all vertices at exactly the same location.
	       * This is more efficient than processing them one at a time,
	       * simplifies the code (see connectLeftDegenerate), and is also
	       * important for correct handling of certain degenerate cases.
	       * For example, suppose there are two identical edges A and B
	       * that belong to different contours (so without this code they would
	       * be processed by separate sweep events).  Suppose another edge C
	       * crosses A and B from above.  When A is processed, we split it
	       * at its intersection point with C.  However this also splits C,
	       * so when we insert B we may compute a slightly different
	       * intersection point.  This might leave two edges with a small
	       * gap between them.  This kind of error is especially obvious
	       * when using boundary extraction (GLU_TESS_BOUNDARY_ONLY).
	       */
	      vNext = /** @type {libtess.GluVertex} */(tess.pq.extractMin());
	      libtess.sweep.spliceMergeVertices_(tess, v.anEdge, vNext.anEdge);
	    }
	    libtess.sweep.sweepEvent_(tess, v);
	  }

	  // TODO(bckenny): what does the next comment mean? can we eliminate event except when debugging?
	  // Set tess.event for debugging purposes
	  var minRegion = tess.dict.getMin().getKey();
	  tess.event = minRegion.eUp.org;
	  libtess.sweep.doneEdgeDict_(tess);
	  libtess.sweep.donePriorityQ_(tess);

	  libtess.sweep.removeDegenerateFaces_(tess.mesh);
	  tess.mesh.checkMesh();
	};


	/**
	 * When we merge two edges into one, we need to compute the combined
	 * winding of the new edge.
	 * @private
	 * @param {libtess.GluHalfEdge} eDst [description].
	 * @param {libtess.GluHalfEdge} eSrc [description].
	 */
	libtess.sweep.addWinding_ = function(eDst, eSrc) {
	  // NOTE(bckenny): from AddWinding macro
	  eDst.winding += eSrc.winding;
	  eDst.sym.winding += eSrc.sym.winding;
	};


	/**
	 * Both edges must be directed from right to left (this is the canonical
	 * direction for the upper edge of each region).
	 *
	 * The strategy is to evaluate a "t" value for each edge at the
	 * current sweep line position, given by tess.event.  The calculations
	 * are designed to be very stable, but of course they are not perfect.
	 *
	 * Special case: if both edge destinations are at the sweep event,
	 * we sort the edges by slope (they would otherwise compare equally).
	 *
	 * @private
	 * @param {!libtess.GluTesselator} tess
	 * @param {!libtess.ActiveRegion} reg1
	 * @param {!libtess.ActiveRegion} reg2
	 * @return {boolean}
	 */
	libtess.sweep.edgeLeq_ = function(tess, reg1, reg2) {
	  var event = tess.event;
	  var e1 = reg1.eUp;
	  var e2 = reg2.eUp;

	  if (e1.dst() === event) {
	    if (e2.dst() === event) {
	      // Two edges right of the sweep line which meet at the sweep event.
	      // Sort them by slope.
	      if (libtess.geom.vertLeq(e1.org, e2.org)) {
	        return libtess.geom.edgeSign(e2.dst(), e1.org, e2.org) <= 0;
	      }

	      return libtess.geom.edgeSign(e1.dst(), e2.org, e1.org) >= 0;
	    }

	    return libtess.geom.edgeSign(e2.dst(), event, e2.org) <= 0;
	  }

	  if (e2.dst() === event) {
	    return libtess.geom.edgeSign(e1.dst(), event, e1.org) >= 0;
	  }

	  // General case - compute signed distance *from* e1, e2 to event
	  var t1 = libtess.geom.edgeEval(e1.dst(), event, e1.org);
	  var t2 = libtess.geom.edgeEval(e2.dst(), event, e2.org);
	  return (t1 >= t2);
	};


	/**
	 * [deleteRegion_ description]
	 * @private
	 * @param {libtess.GluTesselator} tess [description].
	 * @param {libtess.ActiveRegion} reg [description].
	 */
	libtess.sweep.deleteRegion_ = function(tess, reg) {
	  if (reg.fixUpperEdge) {
	    // It was created with zero winding number, so it better be
	    // deleted with zero winding number (ie. it better not get merged
	    // with a real edge).
	  }

	  reg.eUp.activeRegion = null;

	  tess.dict.deleteNode(reg.nodeUp);
	  reg.nodeUp = null;

	  // memFree( reg ); TODO(bckenny)
	  // TODO(bckenny): may need to null at callsite
	};


	/**
	 * Replace an upper edge which needs fixing (see connectRightVertex).
	 * @private
	 * @param {libtess.ActiveRegion} reg [description].
	 * @param {libtess.GluHalfEdge} newEdge [description].
	 */
	libtess.sweep.fixUpperEdge_ = function(reg, newEdge) {
	  libtess.mesh.deleteEdge(reg.eUp);

	  reg.fixUpperEdge = false;
	  reg.eUp = newEdge;
	  newEdge.activeRegion = reg;
	};


	/**
	 * Find the region above the uppermost edge with the same origin.
	 * @private
	 * @param {libtess.ActiveRegion} reg [description].
	 * @return {libtess.ActiveRegion} [description].
	 */
	libtess.sweep.topLeftRegion_ = function(reg) {
	  var org = reg.eUp.org;

	  // Find the region above the uppermost edge with the same origin
	  do {
	    reg = reg.regionAbove();
	  } while (reg.eUp.org === org);

	  // If the edge above was a temporary edge introduced by connectRightVertex,
	  // now is the time to fix it.
	  if (reg.fixUpperEdge) {
	    var e = libtess.mesh.connect(reg.regionBelow().eUp.sym, reg.eUp.lNext);
	    libtess.sweep.fixUpperEdge_(reg, e);
	    reg = reg.regionAbove();
	  }

	  return reg;
	};


	/**
	 * Find the region above the uppermost edge with the same destination.
	 * @private
	 * @param {libtess.ActiveRegion} reg [description].
	 * @return {libtess.ActiveRegion} [description].
	 */
	libtess.sweep.topRightRegion_ = function(reg) {
	  var dst = reg.eUp.dst();

	  do {
	    reg = reg.regionAbove();
	  } while (reg.eUp.dst() === dst);

	  return reg;
	};


	/**
	 * Add a new active region to the sweep line, *somewhere* below "regAbove"
	 * (according to where the new edge belongs in the sweep-line dictionary).
	 * The upper edge of the new region will be "eNewUp".
	 * Winding number and "inside" flag are not updated.
	 *
	 * @private
	 * @param {libtess.GluTesselator} tess [description].
	 * @param {libtess.ActiveRegion} regAbove [description].
	 * @param {libtess.GluHalfEdge} eNewUp [description].
	 * @return {libtess.ActiveRegion} regNew.
	 */
	libtess.sweep.addRegionBelow_ = function(tess, regAbove, eNewUp) {
	  var regNew = new libtess.ActiveRegion();

	  regNew.eUp = eNewUp;
	  regNew.nodeUp = tess.dict.insertBefore(regAbove.nodeUp, regNew);
	  eNewUp.activeRegion = regNew;

	  return regNew;
	};


	/**
	 * [isWindingInside_ description]
	 * @private
	 * @param {libtess.GluTesselator} tess [description].
	 * @param {number} n int.
	 * @return {boolean} [description].
	 */
	libtess.sweep.isWindingInside_ = function(tess, n) {
	  switch (tess.windingRule) {
	    case libtess.windingRule.GLU_TESS_WINDING_ODD:
	      return ((n & 1) !== 0);
	    case libtess.windingRule.GLU_TESS_WINDING_NONZERO:
	      return (n !== 0);
	    case libtess.windingRule.GLU_TESS_WINDING_POSITIVE:
	      return (n > 0);
	    case libtess.windingRule.GLU_TESS_WINDING_NEGATIVE:
	      return (n < 0);
	    case libtess.windingRule.GLU_TESS_WINDING_ABS_GEQ_TWO:
	      return (n >= 2) || (n <= -2);
	  }

	  // TODO(bckenny): not reached
	  return false;
	};


	/**
	 * [computeWinding_ description]
	 * @private
	 * @param {libtess.GluTesselator} tess [description].
	 * @param {libtess.ActiveRegion} reg [description].
	 */
	libtess.sweep.computeWinding_ = function(tess, reg) {
	  reg.windingNumber = reg.regionAbove().windingNumber + reg.eUp.winding;
	  reg.inside = libtess.sweep.isWindingInside_(tess, reg.windingNumber);
	};


	/**
	 * Delete a region from the sweep line. This happens when the upper
	 * and lower chains of a region meet (at a vertex on the sweep line).
	 * The "inside" flag is copied to the appropriate mesh face (we could
	 * not do this before -- since the structure of the mesh is always
	 * changing, this face may not have even existed until now).
	 *
	 * @private
	 * @param {libtess.GluTesselator} tess [description].
	 * @param {libtess.ActiveRegion} reg [description].
	 */
	libtess.sweep.finishRegion_ = function(tess, reg) {
	  // TODO(bckenny): may need to null reg at callsite

	  var e = reg.eUp;
	  var f = e.lFace;

	  f.inside = reg.inside;
	  f.anEdge = e;   // optimization for tessmono.tessellateMonoRegion() // TODO(bckenny): how so?
	  libtess.sweep.deleteRegion_(tess, reg);
	};


	/**
	 * We are given a vertex with one or more left-going edges. All affected
	 * edges should be in the edge dictionary. Starting at regFirst.eUp,
	 * we walk down deleting all regions where both edges have the same
	 * origin vOrg. At the same time we copy the "inside" flag from the
	 * active region to the face, since at this point each face will belong
	 * to at most one region (this was not necessarily true until this point
	 * in the sweep). The walk stops at the region above regLast; if regLast
	 * is null we walk as far as possible. At the same time we relink the
	 * mesh if necessary, so that the ordering of edges around vOrg is the
	 * same as in the dictionary.
	 *
	 * @private
	 * @param {libtess.GluTesselator} tess [description].
	 * @param {libtess.ActiveRegion} regFirst [description].
	 * @param {libtess.ActiveRegion} regLast [description].
	 * @return {libtess.GluHalfEdge} [description].
	 */
	libtess.sweep.finishLeftRegions_ = function(tess, regFirst, regLast) {
	  var regPrev = regFirst;
	  var ePrev = regFirst.eUp;
	  while (regPrev !== regLast) {
	    // placement was OK
	    regPrev.fixUpperEdge = false;
	    var reg = regPrev.regionBelow();
	    var e = reg.eUp;
	    if (e.org !== ePrev.org) {
	      if (!reg.fixUpperEdge) {
	        /* Remove the last left-going edge. Even though there are no further
	         * edges in the dictionary with this origin, there may be further
	         * such edges in the mesh (if we are adding left edges to a vertex
	         * that has already been processed). Thus it is important to call
	         * finishRegion rather than just deleteRegion.
	         */
	        libtess.sweep.finishRegion_(tess, regPrev);
	        break;
	      }

	      // If the edge below was a temporary edge introduced by
	      // connectRightVertex, now is the time to fix it.
	      e = libtess.mesh.connect(ePrev.lPrev(), e.sym);
	      libtess.sweep.fixUpperEdge_(reg, e);
	    }

	    // Relink edges so that ePrev.oNext === e
	    if (ePrev.oNext !== e) {
	      libtess.mesh.meshSplice(e.oPrev(), e);
	      libtess.mesh.meshSplice(ePrev, e);
	    }

	    // may change reg.eUp
	    libtess.sweep.finishRegion_(tess, regPrev);
	    ePrev = reg.eUp;
	    regPrev = reg;
	  }

	  return ePrev;
	};


	/**
	 * Purpose: insert right-going edges into the edge dictionary, and update
	 * winding numbers and mesh connectivity appropriately. All right-going
	 * edges share a common origin vOrg. Edges are inserted CCW starting at
	 * eFirst; the last edge inserted is eLast.oPrev. If vOrg has any
	 * left-going edges already processed, then eTopLeft must be the edge
	 * such that an imaginary upward vertical segment from vOrg would be
	 * contained between eTopLeft.oPrev and eTopLeft; otherwise eTopLeft
	 * should be null.
	 *
	 * @private
	 * @param {libtess.GluTesselator} tess [description].
	 * @param {libtess.ActiveRegion} regUp [description].
	 * @param {libtess.GluHalfEdge} eFirst [description].
	 * @param {libtess.GluHalfEdge} eLast [description].
	 * @param {libtess.GluHalfEdge} eTopLeft [description].
	 * @param {boolean} cleanUp [description].
	 */
	libtess.sweep.addRightEdges_ = function(tess, regUp, eFirst, eLast, eTopLeft,
	    cleanUp) {

	  var firstTime = true;

	  // Insert the new right-going edges in the dictionary
	  var e = eFirst;
	  do {
	    libtess.sweep.addRegionBelow_(tess, regUp, e.sym);
	    e = e.oNext;
	  } while (e !== eLast);

	  // Walk *all* right-going edges from e.org, in the dictionary order,
	  // updating the winding numbers of each region, and re-linking the mesh
	  // edges to match the dictionary ordering (if necessary).
	  if (eTopLeft === null) {
	    eTopLeft = regUp.regionBelow().eUp.rPrev();
	  }
	  var regPrev = regUp;
	  var ePrev = eTopLeft;
	  var reg;
	  for (;;) {
	    reg = regPrev.regionBelow();
	    e = reg.eUp.sym;
	    if (e.org !== ePrev.org) {
	      break;
	    }

	    if (e.oNext !== ePrev) {
	      // Unlink e from its current position, and relink below ePrev
	      libtess.mesh.meshSplice(e.oPrev(), e);
	      libtess.mesh.meshSplice(ePrev.oPrev(), e);
	    }
	    // Compute the winding number and "inside" flag for the new regions
	    reg.windingNumber = regPrev.windingNumber - e.winding;
	    reg.inside = libtess.sweep.isWindingInside_(tess, reg.windingNumber);

	    // Check for two outgoing edges with same slope -- process these
	    // before any intersection tests (see example in libtess.sweep.computeInterior).
	    regPrev.dirty = true;
	    if (!firstTime && libtess.sweep.checkForRightSplice_(tess, regPrev)) {
	      libtess.sweep.addWinding_(e, ePrev);
	      libtess.sweep.deleteRegion_(tess, regPrev); // TODO(bckenny): need to null regPrev anywhere else?
	      libtess.mesh.deleteEdge(ePrev);
	    }
	    firstTime = false;
	    regPrev = reg;
	    ePrev = e;
	  }

	  regPrev.dirty = true;

	  if (cleanUp) {
	    // Check for intersections between newly adjacent edges.
	    libtess.sweep.walkDirtyRegions_(tess, regPrev);
	  }
	};


	/**
	 * [callCombine_ description]
	 * @private
	 * @param {libtess.GluTesselator} tess [description].
	 * @param {libtess.GluVertex} isect [description].
	 * @param {Array.<Object>} data [description].
	 * @param {Array.<number>} weights [description].
	 * @param {boolean} needed [description].
	 */
	libtess.sweep.callCombine_ = function(tess, isect, data, weights, needed) {
	  // Copy coord data in case the callback changes it.
	  var coords = [
	    isect.coords[0],
	    isect.coords[1],
	    isect.coords[2]
	  ];

	  isect.data = null;
	  isect.data = tess.callCombineOrCombineData(coords, data, weights);
	  if (isect.data === null) {
	    if (!needed) {
	      // not needed, so just use data from first vertex
	      isect.data = data[0];

	    } else if (!tess.fatalError) {
	      // The only way fatal error is when two edges are found to intersect,
	      // but the user has not provided the callback necessary to handle
	      // generated intersection points.
	      tess.callErrorOrErrorData(
	          libtess.errorType.GLU_TESS_NEED_COMBINE_CALLBACK);
	      tess.fatalError = true;
	    }
	  }
	};


	/**
	 * Two vertices with idential coordinates are combined into one.
	 * e1.org is kept, while e2.org is discarded.
	 * @private
	 * @param {libtess.GluTesselator} tess [description].
	 * @param {libtess.GluHalfEdge} e1 [description].
	 * @param {libtess.GluHalfEdge} e2 [description].
	 */
	libtess.sweep.spliceMergeVertices_ = function(tess, e1, e2) {
	  // TODO(bckenny): better way to init these? save them?
	  var data = [null, null, null, null];
	  var weights = [0.5, 0.5, 0, 0];

	  data[0] = e1.org.data;
	  data[1] = e2.org.data;
	  libtess.sweep.callCombine_(tess, e1.org, data, weights, false);
	  libtess.mesh.meshSplice(e1, e2);
	};


	/**
	 * Find some weights which describe how the intersection vertex is
	 * a linear combination of org and dst. Each of the two edges
	 * which generated "isect" is allocated 50% of the weight; each edge
	 * splits the weight between its org and dst according to the
	 * relative distance to "isect".
	 *
	 * @private
	 * @param {libtess.GluVertex} isect [description].
	 * @param {libtess.GluVertex} org [description].
	 * @param {libtess.GluVertex} dst [description].
	 * @param {Array.<number>} weights [description].
	 * @param {number} weightIndex Index into weights for first weight to supply.
	 */
	libtess.sweep.vertexWeights_ = function(isect, org, dst, weights, weightIndex) {
	  // TODO(bckenny): think through how we can use L1dist here and be correct for coords
	  var t1 = libtess.geom.vertL1dist(org, isect);
	  var t2 = libtess.geom.vertL1dist(dst, isect);

	  // TODO(bckenny): introduced weightIndex to mimic addressing in original
	  // 1) document (though it is private and only used from getIntersectData)
	  // 2) better way? manually inline into getIntersectData? supply two two-length tmp arrays?
	  var i0 = weightIndex;
	  var i1 = weightIndex + 1;
	  weights[i0] = 0.5 * t2 / (t1 + t2);
	  weights[i1] = 0.5 * t1 / (t1 + t2);
	  isect.coords[0] += weights[i0] * org.coords[0] + weights[i1] * dst.coords[0];
	  isect.coords[1] += weights[i0] * org.coords[1] + weights[i1] * dst.coords[1];
	  isect.coords[2] += weights[i0] * org.coords[2] + weights[i1] * dst.coords[2];
	};


	/**
	 * We've computed a new intersection point, now we need a "data" pointer
	 * from the user so that we can refer to this new vertex in the
	 * rendering callbacks.
	 * @private
	 * @param {libtess.GluTesselator} tess [description].
	 * @param {libtess.GluVertex} isect [description].
	 * @param {libtess.GluVertex} orgUp [description].
	 * @param {libtess.GluVertex} dstUp [description].
	 * @param {libtess.GluVertex} orgLo [description].
	 * @param {libtess.GluVertex} dstLo [description].
	 */
	libtess.sweep.getIntersectData_ = function(tess, isect, orgUp, dstUp, orgLo,
	    dstLo) {

	  // TODO(bckenny): called for every intersection event, should these be from a pool?
	  // TODO(bckenny): better way to init these?
	  var weights = [0, 0, 0, 0];
	  var data = [
	    orgUp.data,
	    dstUp.data,
	    orgLo.data,
	    dstLo.data
	  ];

	  // TODO(bckenny): it appears isect is a reappropriated vertex, so does need to be zeroed.
	  // double check this.
	  isect.coords[0] = isect.coords[1] = isect.coords[2] = 0;

	  // TODO(bckenny): see note in libtess.sweep.vertexWeights_ for explanation of weightIndex. fix?
	  libtess.sweep.vertexWeights_(isect, orgUp, dstUp, weights, 0);
	  libtess.sweep.vertexWeights_(isect, orgLo, dstLo, weights, 2);

	  libtess.sweep.callCombine_(tess, isect, data, weights, true);
	};


	/**
	 * Check the upper and lower edge of regUp, to make sure that the
	 * eUp.org is above eLo, or eLo.org is below eUp (depending on which
	 * origin is leftmost).
	 *
	 * The main purpose is to splice right-going edges with the same
	 * dest vertex and nearly identical slopes (ie. we can't distinguish
	 * the slopes numerically). However the splicing can also help us
	 * to recover from numerical errors. For example, suppose at one
	 * point we checked eUp and eLo, and decided that eUp.org is barely
	 * above eLo. Then later, we split eLo into two edges (eg. from
	 * a splice operation like this one). This can change the result of
	 * our test so that now eUp.org is incident to eLo, or barely below it.
	 * We must correct this condition to maintain the dictionary invariants.
	 *
	 * One possibility is to check these edges for intersection again
	 * (i.e. checkForIntersect). This is what we do if possible. However
	 * checkForIntersect requires that tess.event lies between eUp and eLo,
	 * so that it has something to fall back on when the intersection
	 * calculation gives us an unusable answer. So, for those cases where
	 * we can't check for intersection, this routine fixes the problem
	 * by just splicing the offending vertex into the other edge.
	 * This is a guaranteed solution, no matter how degenerate things get.
	 * Basically this is a combinatorial solution to a numerical problem.
	 *
	 * @private
	 * @param {libtess.GluTesselator} tess [description].
	 * @param {libtess.ActiveRegion} regUp [description].
	 * @return {boolean} [description].
	 */
	libtess.sweep.checkForRightSplice_ = function(tess, regUp) {
	  // TODO(bckenny): fully learn how these two checks work

	  var regLo = regUp.regionBelow();
	  var eUp = regUp.eUp;
	  var eLo = regLo.eUp;

	  if (libtess.geom.vertLeq(eUp.org, eLo.org)) {
	    if (libtess.geom.edgeSign(eLo.dst(), eUp.org, eLo.org) > 0) {
	      return false;
	    }

	    // eUp.org appears to be below eLo
	    if (!libtess.geom.vertEq(eUp.org, eLo.org)) {
	      // Splice eUp.org into eLo
	      libtess.mesh.splitEdge(eLo.sym);
	      libtess.mesh.meshSplice(eUp, eLo.oPrev());
	      regUp.dirty = regLo.dirty = true;

	    } else if (eUp.org !== eLo.org) {
	      // merge the two vertices, discarding eUp.org
	      // TODO(bckenny): fix pqHandle null situation
	      tess.pq.remove(/** @type {libtess.PQHandle} */(eUp.org.pqHandle));
	      libtess.sweep.spliceMergeVertices_(tess, eLo.oPrev(), eUp);
	    }

	  } else {
	    if (libtess.geom.edgeSign(eUp.dst(), eLo.org, eUp.org) < 0) {
	      return false;
	    }

	    // eLo.org appears to be above eUp, so splice eLo.org into eUp
	    regUp.regionAbove().dirty = regUp.dirty = true;
	    libtess.mesh.splitEdge(eUp.sym);
	    libtess.mesh.meshSplice(eLo.oPrev(), eUp);
	  }

	  return true;
	};


	/**
	 * Check the upper and lower edge of regUp to make sure that the
	 * eUp.dst() is above eLo, or eLo.dst() is below eUp (depending on which
	 * destination is rightmost).
	 *
	 * Theoretically, this should always be true. However, splitting an edge
	 * into two pieces can change the results of previous tests. For example,
	 * suppose at one point we checked eUp and eLo, and decided that eUp.dst()
	 * is barely above eLo. Then later, we split eLo into two edges (eg. from
	 * a splice operation like this one). This can change the result of
	 * the test so that now eUp.dst() is incident to eLo, or barely below it.
	 * We must correct this condition to maintain the dictionary invariants
	 * (otherwise new edges might get inserted in the wrong place in the
	 * dictionary, and bad stuff will happen).
	 *
	 * We fix the problem by just splicing the offending vertex into the
	 * other edge.
	 *
	 * @private
	 * @param {libtess.GluTesselator} tess description].
	 * @param {libtess.ActiveRegion} regUp [description].
	 * @return {boolean} [description].
	 */
	libtess.sweep.checkForLeftSplice_ = function(tess, regUp) {
	  var regLo = regUp.regionBelow();
	  var eUp = regUp.eUp;
	  var eLo = regLo.eUp;
	  var e;

	  if (libtess.geom.vertLeq(eUp.dst(), eLo.dst())) {
	    if (libtess.geom.edgeSign(eUp.dst(), eLo.dst(), eUp.org) < 0) {
	      return false;
	    }

	    // eLo.dst() is above eUp, so splice eLo.dst() into eUp
	    regUp.regionAbove().dirty = regUp.dirty = true;
	    e = libtess.mesh.splitEdge(eUp);
	    libtess.mesh.meshSplice(eLo.sym, e);
	    e.lFace.inside = regUp.inside;

	  } else {
	    if (libtess.geom.edgeSign(eLo.dst(), eUp.dst(), eLo.org) > 0) {
	      return false;
	    }

	    // eUp.dst() is below eLo, so splice eUp.dst() into eLo
	    regUp.dirty = regLo.dirty = true;
	    e = libtess.mesh.splitEdge(eLo);
	    libtess.mesh.meshSplice(eUp.lNext, eLo.sym);
	    e.rFace().inside = regUp.inside;
	  }

	  return true;
	};


	/**
	 * Check the upper and lower edges of the given region to see if
	 * they intersect. If so, create the intersection and add it
	 * to the data structures.
	 *
	 * Returns true if adding the new intersection resulted in a recursive
	 * call to addRightEdges_(); in this case all "dirty" regions have been
	 * checked for intersections, and possibly regUp has been deleted.
	 *
	 * @private
	 * @param {libtess.GluTesselator} tess [description].
	 * @param {libtess.ActiveRegion} regUp [description].
	 * @return {boolean} [description].
	 */
	libtess.sweep.checkForIntersect_ = function(tess, regUp) {
	  var regLo = regUp.regionBelow();
	  var eUp = regUp.eUp;
	  var eLo = regLo.eUp;
	  var orgUp = eUp.org;
	  var orgLo = eLo.org;
	  var dstUp = eUp.dst();
	  var dstLo = eLo.dst();

	  var isect = new libtess.GluVertex();

	  if (orgUp === orgLo) {
	    // right endpoints are the same
	    return false;
	  }

	  var tMinUp = Math.min(orgUp.t, dstUp.t);
	  var tMaxLo = Math.max(orgLo.t, dstLo.t);
	  if (tMinUp > tMaxLo) {
	    // t ranges do not overlap
	    return false;
	  }

	  if (libtess.geom.vertLeq(orgUp, orgLo)) {
	    if (libtess.geom.edgeSign(dstLo, orgUp, orgLo) > 0) {
	      return false;
	    }
	  } else {
	    if (libtess.geom.edgeSign(dstUp, orgLo, orgUp) < 0) {
	      return false;
	    }
	  }

	  // At this point the edges intersect, at least marginally
	  libtess.geom.edgeIntersect(dstUp, orgUp, dstLo, orgLo, isect);

	  // The following properties are guaranteed:

	  if (libtess.geom.vertLeq(isect, tess.event)) {
	    /* The intersection point lies slightly to the left of the sweep line,
	     * so move it until it's slightly to the right of the sweep line.
	     * (If we had perfect numerical precision, this would never happen
	     * in the first place). The easiest and safest thing to do is
	     * replace the intersection by tess.event.
	     */
	    isect.s = tess.event.s;
	    isect.t = tess.event.t;
	  }

	  // TODO(bckenny): try to find test54.d
	  /* Similarly, if the computed intersection lies to the right of the
	   * rightmost origin (which should rarely happen), it can cause
	   * unbelievable inefficiency on sufficiently degenerate inputs.
	   * (If you have the test program, try running test54.d with the
	   * "X zoom" option turned on).
	   */
	  var orgMin = libtess.geom.vertLeq(orgUp, orgLo) ? orgUp : orgLo;
	  if (libtess.geom.vertLeq(orgMin, isect)) {
	    isect.s = orgMin.s;
	    isect.t = orgMin.t;
	  }

	  if (libtess.geom.vertEq(isect, orgUp) || libtess.geom.vertEq(isect, orgLo)) {
	    // Easy case -- intersection at one of the right endpoints
	    libtess.sweep.checkForRightSplice_(tess, regUp);
	    return false;
	  }

	  // TODO(bckenny): clean this up; length is distracting
	  if ((!libtess.geom.vertEq(dstUp, tess.event) &&
	      libtess.geom.edgeSign(dstUp, tess.event, isect) >= 0) ||
	      (!libtess.geom.vertEq(dstLo, tess.event) &&
	      libtess.geom.edgeSign(dstLo, tess.event, isect) <= 0)) {

	    /* Very unusual -- the new upper or lower edge would pass on the
	     * wrong side of the sweep event, or through it. This can happen
	     * due to very small numerical errors in the intersection calculation.
	     */
	    if (dstLo === tess.event) {
	      // Splice dstLo into eUp, and process the new region(s)
	      libtess.mesh.splitEdge(eUp.sym);
	      libtess.mesh.meshSplice(eLo.sym, eUp);
	      regUp = libtess.sweep.topLeftRegion_(regUp);
	      eUp = regUp.regionBelow().eUp;
	      libtess.sweep.finishLeftRegions_(tess, regUp.regionBelow(), regLo);
	      libtess.sweep.addRightEdges_(tess, regUp, eUp.oPrev(), eUp, eUp, true);
	      return true;
	    }

	    if (dstUp === tess.event) {
	      // Splice dstUp into eLo, and process the new region(s)
	      libtess.mesh.splitEdge(eLo.sym);
	      libtess.mesh.meshSplice(eUp.lNext, eLo.oPrev());
	      regLo = regUp;
	      regUp = libtess.sweep.topRightRegion_(regUp);
	      var e = regUp.regionBelow().eUp.rPrev();
	      regLo.eUp = eLo.oPrev();
	      eLo = libtess.sweep.finishLeftRegions_(tess, regLo, null);
	      libtess.sweep.addRightEdges_(tess, regUp, eLo.oNext, eUp.rPrev(), e,
	          true);
	      return true;
	    }

	    /* Special case: called from connectRightVertex. If either
	     * edge passes on the wrong side of tess.event, split it
	     * (and wait for connectRightVertex to splice it appropriately).
	     */
	    if (libtess.geom.edgeSign(dstUp, tess.event, isect) >= 0) {
	      regUp.regionAbove().dirty = regUp.dirty = true;
	      libtess.mesh.splitEdge(eUp.sym);
	      eUp.org.s = tess.event.s;
	      eUp.org.t = tess.event.t;
	    }

	    if (libtess.geom.edgeSign(dstLo, tess.event, isect) <= 0) {
	      regUp.dirty = regLo.dirty = true;
	      libtess.mesh.splitEdge(eLo.sym);
	      eLo.org.s = tess.event.s;
	      eLo.org.t = tess.event.t;
	    }

	    // leave the rest for connectRightVertex
	    return false;
	  }

	  /* General case -- split both edges, splice into new vertex.
	   * When we do the splice operation, the order of the arguments is
	   * arbitrary as far as correctness goes. However, when the operation
	   * creates a new face, the work done is proportional to the size of
	   * the new face. We expect the faces in the processed part of
	   * the mesh (ie. eUp.lFace) to be smaller than the faces in the
	   * unprocessed original contours (which will be eLo.oPrev.lFace).
	   */
	  libtess.mesh.splitEdge(eUp.sym);
	  libtess.mesh.splitEdge(eLo.sym);
	  libtess.mesh.meshSplice(eLo.oPrev(), eUp);
	  eUp.org.s = isect.s;
	  eUp.org.t = isect.t;
	  eUp.org.pqHandle = tess.pq.insert(eUp.org);
	  libtess.sweep.getIntersectData_(tess, eUp.org, orgUp, dstUp, orgLo, dstLo);
	  regUp.regionAbove().dirty = regUp.dirty = regLo.dirty = true;

	  return false;
	};


	/**
	 * When the upper or lower edge of any region changes, the region is
	 * marked "dirty". This routine walks through all the dirty regions
	 * and makes sure that the dictionary invariants are satisfied
	 * (see the comments at the beginning of this file). Of course,
	 * new dirty regions can be created as we make changes to restore
	 * the invariants.
	 * @private
	 * @param {libtess.GluTesselator} tess [description].
	 * @param {libtess.ActiveRegion} regUp [description].
	 */
	libtess.sweep.walkDirtyRegions_ = function(tess, regUp) {
	  var regLo = regUp.regionBelow();

	  for (;;) {
	    // Find the lowest dirty region (we walk from the bottom up).
	    while (regLo.dirty) {
	      regUp = regLo;
	      regLo = regLo.regionBelow();
	    }
	    if (!regUp.dirty) {
	      regLo = regUp;
	      regUp = regUp.regionAbove();
	      if (regUp === null || !regUp.dirty) {
	        // We've walked all the dirty regions
	        return;
	      }
	    }

	    regUp.dirty = false;
	    var eUp = regUp.eUp;
	    var eLo = regLo.eUp;

	    if (eUp.dst() !== eLo.dst()) {
	      // Check that the edge ordering is obeyed at the dst vertices.
	      if (libtess.sweep.checkForLeftSplice_(tess, regUp)) {
	        // If the upper or lower edge was marked fixUpperEdge, then
	        // we no longer need it (since these edges are needed only for
	        // vertices which otherwise have no right-going edges).
	        if (regLo.fixUpperEdge) {
	          libtess.sweep.deleteRegion_(tess, regLo);
	          libtess.mesh.deleteEdge(eLo);
	          regLo = regUp.regionBelow();
	          eLo = regLo.eUp;

	        } else if (regUp.fixUpperEdge) {
	          libtess.sweep.deleteRegion_(tess, regUp);
	          libtess.mesh.deleteEdge(eUp);
	          regUp = regLo.regionAbove();
	          eUp = regUp.eUp;
	        }
	      }
	    }

	    if (eUp.org !== eLo.org) {
	      if (eUp.dst() !== eLo.dst() && !regUp.fixUpperEdge &&
	          !regLo.fixUpperEdge &&
	          (eUp.dst() === tess.event || eLo.dst() === tess.event)) {
	        /* When all else fails in checkForIntersect(), it uses tess.event
	         * as the intersection location. To make this possible, it requires
	         * that tess.event lie between the upper and lower edges, and also
	         * that neither of these is marked fixUpperEdge (since in the worst
	         * case it might splice one of these edges into tess.event, and
	         * violate the invariant that fixable edges are the only right-going
	         * edge from their associated vertex).
	         */
	        if (libtess.sweep.checkForIntersect_(tess, regUp)) {
	          // walkDirtyRegions() was called recursively; we're done
	          return;
	        }

	      } else {
	        // Even though we can't use checkForIntersect(), the org vertices
	        // may violate the dictionary edge ordering. Check and correct this.
	        libtess.sweep.checkForRightSplice_(tess, regUp);
	      }
	    }

	    if (eUp.org === eLo.org && eUp.dst() === eLo.dst()) {
	      // A degenerate loop consisting of only two edges -- delete it.
	      libtess.sweep.addWinding_(eLo, eUp);
	      libtess.sweep.deleteRegion_(tess, regUp);
	      libtess.mesh.deleteEdge(eUp);
	      regUp = regLo.regionAbove();
	    }
	  }
	};


	/**
	 * Purpose: connect a "right" vertex vEvent (one where all edges go left)
	 * to the unprocessed portion of the mesh. Since there are no right-going
	 * edges, two regions (one above vEvent and one below) are being merged
	 * into one. regUp is the upper of these two regions.
	 *
	 * There are two reasons for doing this (adding a right-going edge):
	 *  - if the two regions being merged are "inside", we must add an edge
	 *    to keep them separated (the combined region would not be monotone).
	 *  - in any case, we must leave some record of vEvent in the dictionary,
	 *    so that we can merge vEvent with features that we have not seen yet.
	 *    For example, maybe there is a vertical edge which passes just to
	 *    the right of vEvent; we would like to splice vEvent into this edge.
	 *
	 * However, we don't want to connect vEvent to just any vertex. We don't
	 * want the new edge to cross any other edges; otherwise we will create
	 * intersection vertices even when the input data had no self-intersections.
	 * (This is a bad thing; if the user's input data has no intersections,
	 * we don't want to generate any false intersections ourselves.)
	 *
	 * Our eventual goal is to connect vEvent to the leftmost unprocessed
	 * vertex of the combined region (the union of regUp and regLo).
	 * But because of unseen vertices with all right-going edges, and also
	 * new vertices which may be created by edge intersections, we don't
	 * know where that leftmost unprocessed vertex is. In the meantime, we
	 * connect vEvent to the closest vertex of either chain, and mark the region
	 * as "fixUpperEdge". This flag says to delete and reconnect this edge
	 * to the next processed vertex on the boundary of the combined region.
	 * Quite possibly the vertex we connected to will turn out to be the
	 * closest one, in which case we won't need to make any changes.
	 *
	 * @private
	 * @param {libtess.GluTesselator} tess [description].
	 * @param {libtess.ActiveRegion} regUp [description].
	 * @param {libtess.GluHalfEdge} eBottomLeft [description].
	 */
	libtess.sweep.connectRightVertex_ = function(tess, regUp, eBottomLeft) {
	  var eTopLeft = eBottomLeft.oNext;
	  var regLo = regUp.regionBelow();
	  var eUp = regUp.eUp;
	  var eLo = regLo.eUp;
	  var degenerate = false;

	  if (eUp.dst() !== eLo.dst()) {
	    libtess.sweep.checkForIntersect_(tess, regUp);
	  }

	  // Possible new degeneracies: upper or lower edge of regUp may pass
	  // through vEvent, or may coincide with new intersection vertex
	  if (libtess.geom.vertEq(eUp.org, tess.event)) {
	    libtess.mesh.meshSplice(eTopLeft.oPrev(), eUp);
	    regUp = libtess.sweep.topLeftRegion_(regUp);
	    eTopLeft = regUp.regionBelow().eUp;
	    libtess.sweep.finishLeftRegions_(tess, regUp.regionBelow(), regLo);
	    degenerate = true;
	  }
	  if (libtess.geom.vertEq(eLo.org, tess.event)) {
	    libtess.mesh.meshSplice(eBottomLeft, eLo.oPrev());
	    eBottomLeft = libtess.sweep.finishLeftRegions_(tess, regLo, null);
	    degenerate = true;
	  }
	  if (degenerate) {
	    libtess.sweep.addRightEdges_(tess, regUp, eBottomLeft.oNext, eTopLeft,
	        eTopLeft, true);
	    return;
	  }

	  // Non-degenerate situation -- need to add a temporary, fixable edge.
	  // Connect to the closer of eLo.org, eUp.org.
	  var eNew;
	  if (libtess.geom.vertLeq(eLo.org, eUp.org)) {
	    eNew = eLo.oPrev();
	  } else {
	    eNew = eUp;
	  }
	  eNew = libtess.mesh.connect(eBottomLeft.lPrev(), eNew);

	  // Prevent cleanup, otherwise eNew might disappear before we've even
	  // had a chance to mark it as a temporary edge.
	  libtess.sweep.addRightEdges_(tess, regUp, eNew, eNew.oNext, eNew.oNext,
	      false);
	  eNew.sym.activeRegion.fixUpperEdge = true;
	  libtess.sweep.walkDirtyRegions_(tess, regUp);
	};


	/**
	 * The event vertex lies exacty on an already-processed edge or vertex.
	 * Adding the new vertex involves splicing it into the already-processed
	 * part of the mesh.
	 * @private
	 * @param {libtess.GluTesselator} tess [description].
	 * @param {libtess.ActiveRegion} regUp [description].
	 * @param {libtess.GluVertex} vEvent [description].
	 */
	libtess.sweep.connectLeftDegenerate_ = function(tess, regUp, vEvent) {
	  var e = regUp.eUp;
	  /* istanbul ignore if */
	  if (libtess.geom.vertEq(e.org, vEvent)) {
	    // NOTE(bckenny): this code is unreachable but remains for a hypothetical
	    // future extension of libtess. See docs on libtess.sweep.TOLERANCE_NONZERO_
	    // for more information. Conditional on TOLERANCE_NONZERO_ to help Closure
	    // Compiler eliminate dead code.
	    // e.org is an unprocessed vertex - just combine them, and wait
	    // for e.org to be pulled from the queue
	    if (libtess.sweep.TOLERANCE_NONZERO_) {
	      libtess.sweep.spliceMergeVertices_(tess, e, vEvent.anEdge);
	    }
	    return;
	  }

	  if (!libtess.geom.vertEq(e.dst(), vEvent)) {
	    // General case -- splice vEvent into edge e which passes through it
	    libtess.mesh.splitEdge(e.sym);

	    if (regUp.fixUpperEdge) {
	      // This edge was fixable -- delete unused portion of original edge
	      libtess.mesh.deleteEdge(e.oNext);
	      regUp.fixUpperEdge = false;
	    }

	    libtess.mesh.meshSplice(vEvent.anEdge, e);

	    // recurse
	    libtess.sweep.sweepEvent_(tess, vEvent);
	    return;
	  }

	  // NOTE(bckenny): this code is unreachable but remains for a hypothetical
	  // future extension of libtess. See docs on libtess.sweep.TOLERANCE_NONZERO_
	  // for more information. Conditional on TOLERANCE_NONZERO_ to help Closure
	  // Compiler eliminate dead code.
	  // vEvent coincides with e.dst(), which has already been processed.
	  // Splice in the additional right-going edges.
	  /* istanbul ignore next */

	  /* istanbul ignore next */
	  if (libtess.sweep.TOLERANCE_NONZERO_) {
	    regUp = libtess.sweep.topRightRegion_(regUp);
	    var reg = regUp.regionBelow();
	    var eTopRight = reg.eUp.sym;
	    var eTopLeft = eTopRight.oNext;
	    var eLast = eTopLeft;

	    if (reg.fixUpperEdge) {
	      // Here e.dst() has only a single fixable edge going right.
	      // We can delete it since now we have some real right-going edges.

	      // there are some left edges too
	      libtess.sweep.deleteRegion_(tess, reg); // TODO(bckenny): something to null?
	      libtess.mesh.deleteEdge(eTopRight);
	      eTopRight = eTopLeft.oPrev();
	    }

	    libtess.mesh.meshSplice(vEvent.anEdge, eTopRight);
	    if (!libtess.geom.edgeGoesLeft(eTopLeft)) {
	      // e.dst() had no left-going edges -- indicate this to addRightEdges()
	      eTopLeft = null;
	    }

	    libtess.sweep.addRightEdges_(tess, regUp, eTopRight.oNext, eLast, eTopLeft,
	        true);
	  }
	};


	/**
	 * Connect a "left" vertex (one where both edges go right)
	 * to the processed portion of the mesh. Let R be the active region
	 * containing vEvent, and let U and L be the upper and lower edge
	 * chains of R. There are two possibilities:
	 *
	 * - the normal case: split R into two regions, by connecting vEvent to
	 *   the rightmost vertex of U or L lying to the left of the sweep line
	 *
	 * - the degenerate case: if vEvent is close enough to U or L, we
	 *   merge vEvent into that edge chain. The subcases are:
	 *  - merging with the rightmost vertex of U or L
	 *  - merging with the active edge of U or L
	 *  - merging with an already-processed portion of U or L
	 *
	 * @private
	 * @param {libtess.GluTesselator} tess   [description].
	 * @param {libtess.GluVertex} vEvent [description].
	 */
	libtess.sweep.connectLeftVertex_ = function(tess, vEvent) {
	  // TODO(bckenny): tmp only used for sweep. better to keep tmp across calls?
	  var tmp = new libtess.ActiveRegion();

	  // NOTE(bckenny): this was commented out in the original
	  // libtess.assert(vEvent.anEdge.oNext.oNext === vEvent.anEdge);

	  // Get a pointer to the active region containing vEvent
	  tmp.eUp = vEvent.anEdge.sym;
	  var regUp = tess.dict.search(tmp).getKey();
	  var regLo = regUp.regionBelow();
	  var eUp = regUp.eUp;
	  var eLo = regLo.eUp;

	  // try merging with U or L first
	  if (libtess.geom.edgeSign(eUp.dst(), vEvent, eUp.org) === 0) {
	    libtess.sweep.connectLeftDegenerate_(tess, regUp, vEvent);
	    return;
	  }

	  // Connect vEvent to rightmost processed vertex of either chain.
	  // e.dst() is the vertex that we will connect to vEvent.
	  var reg = libtess.geom.vertLeq(eLo.dst(), eUp.dst()) ? regUp : regLo;
	  var eNew;
	  if (regUp.inside || reg.fixUpperEdge) {
	    if (reg === regUp) {
	      eNew = libtess.mesh.connect(vEvent.anEdge.sym, eUp.lNext);

	    } else {
	      var tempHalfEdge = libtess.mesh.connect(eLo.dNext(), vEvent.anEdge);
	      eNew = tempHalfEdge.sym;
	    }

	    if (reg.fixUpperEdge) {
	      libtess.sweep.fixUpperEdge_(reg, eNew);

	    } else {
	      libtess.sweep.computeWinding_(tess,
	          libtess.sweep.addRegionBelow_(tess, regUp, eNew));
	    }
	    libtess.sweep.sweepEvent_(tess, vEvent);

	  } else {
	    // The new vertex is in a region which does not belong to the polygon.
	    // We don''t need to connect this vertex to the rest of the mesh.
	    libtess.sweep.addRightEdges_(tess, regUp, vEvent.anEdge, vEvent.anEdge,
	        null, true);
	  }
	};


	/**
	 * Does everything necessary when the sweep line crosses a vertex.
	 * Updates the mesh and the edge dictionary.
	 * @private
	 * @param {libtess.GluTesselator} tess [description].
	 * @param {libtess.GluVertex} vEvent [description].
	 */
	libtess.sweep.sweepEvent_ = function(tess, vEvent) {
	  tess.event = vEvent; // for access in edgeLeq_ // TODO(bckenny): wuh?

	  /* Check if this vertex is the right endpoint of an edge that is
	   * already in the dictionary.  In this case we don't need to waste
	   * time searching for the location to insert new edges.
	   */
	  var e = vEvent.anEdge;
	  while (e.activeRegion === null) {
	    e = e.oNext;
	    if (e === vEvent.anEdge) {
	      // All edges go right -- not incident to any processed edges
	      libtess.sweep.connectLeftVertex_(tess, vEvent);
	      return;
	    }
	  }

	  /* Processing consists of two phases: first we "finish" all the
	   * active regions where both the upper and lower edges terminate
	   * at vEvent (ie. vEvent is closing off these regions).
	   * We mark these faces "inside" or "outside" the polygon according
	   * to their winding number, and delete the edges from the dictionary.
	   * This takes care of all the left-going edges from vEvent.
	   */
	  var regUp = libtess.sweep.topLeftRegion_(e.activeRegion);
	  var reg = regUp.regionBelow();
	  var eTopLeft = reg.eUp;
	  var eBottomLeft = libtess.sweep.finishLeftRegions_(tess, reg, null);

	  /* Next we process all the right-going edges from vEvent. This
	   * involves adding the edges to the dictionary, and creating the
	   * associated "active regions" which record information about the
	   * regions between adjacent dictionary edges.
	   */
	  if (eBottomLeft.oNext === eTopLeft) {
	    // No right-going edges -- add a temporary "fixable" edge
	    libtess.sweep.connectRightVertex_(tess, regUp, eBottomLeft);

	  } else {
	    libtess.sweep.addRightEdges_(tess, regUp, eBottomLeft.oNext, eTopLeft,
	        eTopLeft, true);
	  }
	};


	/**
	 * We add two sentinel edges above and below all other edges,
	 * to avoid special cases at the top and bottom.
	 * @private
	 * @param {libtess.GluTesselator} tess [description].
	 * @param {number} t [description].
	 */
	libtess.sweep.addSentinel_ = function(tess, t) {
	  var reg = new libtess.ActiveRegion();

	  var e = libtess.mesh.makeEdge(tess.mesh);

	  e.org.s = libtess.sweep.SENTINEL_COORD_;
	  e.org.t = t;
	  e.dst().s = -libtess.sweep.SENTINEL_COORD_;
	  e.dst().t = t;
	  tess.event = e.dst(); //initialize it

	  reg.eUp = e;
	  reg.windingNumber = 0;
	  reg.inside = false;
	  reg.fixUpperEdge = false;
	  reg.sentinel = true;
	  reg.dirty = false;
	  reg.nodeUp = tess.dict.insert(reg);
	};


	/**
	 * We maintain an ordering of edge intersections with the sweep line.
	 * This order is maintained in a dynamic dictionary.
	 * @private
	 * @param {libtess.GluTesselator} tess [description].
	 */
	libtess.sweep.initEdgeDict_ = function(tess) {
	  tess.dict = new libtess.Dict(tess, libtess.sweep.edgeLeq_);

	  libtess.sweep.addSentinel_(tess, -libtess.sweep.SENTINEL_COORD_);
	  libtess.sweep.addSentinel_(tess, libtess.sweep.SENTINEL_COORD_);
	};


	/**
	 * [doneEdgeDict_ description]
	 * @private
	 * @param {libtess.GluTesselator} tess [description].
	 */
	libtess.sweep.doneEdgeDict_ = function(tess) {
	  // NOTE(bckenny): fixedEdges is only used in the assert below, so ignore so
	  // when asserts are removed jshint won't error.
	  /* jshint unused:false */
	  var fixedEdges = 0;

	  var reg;
	  while ((reg = tess.dict.getMin().getKey()) !== null) {
	    // At the end of all processing, the dictionary should contain
	    // only the two sentinel edges, plus at most one "fixable" edge
	    // created by connectRightVertex().
	    if (!reg.sentinel) {
	    }
	    libtess.sweep.deleteRegion_(tess, reg);
	  }

	  // NOTE(bckenny): see tess.dict.deleteDict_() for old delete dict function
	  tess.dict = null;
	};


	/**
	 * Remove zero-length edges, and contours with fewer than 3 vertices.
	 * @private
	 * @param {libtess.GluTesselator} tess [description].
	 */
	libtess.sweep.removeDegenerateEdges_ = function(tess) {
	  var eHead = tess.mesh.eHead;

	  var eNext;
	  for (var e = eHead.next; e !== eHead; e = eNext) {
	    eNext = e.next;
	    var eLNext = e.lNext;

	    if (libtess.geom.vertEq(e.org, e.dst()) && e.lNext.lNext !== e) {
	      // Zero-length edge, contour has at least 3 edges
	      libtess.sweep.spliceMergeVertices_(tess, eLNext, e); // deletes e.org
	      libtess.mesh.deleteEdge(e); // e is a self-loop TODO(bckenny): does this comment really apply here?
	      e = eLNext;
	      eLNext = e.lNext;
	    }

	    if (eLNext.lNext === e) {
	      // Degenerate contour (one or two edges)
	      if (eLNext !== e) {
	        if (eLNext === eNext || eLNext === eNext.sym) {
	          eNext = eNext.next;
	        }
	        libtess.mesh.deleteEdge(eLNext);
	      }

	      if (e === eNext || e === eNext.sym) {
	        eNext = eNext.next;
	      }
	      libtess.mesh.deleteEdge(e);
	    }
	  }
	};


	/**
	 * Construct priority queue and insert all vertices into it, which determines
	 * the order in which vertices cross the sweep line.
	 * @private
	 * @param {libtess.GluTesselator} tess [description].
	 */
	libtess.sweep.initPriorityQ_ = function(tess) {
	  // TODO(bckenny): libtess.geom.vertLeq needs cast?
	  var pq = new libtess.PriorityQ(
	      /** @type {function(Object, Object): boolean} */(libtess.geom.vertLeq));
	  tess.pq = pq;

	  var vHead = tess.mesh.vHead;
	  var v;
	  for (v = vHead.next; v !== vHead; v = v.next) {
	    v.pqHandle = pq.insert(v);
	  }

	  pq.init();
	};


	/**
	 * [donePriorityQ_ description]
	 * @private
	 * @param {libtess.GluTesselator} tess [description].
	 */
	libtess.sweep.donePriorityQ_ = function(tess) {
	  // TODO(bckenny): probably don't need deleteQ. check that function for comment
	  tess.pq.deleteQ();
	  tess.pq = null;
	};


	/**
	 * Delete any degenerate faces with only two edges. walkDirtyRegions()
	 * will catch almost all of these, but it won't catch degenerate faces
	 * produced by splice operations on already-processed edges.
	 * The two places this can happen are in finishLeftRegions(), when
	 * we splice in a "temporary" edge produced by connectRightVertex(),
	 * and in checkForLeftSplice(), where we splice already-processed
	 * edges to ensure that our dictionary invariants are not violated
	 * by numerical errors.
	 *
	 * In both these cases it is *very* dangerous to delete the offending
	 * edge at the time, since one of the routines further up the stack
	 * will sometimes be keeping a pointer to that edge.
	 *
	 * @private
	 * @param {libtess.GluMesh} mesh [description].
	 */
	libtess.sweep.removeDegenerateFaces_ = function(mesh) {
	  var fNext;
	  for (var f = mesh.fHead.next; f !== mesh.fHead; f = fNext) {
	    fNext = f.next;
	    var e = f.anEdge;

	    if (e.lNext.lNext === e) {
	      // A face with only two edges
	      libtess.sweep.addWinding_(e.oNext, e);
	      libtess.mesh.deleteEdge(e);
	    }
	  }
	};


	/* global libtess */

	/** @const */
	libtess.tessmono = {};

	/**
	 * Tessellates a monotone region (what else would it do??). The region must
	 * consist of a single loop of half-edges (see mesh.js) oriented CCW. "Monotone"
	 * in this case means that any vertical line intersects the interior of the
	 * region in a single interval.
	 *
	 * Tessellation consists of adding interior edges (actually pairs of
	 * half-edges), to split the region into non-overlapping triangles.
	 * @private
	 * @param {!libtess.GluFace} face
	 */
	libtess.tessmono.tessellateMonoRegion_ = function(face) {
	  /* The basic idea is explained in Preparata and Shamos (which I don't
	   * have handy right now), although their implementation is more
	   * complicated than this one. The are two edge chains, an upper chain
	   * and a lower chain. We process all vertices from both chains in order,
	   * from right to left.
	   *
	   * The algorithm ensures that the following invariant holds after each
	   * vertex is processed: the untessellated region consists of two
	   * chains, where one chain (say the upper) is a single edge, and
	   * the other chain is concave. The left vertex of the single edge
	   * is always to the left of all vertices in the concave chain.
	   *
	   * Each step consists of adding the rightmost unprocessed vertex to one
	   * of the two chains, and forming a fan of triangles from the rightmost
	   * of two chain endpoints. Determining whether we can add each triangle
	   * to the fan is a simple orientation test. By making the fan as large
	   * as possible, we restore the invariant (check it yourself).
	   *
	   * All edges are oriented CCW around the boundary of the region.
	   * First, find the half-edge whose origin vertex is rightmost.
	   * Since the sweep goes from left to right, face.anEdge should
	   * be close to the edge we want.
	   */
	  var up = face.anEdge;

	  for (; libtess.geom.vertLeq(up.dst(), up.org); up = up.lPrev()) { }
	  for (; libtess.geom.vertLeq(up.org, up.dst()); up = up.lNext) { }

	  var lo = up.lPrev();

	  var tempHalfEdge;
	  while (up.lNext !== lo) {
	    if (libtess.geom.vertLeq(up.dst(), lo.org)) {
	      // up.dst() is on the left. It is safe to form triangles from lo.org.
	      // The edgeGoesLeft test guarantees progress even when some triangles
	      // are CW, given that the upper and lower chains are truly monotone.
	      while (lo.lNext !== up && (libtess.geom.edgeGoesLeft(lo.lNext) ||
	          libtess.geom.edgeSign(lo.org, lo.dst(), lo.lNext.dst()) <= 0)) {

	        tempHalfEdge = libtess.mesh.connect(lo.lNext, lo);
	        lo = tempHalfEdge.sym;
	      }
	      lo = lo.lPrev();

	    } else {
	      // lo.org is on the left. We can make CCW triangles from up.dst().
	      while (lo.lNext !== up && (libtess.geom.edgeGoesRight(up.lPrev()) ||
	          libtess.geom.edgeSign(up.dst(), up.org, up.lPrev().org) >= 0)) {

	        tempHalfEdge = libtess.mesh.connect(up, up.lPrev());
	        up = tempHalfEdge.sym;
	      }
	      up = up.lNext;
	    }
	  }

	  // Now lo.org == up.dst() == the leftmost vertex. The remaining region
	  // can be tessellated in a fan from this leftmost vertex.
	  while (lo.lNext.lNext !== up) {
	    tempHalfEdge = libtess.mesh.connect(lo.lNext, lo);
	    lo = tempHalfEdge.sym;
	  }
	};

	/**
	 * Tessellates each region of the mesh which is marked "inside" the polygon.
	 * Each such region must be monotone.
	 * @param {!libtess.GluMesh} mesh
	 */
	libtess.tessmono.tessellateInterior = function(mesh) {
	  var next;
	  for (var f = mesh.fHead.next; f !== mesh.fHead; f = next) {
	    // Make sure we don't try to tessellate the new triangles.
	    next = f.next;
	    if (f.inside) {
	      libtess.tessmono.tessellateMonoRegion_(f);
	    }
	  }
	};

	/**
	 * Zaps (i.e. sets to null) all faces which are not marked "inside" the polygon.
	 * Since further mesh operations on null faces are not allowed, the main purpose
	 * is to clean up the mesh so that exterior loops are not represented in the
	 * data structure.
	 * @param {!libtess.GluMesh} mesh
	 */
	libtess.tessmono.discardExterior = function(mesh) {
	  var next;
	  for (var f = mesh.fHead.next; f !== mesh.fHead; f = next) {
	    // Since f will be destroyed, save its next pointer.
	    next = f.next;
	    if (!f.inside) {
	      libtess.mesh.zapFace(f);
	    }
	  }
	};

	/**
	 * Resets the winding numbers on all edges so that regions marked "inside" the
	 * polygon have a winding number of "value", and regions outside have a winding
	 * number of 0.
	 *
	 * If keepOnlyBoundary is true, it also deletes all edges which do not separate
	 * an interior region from an exterior one.
	 *
	 * @param {!libtess.GluMesh} mesh
	 * @param {number} value
	 * @param {boolean} keepOnlyBoundary
	 */
	libtess.tessmono.setWindingNumber = function(mesh, value, keepOnlyBoundary) {
	  var eNext;
	  for (var e = mesh.eHead.next; e !== mesh.eHead; e = eNext) {
	    eNext = e.next;

	    if (e.rFace().inside !== e.lFace.inside) {
	      // This is a boundary edge (one side is interior, one is exterior).
	      e.winding = (e.lFace.inside) ? value : -value;

	    } else {
	      // Both regions are interior, or both are exterior.
	      if (!keepOnlyBoundary) {
	        e.winding = 0;

	      } else {
	        libtess.mesh.deleteEdge(e);
	      }
	    }
	  }
	};


	/* global libtess */

	/**
	 * A list of edges crossing the sweep line, sorted from top to bottom.
	 * Implementation is a doubly-linked list, sorted by the injected edgeLeq
	 * comparator function. Here it is a simple ordering, but see libtess.sweep for
	 * the list of invariants on the edge dictionary this ordering creates.
	 * @constructor
	 * @struct
	 * @param {!libtess.GluTesselator} frame
	 * @param {function(!libtess.GluTesselator, !libtess.ActiveRegion, !libtess.ActiveRegion): boolean} leq
	 */
	libtess.Dict = function(frame, leq) {

	  /**
	   * The head of the doubly-linked DictNode list. At creation time, links back
	   * and forward only to itself.
	   * @private
	   */
	  this.head_ = new libtess.DictNode();

	  /**
	   * The GluTesselator used as the frame for edge/event comparisons.
	   * @private
	   */
	  this.frame_ = frame;

	  /**
	   * Comparison function to maintain the invariants of the Dict. See
	   * libtess.sweep.edgeLeq_ for source.
	   * @private
	   * @type {function(!libtess.GluTesselator, !libtess.ActiveRegion, !libtess.ActiveRegion): boolean}
	   */
	  this.leq_ = leq;
	};

	/* istanbul ignore next */
	/**
	 * Formerly used to delete the dict.
	 * NOTE(bckenny): No longer called but left for memFree documentation. Nulled at
	 * former callsite instead (sweep.doneEdgeDict_)
	 * @private
	 */
	libtess.Dict.prototype.deleteDict_ = function() {
	  // for (var node = this.head_.next; node !== this.head_; node = node.next) {
	  //   memFree(node);
	  // }
	  // memFree(dict);
	};

	/**
	 * Insert the supplied key into the edge list and return its new node.
	 * @param {libtess.DictNode} node
	 * @param {!libtess.ActiveRegion} key
	 * @return {!libtess.DictNode}
	 */
	libtess.Dict.prototype.insertBefore = function(node, key) {
	  do {
	    node = node.prev;
	  } while (node.key !== null && !this.leq_(this.frame_, node.key, key));

	  // insert the new node and update the surrounding nodes to point to it
	  var newNode = new libtess.DictNode(key, node.next, node);
	  node.next.prev = newNode;
	  node.next = newNode;

	  return newNode;
	};

	/**
	 * Insert key into the dict and return the new node that contains it.
	 * @param {!libtess.ActiveRegion} key
	 * @return {!libtess.DictNode}
	 */
	libtess.Dict.prototype.insert = function(key) {
	  // NOTE(bckenny): from a macro in dict.h/dict-list.h
	  return this.insertBefore(this.head_, key);
	};

	/**
	 * Remove node from the list.
	 * @param {libtess.DictNode} node
	 */
	libtess.Dict.prototype.deleteNode = function(node) {
	  node.next.prev = node.prev;
	  node.prev.next = node.next;

	  // NOTE(bckenny): nulled at callsite (sweep.deleteRegion_)
	  // memFree( node );
	};

	/**
	 * Search returns the node with the smallest key greater than or equal
	 * to the given key. If there is no such key, returns a node whose
	 * key is null. Similarly, max(d).getSuccessor() has a null key, etc.
	 * @param {!libtess.ActiveRegion} key
	 * @return {!libtess.DictNode}
	 */
	libtess.Dict.prototype.search = function(key) {
	  var node = this.head_;

	  do {
	    node = node.next;
	  } while (node.key !== null && !this.leq_(this.frame_, key, node.key));

	  return node;
	};

	/**
	 * Return the node with the smallest key.
	 * @return {!libtess.DictNode}
	 */
	libtess.Dict.prototype.getMin = function() {
	  // NOTE(bckenny): from a macro in dict.h/dict-list.h
	  return this.head_.next;
	};

	// NOTE(bckenny): libtess.Dict.getMax isn't called within libtess and isn't part
	// of the public API. For now, leaving in but ignoring for coverage.
	/* istanbul ignore next */
	/**
	 * Returns the node with the greatest key.
	 * @return {!libtess.DictNode}
	 */
	libtess.Dict.prototype.getMax = function() {
	  // NOTE(bckenny): from a macro in dict.h/dict-list.h
	  return this.head_.prev;
	};


	/* global libtess */

	/**
	 * A doubly-linked-list node with a libtess.ActiveRegion payload.
	 * The key for this node and the next and previous nodes in the parent Dict list
	 * can be provided to insert it into an existing list (or all can be omitted if
	 * this is to be the founding node of the list).
	 * @param {!libtess.ActiveRegion=} opt_key
	 * @param {!libtess.DictNode=} opt_nextNode
	 * @param {!libtess.DictNode=} opt_prevNode
	 * @constructor
	 * @struct
	 */
	libtess.DictNode = function(opt_key, opt_nextNode, opt_prevNode) {
	  /**
	   * The ActiveRegion key for this node, or null if the head of the list.
	   * @type {libtess.ActiveRegion}
	   */
	  this.key = opt_key || null;

	  /**
	   * Link to next DictNode in parent list or to self if this is the first node.
	   * @type {!libtess.DictNode}
	   */
	  this.next = opt_nextNode || this;

	  /**
	   * Link to previous DictNode in parent list or to self if this is the first
	   * node.
	   * @type {!libtess.DictNode}
	   */
	  this.prev = opt_prevNode || this;
	};

	/**
	 * Get the key from this node.
	 * @return {libtess.ActiveRegion}
	 */
	libtess.DictNode.prototype.getKey = function() {
	  return this.key;
	};

	/**
	 * Get the successor node to this one.
	 * @return {!libtess.DictNode}
	 */
	libtess.DictNode.prototype.getSuccessor = function() {
	  return this.next;
	};

	/**
	 * Get the predecessor node to this one.
	 * @return {!libtess.DictNode}
	 */
	libtess.DictNode.prototype.getPredecessor = function() {
	  return this.prev;
	};



	/* global libtess */

	/**
	 * Cached vertex data for single-countour polygons for quick-and-dirty
	 * decomposition.
	 * @constructor
	 * @struct
	 */
	libtess.CachedVertex = function() {
	  /**
	   * [coords description]
	   * @type {Array.<number>}
	   */
	  this.coords = [0, 0, 0];
	  // TODO(bckenny): better way to init?

	  /**
	   * [data description]
	   * @type {Object}
	   */
	  this.data = null;
	};



	/* global libtess */

	// TODO(bckenny): create more javascript-y API, e.g. make gluTessEndPolygon
	// async, don't require so many temp objects created

	/**
	 * The tesselator main class, providing the public API.
	 * @constructor
	 * @struct
	 */
	libtess.GluTesselator = function() {
	  // Only initialize fields which can be changed by the api. Other fields
	  // are initialized where they are used.

	  // TODO(bckenny): many of these can be made private
	  // TODO(bckenny): can we combine call* and call*Data functions?

	  /*** state needed for collecting the input data ***/

	  /**
	   * what begin/end calls have we seen?
	   * @type {libtess.GluTesselator.tessState_}
	   */
	  this.state = libtess.GluTesselator.tessState_.T_DORMANT;

	  /**
	   * lastEdge_.org is the most recent vertex
	   * @private
	   * @type {libtess.GluHalfEdge}
	   */
	  this.lastEdge_ = null;

	  /**
	   * stores the input contours, and eventually the tessellation itself
	   * @type {libtess.GluMesh}
	   */
	  this.mesh = null;
	  // NOTE(bckenny): initialized in this.emptyCache_

	  /**
	   * Error callback.
	   * @private
	   * @type {?function((libtess.errorType|libtess.gluEnum))}
	   */
	  this.callError_ = null;


	  /*** state needed for projecting onto the sweep plane ***/

	  /**
	   * user-specified normal (if provided)
	   * @type {!Array.<number>}
	   */
	  this.normal = [0, 0, 0];
	  // TODO(bckenny): better way to init these arrays?

	  /**
	   * unit vector in s-direction (debugging)
	   * @type {!Array.<number>}
	   */
	  this.sUnit = [0, 0, 0];

	  /**
	   * unit vector in t-direction (debugging)
	   * @type {!Array.<number>}
	   */
	  this.tUnit = [0, 0, 0];

	  /*** state needed for the line sweep ***/
	  // TODO(bckenny): this could be moved to a sweep state object of some sort

	  /**
	   * tolerance for merging features
	   * @type {number}
	   */
	  this.relTolerance = libtess.GLU_TESS_DEFAULT_TOLERANCE;

	  /**
	   * rule for determining polygon interior
	   * @type {libtess.windingRule}
	   */
	  this.windingRule = libtess.windingRule.GLU_TESS_WINDING_ODD;

	  /**
	   * fatal error: needed combine callback
	   * @type {boolean}
	   */
	  this.fatalError = false;

	  /**
	   * edge dictionary for sweep line
	   * @type {libtess.Dict}
	   */
	  this.dict = null;
	  // NOTE(bckenny): dict initialized in sweep.initEdgeDict_, removed in sweep.doneEdgeDict_

	  /**
	   * priority queue of vertex events
	   * @type {libtess.PriorityQ}
	   */
	  this.pq = null;
	  // NOTE(bckenny): pq initialized in sweep.initPriorityQ

	  /**
	   * current sweep event being processed
	   * @type {libtess.GluVertex}
	   */
	  this.event = null;

	  /**
	   * Combine callback.
	   * @private
	   * @type {?function(Array.<number>, Array.<Object>, Array.<number>): Object}
	   */
	  this.callCombine_ = null;

	  /*** state needed for rendering callbacks (see render.js) ***/

	  /**
	   * Extract contours, not triangles
	   * @type {boolean}
	   */
	  this.boundaryOnly = false;

	  /**
	   * Begin callback.
	   * @private
	   * @type {?function(libtess.primitiveType)}
	   */
	  this.callBegin_ = null;

	  /**
	   * Edge flag callback.
	   * @private
	   * @type {?function(boolean)}
	   */
	  this.callEdgeFlag_ = null;

	  /**
	   * Vertex callback.
	   * @private
	   * @type {?function(Object)}
	   */
	  this.callVertex_ = null;

	  /**
	   * End callback.
	   * @private
	   * @type {?function()}
	   */
	  this.callEnd_ = null;

	  /**
	   * Mesh callback.
	   * @private
	   * @type {?function(libtess.GluMesh)}
	   */
	  this.callMesh_ = null;

	  /*** rendering callbacks that also pass polygon data  ***/
	  /**
	   * BeginData callback.
	   * @private
	   * @type {?function(libtess.primitiveType, Object)}
	   */
	  this.callBeginData_ = null;

	  /**
	   * EdgeFlagData callback.
	   * @private
	   * @type {?function(boolean, Object)}
	   */
	  this.callEdgeFlagData_ = null;

	  /**
	   * VertexData callback.
	   * @private
	   * @type {?function(Object, Object)}
	   */
	  this.callVertexData_ = null;

	  /**
	   * EndData callback.
	   * @private
	   * @type {?function(Object)}
	   */
	  this.callEndData_ = null;

	  /**
	   * ErrorData callback.
	   * @private
	   * @type {?function((libtess.errorType|libtess.gluEnum), Object)}
	   */
	  this.callErrorData_ = null;

	  /**
	   * CombineData callback.
	   * @private
	   * @type {?function(Array.<number>, Array.<Object>, Array.<number>, Object): Object}
	   */
	  this.callCombineData_ = null;

	  /**
	   * client data for current polygon
	   * @private
	   * @type {Object}
	   */
	  this.polygonData_ = null;

	  /*** state needed to cache single-contour polygons for renderCache() ***/
	  /**
	   * empty cache on next vertex() call
	   * @type {boolean}
	   */
	  this.emptyCache = false;
	  // TODO(bckenny): possibly rename to be clear it's a boolean

	  /**
	   * number of cached vertices
	   * @type {number}
	   */
	  this.cacheCount = 0;

	  /**
	   * the vertex data
	   * @type {Array.<libtess.CachedVertex>}
	   */
	  this.cache = new Array(libtess.TESS_MAX_CACHE);

	  // TODO(bckenny): fill now? or init on demand
	  for (var i = 0; i < libtess.TESS_MAX_CACHE; i++) {
	    this.cache[i] = new libtess.CachedVertex();
	  }
	};

	/**
	 * The begin/end calls must be properly nested. We keep track of the current
	 * state to enforce the ordering.
	 * @enum {number}
	 * @private
	 */
	libtess.GluTesselator.tessState_ = {
	  T_DORMANT: 0,
	  T_IN_POLYGON: 1,
	  T_IN_CONTOUR: 2
	};

	/**
	 * Destory the tesselator object. See README.
	 */
	libtess.GluTesselator.prototype.gluDeleteTess = function() {
	  // TODO(bckenny): This does nothing but assert that it isn't called while
	  // building the polygon since we rely on GC to handle memory. *If* the public
	  // API changes, this should go.
	  this.requireState_(libtess.GluTesselator.tessState_.T_DORMANT);
	  // memFree(tess); TODO(bckenny)
	};


	/**
	 * Set properties for control over tesselation. See README.
	 * @param {libtess.gluEnum} which [description].
	 * @param {number|boolean} value [description].
	 */
	libtess.GluTesselator.prototype.gluTessProperty = function(which, value) {
	  // TODO(bckenny): split into more setters?
	  // TODO(bckenny): in any case, we can do better than this switch statement

	  switch (which) {
	    case libtess.gluEnum.GLU_TESS_TOLERANCE:
	      if (value < 0 || value > 1) {
	        break;
	      }
	      // TODO(bckenny): libtess doesn't support any tolerance but 0. This should
	      // reject any non-zero tolerance accordingly.
	      this.relTolerance = /** @type {number} */(value);
	      return;

	    case libtess.gluEnum.GLU_TESS_WINDING_RULE:
	      var windingRule = /** @type {libtess.windingRule} */(value);

	      switch (windingRule) {
	        case libtess.windingRule.GLU_TESS_WINDING_ODD:
	        case libtess.windingRule.GLU_TESS_WINDING_NONZERO:
	        case libtess.windingRule.GLU_TESS_WINDING_POSITIVE:
	        case libtess.windingRule.GLU_TESS_WINDING_NEGATIVE:
	        case libtess.windingRule.GLU_TESS_WINDING_ABS_GEQ_TWO:
	          this.windingRule = windingRule;
	          return;
	        default:
	      }
	      break;

	    case libtess.gluEnum.GLU_TESS_BOUNDARY_ONLY:
	      // TODO(bckenny): added boolean param type. make sure ok.
	      this.boundaryOnly = !!value;
	      return;

	    default:
	      this.callErrorOrErrorData(libtess.gluEnum.GLU_INVALID_ENUM);
	      return;
	  }
	  this.callErrorOrErrorData(libtess.gluEnum.GLU_INVALID_VALUE);
	};


	/**
	 * Returns tessellator property
	 * @param {libtess.gluEnum} which [description].
	 * @return {number|boolean} [description].
	 */
	libtess.GluTesselator.prototype.gluGetTessProperty = function(which) {
	  // TODO(bckenny): as above, split into more getters? and improve on switch statement
	  // why are these being asserted in getter but not setter?

	  switch (which) {
	    case libtess.gluEnum.GLU_TESS_TOLERANCE:
	      // tolerance should be in range [0..1]
	      return this.relTolerance;

	    case libtess.gluEnum.GLU_TESS_WINDING_RULE:
	      var rule = this.windingRule;
	      return rule;

	    case libtess.gluEnum.GLU_TESS_BOUNDARY_ONLY:
	      return this.boundaryOnly;

	    default:
	      this.callErrorOrErrorData(libtess.gluEnum.GLU_INVALID_ENUM);
	      break;
	  }
	  return false;
	};


	/**
	 * Lets the user supply the polygon normal, if known.  All input data
	 * is projected into a plane perpendicular to the normal before
	 * tesselation. All output triangles are oriented CCW with
	 * respect to the normal (CW orientation can be obtained by
	 * reversing the sign of the supplied normal). For example, if
	 * you know that all polygons lie in the x-y plane, call
	 * "tess.gluTessNormal(0.0, 0.0, 1.0)" before rendering any polygons.
	 *
	 * @param {number} x [description].
	 * @param {number} y [description].
	 * @param {number} z [description].
	 */
	libtess.GluTesselator.prototype.gluTessNormal = function(x, y, z) {
	  this.normal[0] = x;
	  this.normal[1] = y;
	  this.normal[2] = z;
	};


	/**
	 * Specify callbacks. See README. A null or undefined opt_fn removes current callback.
	 *
	 * @param {libtess.gluEnum} which [description].
	 * @param {?Function=} opt_fn [description].
	 */
	libtess.GluTesselator.prototype.gluTessCallback = function(which, opt_fn) {
	  var fn = !opt_fn ? null : opt_fn;
	  // TODO(bckenny): better opt_fn typing?

	  switch (which) {
	    case libtess.gluEnum.GLU_TESS_BEGIN:
	      this.callBegin_ = /** @type {function(libtess.primitiveType)} */ (fn);
	      return;

	    case libtess.gluEnum.GLU_TESS_BEGIN_DATA:
	      this.callBeginData_ =
	          /** @type {function(libtess.primitiveType, Object)} */ (fn);
	      return;

	    case libtess.gluEnum.GLU_TESS_EDGE_FLAG:
	      this.callEdgeFlag_ = /** @type {function(boolean)} */ (fn);
	      return;

	    case libtess.gluEnum.GLU_TESS_EDGE_FLAG_DATA:
	      this.callEdgeFlagData_ = /** @type {function(boolean, Object)} */ (fn);
	      return;

	    case libtess.gluEnum.GLU_TESS_VERTEX:
	      this.callVertex_ = /** @type {function(Object)} */ (fn);
	      return;

	    case libtess.gluEnum.GLU_TESS_VERTEX_DATA:
	      this.callVertexData_ = /** @type {function(Object, Object)} */ (fn);
	      return;

	    case libtess.gluEnum.GLU_TESS_END:
	      this.callEnd_ = /** @type {function()} */ (fn);
	      return;

	    case libtess.gluEnum.GLU_TESS_END_DATA:
	      this.callEndData_ = /** @type {function(Object)} */ (fn);
	      return;

	    case libtess.gluEnum.GLU_TESS_ERROR:
	      this.callError_ = /** @type {function((libtess.errorType|libtess.gluEnum))} */ (fn);
	      return;

	    case libtess.gluEnum.GLU_TESS_ERROR_DATA:
	      this.callErrorData_ =
	          /** @type {function((libtess.errorType|libtess.gluEnum), Object)} */ (fn);
	      return;

	    case libtess.gluEnum.GLU_TESS_COMBINE:
	      this.callCombine_ = /** @type {function(Array.<number>, Array.<Object>, Array.<number>): Object} */ (fn);
	      return;

	    case libtess.gluEnum.GLU_TESS_COMBINE_DATA:
	      this.callCombineData_ = /** @type {function(Array.<number>, Array.<Object>, Array.<number>, Object): Object} */ (fn);
	      return;

	    case libtess.gluEnum.GLU_TESS_MESH:
	      this.callMesh_ = /** @type {function(libtess.GluMesh)} */ (fn);
	      return;

	    default:
	      this.callErrorOrErrorData(libtess.gluEnum.GLU_INVALID_ENUM);
	      return;
	  }
	};


	/**
	 * Specify a vertex and associated data. Must be within calls to
	 * beginContour/endContour. See README.
	 *
	 * @param {Array.<number>} coords [description].
	 * @param {Object} data [description].
	 */
	libtess.GluTesselator.prototype.gluTessVertex = function(coords, data) {
	  var tooLarge = false;

	  // TODO(bckenny): pool allocation?
	  var clamped = [0, 0, 0];

	  this.requireState_(libtess.GluTesselator.tessState_.T_IN_CONTOUR);

	  if (this.emptyCache) {
	    this.emptyCache_();
	    this.lastEdge_ = null;
	  }

	  for (var i = 0; i < 3; ++i) {
	    var x = coords[i];
	    if (x < -libtess.GLU_TESS_MAX_COORD) {
	      x = -libtess.GLU_TESS_MAX_COORD;
	      tooLarge = true;
	    }
	    if (x > libtess.GLU_TESS_MAX_COORD) {
	      x = libtess.GLU_TESS_MAX_COORD;
	      tooLarge = true;
	    }
	    clamped[i] = x;
	  }

	  if (tooLarge) {
	    this.callErrorOrErrorData(libtess.errorType.GLU_TESS_COORD_TOO_LARGE);
	  }

	  if (this.mesh === null) {
	    if (this.cacheCount < libtess.TESS_MAX_CACHE) {
	      this.cacheVertex_(clamped, data);
	      return;
	    }

	    // cache is full, create mesh and add cached verts to it
	    this.emptyCache_();
	  }

	  this.addVertex_(clamped, data);
	};


	/**
	 * [gluTessBeginPolygon description]
	 * @param {Object} data Client data for current polygon.
	 */
	libtess.GluTesselator.prototype.gluTessBeginPolygon = function(data) {
	  this.requireState_(libtess.GluTesselator.tessState_.T_DORMANT);

	  this.state = libtess.GluTesselator.tessState_.T_IN_POLYGON;
	  this.cacheCount = 0;
	  this.emptyCache = false;
	  this.mesh = null;

	  this.polygonData_ = data;
	};


	/**
	 * [gluTessBeginContour description]
	 */
	libtess.GluTesselator.prototype.gluTessBeginContour = function() {
	  this.requireState_(libtess.GluTesselator.tessState_.T_IN_POLYGON);

	  this.state = libtess.GluTesselator.tessState_.T_IN_CONTOUR;
	  this.lastEdge_ = null;
	  if (this.cacheCount > 0) {
	    // Just set a flag so we don't get confused by empty contours
	    // -- these can be generated accidentally with the obsolete
	    // NextContour() interface.
	    // TODO(bckenny): we aren't implementing NextContour() interface.
	    this.emptyCache = true;
	  }
	};


	/**
	 * [gluTessEndContour description]
	 */
	libtess.GluTesselator.prototype.gluTessEndContour = function() {
	  this.requireState_(libtess.GluTesselator.tessState_.T_IN_CONTOUR);
	  this.state = libtess.GluTesselator.tessState_.T_IN_POLYGON;
	};


	/**
	 * [gluTessEndPolygon description]
	 */
	libtess.GluTesselator.prototype.gluTessEndPolygon = function() {
	  this.requireState_(libtess.GluTesselator.tessState_.T_IN_POLYGON);
	  this.state = libtess.GluTesselator.tessState_.T_DORMANT;

	  if (this.mesh === null) {
	    // TODO(bckenny): can we eliminate more cache functionality?
	    this.emptyCache_();
	  }

	  // Determine the polygon normal and project vertices onto the plane
	  // of the polygon.
	  libtess.normal.projectPolygon(this);

	  // computeInterior(tess) computes the planar arrangement specified
	  // by the given contours, and further subdivides this arrangement
	  // into regions. Each region is marked "inside" if it belongs
	  // to the polygon, according to the rule given by this.windingRule.
	  // Each interior region is guaranteed be monotone.
	  libtess.sweep.computeInterior(this);

	  if (!this.fatalError) {
	    // If the user wants only the boundary contours, we throw away all edges
	    // except those which separate the interior from the exterior.
	    // Otherwise we tessellate all the regions marked "inside".
	    // NOTE(bckenny): we know this.mesh has been initialized, so help closure out.
	    var mesh = /** @type {!libtess.GluMesh} */(this.mesh);
	    if (this.boundaryOnly) {
	      libtess.tessmono.setWindingNumber(mesh, 1, true);
	    } else {
	      libtess.tessmono.tessellateInterior(mesh);
	    }

	    this.mesh.checkMesh();

	    if (this.callBegin_ || this.callEnd_ || this.callVertex_ ||
	        this.callEdgeFlag_ || this.callBeginData_ || this.callEndData_ ||
	        this.callVertexData_ || this.callEdgeFlagData_) {

	      if (this.boundaryOnly) {
	        // output boundary contours
	        libtess.render.renderBoundary(this, this.mesh);

	      } else {
	        // output triangles (with edge callback if one is set)
	        var flagEdges = !!(this.callEdgeFlag_ || this.callEdgeFlagData_);
	        libtess.render.renderMesh(this, this.mesh, flagEdges);
	      }
	    }

	    if (this.callMesh_) {
	      // Throw away the exterior faces, so that all faces are interior.
	      // This way the user doesn't have to check the "inside" flag,
	      // and we don't need to even reveal its existence. It also leaves
	      // the freedom for an implementation to not generate the exterior
	      // faces in the first place.
	      libtess.tessmono.discardExterior(this.mesh);
	      // user wants the mesh itself
	      this.callMesh_(this.mesh);

	      this.mesh = null;
	      this.polygonData_ = null;
	      return;
	    }
	  }

	  libtess.mesh.deleteMesh(this.mesh);
	  this.polygonData_ = null;
	  this.mesh = null;
	};


	/**
	 * Return the tessellator to its original dormant state.
	 * @private
	 */
	libtess.GluTesselator.prototype.makeDormant_ = function() {
	  if (this.mesh) {
	    libtess.mesh.deleteMesh(this.mesh);
	  }
	  this.state = libtess.GluTesselator.tessState_.T_DORMANT;
	  this.lastEdge_ = null;
	  this.mesh = null;
	};


	/**
	 * [requireState_ description]
	 * @private
	 * @param {libtess.GluTesselator.tessState_} state [description].
	 */
	libtess.GluTesselator.prototype.requireState_ = function(state) {
	  if (this.state !== state) {
	    this.gotoState_(state);
	  }
	};


	/**
	 * [gotoState_ description]
	 * @private
	 * @param  {libtess.GluTesselator.tessState_} newState [description].
	 */
	libtess.GluTesselator.prototype.gotoState_ = function(newState) {
	  while (this.state !== newState) {
	    // We change the current state one level at a time, to get to the desired
	    // state.
	    if (this.state < newState) {
	      switch (this.state) {
	        case libtess.GluTesselator.tessState_.T_DORMANT:
	          this.callErrorOrErrorData(
	              libtess.errorType.GLU_TESS_MISSING_BEGIN_POLYGON);
	          this.gluTessBeginPolygon(null);
	          break;

	        case libtess.GluTesselator.tessState_.T_IN_POLYGON:
	          this.callErrorOrErrorData(
	              libtess.errorType.GLU_TESS_MISSING_BEGIN_CONTOUR);
	          this.gluTessBeginContour();
	          break;
	      }

	    } else {
	      switch (this.state) {
	        case libtess.GluTesselator.tessState_.T_IN_CONTOUR:
	          this.callErrorOrErrorData(
	              libtess.errorType.GLU_TESS_MISSING_END_CONTOUR);
	          this.gluTessEndContour();
	          break;

	        case libtess.GluTesselator.tessState_.T_IN_POLYGON:
	          this.callErrorOrErrorData(
	              libtess.errorType.GLU_TESS_MISSING_END_POLYGON);
	          // this.gluTessEndPolygon() is too much work!
	          this.makeDormant_();
	          break;
	      }
	    }
	  }
	};


	/**
	 * [addVertex_ description]
	 * @private
	 * @param {Array.<number>} coords [description].
	 * @param {Object} data [description].
	 */
	libtess.GluTesselator.prototype.addVertex_ = function(coords, data) {
	  var e = this.lastEdge_;
	  if (e === null) {
	    // Make a self-loop (one vertex, one edge).
	    e = libtess.mesh.makeEdge(this.mesh);
	    libtess.mesh.meshSplice(e, e.sym);

	  } else {
	    // Create a new vertex and edge which immediately follow e
	    // in the ordering around the left face.
	    libtess.mesh.splitEdge(e);
	    e = e.lNext;
	  }

	  // The new vertex is now e.org.
	  e.org.data = data;
	  e.org.coords[0] = coords[0];
	  e.org.coords[1] = coords[1];
	  e.org.coords[2] = coords[2];

	  // The winding of an edge says how the winding number changes as we
	  // cross from the edge''s right face to its left face.  We add the
	  // vertices in such an order that a CCW contour will add +1 to
	  // the winding number of the region inside the contour.
	  e.winding = 1;
	  e.sym.winding = -1;

	  this.lastEdge_ = e;
	};


	/**
	 * [cacheVertex_ description]
	 * @private
	 * @param {Array.<number>} coords [description].
	 * @param {Object} data [description].
	 */
	libtess.GluTesselator.prototype.cacheVertex_ = function(coords, data) {
	  var v = this.cache[this.cacheCount];

	  v.data = data;
	  v.coords[0] = coords[0];
	  v.coords[1] = coords[1];
	  v.coords[2] = coords[2];
	  ++this.cacheCount;
	};


	/**
	 * [emptyCache_ description]
	 * @private
	 */
	libtess.GluTesselator.prototype.emptyCache_ = function() {
	  // NOTE(bckenny): surprise!
	  this.mesh = new libtess.GluMesh();

	  for (var i = 0; i < this.cacheCount; i++) {
	    var v = this.cache[i];
	    this.addVertex_(v.coords, v.data);
	  }

	  this.cacheCount = 0;
	  this.emptyCache = false;
	};


	// TODO(bckenny): all following conditional callbacks could be simplified
	// TODO(bckenny): using null for now, but may rework
	// TODO(bckenny): should add documentation that references in callback are volatile (or make a copy)
	// see README callback descriptions
	/**
	 * [callBeginOrBeginData description]
	 * @param {libtess.primitiveType} type [description].
	 */
	libtess.GluTesselator.prototype.callBeginOrBeginData = function(type) {
	  if (this.callBeginData_) {
	    this.callBeginData_(type, this.polygonData_);

	  } else if (this.callBegin_) {
	    this.callBegin_(type);
	  }
	};


	/**
	 * [callVertexOrVertexData description]
	 * @param {Object} data [description].
	 */
	libtess.GluTesselator.prototype.callVertexOrVertexData = function(data) {
	  if (this.callVertexData_) {
	    this.callVertexData_(data, this.polygonData_);

	  } else if (this.callVertex_) {
	    this.callVertex_(data);
	  }
	};


	/**
	 * [callEdgeFlagOrEdgeFlagData description]
	 * @param {boolean} flag [description].
	 */
	libtess.GluTesselator.prototype.callEdgeFlagOrEdgeFlagData = function(flag) {
	  if (this.callEdgeFlagData_) {
	    this.callEdgeFlagData_(flag, this.polygonData_);

	  } else if (this.callEdgeFlag_) {
	    this.callEdgeFlag_(flag);
	  }
	};


	/**
	 * [callEndOrEndData description]
	 */
	libtess.GluTesselator.prototype.callEndOrEndData = function() {
	  if (this.callEndData_) {
	    this.callEndData_(this.polygonData_);

	  } else if (this.callEnd_) {
	    this.callEnd_();
	  }
	};


	/**
	 * [callCombineOrCombineData description]
	 * @param {Array.<number>} coords [description].
	 * @param {Array.<Object>} data [description].
	 * @param {Array.<number>} weight [description].
	 * @return {Object} Interpolated vertex.
	 */
	libtess.GluTesselator.prototype.callCombineOrCombineData =
	    function(coords, data, weight) {

	  var interpData;
	  if (this.callCombineData_) {
	    interpData = this.callCombineData_(coords, data, weight, this.polygonData_);

	  } else if (this.callCombine_) {
	    interpData = this.callCombine_(coords, data, weight);
	  }

	  // TODO(bckenny): can't be undefined
	  if (interpData === undefined) {
	    interpData = null;
	  }
	  return interpData;
	};


	// TODO(bckenny): combine the enums in libtess
	/**
	 * [callErrorOrErrorData description]
	 * @param {(libtess.errorType|libtess.gluEnum)} errno [description].
	 */
	libtess.GluTesselator.prototype.callErrorOrErrorData = function(errno) {
	  if (this.callErrorData_) {
	    this.callErrorData_(errno, this.polygonData_);

	  } else if (this.callError_) {
	    this.callError_(errno);
	  }
	};



	/* global libtess */

	/**
	 * Each face has a pointer to the next and previous faces in the
	 * circular list, and a pointer to a half-edge with this face as
	 * the left face (null if this is the dummy header). There is also
	 * a field "data" for client data.
	 *
	 * @param {libtess.GluFace=} opt_nextFace
	 * @param {libtess.GluFace=} opt_prevFace
	 * @constructor
	 * @struct
	 */
	libtess.GluFace = function(opt_nextFace, opt_prevFace) {
	  // TODO(bckenny): reverse order of params?

	  /**
	   * next face (never null)
	   * @type {!libtess.GluFace}
	   */
	  this.next = opt_nextFace || this;

	  /**
	   * previous face (never NULL)
	   * @type {!libtess.GluFace}
	   */
	  this.prev = opt_prevFace || this;

	  /**
	   * A half edge with this left face.
	   * @type {libtess.GluHalfEdge}
	   */
	  this.anEdge = null;

	  /**
	   * room for client's data
	   * @type {Object}
	   */
	  this.data = null;

	  /**
	   * This face is in the polygon interior.
	   * @type {boolean}
	   */
	  this.inside = false;
	};



	/* global libtess */

	/**
	 * The fundamental data structure is the "half-edge". Two half-edges
	 * go together to make an edge, but they point in opposite directions.
	 * Each half-edge has a pointer to its mate (the "symmetric" half-edge sym),
	 * its origin vertex (org), the face on its left side (lFace), and the
	 * adjacent half-edges in the CCW direction around the origin vertex
	 * (oNext) and around the left face (lNext). There is also a "next"
	 * pointer for the global edge list (see below).
	 *
	 * The notation used for mesh navigation:
	 *  sym   = the mate of a half-edge (same edge, but opposite direction)
	 *  oNext = edge CCW around origin vertex (keep same origin)
	 *  dNext = edge CCW around destination vertex (keep same dest)
	 *  lNext = edge CCW around left face (dest becomes new origin)
	 *  rNext = edge CCW around right face (origin becomes new dest)
	 *
	 * "prev" means to substitute CW for CCW in the definitions above.
	 *
	 * The circular edge list is special; since half-edges always occur
	 * in pairs (e and e.sym), each half-edge stores a pointer in only
	 * one direction. Starting at eHead and following the e.next pointers
	 * will visit each *edge* once (ie. e or e.sym, but not both).
	 * e.sym stores a pointer in the opposite direction, thus it is
	 * always true that e.sym.next.sym.next === e.
	 *
	 * @param {libtess.GluHalfEdge=} opt_nextEdge
	 * @constructor
	 * @struct
	 */
	libtess.GluHalfEdge = function(opt_nextEdge) {
	  // TODO(bckenny): are these the right defaults? (from gl_meshNewMesh requirements)

	  /**
	   * doubly-linked list (prev==sym->next)
	   * @type {!libtess.GluHalfEdge}
	   */
	  this.next = opt_nextEdge || this;

	  // TODO(bckenny): how can this be required if created in pairs? move to factory creation only?
	  /**
	   * same edge, opposite direction
	   * @type {libtess.GluHalfEdge}
	   */
	  this.sym = null;

	  /**
	   * next edge CCW around origin
	   * @type {libtess.GluHalfEdge}
	   */
	  this.oNext = null;

	  /**
	   * next edge CCW around left face
	   * @type {libtess.GluHalfEdge}
	   */
	  this.lNext = null;

	  /**
	   * origin vertex (oVertex too long)
	   * @type {libtess.GluVertex}
	   */
	  this.org = null;

	  /**
	   * left face
	   * @type {libtess.GluFace}
	   */
	  this.lFace = null;

	  // Internal data (keep hidden)
	  // NOTE(bckenny): can't be private, though...

	  /**
	   * a region with this upper edge (see sweep.js)
	   * @type {libtess.ActiveRegion}
	   */
	  this.activeRegion = null;

	  /**
	   * change in winding number when crossing from the right face to the left face
	   * @type {number}
	   */
	  this.winding = 0;
	};

	// NOTE(bckenny): the following came from macros in mesh
	// TODO(bckenny): using methods as aliases for sym connections for now.
	// not sure about this approach. getters? renames?


	/**
	 * [rFace description]
	 * @return {libtess.GluFace} [description].
	 */
	libtess.GluHalfEdge.prototype.rFace = function() {
	  return this.sym.lFace;
	};


	/**
	 * [dst description]
	 * @return {libtess.GluVertex} [description].
	 */
	libtess.GluHalfEdge.prototype.dst = function() {
	  return this.sym.org;
	};


	/**
	 * [oPrev description]
	 * @return {libtess.GluHalfEdge} [description].
	 */
	libtess.GluHalfEdge.prototype.oPrev = function() {
	  return this.sym.lNext;
	};


	/**
	 * [lPrev description]
	 * @return {libtess.GluHalfEdge} [description].
	 */
	libtess.GluHalfEdge.prototype.lPrev = function() {
	  return this.oNext.sym;
	};

	// NOTE(bckenny): libtess.GluHalfEdge.dPrev is called nowhere in libtess and
	// isn't part of the current public API. It could be useful for mesh traversal
	// and manipulation if made public, however.
	/* istanbul ignore next */
	/**
	 * The edge clockwise around destination vertex (keep same dest).
	 * @return {libtess.GluHalfEdge}
	 */
	libtess.GluHalfEdge.prototype.dPrev = function() {
	  return this.lNext.sym;
	};


	/**
	 * [rPrev description]
	 * @return {libtess.GluHalfEdge} [description].
	 */
	libtess.GluHalfEdge.prototype.rPrev = function() {
	  return this.sym.oNext;
	};


	/**
	 * [dNext description]
	 * @return {libtess.GluHalfEdge} [description].
	 */
	libtess.GluHalfEdge.prototype.dNext = function() {
	  return this.rPrev().sym;
	};


	// NOTE(bckenny): libtess.GluHalfEdge.rNext is called nowhere in libtess and
	// isn't part of the current public API. It could be useful for mesh traversal
	// and manipulation if made public, however.
	/* istanbul ignore next */
	/**
	 * The edge CCW around the right face (origin of this becomes new dest).
	 * @return {libtess.GluHalfEdge}
	 */
	libtess.GluHalfEdge.prototype.rNext = function() {
	  return this.oPrev().sym;
	};



	/* global libtess */

	/**
	 * Creates a new mesh with no edges, no vertices,
	 * and no loops (what we usually call a "face").
	 *
	 * @constructor
	 * @struct
	 */
	libtess.GluMesh = function() {
	  /**
	   * dummy header for vertex list
	   * @type {libtess.GluVertex}
	   */
	  this.vHead = new libtess.GluVertex();

	  /**
	   * dummy header for face list
	   * @type {libtess.GluFace}
	   */
	  this.fHead = new libtess.GluFace();

	  /**
	   * dummy header for edge list
	   * @type {libtess.GluHalfEdge}
	   */
	  this.eHead = new libtess.GluHalfEdge();

	  /**
	   * and its symmetric counterpart
	   * @type {libtess.GluHalfEdge}
	   */
	  this.eHeadSym = new libtess.GluHalfEdge();

	  // TODO(bckenny): better way to pair these?
	  this.eHead.sym = this.eHeadSym;
	  this.eHeadSym.sym = this.eHead;
	};


	// TODO(bckenny): #ifndef NDEBUG
	/**
	 * Checks mesh for self-consistency.
	 */
	libtess.GluMesh.prototype.checkMesh = function() {
	  if (!libtess.DEBUG) {
	    return;
	  }

	  var fHead = this.fHead;
	  var vHead = this.vHead;
	  var eHead = this.eHead;

	  var e;

	  // faces
	  var f;
	  var fPrev = fHead;
	  for (fPrev = fHead; (f = fPrev.next) !== fHead; fPrev = f) {
	    e = f.anEdge;
	    do {
	      e = e.lNext;
	    } while (e !== f.anEdge);
	  }

	  // vertices
	  var v;
	  var vPrev = vHead;
	  for (vPrev = vHead; (v = vPrev.next) !== vHead; vPrev = v) {
	    e = v.anEdge;
	    do {
	      e = e.oNext;
	    } while (e !== v.anEdge);
	  }

	  // edges
	  var ePrev = eHead;
	  for (ePrev = eHead; (e = ePrev.next) !== eHead; ePrev = e) {
	  }
	};



	/* global libtess */

	/**
	 * Each vertex has a pointer to next and previous vertices in the
	 * circular list, and a pointer to a half-edge with this vertex as
	 * the origin (null if this is the dummy header). There is also a
	 * field "data" for client data.
	 *
	 * @param {libtess.GluVertex=} opt_nextVertex [description].
	 * @param {libtess.GluVertex=} opt_prevVertex [description].
	 * @constructor
	 * @struct
	 */
	libtess.GluVertex = function(opt_nextVertex, opt_prevVertex) {
	  // TODO(bckenny): reverse order of params?

	  /**
	   * Next vertex (never null).
	   * @type {!libtess.GluVertex}
	   */
	  this.next = opt_nextVertex || this;

	  /**
	   * Previous vertex (never null).
	   * @type {!libtess.GluVertex}
	   */
	  this.prev = opt_prevVertex || this;

	  /**
	   * A half-edge with this origin.
	   * @type {libtess.GluHalfEdge}
	   */
	  this.anEdge = null;

	  /**
	   * The client's data.
	   * @type {Object}
	   */
	  this.data = null;

	  /**
	   * The vertex location in 3D.
	   * @type {!Array.<number>}
	   */
	  this.coords = [0, 0, 0];
	  // TODO(bckenny): we may want to rethink coords, either eliminate (using s
	  // and t and user data) or index into contiguous storage?

	  /**
	   * Component of projection onto the sweep plane.
	   * @type {number}
	   */
	  this.s = 0;

	  /**
	   * Component of projection onto the sweep plane.
	   * @type {number}
	   */
	  this.t = 0;

	  /**
	   * To allow deletion from priority queue.
	   * @type {?libtess.PQHandle}
	   */
	  this.pqHandle = null;
	  // NOTE(bckenny): pqHandle inited in sweep
	  // TODO(bckenny): can we have a numeric default value? null may do bad things
	};



	/* global libtess */

	// TODO(bckenny): more specific typing on key

	/**
	 * [PQHandleElem description]
	 * @constructor
	 * @struct
	 */
	libtess.PQHandleElem = function() {
	  // TODO(bckenny): if key could instead be an indexed into another store, makes heap storage a lot easier

	  /**
	   * [key description]
	   * @type {libtess.PQKey}
	   */
	  this.key = null;

	  /**
	   * [node description]
	   * @type {libtess.PQHandle}
	   */
	  this.node = 0;
	};


	/**
	 * Allocate a PQHandleElem array of size size. If oldArray is not null, its
	 * contents are copied to the beginning of the new array. The rest of the array
	 * is filled with new PQHandleElems.
	 *
	 * @param {?Array.<libtess.PQHandleElem>} oldArray [description].
	 * @param {number} size [description].
	 * @return {Array.<libtess.PQHandleElem>} [description].
	 */
	libtess.PQHandleElem.realloc = function(oldArray, size) {
	  var newArray = new Array(size);

	  // TODO(bckenny): better to reallocate array? or grow array?
	  var index = 0;
	  if (oldArray !== null) {
	    for (; index < oldArray.length; index++) {
	      newArray[index] = oldArray[index];
	    }
	  }

	  for (; index < size; index++) {
	    newArray[index] = new libtess.PQHandleElem();
	  }

	  return newArray;
	};



	/* global libtess */

	// TODO(bckenny): maybe just have these created inline as literals
	// (or unboxed directly - PQHandle is just an array index number)

	/**
	 * [PQNode description]
	 * @constructor
	 * @struct
	 */
	libtess.PQNode = function() {
	  /**
	   * [handle description]
	   * @type {libtess.PQHandle}
	   */
	  this.handle = 0;
	};


	/**
	 * Allocate a PQNode array of size size. If oldArray is not null, its contents
	 * are copied to the beginning of the new array. The rest of the array is
	 * filled with new PQNodes.
	 *
	 * @param {?Array.<libtess.PQNode>} oldArray [description].
	 * @param {number} size [description].
	 * @return {Array.<libtess.PQNode>} [description].
	 */
	libtess.PQNode.realloc = function(oldArray, size) {
	  var newArray = new Array(size);

	  // TODO(bckenny): better to reallocate array? or grow array?
	  var index = 0;
	  if (oldArray !== null) {
	    for (; index < oldArray.length; index++) {
	      newArray[index] = oldArray[index];
	    }
	  }

	  for (; index < size; index++) {
	    newArray[index] = new libtess.PQNode();
	  }

	  return newArray;
	};



	/* global libtess */

	// TODO(bckenny): preallocating arrays may actually be hurting us in sort
	// performance (esp if theres some undefs in there)

	/**
	 * [PriorityQ description]
	 * @constructor
	 * @struct
	 * @param {function(Object, Object): boolean} leq [description].
	 */
	libtess.PriorityQ = function(leq) {
	  /**
	   * [keys description]
	   * @private
	   * @type {Array.<libtess.PQKey>}
	   */
	  this.keys_ = libtess.PriorityQ.prototype.PQKeyRealloc_(null,
	      libtess.PriorityQ.INIT_SIZE_);

	  /**
	   * Array of indexes into this.keys_
	   * @private
	   * @type {Array.<number>}
	   */
	  this.order_ = null;

	  /**
	   * [size description]
	   * @private
	   * @type {number}
	   */
	  this.size_ = 0;

	  /**
	   * [max_ description]
	   * @private
	   * @type {number}
	   */
	  this.max_ = libtess.PriorityQ.INIT_SIZE_;

	  /**
	   * [initialized description]
	   * @private
	   * @type {boolean}
	   */
	  this.initialized_ = false;

	  // TODO(bckenny): leq was inlined by define in original, but appears to just
	  // be vertLeq, as passed. keep an eye on this as to why its not used.
	  /**
	   * [leq description]
	   * @private
	   * @type {function(libtess.PQKey, libtess.PQKey): boolean}
	   */
	  this.leq_ =
	      /** @type {function(libtess.PQKey, libtess.PQKey): boolean} */(leq);

	  /**
	   * [heap_ description]
	   * @private
	   * @type {libtess.PriorityQHeap}
	   */
	  this.heap_ = new libtess.PriorityQHeap(this.leq_);
	};


	/**
	 * [INIT_SIZE_ description]
	 * @private
	 * @const
	 * @type {number}
	 */
	libtess.PriorityQ.INIT_SIZE_ = 32;


	/**
	 * [deleteQ description]
	 */
	libtess.PriorityQ.prototype.deleteQ = function() {
	  // TODO(bckenny): unnecessary, I think.
	  this.heap_.deleteHeap();
	  this.heap_ = null;
	  this.order_ = null;
	  this.keys_ = null;
	  // NOTE(bckenny): nulled at callsite (sweep.donePriorityQ_)
	};


	/**
	 * [init description]
	 */
	libtess.PriorityQ.prototype.init = function() {
	  // TODO(bckenny): reuse. in theory, we don't have to empty this, as access is
	  // dictated by this.size_, but array.sort doesn't know that
	  this.order_ = [];

	  // Create an array of indirect pointers to the keys, so that
	  // the handles we have returned are still valid.
	  // TODO(bckenny): valid for when? it appears we can just store indexes into
	  // keys_, but what did this mean?
	  for (var i = 0; i < this.size_; i++) {
	    this.order_[i] = i;
	  }

	  // sort the indirect pointers in descending order of the keys themselves
	  // TODO(bckenny): make sure it's ok that keys[a] === keys[b] returns 1
	  // TODO(bckenny): unstable sort means we may get slightly different polys in
	  // different browsers, but only when passing in equal points
	  // TODO(bckenny): make less awkward closure?
	  var comparator = (function(keys, leq) {
	    return function(a, b) {
	      return leq(keys[a], keys[b]) ? 1 : -1;
	    };
	  })(this.keys_, this.leq_);
	  this.order_.sort(comparator);

	  this.max_ = this.size_;
	  this.initialized_ = true;
	  this.heap_.init();

	  // TODO(bckenny):
	  // #ifndef NDEBUG
	  if (libtess.DEBUG) {
	    var p = 0;
	    var r = p + this.size_ - 1;
	    for (i = p; i < r; ++i) {
	    }
	  }
	  // #endif
	};


	/**
	 * [insert description]
	 * @param {libtess.PQKey} keyNew [description].
	 * @return {libtess.PQHandle} [description].
	 */
	libtess.PriorityQ.prototype.insert = function(keyNew) {
	  // NOTE(bckenny): originally returned LONG_MAX as alloc failure signal. no
	  // longer does.
	  if (this.initialized_) {
	    return this.heap_.insert(keyNew);
	  }

	  var curr = this.size_;
	  if (++this.size_ >= this.max_) {
	    // If the heap overflows, double its size.
	    this.max_ *= 2;
	    this.keys_ =
	        libtess.PriorityQ.prototype.PQKeyRealloc_(this.keys_, this.max_);
	  }

	  this.keys_[curr] = keyNew;

	  // Negative handles index the sorted array.
	  return -(curr + 1);
	};


	/**
	 * Allocate a PQKey array of size size. If oldArray is not null, its
	 * contents are copied to the beginning of the new array. The rest of the array
	 * is filled with nulls.
	 *
	 * @private
	 * @param {?Array.<libtess.PQKey>} oldArray [description].
	 * @param {number} size [description].
	 * @return {Array.<(?libtess.PQKey)>} [description].
	 */
	libtess.PriorityQ.prototype.PQKeyRealloc_ = function(oldArray, size) {
	  // TODO(bckenny): double check return type. can we have ? there?
	  var newArray = new Array(size);

	  // TODO(bckenny): better to reallocate array? or grow array?
	  var index = 0;
	  if (oldArray !== null) {
	    for (; index < oldArray.length; index++) {
	      newArray[index] = oldArray[index];
	    }
	  }

	  for (; index < size; index++) {
	    newArray[index] = null;
	  }

	  return newArray;
	};

	// NOTE(bckenny): libtess.PriorityQ.keyLessThan_ is called nowhere in libtess
	// and isn't part of the public API.
	/* istanbul ignore next */
	/**
	 * Whether x is less than y according to this.leq_.
	 * @private
	 * @param {number} x
	 * @param {number} y
	 * @return {boolean}
	 */
	libtess.PriorityQ.prototype.keyLessThan_ = function(x, y) {
	  // NOTE(bckenny): was macro LT
	  var keyX = this.keys_[x];
	  var keyY = this.keys_[y];
	  return !this.leq_(keyY, keyX);
	};

	// NOTE(bckenny): libtess.PriorityQ.keyGreaterThan_ is called nowhere in libtess
	// and isn't part of the public API.
	/* istanbul ignore next */
	/**
	 * Whether x is greater than y according to this.leq_.
	 * @private
	 * @param {number} x
	 * @param {number} y
	 * @return {boolean}
	 */
	libtess.PriorityQ.prototype.keyGreaterThan_ = function(x, y) {
	  // NOTE(bckenny): was macro GT
	  var keyX = this.keys_[x];
	  var keyY = this.keys_[y];
	  return !this.leq_(keyX, keyY);
	};


	/**
	 * [extractMin description]
	 * @return {libtess.PQKey} [description].
	 */
	libtess.PriorityQ.prototype.extractMin = function() {
	  if (this.size_ === 0) {
	    return this.heap_.extractMin();
	  }

	  var sortMin = this.keys_[this.order_[this.size_ - 1]];
	  if (!this.heap_.isEmpty()) {
	    var heapMin = this.heap_.minimum();
	    if (this.leq_(heapMin, sortMin)) {
	      return this.heap_.extractMin();
	    }
	  }

	  do {
	    --this.size_;
	  } while (this.size_ > 0 && this.keys_[this.order_[this.size_ - 1]] === null);

	  return sortMin;
	};


	/**
	 * [minimum description]
	 * @return {libtess.PQKey} [description].
	 */
	libtess.PriorityQ.prototype.minimum = function() {
	  if (this.size_ === 0) {
	    return this.heap_.minimum();
	  }

	  var sortMin = this.keys_[this.order_[this.size_ - 1]];
	  if (!this.heap_.isEmpty()) {
	    var heapMin = this.heap_.minimum();
	    if (this.leq_(heapMin, sortMin)) {
	      return heapMin;
	    }
	  }

	  return sortMin;
	};

	// NOTE(bckenny): libtess.PriorityQ.isEmpty_ isn't called within libtess and
	// isn't part of the public API. For now, leaving in but ignoring for coverage.
	/* istanbul ignore next */
	/**
	 * Returns whether the priority queue is empty.
	 * @private
	 * @return {boolean}
	 */
	libtess.PriorityQ.prototype.isEmpty_ = function() {
	  return (this.size_ === 0) && this.heap_.isEmpty();
	};


	/**
	 * [remove description]
	 * @param {libtess.PQHandle} curr [description].
	 */
	libtess.PriorityQ.prototype.remove = function(curr) {
	  if (curr >= 0) {
	    this.heap_.remove(curr);
	    return;
	  }
	  curr = -(curr + 1);

	  this.keys_[curr] = null;
	  while (this.size_ > 0 && this.keys_[this.order_[this.size_ - 1]] === null) {
	    --this.size_;
	  }
	};



	/* global libtess */

	// TODO(bckenny): keys appear to always be GluVertex in this case?

	/**
	 * [PriorityQHeap description]
	 * @constructor
	 * @struct
	 * @param {function(libtess.PQKey, libtess.PQKey): boolean} leq [description].
	 */
	libtess.PriorityQHeap = function(leq) {
	  /**
	   * The heap itself. Active nodes are stored in the range 1..size. Each node
	   * stores only an index into handles.
	   * @private
	   * @type {Array.<libtess.PQNode>}
	   */
	  this.nodes_ = libtess.PQNode.realloc(null,
	      libtess.PriorityQHeap.INIT_SIZE_ + 1);

	  /**
	   * Each handle stores a key, plus a pointer back to the node which currently
	   * represents that key (ie. nodes[handles[i].node].handle == i).
	   * @private
	   * @type {Array.<libtess.PQHandleElem>}
	   */
	  this.handles_ = libtess.PQHandleElem.realloc(null,
	      libtess.PriorityQHeap.INIT_SIZE_ + 1);

	  // TODO(bckenny): size and max should probably be libtess.PQHandle for correct
	  // typing (see PriorityQ.js)
	  /**
	   * The size of the queue.
	   * @private
	   * @type {number}
	   */
	  this.size_ = 0;

	  /**
	   * The queue's current allocated space.
	   * @private
	   * @type {number}
	   */
	  this.max_ = libtess.PriorityQHeap.INIT_SIZE_;

	  /**
	   * The index of the next free hole in the handles array. Handle in that slot
	   * has next item in freeList in its node propert. If there are no holes,
	   * freeList === 0 and one at the end of handles must be use.
	   * @private
	   * @type {libtess.PQHandle}
	   */
	  this.freeList_ = 0;

	  /**
	   * Indicates that the heap has been initialized via init. If false, inserts
	   * are fast insertions at the end of a list. If true, all inserts will now be
	   * correctly ordered in the queue before returning.
	   * @private
	   * @type {boolean}
	   */
	  this.initialized_ = false;

	  // TODO(bckenny): leq was inlined by define in original, but appears to
	  // be vertLeq, as passed. Using injected version, but is it better just to
	  // manually inline?
	  /**
	   * [leq description]
	   * @private
	   * @type {function(libtess.PQKey, libtess.PQKey): boolean}
	   */
	  this.leq_ = leq;

	  // so that minimum returns null
	  this.nodes_[1].handle = 1;
	};


	/**
	 * [INIT_SIZE_ description]
	 * @private
	 * @const
	 * @type {number}
	 */
	libtess.PriorityQHeap.INIT_SIZE_ = 32;


	/**
	 * [deleteHeap description]
	 */
	libtess.PriorityQHeap.prototype.deleteHeap = function() {
	  // TODO(bckenny): unnecessary, I think.
	  this.handles_ = null;
	  this.nodes_ = null;
	  // NOTE(bckenny): nulled at callsite in PriorityQ.deleteQ
	};


	/**
	 * Initializing ordering of the heap. Must be called before any method other
	 * than insert is called to ensure correctness when removing or querying.
	 */
	libtess.PriorityQHeap.prototype.init = function() {
	  // This method of building a heap is O(n), rather than O(n lg n).
	  for (var i = this.size_; i >= 1; --i) {
	    this.floatDown_(i);
	  }

	  this.initialized_ = true;
	};


	/**
	 * Insert a new key into the heap.
	 * @param {libtess.PQKey} keyNew The key to insert.
	 * @return {libtess.PQHandle} A handle that can be used to remove the key.
	 */
	libtess.PriorityQHeap.prototype.insert = function(keyNew) {
	  var curr = ++this.size_;

	  // if the heap overflows, double its size.
	  if ((curr * 2) > this.max_) {
	    this.max_ *= 2;
	    this.nodes_ = libtess.PQNode.realloc(this.nodes_, this.max_ + 1);
	    this.handles_ = libtess.PQHandleElem.realloc(this.handles_, this.max_ + 1);
	  }

	  var free;
	  if (this.freeList_ === 0) {
	    free = curr;
	  } else {
	    free = this.freeList_;
	    this.freeList_ = this.handles_[free].node;
	  }

	  this.nodes_[curr].handle = free;
	  this.handles_[free].node = curr;
	  this.handles_[free].key = keyNew;

	  if (this.initialized_) {
	    this.floatUp_(curr);
	  }

	  return free;
	};


	/**
	 * @return {boolean} Whether the heap is empty.
	 */
	libtess.PriorityQHeap.prototype.isEmpty = function() {
	  return this.size_ === 0;
	};


	/**
	 * Returns the minimum key in the heap. If the heap is empty, null will be
	 * returned.
	 * @return {libtess.PQKey} [description].
	 */
	libtess.PriorityQHeap.prototype.minimum = function() {
	  return this.handles_[this.nodes_[1].handle].key;
	};


	/**
	 * Removes the minimum key from the heap and returns it. If the heap is empty,
	 * null will be returned.
	 * @return {libtess.PQKey} [description].
	 */
	libtess.PriorityQHeap.prototype.extractMin = function() {
	  var n = this.nodes_;
	  var h = this.handles_;
	  var hMin = n[1].handle;
	  var min = h[hMin].key;

	  if (this.size_ > 0) {
	    n[1].handle = n[this.size_].handle;
	    h[n[1].handle].node = 1;

	    h[hMin].key = null;
	    h[hMin].node = this.freeList_;
	    this.freeList_ = hMin;

	    if (--this.size_ > 0) {
	      this.floatDown_(1);
	    }
	  }

	  return min;
	};


	/**
	 * Remove key associated with handle hCurr (returned from insert) from heap.
	 * @param {libtess.PQHandle} hCurr [description].
	 */
	libtess.PriorityQHeap.prototype.remove = function(hCurr) {
	  var n = this.nodes_;
	  var h = this.handles_;

	  var curr = h[hCurr].node;
	  n[curr].handle = n[this.size_].handle;
	  h[n[curr].handle].node = curr;

	  if (curr <= --this.size_) {
	    if (curr <= 1 ||
	        this.leq_(h[n[curr >> 1].handle].key, h[n[curr].handle].key)) {

	      this.floatDown_(curr);
	    } else {
	      this.floatUp_(curr);
	    }
	  }

	  h[hCurr].key = null;
	  h[hCurr].node = this.freeList_;
	  this.freeList_ = hCurr;
	};


	/**
	 * [floatDown_ description]
	 * @private
	 * @param {libtess.PQHandle} curr [description].
	 */
	libtess.PriorityQHeap.prototype.floatDown_ = function(curr) {
	  var n = this.nodes_;
	  var h = this.handles_;

	  var hCurr = n[curr].handle;
	  for (;;) {
	    // The children of node i are nodes 2i and 2i+1.
	    // set child to the index of the child with the minimum key
	    var child = curr << 1;
	    if (child < this.size_ &&
	        this.leq_(h[n[child + 1].handle].key, h[n[child].handle].key)) {

	      ++child;
	    }

	    var hChild = n[child].handle;
	    if (child > this.size_ || this.leq_(h[hCurr].key, h[hChild].key)) {
	      n[curr].handle = hCurr;
	      h[hCurr].node = curr;
	      break;
	    }
	    n[curr].handle = hChild;
	    h[hChild].node = curr;
	    curr = child;
	  }
	};


	/**
	 * [floatUp_ description]
	 * @private
	 * @param {libtess.PQHandle} curr [description].
	 */
	libtess.PriorityQHeap.prototype.floatUp_ = function(curr) {
	  var n = this.nodes_;
	  var h = this.handles_;

	  var hCurr = n[curr].handle;
	  for (;;) {
	    var parent = curr >> 1;
	    var hParent = n[parent].handle;
	    if (parent === 0 || this.leq_(h[hParent].key, h[hCurr].key)) {
	      n[curr].handle = hCurr;
	      h[hCurr].node = curr;
	      break;
	    }

	    n[curr].handle = hParent;
	    h[hParent].node = curr;
	    curr = parent;
	  }
	};


	/* global libtess */

	// TODO(bckenny): apparently only visible outside of sweep for debugging routines.
	// find out if we can hide

	/**
	 * For each pair of adjacent edges crossing the sweep line, there is
	 * an ActiveRegion to represent the region between them. The active
	 * regions are kept in sorted order in a dynamic dictionary. As the
	 * sweep line crosses each vertex, we update the affected regions.
	 * @constructor
	 * @struct
	 */
	libtess.ActiveRegion = function() {
	  // TODO(bckenny): I *think* eUp and nodeUp could be passed in as constructor params

	  /**
	   * The upper edge of the region, directed right to left
	   * @type {libtess.GluHalfEdge}
	   */
	  this.eUp = null;

	  /**
	   * Dictionary node corresponding to eUp edge.
	   * @type {libtess.DictNode}
	   */
	  this.nodeUp = null;

	  /**
	   * Used to determine which regions are inside the polygon.
	   * @type {number}
	   */
	  this.windingNumber = 0;

	  /**
	   * Whether this region is inside the polygon.
	   * @type {boolean}
	   */
	  this.inside = false;

	  /**
	   * Marks fake edges at t = +/-infinity.
	   * @type {boolean}
	   */
	  this.sentinel = false;

	  /**
	   * Marks regions where the upper or lower edge has changed, but we haven't
	   * checked whether they intersect yet.
	   * @type {boolean}
	   */
	  this.dirty = false;

	  /**
	   * marks temporary edges introduced when we process a "right vertex" (one
	   * without any edges leaving to the right)
	   * @type {boolean}
	   */
	  this.fixUpperEdge = false;
	};

	/**
	 * Returns the ActiveRegion below this one.
	 * @return {libtess.ActiveRegion}
	 */
	libtess.ActiveRegion.prototype.regionBelow = function() {
	  return this.nodeUp.getPredecessor().getKey();
	};

	/**
	 * Returns the ActiveRegion above this one.
	 * @return {libtess.ActiveRegion}
	 */
	libtess.ActiveRegion.prototype.regionAbove = function() {
	  return this.nodeUp.getSuccessor().getKey();
	};

	/* global libtess, module */

	/**
	 * node.js export for non-compiled source
	 */
	if (true) {
	  module.exports = libtess;
	}


/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

	var AbstractPrimitive = __webpack_require__(146);
	var BoundingBox = __webpack_require__(78);
	var Location = __webpack_require__(28);
	var PickedObject = __webpack_require__(87);
	var Position = __webpack_require__(47);
	var SurfacePolygon = __webpack_require__(166);
	var Vec3 = __webpack_require__(35);
	var WWMath = __webpack_require__(36);
	var cdt2d = __webpack_require__(169);
	var PrimitiveUtils = __webpack_require__(154);
	var Utils = __webpack_require__(144);
	var WebGL = __webpack_require__(155);
	// var TriangleNormal = require('triangle-normal');
	// var cleanPslg = require('clean-pslg');
	// var pslg2poly = require('pslg-to-poly');

	var Polygon = function (boundaries, attributes, highlightAttributes) {
	    this._boundaries = boundaries;
	    AbstractPrimitive.call(this, attributes, highlightAttributes);
	    this._extrude = true;
	    this.height = 0;
	    // this.simplifyPolygon();
	};

	Polygon.prototype = Object.create(AbstractPrimitive.prototype);

	Polygon.prototype.calculateGreatCircleBoundaries = function(dc, boundaries) {
	    var self = this;
	    return boundaries.map(function(circle) {
	        return self.makeTessellatedPositions(dc, circle);
	    });
	};

	Polygon.prototype.positionsAsArray = function () {
	    return this._boundaries[0];
	};

	Polygon.prototype.makeSurfacePrimitive = function () {
	    var surfacePolygon = new SurfacePolygon(this._boundaries, this._attributes);
	    surfacePolygon._highlightAttributes = this._highlightAttributes;
	    return surfacePolygon;
	};

	Polygon.prototype.doMakeOrderedRenderable = function (dc) {
	    // A null reference position is a signal that there are no boundaries to render.
	    if (!this.referencePosition) {
	        return null;
	    }

	    if (!this.activeAttributes.drawInterior && !this.activeAttributes.drawOutline) {
	        return null;
	    }

	    var elevationAtReferencePoint = this.getElevationAtReferencePoint(dc);

	    // See if the current shape data can be re-used.
	    if (this.currentData.boundaryPoints &&
	        elevationAtReferencePoint === this.elevationAtReferencePoint
	    ) return this;

	    this.elevationAtReferencePoint = elevationAtReferencePoint;


	    var currentData = this.currentData;

	    // Set the transformation matrix to correspond to the reference position.
	    var refPt = currentData.referencePoint;
	    dc.surfacePointForMode(
	        this.referencePosition.latitude,
	        this.referencePosition.longitude,
	        this.referencePosition.altitude,
	        this._altitudeMode,
	        refPt
	    );

	    currentData.transformationMatrix.setToTranslation(refPt[0], refPt[1], refPt[2]);
	    currentData.greatCircleBoundaries = this.calculateGreatCircleBoundaries(dc, this._boundaries);
	    currentData.boundaryPoints = this.computeBoundaryPoints(dc, currentData.greatCircleBoundaries);
	    currentData.originalBoundaries = this.computeBoundaryPoints(dc, this._boundaries);

	    currentData.capTriangles = this.triangulate(dc,  currentData.greatCircleBoundaries, this.referencePosition.altitude);
	    currentData.capTriangles = currentData.capTriangles.map(mapper);
	    currentData.capTriangles = WebGL.pointsAsFloat32array(currentData.capTriangles, 3);
	    // currentData.capNormals = this.createNormalsBuffer(currentData.capTriangles);


	    currentData.sidesBuffer = this.makeSidesBuffer(currentData.greatCircleBoundaries[0].length - 1);

	    currentData.drawInterior = this.activeAttributes.drawInterior; // remember for validation
	    this.resetExpiration(currentData);
	    currentData.fillVbo = true; // causes VBOs to be reloaded

	    if (!currentData.extent) {
	        currentData.extent = new BoundingBox();
	    }

	    currentData.extent.setToPoints(currentData.sidesBuffer);

	    currentData.extent.translate(currentData.referencePoint);

	    return this;

	    function mapper(p) {
	        return dc.surfacePointForMode(
	            p.latitude, p.longitude, p.altitude,
	            WorldWind.RELATIVE_TO_GROUND,
	            new Vec3(0,0,0)
	        ).subtract(refPt);
	    }
	};

	// Polygon.prototype.simplifyPolygon = function () {
	//     var outer = this.positionsAsArray();
	//     var last = outer.pop();
	//     var pts = outer.map(Utils.array);
	//     var edges = outer.map(function (p, i) {
	//         return [i, i === outer.length -1 ? 0 : i + 1];
	//     });
	//     if(!cleanPslg(pts, edges)) {
	//         outer.push(last);
	//         return;
	//     }
	//     var polygon = pslg2poly(pts, edges);
	//     polygon[0].push(polygon[0][0]);
	//     this._boundaries[0] = polygon[0].map(Utils.position);
	// };
	//
	// Polygon.prototype.createNormalsBuffer = function(t) {
	//     var n = [0, 0, 0];
	//     var r = new Float32Array(t.length);
	//     for (var i = 0; i < t.length / 9; i++) {
	//         var x = i * 9;
	//         TriangleNormal(
	//             t[x + 0], t[x + 1], t[x + 2],
	//             t[x + 3], t[x + 4], t[x + 5],
	//             t[x + 6], t[x + 7], t[x + 8],
	//             n
	//         );
	//         r[x + 0] = r[x + 3] = r[x + 6] = n[0];
	//         r[x + 1] = r[x + 4] = r[x + 7] = n[1];
	//         r[x + 2] = r[x + 5] = r[x + 8] = n[2];
	//     }
	//     return r;
	// };

	Polygon.prototype.extraPoints = function(dc, altitude) {
	    var minLat=1e3, minLon=1e3, maxLat=-1e3, maxLon=-1e3;

	    this._boundaries[0].forEach(function(pt) {
	        minLat > pt.latitude && (minLat = pt.latitude);
	        maxLat < pt.latitude && (maxLat = pt.latitude);
	        minLon > pt.longitude && (minLon = pt.longitude);
	        maxLon < pt.longitude && (maxLon = pt.longitude);
	    });

	    var points = [];
	    for (var i = 1; i < 1 + Math.floor(maxLat - minLat) * 2; i++) {
	        for (var j = 1; j < 1 + Math.floor(maxLon - minLon) * 2; j++) {
	            points.push([
	                WWMath.interpolate(0.05*i, minLat, maxLat),
	                WWMath.interpolate(0.05*j, minLon, maxLon),
	                altitude
	            ]);
	        }
	    }
	    return points;

	};

	Polygon.prototype.computeBoundaryPoints = function (dc, boundaries) {
	    var eyeDistSquared = Number.MAX_VALUE,
	        eyePoint = dc.navigatorState.eyePoint,
	        boundaryPoints = [],
	        stride = this._extrude ? 6 : 3,
	        pt = new Vec3(0, 0, 0),
	        numBoundaryPoints, pos, k, dSquared;

	    for (var b = 0; b < boundaries.length; b++) {
	        numBoundaryPoints = (this._extrude ? 2 : 1) * boundaries[b].length;
	        boundaryPoints[b] = new Float32Array(numBoundaryPoints * 3);

	        for (var i = 0, len = boundaries[b].length; i < len; i++) {
	            pos = boundaries[b][i];

	            dc.surfacePointForMode(pos.latitude, pos.longitude, pos.altitude, this.altitudeMode, pt);
	            dSquared = pt.distanceToSquared(eyePoint);
	            if (dSquared < eyeDistSquared) {
	                eyeDistSquared = dSquared;
	            }
	            pt.subtract(this.currentData.referencePoint);

	            k = stride * i;
	            boundaryPoints[b][k] = pt[0];
	            boundaryPoints[b][k + 1] = pt[1];
	            boundaryPoints[b][k + 2] = pt[2];

	            if (this._extrude) {
	                dc.surfacePointForMode(pos.latitude, pos.longitude, 0, this.altitudeMode, pt);
	                dSquared = pt.distanceToSquared(eyePoint);
	                if (dSquared < eyeDistSquared) {
	                    eyeDistSquared = dSquared;
	                }
	                pt.subtract(this.currentData.referencePoint);

	                boundaryPoints[b][k + 3] = pt[0];
	                boundaryPoints[b][k + 4] = pt[1];
	                boundaryPoints[b][k + 5] = pt[2];
	            }
	        }
	    }

	    this.currentData.eyeDistance = Math.sqrt(eyeDistSquared);

	    return boundaryPoints;
	};

	Polygon.prototype.triangulate = function (dc, boundaryPoints, altitude) {
	    var arrays = boundaryPoints.map(function(singleArray) {
	        var array = singleArray.map(pointMapper);
	        array.pop(); // remove last (enclosing) point
	        return array;
	    });

	    var points = arrays.reduce(function(acc, pointsArray) {
	        return acc.concat(pointsArray);
	    }, []);

	    points = points.concat(this.extraPoints(dc, altitude));

	    var edges = [];
	    var offset = 0;
	    for (var arr = 0; arr < arrays.length; arr++){
	        var ring = arrays[arr];
	        for (var i = 0; i < ring.length; i++) {
	            var next = i === ring.length - 1 ? 0 : i + 1;
	            edges.push([i, next]);
	        }
	        offset += ring.length;
	    }

	    var triangles = cdt2d(points, edges, {
	        exterior: false
	    });

	    var array = [];

	    triangles.forEach(function(triangle) {
	        triangle.forEach(function(pointIndex) {
	            var p = points[pointIndex];
	            array.push(new Position(p[0], p[1], p[2]));
	        });
	    });

	    return array;

	    function addEdges(ring) {
	        for (var i = 0; i < ring.length; i++) {
	            edges.push([ring[i], ring[i === ring.length - 1 ? 0 : i + 1]]);
	        }
	    }

	    function pointMapper(pt) {
	        return [pt.latitude, pt.longitude, pt.altitude];
	    }
	};

	Polygon.prototype.makeTessellatedPositions = function (dc, points) {
	    var tessellatedPositions = [],
	        ptA = new Vec3(0, 0, 0),
	        ptB = new Vec3(0, 0, 0),
	        posA = points[0],
	        posB;
	    var self = this;
	    posA.altitude += self.heightFactor;
	    tessellatedPositions.push(posA);
	    for (var i = 1, len = points.length; i < len; i++) {
	        posB = points[i];
	        posB.altitude += self.heightFactor;
	        this.makeSegment(dc, posA, posB, ptA, ptB, tessellatedPositions);
	        posA = posB;
	        ptA.copy(ptB);
	    }
	    return tessellatedPositions;
	};

	Polygon.prototype.mustDrawVerticals = function (dc) {
	    return this._extrude
	        && this.activeAttributes.drawOutline
	        && this.activeAttributes.drawVerticals
	        && this.altitudeMode !== WorldWind.CLAMP_TO_GROUND;
	};

	Polygon.prototype.doRenderOrdered = function (dc) {
	    var currentData = this.currentData,
	        pickColor;

	    if (dc.pickingMode) {
	        pickColor = dc.uniquePickColor();
	    }

	    // Draw the cap if the interior requested and we were able to tessellate the polygon.
	    if (this.activeAttributes.drawInterior &&
	        currentData.capTriangles &&
	        currentData.capTriangles.length > 0) {
	        this.drawCap(dc, pickColor);
	    }

	    if (this._extrude && this.activeAttributes.drawInterior) {
	        this.drawSides(dc, pickColor);
	    }

	    if (this.activeAttributes.drawOutline) {
	        //this.drawOutline(dc, pickColor);
	    }

	    currentData.fillVbo = false;

	    if (dc.pickingMode) {
	        var po = new PickedObject(pickColor, this.pickDelegate ? this.pickDelegate : this, null, dc.currentLayer, false);
	        dc.resolvePick(po);
	    }

	   // this.currentData.extent.render(dc)
	};

	Polygon.prototype.drawCap = function (dc, pickColor) {
	    var gl = dc.currentGlContext,
	        program = dc.currentProgram,
	        currentData = this.currentData,
	        numCapVertices = currentData.capTriangles.length / 3;

	    this.applyMvpMatrix(dc);
	    this.loadShaderVariables(dc, this.activeAttributes.interiorColor, pickColor);

	    WebGL.createOrLoadVBO(dc, this.currentData, 'capVboPositionsCacheKey', 'capTriangles');
	    gl.vertexAttribPointer(program.vertexPointLocation, 3, gl.FLOAT, false, 0, 0);

	    // if (!dc.pickingMode) {
	    //     WebGL.createOrLoadVBO(dc, this.currentData, 'capVboNormalsCacheKey', 'capNormals');
	    //     gl.enableVertexAttribArray(program.normalVectorLocation);
	    //     gl.vertexAttribPointer(program.normalVectorLocation, 3, gl.FLOAT, true, 12, 0);
	    //     program.loadApplyLighting(gl, true);
	    //     program.loadModelviewInverse(gl, dc.navigatorState.modelviewNormalTransform);
	    // }

	    gl.drawArrays(
	        // gl.LINE_STRIP
	        gl.TRIANGLES
	        , 0, numCapVertices);
	};

	Polygon.prototype.loadShaderVariables = function(dc, color, pickColor) {
	    WebGL.loadShaderVariables(dc, color, pickColor, this.layer.opacity);
	};

	Polygon.prototype.makeCapBufferWithNormals = function () {
	    var currentData = this.currentData,
	        normal = currentData.capNormal,
	        numFloatsIn = 3,
	        numFloatsOut = numFloatsIn + 3,
	        numVertices = currentData.capTriangles.length / numFloatsIn,
	        bufferIn = currentData.capTriangles,
	        bufferOut = new Float32Array(numVertices * numFloatsOut),
	        k = 0;

	    for (var i = 0; i < numVertices; i++) {
	        for (var j = 0; j < numFloatsIn; j++) {
	            bufferOut[k++] = bufferIn[i * numFloatsIn + j];
	        }

	        bufferOut[k++] = normal[0];
	        bufferOut[k++] = normal[1];
	        bufferOut[k++] = normal[2];
	    }

	    return bufferOut;
	};

	Polygon.prototype.drawSides = function (dc, pickColor) {
	    var gl = dc.currentGlContext,
	        program = dc.currentProgram,
	        currentData = this.currentData,
	        refreshBuffers = currentData.fillVbo,
	        applyLighting = this.activeAttributes.applyLighting,
	        numFloatsPerVertex = 3  + (applyLighting ? 3 : 0),
	        numBytesPerVertex = 4 * numFloatsPerVertex,
	        vboId, textureBound, sidesBuffer, numSides;

	    numSides = 0;
	    for (var b = 0; b < currentData.boundaryPoints.length; b++) { // for each boundary}
	        numSides += (currentData.boundaryPoints[b].length / 6) - 1; // 6 floats per boundary point: top + bottom
	    }

	    if (!currentData.sidesVboCacheKey) {
	        currentData.sidesVboCacheKey = dc.gpuResourceCache.generateCacheKey();
	    }

	    vboId = dc.gpuResourceCache.resourceForKey(currentData.sidesVboCacheKey);
	    if (!vboId || refreshBuffers) {
	        //sidesBuffer = this.makeSidesBuffer(numSides);
	        currentData.numSideVertices = currentData.sidesBuffer.length / numFloatsPerVertex;

	        if (!vboId) {
	            vboId = gl.createBuffer();
	        }

	        dc.gpuResourceCache.putResource(currentData.sidesVboCacheKey, vboId, currentData.sidesBuffer.length * 4);
	        gl.bindBuffer(gl.ARRAY_BUFFER, vboId);
	        gl.bufferData(gl.ARRAY_BUFFER, currentData.sidesBuffer, gl.STATIC_DRAW);
	        dc.frameStatistics.incrementVboLoadCount(1);



	        currentData.groundPoints = new Float32Array(currentData.numSideVertices);
	        for (var i = 0; i <= currentData.numSideVertices / 6; i++) {
	            currentData.groundPoints[i*6 + 0] = 1; // 0
	            currentData.groundPoints[i*6 + 1] = 0; // 1
	            currentData.groundPoints[i*6 + 2] = 1; // 2

	            currentData.groundPoints[i*6 + 3] = 0; // 1
	            currentData.groundPoints[i*6 + 4] = 0; // 3
	            currentData.groundPoints[i*6 + 5] = 1; // 2
	        }

	    } else {
	        gl.bindBuffer(gl.ARRAY_BUFFER, vboId);
	    }



	    this.loadShaderVariables(dc, this.activeAttributes.interiorColor, pickColor);


	    program.loadTextureEnabled(gl, false);

	    if (applyLighting && !dc.pickingMode) {
	        program.loadApplyLighting(gl, true);
	        gl.enableVertexAttribArray(program.normalVectorLocation);
	        gl.vertexAttribPointer(program.normalVectorLocation, 3, gl.FLOAT, false, numBytesPerVertex, numBytesPerVertex - 12);
	    } else {
	        program.loadApplyLighting(gl, false);
	    }

	    gl.vertexAttribPointer(program.vertexPointLocation, 3, gl.FLOAT, false, numBytesPerVertex, 0);
	    // gl.drawArrays(gl.TRIANGLES, 0, currentData.numSideVertices);

	    gl.enableVertexAttribArray(dc.currentProgram.groundPointsLocation);
	    WebGL.createOrLoadVBO(dc, this.currentData, 'sidesGroundPointsVBO', 'groundPoints');
	    gl.vertexAttribPointer(program.groundPointsLocation, 1, gl.FLOAT, false, 0, 0);


	    gl.drawArrays(gl.TRIANGLES, 0, currentData.numSideVertices);
	};

	Polygon.prototype.makeSidesBuffer = function (numSides) {
	    var currentData = this.currentData,
	        applyLighting = this.activeAttributes.applyLighting,
	        numFloatsPerVertex = 3 + (applyLighting ? 3 : 0),
	        sidesBuffer, sidesBufferIndex, numBufferFloats, v0, v1, v2, v3, t0, t1, t2, t3;

	    numBufferFloats = numSides * 2 * 3 * numFloatsPerVertex; // 2 triangles per side, 3 vertices per triangle
	    sidesBuffer = new Float32Array(numBufferFloats);
	    sidesBufferIndex = 0;

	    v0 = new Vec3(0, 0, 0);
	    v1 = new Vec3(0, 0, 0);
	    v2 = new Vec3(0, 0, 0);
	    v3 = new Vec3(0, 0, 0);


	    t0 = t1 = t2 = t3 = null;


	    for (var b = 0; b < currentData.boundaryPoints.length; b++) { // for each boundary}
	        var boundaryPoints = currentData.boundaryPoints[b],
	            sideNormal;

	        for (var i = 0; i < boundaryPoints.length - 6; i += 6) {
	            v0[0] = boundaryPoints[i];
	            v0[1] = boundaryPoints[i + 1];
	            v0[2] = boundaryPoints[i + 2];

	            v1[0] = boundaryPoints[i + 3];
	            v1[1] = boundaryPoints[i + 4];
	            v1[2] = boundaryPoints[i + 5];

	            v2[0] = boundaryPoints[i + 6];
	            v2[1] = boundaryPoints[i + 7];
	            v2[2] = boundaryPoints[i + 8];

	            v3[0] = boundaryPoints[i + 9];
	            v3[1] = boundaryPoints[i + 10];
	            v3[2] = boundaryPoints[i + 11];

	            sideNormal = applyLighting ? Vec3.computeTriangleNormal(v0, v1, v2) : null;

	            // First triangle.
	            this.addVertexToBuffer(v0, t0, sideNormal, sidesBuffer, sidesBufferIndex);
	            sidesBufferIndex += numFloatsPerVertex;

	            this.addVertexToBuffer(v1, t1, sideNormal, sidesBuffer, sidesBufferIndex);
	            sidesBufferIndex += numFloatsPerVertex;

	            this.addVertexToBuffer(v2, t2, sideNormal, sidesBuffer, sidesBufferIndex);
	            sidesBufferIndex += numFloatsPerVertex;

	            // Second triangle.
	            this.addVertexToBuffer(v1, t1, sideNormal, sidesBuffer, sidesBufferIndex);
	            sidesBufferIndex += numFloatsPerVertex;

	            this.addVertexToBuffer(v3, t3, sideNormal, sidesBuffer, sidesBufferIndex);
	            sidesBufferIndex += numFloatsPerVertex;

	            this.addVertexToBuffer(v2, t2, sideNormal, sidesBuffer, sidesBufferIndex);
	            sidesBufferIndex += numFloatsPerVertex;
	        }
	    }

	    return sidesBuffer;
	};

	Polygon.prototype.addVertexToBuffer = function (v, texCoord, normal, buffer, bufferIndex) {
	    buffer[bufferIndex++] = v[0];
	    buffer[bufferIndex++] = v[1];
	    buffer[bufferIndex++] = v[2];

	    if (texCoord) {
	        buffer[bufferIndex++] = texCoord[0];
	        buffer[bufferIndex++] = texCoord[1];
	    }

	    if (normal) {
	        buffer[bufferIndex++] = normal[0];
	        buffer[bufferIndex++] = normal[1];
	        buffer[bufferIndex] = normal[2];
	    }
	};

	Polygon.prototype.drawOutline = function (dc, pickColor) {
	    var gl = dc.currentGlContext,
	        program = dc.currentProgram,
	        currentData = this.currentData,
	        refreshBuffers = currentData.fillVbo,
	        numBoundaryPoints, vboId, stride, nPts;

	    program.loadTextureEnabled(gl, false);
	    program.loadApplyLighting(gl, false);


	    gl.disableVertexAttribArray(program.vertexTexCoordLocation); // we're not texturing the outline

	    if (this.activeAttributes.applyLighting) {
	        gl.disableVertexAttribArray(program.normalVectorLocation); // we're not lighting the outline
	    }

	    if (!currentData.boundaryVboCacheKeys) {
	        this.currentData.boundaryVboCacheKeys = [];
	    }

	    // Make the outline stand out from the interior.
	    this.applyMvpMatrix(dc);

	    program.loadTextureEnabled(gl, false);
	    gl.disableVertexAttribArray(program.vertexTexCoordLocation);

	    for (var b = 0; b < currentData.boundaryPoints.length; b++) { // for each boundary}
	        numBoundaryPoints = currentData.boundaryPoints[b].length / 3;

	        if (!currentData.boundaryVboCacheKeys[b]) {
	            currentData.boundaryVboCacheKeys[b] = dc.gpuResourceCache.generateCacheKey();
	        }

	        vboId = dc.gpuResourceCache.resourceForKey(currentData.boundaryVboCacheKeys[b]);
	        if (!vboId) {
	            vboId = gl.createBuffer();
	            dc.gpuResourceCache.putResource(currentData.boundaryVboCacheKeys[b], vboId, numBoundaryPoints * 12);
	            refreshBuffers = true;
	        }

	        gl.bindBuffer(gl.ARRAY_BUFFER, vboId);
	        if (refreshBuffers) {
	            var vboData = this._extrude ? currentData.boundaryPoints[b].map(function(value, index){
	                return (index +1) % 6 === 0 ? 0 : value; // set every second point elevation to zero(on ground)
	            }) : currentData.boundaryPoints[b];
	            gl.bufferData(gl.ARRAY_BUFFER, vboData, gl.STATIC_DRAW);
	            dc.frameStatistics.incrementVboLoadCount(1);
	        }

	        this.loadShaderVariables(dc, this.activeAttributes.outlineColor, pickColor);

	        gl.lineWidth(this.activeAttributes.outlineWidth);

	        if (this._extrude) {
	            stride = 24;
	            nPts = numBoundaryPoints / 2;
	        } else {
	            stride = 12;
	            nPts = numBoundaryPoints;
	        }

	        gl.vertexAttribPointer(program.vertexPointLocation, 3, gl.FLOAT, false, stride, 0);
	        gl.drawArrays(gl.LINE_STRIP, 0, nPts);

	        if (this.mustDrawVerticals(dc)) {

	            gl.vertexAttribPointer(program.vertexPointLocation, 3, gl.FLOAT, false, 0, 0);
	            gl.drawArrays(gl.LINES, 0, numBoundaryPoints - 2);
	        }
	    }
	};

	module.exports = Polygon;

/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict'

	var monotoneTriangulate = __webpack_require__(170)
	var makeIndex = __webpack_require__(178)
	var delaunayFlip = __webpack_require__(179)
	var filterTriangulation = __webpack_require__(181)

	module.exports = cdt2d

	function canonicalizeEdge(e) {
	  return [Math.min(e[0], e[1]), Math.max(e[0], e[1])]
	}

	function compareEdge(a, b) {
	  return a[0]-b[0] || a[1]-b[1]
	}

	function canonicalizeEdges(edges) {
	  return edges.map(canonicalizeEdge).sort(compareEdge)
	}

	function getDefault(options, property, dflt) {
	  if(property in options) {
	    return options[property]
	  }
	  return dflt
	}

	function cdt2d(points, edges, options) {

	  if(!Array.isArray(edges)) {
	    options = edges || {}
	    edges = []
	  } else {
	    options = options || {}
	    edges = edges || []
	  }

	  //Parse out options
	  var delaunay = !!getDefault(options, 'delaunay', true)
	  var interior = !!getDefault(options, 'interior', true)
	  var exterior = !!getDefault(options, 'exterior', true)
	  var infinity = !!getDefault(options, 'infinity', false)

	  //Handle trivial case
	  if((!interior && !exterior) || points.length === 0) {
	    return []
	  }

	  //Construct initial triangulation
	  var cells = monotoneTriangulate(points, edges)

	  //If delaunay refinement needed, then improve quality by edge flipping
	  if(delaunay || interior !== exterior || infinity) {

	    //Index all of the cells to support fast neighborhood queries
	    var triangulation = makeIndex(points.length, canonicalizeEdges(edges))
	    for(var i=0; i<cells.length; ++i) {
	      var f = cells[i]
	      triangulation.addTriangle(f[0], f[1], f[2])
	    }

	    //Run edge flipping
	    if(delaunay) {
	      delaunayFlip(points, triangulation)
	    }

	    //Filter points
	    if(!exterior) {
	      return filterTriangulation(triangulation, -1)
	    } else if(!interior) {
	      return filterTriangulation(triangulation,  1, infinity)
	    } else if(infinity) {
	      return filterTriangulation(triangulation, 0, infinity)
	    } else {
	      return triangulation.cells()
	    }
	    
	  } else {
	    return cells
	  }
	}


/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict'

	var bsearch = __webpack_require__(171)
	var orient = __webpack_require__(172)[3]

	var EVENT_POINT = 0
	var EVENT_END   = 1
	var EVENT_START = 2

	module.exports = monotoneTriangulate

	//A partial convex hull fragment, made of two unimonotone polygons
	function PartialHull(a, b, idx, lowerIds, upperIds) {
	  this.a = a
	  this.b = b
	  this.idx = idx
	  this.lowerIds = lowerIds
	  this.upperIds = upperIds
	}

	//An event in the sweep line procedure
	function Event(a, b, type, idx) {
	  this.a    = a
	  this.b    = b
	  this.type = type
	  this.idx  = idx
	}

	//This is used to compare events for the sweep line procedure
	// Points are:
	//  1. sorted lexicographically
	//  2. sorted by type  (point < end < start)
	//  3. segments sorted by winding order
	//  4. sorted by index
	function compareEvent(a, b) {
	  var d =
	    (a.a[0] - b.a[0]) ||
	    (a.a[1] - b.a[1]) ||
	    (a.type - b.type)
	  if(d) { return d }
	  if(a.type !== EVENT_POINT) {
	    d = orient(a.a, a.b, b.b)
	    if(d) { return d }
	  }
	  return a.idx - b.idx
	}

	function testPoint(hull, p) {
	  return orient(hull.a, hull.b, p)
	}

	function addPoint(cells, hulls, points, p, idx) {
	  var lo = bsearch.lt(hulls, p, testPoint)
	  var hi = bsearch.gt(hulls, p, testPoint)
	  for(var i=lo; i<hi; ++i) {
	    var hull = hulls[i]

	    //Insert p into lower hull
	    var lowerIds = hull.lowerIds
	    var m = lowerIds.length
	    while(m > 1 && orient(
	        points[lowerIds[m-2]],
	        points[lowerIds[m-1]],
	        p) > 0) {
	      cells.push(
	        [lowerIds[m-1],
	         lowerIds[m-2],
	         idx])
	      m -= 1
	    }
	    lowerIds.length = m
	    lowerIds.push(idx)

	    //Insert p into upper hull
	    var upperIds = hull.upperIds
	    var m = upperIds.length
	    while(m > 1 && orient(
	        points[upperIds[m-2]],
	        points[upperIds[m-1]],
	        p) < 0) {
	      cells.push(
	        [upperIds[m-2],
	         upperIds[m-1],
	         idx])
	      m -= 1
	    }
	    upperIds.length = m
	    upperIds.push(idx)
	  }
	}

	function findSplit(hull, edge) {
	  var d
	  if(hull.a[0] < edge.a[0]) {
	    d = orient(hull.a, hull.b, edge.a)
	  } else {
	    d = orient(edge.b, edge.a, hull.a)
	  }
	  if(d) { return d }
	  if(edge.b[0] < hull.b[0]) {
	    d = orient(hull.a, hull.b, edge.b)
	  } else {
	    d = orient(edge.b, edge.a, hull.b)
	  }
	  return d || hull.idx - edge.idx
	}

	function splitHulls(hulls, points, event) {
	  var splitIdx = bsearch.le(hulls, event, findSplit)
	  var hull = hulls[splitIdx]
	  var upperIds = hull.upperIds
	  var x = upperIds[upperIds.length-1]
	  hull.upperIds = [x]
	  hulls.splice(splitIdx+1, 0,
	    new PartialHull(event.a, event.b, event.idx, [x], upperIds))
	}


	function mergeHulls(hulls, points, event) {
	  //Swap pointers for merge search
	  var tmp = event.a
	  event.a = event.b
	  event.b = tmp
	  var mergeIdx = bsearch.eq(hulls, event, findSplit)
	  var upper = hulls[mergeIdx]
	  var lower = hulls[mergeIdx-1]
	  lower.upperIds = upper.upperIds
	  hulls.splice(mergeIdx, 1)
	}


	function monotoneTriangulate(points, edges) {

	  var numPoints = points.length
	  var numEdges = edges.length

	  var events = []

	  //Create point events
	  for(var i=0; i<numPoints; ++i) {
	    events.push(new Event(
	      points[i],
	      null,
	      EVENT_POINT,
	      i))
	  }

	  //Create edge events
	  for(var i=0; i<numEdges; ++i) {
	    var e = edges[i]
	    var a = points[e[0]]
	    var b = points[e[1]]
	    if(a[0] < b[0]) {
	      events.push(
	        new Event(a, b, EVENT_START, i),
	        new Event(b, a, EVENT_END, i))
	    } else if(a[0] > b[0]) {
	      events.push(
	        new Event(b, a, EVENT_START, i),
	        new Event(a, b, EVENT_END, i))
	    }
	  }

	  //Sort events
	  events.sort(compareEvent)

	  //Initialize hull
	  var minX = events[0].a[0] - (1 + Math.abs(events[0].a[0])) * Math.pow(2, -52)
	  var hull = [ new PartialHull([minX, 1], [minX, 0], -1, [], [], [], []) ]

	  //Process events in order
	  var cells = []
	  for(var i=0, numEvents=events.length; i<numEvents; ++i) {
	    var event = events[i]
	    var type = event.type
	    if(type === EVENT_POINT) {
	      addPoint(cells, hull, points, event.a, event.idx)
	    } else if(type === EVENT_START) {
	      splitHulls(hull, points, event)
	    } else {
	      mergeHulls(hull, points, event)
	    }
	  }

	  //Return triangulation
	  return cells
	}


/***/ }),
/* 171 */
/***/ (function(module, exports) {

	"use strict"

	function compileSearch(funcName, predicate, reversed, extraArgs, earlyOut) {
	  var code = [
	    "function ", funcName, "(a,l,h,", extraArgs.join(","),  "){",
	earlyOut ? "" : "var i=", (reversed ? "l-1" : "h+1"),
	";while(l<=h){\
	var m=(l+h)>>>1,x=a[m]"]
	  if(earlyOut) {
	    if(predicate.indexOf("c") < 0) {
	      code.push(";if(x===y){return m}else if(x<=y){")
	    } else {
	      code.push(";var p=c(x,y);if(p===0){return m}else if(p<=0){")
	    }
	  } else {
	    code.push(";if(", predicate, "){i=m;")
	  }
	  if(reversed) {
	    code.push("l=m+1}else{h=m-1}")
	  } else {
	    code.push("h=m-1}else{l=m+1}")
	  }
	  code.push("}")
	  if(earlyOut) {
	    code.push("return -1};")
	  } else {
	    code.push("return i};")
	  }
	  return code.join("")
	}

	function compileBoundsSearch(predicate, reversed, suffix, earlyOut) {
	  var result = new Function([
	  compileSearch("A", "x" + predicate + "y", reversed, ["y"], earlyOut),
	  compileSearch("P", "c(x,y)" + predicate + "0", reversed, ["y", "c"], earlyOut),
	"function dispatchBsearch", suffix, "(a,y,c,l,h){\
	if(typeof(c)==='function'){\
	return P(a,(l===void 0)?0:l|0,(h===void 0)?a.length-1:h|0,y,c)\
	}else{\
	return A(a,(c===void 0)?0:c|0,(l===void 0)?a.length-1:l|0,y)\
	}}\
	return dispatchBsearch", suffix].join(""))
	  return result()
	}

	module.exports = {
	  ge: compileBoundsSearch(">=", false, "GE"),
	  gt: compileBoundsSearch(">", false, "GT"),
	  lt: compileBoundsSearch("<", true, "LT"),
	  le: compileBoundsSearch("<=", true, "LE"),
	  eq: compileBoundsSearch("-", true, "EQ", true)
	}


/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict"

	var twoProduct = __webpack_require__(173)
	var robustSum = __webpack_require__(174)
	var robustScale = __webpack_require__(175)
	var robustSubtract = __webpack_require__(177)

	var NUM_EXPAND = 5

	var EPSILON     = 1.1102230246251565e-16
	var ERRBOUND3   = (3.0 + 16.0 * EPSILON) * EPSILON
	var ERRBOUND4   = (7.0 + 56.0 * EPSILON) * EPSILON

	function cofactor(m, c) {
	  var result = new Array(m.length-1)
	  for(var i=1; i<m.length; ++i) {
	    var r = result[i-1] = new Array(m.length-1)
	    for(var j=0,k=0; j<m.length; ++j) {
	      if(j === c) {
	        continue
	      }
	      r[k++] = m[i][j]
	    }
	  }
	  return result
	}

	function matrix(n) {
	  var result = new Array(n)
	  for(var i=0; i<n; ++i) {
	    result[i] = new Array(n)
	    for(var j=0; j<n; ++j) {
	      result[i][j] = ["m", j, "[", (n-i-1), "]"].join("")
	    }
	  }
	  return result
	}

	function sign(n) {
	  if(n & 1) {
	    return "-"
	  }
	  return ""
	}

	function generateSum(expr) {
	  if(expr.length === 1) {
	    return expr[0]
	  } else if(expr.length === 2) {
	    return ["sum(", expr[0], ",", expr[1], ")"].join("")
	  } else {
	    var m = expr.length>>1
	    return ["sum(", generateSum(expr.slice(0, m)), ",", generateSum(expr.slice(m)), ")"].join("")
	  }
	}

	function determinant(m) {
	  if(m.length === 2) {
	    return [["sum(prod(", m[0][0], ",", m[1][1], "),prod(-", m[0][1], ",", m[1][0], "))"].join("")]
	  } else {
	    var expr = []
	    for(var i=0; i<m.length; ++i) {
	      expr.push(["scale(", generateSum(determinant(cofactor(m, i))), ",", sign(i), m[0][i], ")"].join(""))
	    }
	    return expr
	  }
	}

	function orientation(n) {
	  var pos = []
	  var neg = []
	  var m = matrix(n)
	  var args = []
	  for(var i=0; i<n; ++i) {
	    if((i&1)===0) {
	      pos.push.apply(pos, determinant(cofactor(m, i)))
	    } else {
	      neg.push.apply(neg, determinant(cofactor(m, i)))
	    }
	    args.push("m" + i)
	  }
	  var posExpr = generateSum(pos)
	  var negExpr = generateSum(neg)
	  var funcName = "orientation" + n + "Exact"
	  var code = ["function ", funcName, "(", args.join(), "){var p=", posExpr, ",n=", negExpr, ",d=sub(p,n);\
	return d[d.length-1];};return ", funcName].join("")
	  var proc = new Function("sum", "prod", "scale", "sub", code)
	  return proc(robustSum, twoProduct, robustScale, robustSubtract)
	}

	var orientation3Exact = orientation(3)
	var orientation4Exact = orientation(4)

	var CACHED = [
	  function orientation0() { return 0 },
	  function orientation1() { return 0 },
	  function orientation2(a, b) { 
	    return b[0] - a[0]
	  },
	  function orientation3(a, b, c) {
	    var l = (a[1] - c[1]) * (b[0] - c[0])
	    var r = (a[0] - c[0]) * (b[1] - c[1])
	    var det = l - r
	    var s
	    if(l > 0) {
	      if(r <= 0) {
	        return det
	      } else {
	        s = l + r
	      }
	    } else if(l < 0) {
	      if(r >= 0) {
	        return det
	      } else {
	        s = -(l + r)
	      }
	    } else {
	      return det
	    }
	    var tol = ERRBOUND3 * s
	    if(det >= tol || det <= -tol) {
	      return det
	    }
	    return orientation3Exact(a, b, c)
	  },
	  function orientation4(a,b,c,d) {
	    var adx = a[0] - d[0]
	    var bdx = b[0] - d[0]
	    var cdx = c[0] - d[0]
	    var ady = a[1] - d[1]
	    var bdy = b[1] - d[1]
	    var cdy = c[1] - d[1]
	    var adz = a[2] - d[2]
	    var bdz = b[2] - d[2]
	    var cdz = c[2] - d[2]
	    var bdxcdy = bdx * cdy
	    var cdxbdy = cdx * bdy
	    var cdxady = cdx * ady
	    var adxcdy = adx * cdy
	    var adxbdy = adx * bdy
	    var bdxady = bdx * ady
	    var det = adz * (bdxcdy - cdxbdy) 
	            + bdz * (cdxady - adxcdy)
	            + cdz * (adxbdy - bdxady)
	    var permanent = (Math.abs(bdxcdy) + Math.abs(cdxbdy)) * Math.abs(adz)
	                  + (Math.abs(cdxady) + Math.abs(adxcdy)) * Math.abs(bdz)
	                  + (Math.abs(adxbdy) + Math.abs(bdxady)) * Math.abs(cdz)
	    var tol = ERRBOUND4 * permanent
	    if ((det > tol) || (-det > tol)) {
	      return det
	    }
	    return orientation4Exact(a,b,c,d)
	  }
	]

	function slowOrient(args) {
	  var proc = CACHED[args.length]
	  if(!proc) {
	    proc = CACHED[args.length] = orientation(args.length)
	  }
	  return proc.apply(undefined, args)
	}

	function generateOrientationProc() {
	  while(CACHED.length <= NUM_EXPAND) {
	    CACHED.push(orientation(CACHED.length))
	  }
	  var args = []
	  var procArgs = ["slow"]
	  for(var i=0; i<=NUM_EXPAND; ++i) {
	    args.push("a" + i)
	    procArgs.push("o" + i)
	  }
	  var code = [
	    "function getOrientation(", args.join(), "){switch(arguments.length){case 0:case 1:return 0;"
	  ]
	  for(var i=2; i<=NUM_EXPAND; ++i) {
	    code.push("case ", i, ":return o", i, "(", args.slice(0, i).join(), ");")
	  }
	  code.push("}var s=new Array(arguments.length);for(var i=0;i<arguments.length;++i){s[i]=arguments[i]};return slow(s);}return getOrientation")
	  procArgs.push(code.join(""))

	  var proc = Function.apply(undefined, procArgs)
	  module.exports = proc.apply(undefined, [slowOrient].concat(CACHED))
	  for(var i=0; i<=NUM_EXPAND; ++i) {
	    module.exports[i] = CACHED[i]
	  }
	}

	generateOrientationProc()

/***/ }),
/* 173 */
/***/ (function(module, exports) {

	"use strict"

	module.exports = twoProduct

	var SPLITTER = +(Math.pow(2, 27) + 1.0)

	function twoProduct(a, b, result) {
	  var x = a * b

	  var c = SPLITTER * a
	  var abig = c - a
	  var ahi = c - abig
	  var alo = a - ahi

	  var d = SPLITTER * b
	  var bbig = d - b
	  var bhi = d - bbig
	  var blo = b - bhi

	  var err1 = x - (ahi * bhi)
	  var err2 = err1 - (alo * bhi)
	  var err3 = err2 - (ahi * blo)

	  var y = alo * blo - err3

	  if(result) {
	    result[0] = y
	    result[1] = x
	    return result
	  }

	  return [ y, x ]
	}

/***/ }),
/* 174 */
/***/ (function(module, exports) {

	"use strict"

	module.exports = linearExpansionSum

	//Easy case: Add two scalars
	function scalarScalar(a, b) {
	  var x = a + b
	  var bv = x - a
	  var av = x - bv
	  var br = b - bv
	  var ar = a - av
	  var y = ar + br
	  if(y) {
	    return [y, x]
	  }
	  return [x]
	}

	function linearExpansionSum(e, f) {
	  var ne = e.length|0
	  var nf = f.length|0
	  if(ne === 1 && nf === 1) {
	    return scalarScalar(e[0], f[0])
	  }
	  var n = ne + nf
	  var g = new Array(n)
	  var count = 0
	  var eptr = 0
	  var fptr = 0
	  var abs = Math.abs
	  var ei = e[eptr]
	  var ea = abs(ei)
	  var fi = f[fptr]
	  var fa = abs(fi)
	  var a, b
	  if(ea < fa) {
	    b = ei
	    eptr += 1
	    if(eptr < ne) {
	      ei = e[eptr]
	      ea = abs(ei)
	    }
	  } else {
	    b = fi
	    fptr += 1
	    if(fptr < nf) {
	      fi = f[fptr]
	      fa = abs(fi)
	    }
	  }
	  if((eptr < ne && ea < fa) || (fptr >= nf)) {
	    a = ei
	    eptr += 1
	    if(eptr < ne) {
	      ei = e[eptr]
	      ea = abs(ei)
	    }
	  } else {
	    a = fi
	    fptr += 1
	    if(fptr < nf) {
	      fi = f[fptr]
	      fa = abs(fi)
	    }
	  }
	  var x = a + b
	  var bv = x - a
	  var y = b - bv
	  var q0 = y
	  var q1 = x
	  var _x, _bv, _av, _br, _ar
	  while(eptr < ne && fptr < nf) {
	    if(ea < fa) {
	      a = ei
	      eptr += 1
	      if(eptr < ne) {
	        ei = e[eptr]
	        ea = abs(ei)
	      }
	    } else {
	      a = fi
	      fptr += 1
	      if(fptr < nf) {
	        fi = f[fptr]
	        fa = abs(fi)
	      }
	    }
	    b = q0
	    x = a + b
	    bv = x - a
	    y = b - bv
	    if(y) {
	      g[count++] = y
	    }
	    _x = q1 + x
	    _bv = _x - q1
	    _av = _x - _bv
	    _br = x - _bv
	    _ar = q1 - _av
	    q0 = _ar + _br
	    q1 = _x
	  }
	  while(eptr < ne) {
	    a = ei
	    b = q0
	    x = a + b
	    bv = x - a
	    y = b - bv
	    if(y) {
	      g[count++] = y
	    }
	    _x = q1 + x
	    _bv = _x - q1
	    _av = _x - _bv
	    _br = x - _bv
	    _ar = q1 - _av
	    q0 = _ar + _br
	    q1 = _x
	    eptr += 1
	    if(eptr < ne) {
	      ei = e[eptr]
	    }
	  }
	  while(fptr < nf) {
	    a = fi
	    b = q0
	    x = a + b
	    bv = x - a
	    y = b - bv
	    if(y) {
	      g[count++] = y
	    } 
	    _x = q1 + x
	    _bv = _x - q1
	    _av = _x - _bv
	    _br = x - _bv
	    _ar = q1 - _av
	    q0 = _ar + _br
	    q1 = _x
	    fptr += 1
	    if(fptr < nf) {
	      fi = f[fptr]
	    }
	  }
	  if(q0) {
	    g[count++] = q0
	  }
	  if(q1) {
	    g[count++] = q1
	  }
	  if(!count) {
	    g[count++] = 0.0  
	  }
	  g.length = count
	  return g
	}

/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict"

	var twoProduct = __webpack_require__(173)
	var twoSum = __webpack_require__(176)

	module.exports = scaleLinearExpansion

	function scaleLinearExpansion(e, scale) {
	  var n = e.length
	  if(n === 1) {
	    var ts = twoProduct(e[0], scale)
	    if(ts[0]) {
	      return ts
	    }
	    return [ ts[1] ]
	  }
	  var g = new Array(2 * n)
	  var q = [0.1, 0.1]
	  var t = [0.1, 0.1]
	  var count = 0
	  twoProduct(e[0], scale, q)
	  if(q[0]) {
	    g[count++] = q[0]
	  }
	  for(var i=1; i<n; ++i) {
	    twoProduct(e[i], scale, t)
	    var pq = q[1]
	    twoSum(pq, t[0], q)
	    if(q[0]) {
	      g[count++] = q[0]
	    }
	    var a = t[1]
	    var b = q[1]
	    var x = a + b
	    var bv = x - a
	    var y = b - bv
	    q[1] = x
	    if(y) {
	      g[count++] = y
	    }
	  }
	  if(q[1]) {
	    g[count++] = q[1]
	  }
	  if(count === 0) {
	    g[count++] = 0.0
	  }
	  g.length = count
	  return g
	}

/***/ }),
/* 176 */
/***/ (function(module, exports) {

	"use strict"

	module.exports = fastTwoSum

	function fastTwoSum(a, b, result) {
		var x = a + b
		var bv = x - a
		var av = x - bv
		var br = b - bv
		var ar = a - av
		if(result) {
			result[0] = ar + br
			result[1] = x
			return result
		}
		return [ar+br, x]
	}

/***/ }),
/* 177 */
/***/ (function(module, exports) {

	"use strict"

	module.exports = robustSubtract

	//Easy case: Add two scalars
	function scalarScalar(a, b) {
	  var x = a + b
	  var bv = x - a
	  var av = x - bv
	  var br = b - bv
	  var ar = a - av
	  var y = ar + br
	  if(y) {
	    return [y, x]
	  }
	  return [x]
	}

	function robustSubtract(e, f) {
	  var ne = e.length|0
	  var nf = f.length|0
	  if(ne === 1 && nf === 1) {
	    return scalarScalar(e[0], -f[0])
	  }
	  var n = ne + nf
	  var g = new Array(n)
	  var count = 0
	  var eptr = 0
	  var fptr = 0
	  var abs = Math.abs
	  var ei = e[eptr]
	  var ea = abs(ei)
	  var fi = -f[fptr]
	  var fa = abs(fi)
	  var a, b
	  if(ea < fa) {
	    b = ei
	    eptr += 1
	    if(eptr < ne) {
	      ei = e[eptr]
	      ea = abs(ei)
	    }
	  } else {
	    b = fi
	    fptr += 1
	    if(fptr < nf) {
	      fi = -f[fptr]
	      fa = abs(fi)
	    }
	  }
	  if((eptr < ne && ea < fa) || (fptr >= nf)) {
	    a = ei
	    eptr += 1
	    if(eptr < ne) {
	      ei = e[eptr]
	      ea = abs(ei)
	    }
	  } else {
	    a = fi
	    fptr += 1
	    if(fptr < nf) {
	      fi = -f[fptr]
	      fa = abs(fi)
	    }
	  }
	  var x = a + b
	  var bv = x - a
	  var y = b - bv
	  var q0 = y
	  var q1 = x
	  var _x, _bv, _av, _br, _ar
	  while(eptr < ne && fptr < nf) {
	    if(ea < fa) {
	      a = ei
	      eptr += 1
	      if(eptr < ne) {
	        ei = e[eptr]
	        ea = abs(ei)
	      }
	    } else {
	      a = fi
	      fptr += 1
	      if(fptr < nf) {
	        fi = -f[fptr]
	        fa = abs(fi)
	      }
	    }
	    b = q0
	    x = a + b
	    bv = x - a
	    y = b - bv
	    if(y) {
	      g[count++] = y
	    }
	    _x = q1 + x
	    _bv = _x - q1
	    _av = _x - _bv
	    _br = x - _bv
	    _ar = q1 - _av
	    q0 = _ar + _br
	    q1 = _x
	  }
	  while(eptr < ne) {
	    a = ei
	    b = q0
	    x = a + b
	    bv = x - a
	    y = b - bv
	    if(y) {
	      g[count++] = y
	    }
	    _x = q1 + x
	    _bv = _x - q1
	    _av = _x - _bv
	    _br = x - _bv
	    _ar = q1 - _av
	    q0 = _ar + _br
	    q1 = _x
	    eptr += 1
	    if(eptr < ne) {
	      ei = e[eptr]
	    }
	  }
	  while(fptr < nf) {
	    a = fi
	    b = q0
	    x = a + b
	    bv = x - a
	    y = b - bv
	    if(y) {
	      g[count++] = y
	    } 
	    _x = q1 + x
	    _bv = _x - q1
	    _av = _x - _bv
	    _br = x - _bv
	    _ar = q1 - _av
	    q0 = _ar + _br
	    q1 = _x
	    fptr += 1
	    if(fptr < nf) {
	      fi = -f[fptr]
	    }
	  }
	  if(q0) {
	    g[count++] = q0
	  }
	  if(q1) {
	    g[count++] = q1
	  }
	  if(!count) {
	    g[count++] = 0.0  
	  }
	  g.length = count
	  return g
	}

/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict'

	var bsearch = __webpack_require__(171)

	module.exports = createTriangulation

	function Triangulation(stars, edges) {
	  this.stars = stars
	  this.edges = edges
	}

	var proto = Triangulation.prototype

	function removePair(list, j, k) {
	  for(var i=1, n=list.length; i<n; i+=2) {
	    if(list[i-1] === j && list[i] === k) {
	      list[i-1] = list[n-2]
	      list[i] = list[n-1]
	      list.length = n - 2
	      return
	    }
	  }
	}

	proto.isConstraint = (function() {
	  var e = [0,0]
	  function compareLex(a, b) {
	    return a[0] - b[0] || a[1] - b[1]
	  }
	  return function(i, j) {
	    e[0] = Math.min(i,j)
	    e[1] = Math.max(i,j)
	    return bsearch.eq(this.edges, e, compareLex) >= 0
	  }
	})()

	proto.removeTriangle = function(i, j, k) {
	  var stars = this.stars
	  removePair(stars[i], j, k)
	  removePair(stars[j], k, i)
	  removePair(stars[k], i, j)
	}

	proto.addTriangle = function(i, j, k) {
	  var stars = this.stars
	  stars[i].push(j, k)
	  stars[j].push(k, i)
	  stars[k].push(i, j)
	}

	proto.opposite = function(j, i) {
	  var list = this.stars[i]
	  for(var k=1, n=list.length; k<n; k+=2) {
	    if(list[k] === j) {
	      return list[k-1]
	    }
	  }
	  return -1
	}

	proto.flip = function(i, j) {
	  var a = this.opposite(i, j)
	  var b = this.opposite(j, i)
	  this.removeTriangle(i, j, a)
	  this.removeTriangle(j, i, b)
	  this.addTriangle(i, b, a)
	  this.addTriangle(j, a, b)
	}

	proto.edges = function() {
	  var stars = this.stars
	  var result = []
	  for(var i=0, n=stars.length; i<n; ++i) {
	    var list = stars[i]
	    for(var j=0, m=list.length; j<m; j+=2) {
	      result.push([list[j], list[j+1]])
	    }
	  }
	  return result
	}

	proto.cells = function() {
	  var stars = this.stars
	  var result = []
	  for(var i=0, n=stars.length; i<n; ++i) {
	    var list = stars[i]
	    for(var j=0, m=list.length; j<m; j+=2) {
	      var s = list[j]
	      var t = list[j+1]
	      if(i < Math.min(s, t)) {
	        result.push([i, s, t])
	      }
	    }
	  }
	  return result
	}

	function createTriangulation(numVerts, edges) {
	  var stars = new Array(numVerts)
	  for(var i=0; i<numVerts; ++i) {
	    stars[i] = []
	  }
	  return new Triangulation(stars, edges)
	}


/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict'

	var inCircle = __webpack_require__(180)[4]
	var bsearch = __webpack_require__(171)

	module.exports = delaunayRefine

	function testFlip(points, triangulation, stack, a, b, x) {
	  var y = triangulation.opposite(a, b)

	  //Test boundary edge
	  if(y < 0) {
	    return
	  }

	  //Swap edge if order flipped
	  if(b < a) {
	    var tmp = a
	    a = b
	    b = tmp
	    tmp = x
	    x = y
	    y = tmp
	  }

	  //Test if edge is constrained
	  if(triangulation.isConstraint(a, b)) {
	    return
	  }

	  //Test if edge is delaunay
	  if(inCircle(points[a], points[b], points[x], points[y]) < 0) {
	    stack.push(a, b)
	  }
	}

	//Assume edges are sorted lexicographically
	function delaunayRefine(points, triangulation) {
	  var stack = []

	  var numPoints = points.length
	  var stars = triangulation.stars
	  for(var a=0; a<numPoints; ++a) {
	    var star = stars[a]
	    for(var j=1; j<star.length; j+=2) {
	      var b = star[j]

	      //If order is not consistent, then skip edge
	      if(b < a) {
	        continue
	      }

	      //Check if edge is constrained
	      if(triangulation.isConstraint(a, b)) {
	        continue
	      }

	      //Find opposite edge
	      var x = star[j-1], y = -1
	      for(var k=1; k<star.length; k+=2) {
	        if(star[k-1] === b) {
	          y = star[k]
	          break
	        }
	      }

	      //If this is a boundary edge, don't flip it
	      if(y < 0) {
	        continue
	      }

	      //If edge is in circle, flip it
	      if(inCircle(points[a], points[b], points[x], points[y]) < 0) {
	        stack.push(a, b)
	      }
	    }
	  }

	  while(stack.length > 0) {
	    var b = stack.pop()
	    var a = stack.pop()

	    //Find opposite pairs
	    var x = -1, y = -1
	    var star = stars[a]
	    for(var i=1; i<star.length; i+=2) {
	      var s = star[i-1]
	      var t = star[i]
	      if(s === b) {
	        y = t
	      } else if(t === b) {
	        x = s
	      }
	    }

	    //If x/y are both valid then skip edge
	    if(x < 0 || y < 0) {
	      continue
	    }

	    //If edge is now delaunay, then don't flip it
	    if(inCircle(points[a], points[b], points[x], points[y]) >= 0) {
	      continue
	    }

	    //Flip the edge
	    triangulation.flip(a, b)

	    //Test flipping neighboring edges
	    testFlip(points, triangulation, stack, x, a, y)
	    testFlip(points, triangulation, stack, a, y, x)
	    testFlip(points, triangulation, stack, y, b, x)
	    testFlip(points, triangulation, stack, b, x, y)
	  }
	}


/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict"

	var twoProduct = __webpack_require__(173)
	var robustSum = __webpack_require__(174)
	var robustDiff = __webpack_require__(177)
	var robustScale = __webpack_require__(175)

	var NUM_EXPAND = 6

	function cofactor(m, c) {
	  var result = new Array(m.length-1)
	  for(var i=1; i<m.length; ++i) {
	    var r = result[i-1] = new Array(m.length-1)
	    for(var j=0,k=0; j<m.length; ++j) {
	      if(j === c) {
	        continue
	      }
	      r[k++] = m[i][j]
	    }
	  }
	  return result
	}

	function matrix(n) {
	  var result = new Array(n)
	  for(var i=0; i<n; ++i) {
	    result[i] = new Array(n)
	    for(var j=0; j<n; ++j) {
	      result[i][j] = ["m", j, "[", (n-i-2), "]"].join("")
	    }
	  }
	  return result
	}

	function generateSum(expr) {
	  if(expr.length === 1) {
	    return expr[0]
	  } else if(expr.length === 2) {
	    return ["sum(", expr[0], ",", expr[1], ")"].join("")
	  } else {
	    var m = expr.length>>1
	    return ["sum(", generateSum(expr.slice(0, m)), ",", generateSum(expr.slice(m)), ")"].join("")
	  }
	}

	function makeProduct(a, b) {
	  if(a.charAt(0) === "m") {
	    if(b.charAt(0) === "w") {
	      var toks = a.split("[")
	      return ["w", b.substr(1), "m", toks[0].substr(1)].join("")
	    } else {
	      return ["prod(", a, ",", b, ")"].join("")
	    }
	  } else {
	    return makeProduct(b, a)
	  }
	}

	function sign(s) {
	  if(s & 1 !== 0) {
	    return "-"
	  }
	  return ""
	}

	function determinant(m) {
	  if(m.length === 2) {
	    return [["diff(", makeProduct(m[0][0], m[1][1]), ",", makeProduct(m[1][0], m[0][1]), ")"].join("")]
	  } else {
	    var expr = []
	    for(var i=0; i<m.length; ++i) {
	      expr.push(["scale(", generateSum(determinant(cofactor(m, i))), ",", sign(i), m[0][i], ")"].join(""))
	    }
	    return expr
	  }
	}

	function makeSquare(d, n) {
	  var terms = []
	  for(var i=0; i<n-2; ++i) {
	    terms.push(["prod(m", d, "[", i, "],m", d, "[", i, "])"].join(""))
	  }
	  return generateSum(terms)
	}

	function orientation(n) {
	  var pos = []
	  var neg = []
	  var m = matrix(n)
	  for(var i=0; i<n; ++i) {
	    m[0][i] = "1"
	    m[n-1][i] = "w"+i
	  } 
	  for(var i=0; i<n; ++i) {
	    if((i&1)===0) {
	      pos.push.apply(pos,determinant(cofactor(m, i)))
	    } else {
	      neg.push.apply(neg,determinant(cofactor(m, i)))
	    }
	  }
	  var posExpr = generateSum(pos)
	  var negExpr = generateSum(neg)
	  var funcName = "exactInSphere" + n
	  var funcArgs = []
	  for(var i=0; i<n; ++i) {
	    funcArgs.push("m" + i)
	  }
	  var code = ["function ", funcName, "(", funcArgs.join(), "){"]
	  for(var i=0; i<n; ++i) {
	    code.push("var w",i,"=",makeSquare(i,n),";")
	    for(var j=0; j<n; ++j) {
	      if(j !== i) {
	        code.push("var w",i,"m",j,"=scale(w",i,",m",j,"[0]);")
	      }
	    }
	  }
	  code.push("var p=", posExpr, ",n=", negExpr, ",d=diff(p,n);return d[d.length-1];}return ", funcName)
	  var proc = new Function("sum", "diff", "prod", "scale", code.join(""))
	  return proc(robustSum, robustDiff, twoProduct, robustScale)
	}

	function inSphere0() { return 0 }
	function inSphere1() { return 0 }
	function inSphere2() { return 0 }

	var CACHED = [
	  inSphere0,
	  inSphere1,
	  inSphere2
	]

	function slowInSphere(args) {
	  var proc = CACHED[args.length]
	  if(!proc) {
	    proc = CACHED[args.length] = orientation(args.length)
	  }
	  return proc.apply(undefined, args)
	}

	function generateInSphereTest() {
	  while(CACHED.length <= NUM_EXPAND) {
	    CACHED.push(orientation(CACHED.length))
	  }
	  var args = []
	  var procArgs = ["slow"]
	  for(var i=0; i<=NUM_EXPAND; ++i) {
	    args.push("a" + i)
	    procArgs.push("o" + i)
	  }
	  var code = [
	    "function testInSphere(", args.join(), "){switch(arguments.length){case 0:case 1:return 0;"
	  ]
	  for(var i=2; i<=NUM_EXPAND; ++i) {
	    code.push("case ", i, ":return o", i, "(", args.slice(0, i).join(), ");")
	  }
	  code.push("}var s=new Array(arguments.length);for(var i=0;i<arguments.length;++i){s[i]=arguments[i]};return slow(s);}return testInSphere")
	  procArgs.push(code.join(""))

	  var proc = Function.apply(undefined, procArgs)

	  module.exports = proc.apply(undefined, [slowInSphere].concat(CACHED))
	  for(var i=0; i<=NUM_EXPAND; ++i) {
	    module.exports[i] = CACHED[i]
	  }
	}

	generateInSphereTest()

/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict'

	var bsearch = __webpack_require__(171)

	module.exports = classifyFaces

	function FaceIndex(cells, neighbor, constraint, flags, active, next, boundary) {
	  this.cells       = cells
	  this.neighbor    = neighbor
	  this.flags       = flags
	  this.constraint  = constraint
	  this.active      = active
	  this.next        = next
	  this.boundary    = boundary
	}

	var proto = FaceIndex.prototype

	function compareCell(a, b) {
	  return a[0] - b[0] ||
	         a[1] - b[1] ||
	         a[2] - b[2]
	}

	proto.locate = (function() {
	  var key = [0,0,0]
	  return function(a, b, c) {
	    var x = a, y = b, z = c
	    if(b < c) {
	      if(b < a) {
	        x = b
	        y = c
	        z = a
	      }
	    } else if(c < a) {
	      x = c
	      y = a
	      z = b
	    }
	    if(x < 0) {
	      return -1
	    }
	    key[0] = x
	    key[1] = y
	    key[2] = z
	    return bsearch.eq(this.cells, key, compareCell)
	  }
	})()

	function indexCells(triangulation, infinity) {
	  //First get cells and canonicalize
	  var cells = triangulation.cells()
	  var nc = cells.length
	  for(var i=0; i<nc; ++i) {
	    var c = cells[i]
	    var x = c[0], y = c[1], z = c[2]
	    if(y < z) {
	      if(y < x) {
	        c[0] = y
	        c[1] = z
	        c[2] = x
	      }
	    } else if(z < x) {
	      c[0] = z
	      c[1] = x
	      c[2] = y
	    }
	  }
	  cells.sort(compareCell)

	  //Initialize flag array
	  var flags = new Array(nc)
	  for(var i=0; i<flags.length; ++i) {
	    flags[i] = 0
	  }

	  //Build neighbor index, initialize queues
	  var active = []
	  var next   = []
	  var neighbor = new Array(3*nc)
	  var constraint = new Array(3*nc)
	  var boundary = null
	  if(infinity) {
	    boundary = []
	  }
	  var index = new FaceIndex(
	    cells,
	    neighbor,
	    constraint,
	    flags,
	    active,
	    next,
	    boundary)
	  for(var i=0; i<nc; ++i) {
	    var c = cells[i]
	    for(var j=0; j<3; ++j) {
	      var x = c[j], y = c[(j+1)%3]
	      var a = neighbor[3*i+j] = index.locate(y, x, triangulation.opposite(y, x))
	      var b = constraint[3*i+j] = triangulation.isConstraint(x, y)
	      if(a < 0) {
	        if(b) {
	          next.push(i)
	        } else {
	          active.push(i)
	          flags[i] = 1
	        }
	        if(infinity) {
	          boundary.push([y, x, -1])
	        }
	      }
	    }
	  }
	  return index
	}

	function filterCells(cells, flags, target) {
	  var ptr = 0
	  for(var i=0; i<cells.length; ++i) {
	    if(flags[i] === target) {
	      cells[ptr++] = cells[i]
	    }
	  }
	  cells.length = ptr
	  return cells
	}

	function classifyFaces(triangulation, target, infinity) {
	  var index = indexCells(triangulation, infinity)

	  if(target === 0) {
	    if(infinity) {
	      return index.cells.concat(index.boundary)
	    } else {
	      return index.cells
	    }
	  }

	  var side = 1
	  var active = index.active
	  var next = index.next
	  var flags = index.flags
	  var cells = index.cells
	  var constraint = index.constraint
	  var neighbor = index.neighbor

	  while(active.length > 0 || next.length > 0) {
	    while(active.length > 0) {
	      var t = active.pop()
	      if(flags[t] === -side) {
	        continue
	      }
	      flags[t] = side
	      var c = cells[t]
	      for(var j=0; j<3; ++j) {
	        var f = neighbor[3*t+j]
	        if(f >= 0 && flags[f] === 0) {
	          if(constraint[3*t+j]) {
	            next.push(f)
	          } else {
	            active.push(f)
	            flags[f] = side
	          }
	        }
	      }
	    }

	    //Swap arrays and loop
	    var tmp = next
	    next = active
	    active = tmp
	    next.length = 0
	    side = -side
	  }

	  var result = filterCells(cells, flags, target)
	  if(infinity) {
	    return result.concat(index.boundary)
	  }
	  return result
	}


/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

	var PlacemarkAttributes = __webpack_require__(183);
	var TextAttributes = __webpack_require__(184);
	var GeographicText = __webpack_require__(185);
	var Placemark = __webpack_require__(187);
	var Color = __webpack_require__(52);
	var Font = __webpack_require__(128);
	var SurfaceSymbol = __webpack_require__(85);
	var Utils = __webpack_require__(144);

	module.exports = {
	    create: function (desc) {
	        return desc.geometry.properties.api === 'coco' ?
	            createDistanceFieldText(desc) : createText(desc);
	    }
	};

	function createText(desc) {
	    var position = Utils.position(desc.geometry.coordinates);
	    var placemarkAttributes =  new PlacemarkAttributes(null);
	    placemarkAttributes._imageSource = 'images/transparentPixel.png';
	    placemarkAttributes.labelAttributes = new TextAttributes(null);
	    placemarkAttributes.labelAttributes._offset.x = desc.geometry.properties.offsetX || 0;
	    placemarkAttributes.labelAttributes._offset.y = desc.geometry.properties.offsetY || 0;
	    placemarkAttributes.labelAttributes._color = Color.colorFromHex(desc.geometry.properties.color);
	    placemarkAttributes.labelAttributes._font = new Font(20);
	    var text = new Placemark(position, true, placemarkAttributes);
	    text.altitudeMode = WorldWind.RELATIVE_TO_GROUND;
	    text.label = desc.geometry.properties.text;
	    text.eyeDistanceScalingThreshold = 5000;
	    text.source = desc;
	    return [text];
	}

	function createDistanceFieldText(desc) {
	    var position = Utils.position(desc.geometry.coordinates);
	    var surfaceChars = [];
	    var size = desc.geometry.properties.bbox ?
	        getDimension(desc.geometry.properties.bbox)[0]
	        : 0.001*(desc.geometry.properties.fontSize||1);
	    var color = desc.geometry.properties.color;
	    var length = desc.geometry.properties.text ? desc.geometry.properties.text.length : 0;
	    var k = size * 0.5 / Math.cos(position.latitude);
	    position.longitude -= k * (length-1)/2*(2*(desc.geometry.properties.offsetX||0));
	    desc.geometry.properties.text && desc.geometry.properties.text.split('').forEach(function (char) {
	        normalizeLongitude(position);
	        var surfaceChar = new SurfaceSymbol(position, char, size, color, desc.properties);
	        surfaceChar.source = desc;
	        surfaceChars.push(surfaceChar);
	        position.longitude += k;
	    });
	    return surfaceChars;
	}
	function normalizeLongitude(position) {
	    if (position.longitude > 180) position.longitude -= 360;
	    if (position.longitude < -180) position.longitude += 360;
	}

	function getDimension(bbox) {
	    return [
	        bbox.max[0] - bbox.min[0],
	        bbox.max[1] - bbox.min[1]
	    ];
	}

/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports PlacemarkAttributes
	 * @version $Id: PlacemarkAttributes.js 3023 2015-04-15 20:24:17Z tgaskins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(52),
	        __webpack_require__(128),
	        __webpack_require__(45),
	        __webpack_require__(132),
	        __webpack_require__(184)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Color,
	              Font,
	              Offset,
	              ShapeAttributes,
	              TextAttributes) {
	        "use strict";

	        /**
	         * Constructs a placemark attributes bundle.
	         * The defaults indicate a placemark displayed as a white 1x1 pixel square centered on the placemark's
	         * geographic position.
	         * @alias PlacemarkAttributes
	         * @constructor
	         * @classdesc Holds attributes applied to {@link Placemark} shapes.
	         *
	         * @param {PlacemarkAttributes} attributes Attributes to initialize this attributes instance to. May be null,
	         * in which case the new instance contains default attributes.
	         */
	        var PlacemarkAttributes = function (attributes) {
	            // These are all documented with their property accessors below.
	            this._imageColor = attributes ? attributes._imageColor : new Color(1, 1, 1, 1);
	            this._imageOffset = attributes ? attributes._imageOffset
	                : new Offset(WorldWind.OFFSET_FRACTION, 0.5, WorldWind.OFFSET_FRACTION, 0.5);
	            this._imageScale = attributes ? attributes._imageScale : 1;
	            this._imageSource = attributes ? attributes._imageSource : null;
	            this._depthTest = attributes ? attributes._depthTest : true;
	            this._labelAttributes = attributes ? attributes._labelAttributes : new TextAttributes(null);
	            this._drawLeaderLine = attributes ? attributes._drawLeaderLine : false;
	            this._leaderLineAttributes = attributes ? attributes._leaderLineAttributes : new ShapeAttributes(null);

	            /**
	             * Indicates whether this object's state key is invalid. Subclasses must set this value to true when their
	             * attributes change. The state key will be automatically computed the next time it's requested. This flag
	             * will be set to false when that occurs.
	             * @type {Boolean}
	             * @protected
	             */
	            this.stateKeyInvalid = true;
	        };

	        /**
	         * Computes the state key for this attributes object. Subclasses that define additional attributes must
	         * override this method, call it from that method, and append the state of their attributes to its
	         * return value.
	         * @returns {String} The state key for this object.
	         * @protected
	         */
	        PlacemarkAttributes.prototype.computeStateKey = function () {
	            return "ic " + this._imageColor.toHexString(true)
	                + " io " + this._imageOffset.toString()
	                + " is " + this._imageScale
	                + " ip " + this._imageSource
	                + " dt " + this._depthTest
	                + " la " + this._labelAttributes.stateKey
	                + " dll " + this._drawLeaderLine
	                + " lla " + this._leaderLineAttributes.stateKey;
	        };

	        Object.defineProperties(PlacemarkAttributes.prototype, {
	            /**
	             * A string identifying the state of this attributes object. The string encodes the current values of all
	             * this object's properties. It's typically used to validate cached representations of shapes associated
	             * with this attributes object.
	             * @type {String}
	             * @readonly
	             * @memberof PlacemarkAttributes.prototype
	             */
	            stateKey: {
	                get: function () {
	                    if (this.stateKeyInvalid) {
	                        this._stateKey = this.computeStateKey();
	                        this.stateKeyInvalid = false;
	                    }
	                    return this._stateKey;
	                }
	            },

	            /**
	             * The image color.
	             * When this attribute bundle has a valid image path the placemark's image is composed with this image
	             * color to achieve the final placemark color. Otherwise the placemark is drawn in this color. The color
	             * white, the default, causes the image to be drawn in its native colors.
	             * @type {Color}
	             * @default White (1, 1, 1, 1)
	             * @memberof PlacemarkAttributes.prototype
	             */
	            imageColor: {
	                get: function () {
	                    return this._imageColor;
	                },
	                set: function (value) {
	                    this._imageColor = value;
	                    this.stateKeyInvalid = true;
	                }
	            },

	            /**
	             * Indicates the location within the placemark's image to align with the placemark's geographic position.
	             * May be null, in which case the image's bottom-left corner is placed at the geographic position.
	             * @type {Offset}
	             * @default 0.5, 0.5, both fractional (Centers the image on the geographic position.)
	             * @memberof PlacemarkAttributes.prototype
	             */
	            imageOffset: {
	                get: function () {
	                    return this._imageOffset;
	                },
	                set: function (value) {
	                    this._imageOffset = value;
	                    this.stateKeyInvalid = true;
	                }
	            },

	            /**
	             * Indicates the amount to scale the placemark's image.
	             * When this attribute bundle has a valid image path the scale is applied to the image's dimensions. Otherwise the
	             * scale indicates the dimensions in pixels of a square drawn at the placemark's geographic position.
	             * A scale of 0 causes the placemark to disappear; however, the placemark's label, if any, is still drawn.
	             * @type {Number}
	             * @default 1
	             * @memberof PlacemarkAttributes.prototype
	             */
	            imageScale: {
	                get: function () {
	                    return this._imageScale;
	                },
	                set: function (value) {
	                    this._imageScale = value;
	                    this.stateKeyInvalid = true;
	                }
	            },

	            /**
	             * The image source of the placemark's image. May be either a string giving the URL of the image, or an
	             * {@link ImageSource} object identifying an Image created dynamically.
	             * If null, the placemark is drawn as a square whose width and height are
	             * the value of this attribute object's [imageScale]{@link PlacemarkAttributes#imageScale} property.
	             * @type {String|ImageSource}
	             * @default null
	             * @memberof PlacemarkAttributes.prototype
	             */
	            imageSource: {
	                get: function () {
	                    return this._imageSource;
	                },
	                set: function (value) {
	                    this._imageSource = value;
	                    this.stateKeyInvalid = true;
	                }
	            },

	            /**
	             * Indicates whether the placemark should be depth-tested against other objects in the scene. If true,
	             * the placemark may be occluded by terrain and other objects in certain viewing situations. If false,
	             * the placemark will not be occluded by terrain and other objects. If this value is true, the placemark's
	             * label, if any, has an independent depth-test control.
	             * See [PlacemarkAttributes.labelAttributes]{@link PlacemarkAttributes#labelAttributes}
	             * and [TextAttributes.depthTest]{@link TextAttributes#depthTest}.
	             * @type {Boolean}
	             * @default true
	             * @memberof PlacemarkAttributes.prototype
	             */
	            depthTest: {
	                get: function () {
	                    return this._depthTest;
	                },
	                set: function (value) {
	                    this._depthTest = value;
	                    this.stateKeyInvalid = true;
	                }
	            },

	            /**
	             * Indicates the attributes to apply to the placemark's label, if any. If null, the placemark's label is
	             * not drawn.
	             * @type {TextAttributes}
	             * @default The defaults of {@link TextAttributes}.
	             * @memberof PlacemarkAttributes.prototype
	             */
	            labelAttributes: {
	                get: function () {
	                    return this._labelAttributes;
	                },
	                set: function (value) {
	                    this._labelAttributes = value;
	                    this.stateKeyInvalid = true;
	                }
	            },

	            /**
	             * Indicates whether to draw a line from the placemark's geographic position to the ground.
	             * @type {Boolean}
	             * @default false
	             * @memberof PlacemarkAttributes.prototype
	             */
	            drawLeaderLine: {
	                get: function () {
	                    return this._drawLeaderLine;
	                },
	                set: function (value) {
	                    this._drawLeaderLine = value;
	                    this.stateKeyInvalid = true;
	                }
	            },

	            /**
	             * The attributes to apply to the leader line if it's drawn. If null, the placemark's leader line is
	             * not drawn.
	             * @type {ShapeAttributes}
	             * @default The defaults of {@link ShapeAttributes}
	             * @memberof PlacemarkAttributes.prototype
	             */
	            leaderLineAttributes: {
	                get: function () {
	                    return this._leaderLineAttributes;
	                },
	                set: function (value) {
	                    this._leaderLineAttributes = value;
	                    this.stateKeyInvalid = true;
	                }
	            }
	        });

	        return PlacemarkAttributes;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
	;

/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports TextAttributes
	 * @version $Id: TextAttributes.js 3295 2015-06-30 19:16:37Z tgaskins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(52),
	        __webpack_require__(128),
	        __webpack_require__(45)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Color,
	              Font,
	              Offset) {
	        "use strict";

	        /**
	         * Constructs a text attributes bundle.
	         * @alias TextAttributes
	         * @constructor
	         * @classdesc Holds attributes applied to [Text]{@link Text} shapes and [Placemark]{@link Placemark} labels.
	         *
	         * @param {TextAttributes} attributes Attributes to initialize this attributes instance to. May be null,
	         * in which case the new instance contains default attributes.
	         */
	        var TextAttributes = function (attributes) {
	            this._color = attributes ? attributes._color : new Color(1, 1, 1, 1);
	            this._font = attributes ? attributes._font : new Font(14);
	            this._offset = attributes ? attributes._offset
	                : new Offset(WorldWind.OFFSET_FRACTION, 0.5, WorldWind.OFFSET_FRACTION, 0.0);
	            this._scale = attributes ? attributes._scale : 1;
	            this._depthTest = attributes ? attributes._depthTest : false;

	            /**
	             * Indicates whether this object's state key is invalid. Subclasses must set this value to true when their
	             * attributes change. The state key will be automatically computed the next time it's requested. This flag
	             * will be set to false when that occurs.
	             * @type {boolean}
	             * @protected
	             */
	            this.stateKeyInvalid = true;
	        };

	        /**
	         * Computes the state key for this attributes object. Subclasses that define additional attributes must
	         * override this method, call it from that method, and append the state of their attributes to its
	         * return value.
	         * @returns {String} The state key for this object.
	         * @protected
	         */
	        TextAttributes.prototype.computeStateKey = function () {
	            return "c " + this._color.toHexString(true) +
	                " f " + this._font.toString() +
	                " o " + this._offset.toString() +
	                " s " + this._scale +
	                " dt " + this._depthTest;
	        };

	        Object.defineProperties(TextAttributes.prototype, {
	            /**
	             * A string identifying the state of this attributes object. The string encodes the current values of all
	             * this object's properties. It's typically used to validate cached representations of shapes associated
	             * with this attributes object.
	             * @type {String}
	             * @readonly
	             * @memberof TextAttributes.prototype
	             */
	            stateKey: {
	                get: function () {
	                    if (this.stateKeyInvalid) {
	                        this._stateKey = this.computeStateKey();
	                        this.stateKeyInvalid = false;
	                    }
	                    return this._stateKey;
	                }
	            },

	            /**
	             * The text color.
	             * @type {Color}
	             * @default White (1, 1, 1, 1)
	             * @memberof TextAttributes.prototype
	             */
	            color: {
	                get: function () {
	                    return this._color;
	                },
	                set: function (value) {
	                    this._color = value;
	                    this.stateKeyInvalid = true;
	                }
	            },

	            /**
	             * The text size, face and other characteristics, as described in [Font]{@link Font}.
	             * @type {Font}
	             * @default Those of [Font]{@link Font}, but with a font size of 14.
	             * @memberof TextAttributes.prototype
	             */
	            font: {
	                get: function () {
	                    return this._font;
	                },
	                set: function (value) {
	                    this._font = value;
	                    this.stateKeyInvalid = true;
	                }
	            },

	            /**
	             * Indicates the location of the text relative to its specified position.
	             * May be null, in which case the text's bottom-left corner is placed at the specified position.
	             * @type {Offset}
	             * @default 0.5, 0.0, both fractional (Places the text's horizontal center and vertical bottom at the
	             * specified position.)
	             * @memberof TextAttributes.prototype
	             */
	            offset: {
	                get: function () {
	                    return this._offset;
	                },
	                set: function (value) {
	                    this._offset = value;
	                    this.stateKeyInvalid = true;
	                }
	            },

	            /**
	             * Indicates the amount to scale the text. A value of 0 makes the text disappear.
	             * @type {Number}
	             * @default 1.0
	             * @memberof TextAttributes.prototype
	             */
	            scale: {
	                get: function () {
	                    return this._scale;
	                },
	                set: function (value) {
	                    this._scale = value;
	                    this.stateKeyInvalid = true;
	                }
	            },

	            /**
	             * Indicates whether the text should be depth-tested against other objects in the scene. If true,
	             * the text may be occluded by terrain and other objects in certain viewing situations. If false,
	             * the text will not be occluded by terrain and other objects.
	             * @type {Boolean}
	             * @default false
	             * @memberof TextAttributes.prototype
	             */
	            depthTest: {
	                get: function () {
	                    return this._depthTest;
	                },
	                set: function (value) {
	                    this._depthTest = value;
	                    this.stateKeyInvalid = true;
	                }
	            }
	        });

	        return TextAttributes;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports GeographicText
	 * @version $Id: GeographicText.js 3262 2015-06-25 16:50:39Z tgaskins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(30),
	        __webpack_require__(32),
	        __webpack_require__(186),
	        __webpack_require__(35)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
	              Logger,
	              Text,
	              Vec3) {
	        "use strict";

	        /**
	         * Constructs a geographic text shape at a specified position.
	         * @alias GeographicText
	         * @constructor
	         * @augments Text
	         * @classdesc Represents a string of text displayed at a geographic position.
	         * <p>
	         * See also {@link ScreenText}.
	         *
	         * @param {Position} position The text's geographic position.
	         * @param {String} text The text to display.
	         * @throws {ArgumentError} If either the specified position or text is null or undefined.
	         */
	        var GeographicText = function (position, text) {
	            if (!position) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Text", "constructor", "missingPosition"));
	            }

	            Text.call(this, text);

	            /**
	             * This text's geographic position.
	             * The [TextAttributes.offset]{@link TextAttributes#offset} property indicates the relationship of the
	             * text string to this position.
	             * @type {Position}
	             */
	            this.position = position;

	            /**
	             * Indicates the group ID of the declutter group to include this Text shape. This shape
	             * is decluttered relative to all other shapes within its group by the default
	             * [declutter filter]{@link WorldWindow#declutter}. To prevent decluttering of this shape, set its
	             * declutter group to 0.
	             * @type {Number}
	             * @default 1
	             */
	            this.declutterGroup = 1;
	        };

	        // Internal use only. Intentionally not documented.
	        GeographicText.placePoint = new Vec3(0, 0, 0); // Cartesian point corresponding to this placemark's geographic position

	        GeographicText.prototype = Object.create(Text.prototype);

	        /**
	         * Creates a new geographic text object that is a copy of this one.
	         * @returns {GeographicText} The new geographic text object.
	         */
	        GeographicText.prototype.clone = function () {
	            var clone = new GeographicText(this.position, this.text);

	            clone.copy(this);
	            clone.pickDelegate = this.pickDelegate ? this.pickDelegate : this;

	            return clone;
	        };

	        // Documented in superclass.
	        GeographicText.prototype.render = function (dc) {
	            // Filter out instances outside any projection limits.
	            if (dc.globe.projectionLimits
	                && !dc.globe.projectionLimits.containsLocation(this.position.latitude, this.position.longitude)) {
	                return;
	            }

	            Text.prototype.render.call(this, dc);
	        };

	        // Documented in superclass.
	        GeographicText.prototype.computeScreenPointAndEyeDistance = function (dc) {
	            // Compute the text's model point and corresponding distance to the eye point.
	            dc.surfacePointForMode(this.position.latitude, this.position.longitude, this.position.altitude,
	                this.altitudeMode, GeographicText.placePoint);

	            if (!dc.navigatorState.frustumInModelCoordinates.containsPoint(GeographicText.placePoint)) {
	                return false;
	            }

	            this.eyeDistance = this.alwaysOnTop ? 0 : dc.navigatorState.eyePoint.distanceTo(GeographicText.placePoint);

	            // Compute the text's screen point in the OpenGL coordinate system of the WorldWindow by projecting its model
	            // coordinate point onto the viewport. Apply a depth offset in order to cause the text to appear above nearby
	            // terrain. When text is displayed near the terrain portions of its geometry are often behind the terrain,
	            // yet as a screen element the text is expected to be visible. We adjust its depth values rather than moving
	            // the text itself to avoid obscuring its actual position.
	            if (!dc.navigatorState.projectWithDepth(GeographicText.placePoint, this.depthOffset, this.screenPoint)) {
	                return false;
	            }

	            return true;
	        };

	        return GeographicText;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports Text
	 * @version $Id: Text.js 3345 2015-07-28 20:28:35Z dcollins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(30),
	        __webpack_require__(129),
	        __webpack_require__(52),
	        __webpack_require__(128),
	        __webpack_require__(32),
	        __webpack_require__(63),
	        __webpack_require__(87),
	        __webpack_require__(130),
	        __webpack_require__(184),
	        __webpack_require__(66),
	        __webpack_require__(46),
	        __webpack_require__(35),
	        __webpack_require__(36)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
	              BasicTextureProgram,
	              Color,
	              Font,
	              Logger,
	              Matrix,
	              PickedObject,
	              Renderable,
	              TextAttributes,
	              UnsupportedOperationError,
	              Vec2,
	              Vec3,
	              WWMath) {
	        "use strict";

	        /**
	         * Constructs a text shape. This constructor is intended to be called only by subclasses.
	         * @alias Text
	         * @constructor
	         * @augments Renderable
	         * @classdesc Represents a string of text displayed at a specified geographic or screen position.
	         * This is an abstract class meant to be subclassed and not meant to be instantiated directly.
	         * See {@link GeographicText} and {@link ScreenText} for concrete classes.
	         *
	         * @param {String} text The text to display.
	         * @throws {ArgumentError} If the specified text is null or undefined.
	         */
	        var Text = function (text) {
	            if (!text) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Text", "constructor", "missingText"));
	            }

	            Renderable.call(this);

	            /**
	             * The text's attributes. If null and this text is not highlighted, this text is not drawn.
	             * @type {TextAttributes}
	             * @default see [TextAttributes]{@link TextAttributes}
	             */
	            this.attributes = new TextAttributes(null);

	            /**
	             * The attributes used when this text's highlighted flag is true. If null and the
	             * highlighted flag is true, this text's normal attributes are used. If they, too, are null, this
	             * text is not drawn.
	             * @type {TextAttributes}
	             * @default null
	             */
	            this.highlightAttributes = null;

	            /**
	             * Indicates whether this text uses its highlight attributes rather than its normal attributes.
	             * @type {boolean}
	             * @default false
	             */
	            this.highlighted = false;

	            /**
	             * Indicates whether this text is drawn.
	             * @type {boolean}
	             * @default true
	             */
	            this.enabled = true;

	            /**
	             * This shape's text. If null or empty, no text is drawn.
	             * @type {String}
	             * @default null
	             */
	            this.text = text;

	            /**
	             * This text's altitude mode. May be one of
	             * <ul>
	             *  <li>[WorldWind.ABSOLUTE]{@link WorldWind#ABSOLUTE}</li>
	             *  <li>[WorldWind.RELATIVE_TO_GROUND]{@link WorldWind#RELATIVE_TO_GROUND}</li>
	             *  <li>[WorldWind.CLAMP_TO_GROUND]{@link WorldWind#CLAMP_TO_GROUND}</li>
	             * </ul>
	             * @default WorldWind.ABSOLUTE
	             */
	            this.altitudeMode = WorldWind.ABSOLUTE;

	            /**
	             * Indicates the object to return as the userObject of this text when picked. If null,
	             * then this text object is returned as the userObject.
	             * @type {Object}
	             * @default null
	             * @see  [PickedObject.userObject]{@link PickedObject#userObject}
	             */
	            this.pickDelegate = null;

	            /**
	             * Indicates whether this text has visual priority over other shapes in the scene.
	             * @type {Boolean}
	             * @default false
	             */
	            this.alwaysOnTop = false;

	            /**
	             * This shape's target visibility, a value between 0 and 1. During ordered rendering this shape modifies its
	             * [current visibility]{@link Text#currentVisibility} towards its target visibility at the rate
	             * specified by the draw context's [fadeVelocity]{@link DrawContext#fadeVelocity} property. The target
	             * visibility and current visibility are used to control the fading in and out of this shape.
	             * @type {Number}
	             * @default 1
	             */
	            this.targetVisibility = 1;

	            /**
	             * This shape's current visibility, a value between 0 and 1. This property scales the shape's effective
	             * opacity. It is incremented or decremented each frame according to the draw context's
	             * [fade velocity]{@link DrawContext#fadeVelocity} property in order to achieve this shape's current
	             * [target visibility]{@link Text#targetVisibility}. This current visibility and target visibility are
	             * used to control the fading in and out of this shape.
	             * @type {Number}
	             * @default 1
	             * @readonly
	             */
	            this.currentVisibility = 1;

	            /**
	             * Indicates the group ID of the declutter group to include this Text shape. If non-zer0, this shape
	             * is decluttered relative to all other shapes within its group.
	             * @type {Number}
	             * @default 0
	             */
	            this.declutterGroup = 0;

	            /**
	             * The image to display when this text shape is eliminated from the scene due to decluttering.
	             * @type {String}
	             * @default A round dot drawn in this shape's text color.
	             */
	            this.markerImageSource = WorldWind.configuration.baseUrl + "images/white-dot.png";

	            /**
	             * The scale to apply to the [markerImageSource]{@link Text#markerImageSource}.
	             * @type {Number}
	             * @default 0.1
	             */
	            this.markerImageScale = 0.1;

	            // Internal use only. Intentionally not documented.
	            this.activeAttributes = null;

	            // Internal use only. Intentionally not documented.
	            this.activeTexture = null;

	            // Internal use only. Intentionally not documented.
	            this.imageTransform = Matrix.fromIdentity();

	            // Internal use only. Intentionally not documented.
	            this.texCoordMatrix = Matrix.fromIdentity();

	            // Internal use only. Intentionally not documented.
	            this.imageBounds = null;

	            // Internal use only. Intentionally not documented.
	            this.layer = null;

	            // Internal use only. Intentionally not documented.
	            this.depthOffset = -0.003;

	            // Internal use only. Intentionally not documented.
	            this.screenPoint = new Vec3(0, 0, 0);
	        };

	        // Internal use only. Intentionally not documented.
	        Text.matrix = Matrix.fromIdentity(); // scratch variable
	        Text.glPickPoint = new Vec3(0, 0, 0); // scratch variable

	        Text.prototype = Object.create(Renderable.prototype);

	        /**
	         * Copies the contents of a specified text object to this text object.
	         * @param {Text} that The text object to copy.
	         */
	        Text.prototype.copy = function (that) {
	            this.text = that.text;
	            this.attributes = that.attributes;
	            this.highlightAttributes = that.highlightAttributes;
	            this.highlighted = that.highlighted;
	            this.enabled = that.enabled;
	            this.altitudeMode = that.altitudeMode;
	            this.pickDelegate = that.pickDelegate;
	            this.alwaysOnTop = that.alwaysOnTop;
	            this.depthOffset = that.depthOffset;
	            this.declutterGroup = that.declutterGroup;
	            this.targetVisibility = that.targetVisibility;
	            this.currentVisibility = that.currentVisibility;

	            return this;
	        };

	        Object.defineProperties(Text.prototype, {
	            /**
	             * Indicates the screen coordinate bounds of this shape during ordered rendering.
	             * @type {Rectangle}
	             * @readonly
	             * @memberof Text.prototype
	             */
	            screenBounds: {
	                get: function () {
	                    return this.imageBounds;
	                }
	            }
	        });

	        /**
	         * Renders this text. This method is typically not called by applications but is called by
	         * [RenderableLayer]{@link RenderableLayer} during rendering. For this shape this method creates and
	         * enques an ordered renderable with the draw context and does not actually draw the text.
	         * @param {DrawContext} dc The current draw context.
	         */
	        Text.prototype.render = function (dc) {
	            if (!this.enabled || (!this.text) || this.text.length === 0) {
	                return;
	            }

	            if (!dc.accumulateOrderedRenderables) {
	                return;
	            }

	            // Create an ordered renderable for this text. If one has already been created this frame then we're
	            // in 2D-continuous mode and another needs to be created for one of the alternate globe offsets.
	            var orderedText;
	            if (this.lastFrameTime != dc.timestamp) {
	                orderedText = this.makeOrderedRenderable(dc);
	            } else {
	                var textCopy = this.clone();
	                orderedText = textCopy.makeOrderedRenderable(dc);
	            }

	            if (!orderedText) {
	                return;
	            }

	            if (!orderedText.isVisible(dc)) {
	                return;
	            }

	            orderedText.layer = dc.currentLayer;

	            this.lastFrameTime = dc.timestamp;
	            dc.addOrderedRenderable(orderedText);
	        };

	        /**
	         * Draws this shape as an ordered renderable. Applications do not call this function. It is called by
	         * {@link WorldWindow} during rendering. Implements the {@link OrderedRenderable} interface.
	         * @param {DrawContext} dc The current draw context.
	         */
	        Text.prototype.renderOrdered = function (dc) {
	            // Optimize away the case of achieved target visibility of 0 and no marker image to display in that case.
	            if (this.currentVisibility === 0 && this.targetVisibility === 0 && !this.markerImageSource) {
	                return;
	            }

	            this.drawOrderedText(dc);

	            if (dc.pickingMode) {
	                var po = new PickedObject(this.pickColor.clone(), this.pickDelegate ? this.pickDelegate : this,
	                    this.position, this.layer, false);

	                dc.resolvePick(po);
	            }
	        };

	        // Intentionally not documented.
	        Text.prototype.makeOrderedRenderable = function (dc) {
	            var w, h, s,
	                offset;

	            this.determineActiveAttributes(dc);
	            if (!this.activeAttributes) {
	                return null;
	            }

	            //// Compute the text's screen point and distance to the eye point.
	            if (!this.computeScreenPointAndEyeDistance(dc)) {
	                return null;
	            }

	            var labelFont = this.activeAttributes.font,
	                textureKey = this.text + labelFont.toString();

	            this.activeTexture = dc.gpuResourceCache.resourceForKey(textureKey);
	            if (!this.activeTexture) {
	                this.activeTexture = dc.textSupport.createTexture(dc, this.text, labelFont, true);
	                dc.gpuResourceCache.putResource(textureKey, this.activeTexture, this.activeTexture.size);
	            }

	            w = this.activeTexture.imageWidth;
	            h = this.activeTexture.imageHeight;
	            s = this.activeAttributes.scale;
	            offset = this.activeAttributes.offset.offsetForSize(w, h);

	            this.imageTransform.setTranslation(
	                this.screenPoint[0] - offset[0] * s,
	                this.screenPoint[1] - offset[1] * s,
	                this.screenPoint[2]);

	            this.imageTransform.setScale(w * s, h * s, 1);

	            this.imageBounds = WWMath.boundingRectForUnitQuad(this.imageTransform);

	            return this;
	        };

	        /**
	         * Computes this shape's screen point and eye distance. Subclasses must override this method.
	         * @param {DrawContext} dc The current draw context.
	         * @returns {Boolean} true if the screen point can be computed, otherwise false.
	         * @protected
	         */
	        Text.prototype.computeScreenPointAndEyeDistance = function (dc) {
	            throw new UnsupportedOperationError(
	                Logger.logMessage(Logger.LEVEL_SEVERE, "Renderable", "render", "abstractInvocation"));
	        };

	        // Internal. Intentionally not documented.
	        Text.prototype.determineActiveAttributes = function (dc) {
	            if (this.highlighted && this.highlightAttributes) {
	                this.activeAttributes = this.highlightAttributes;
	            } else {
	                this.activeAttributes = this.attributes;
	            }
	        };

	        // Internal. Intentionally not documented.
	        Text.prototype.isVisible = function (dc) {
	            if (dc.pickingMode) {
	                return dc.pickRectangle && this.imageBounds.intersects(dc.pickRectangle);
	            } else {
	                return this.imageBounds.intersects(dc.navigatorState.viewport);
	            }
	        };

	        // Internal. Intentionally not documented.
	        Text.prototype.drawOrderedText = function (dc) {
	            this.beginDrawing(dc);

	            try {
	                this.doDrawOrderedText(dc);
	                if (!dc.pickingMode) {
	                    //this.drawBatchOrderedText(dc);
	                }
	            } finally {
	                this.endDrawing(dc);
	            }
	        };

	        // Internal. Intentionally not documented.
	        Text.prototype.drawBatchOrderedText = function (dc) {
	            // Draw any subsequent text in the ordered renderable queue, removing each from the queue as it's
	            // processed. This avoids the overhead of setting up and tearing down OpenGL state for each text shape.

	            var or;

	            while ((or = dc.peekOrderedRenderable()) && or instanceof Text) {
	                dc.popOrderedRenderable(); // remove it from the queue

	                try {
	                    or.doDrawOrderedText(dc)
	                } catch (e) {
	                    Logger.logMessage(Logger.LEVEL_WARNING, 'Text', 'drawBatchOrderedText',
	                        "Error occurred while rendering text using batching: " + e.message);
	                }
	                // Keep going. Render the rest of the ordered renderables.
	            }
	        };

	        // Internal. Intentionally not documented.
	        Text.prototype.beginDrawing = function (dc) {
	            var gl = dc.currentGlContext,
	                program;

	            dc.findAndBindProgram(BasicTextureProgram);

	            // Configure GL to use the draw context's unit quad VBOs for both model coordinates and texture coordinates.
	            // Most browsers can share the same buffer for vertex and texture coordinates, but Internet Explorer requires
	            // that they be in separate buffers, so the code below uses the 3D buffer for vertex coords and the 2D
	            // buffer for texture coords.
	            program = dc.currentProgram;
	            gl.bindBuffer(gl.ARRAY_BUFFER, dc.unitQuadBuffer3());
	            gl.vertexAttribPointer(program.vertexPointLocation, 3, gl.FLOAT, false, 0, 0);
	            gl.bindBuffer(gl.ARRAY_BUFFER, dc.unitQuadBuffer());
	            gl.vertexAttribPointer(program.vertexTexCoordLocation, 2, gl.FLOAT, false, 0, 0);
	            gl.enableVertexAttribArray(program.vertexPointLocation);
	            gl.enableVertexAttribArray(program.vertexTexCoordLocation);

	            // Tell the program which texture unit to use.
	            program.loadTextureUnit(gl, gl.TEXTURE0);

	            // Turn off texturing in picking mode.
	            if (dc.pickingMode) {
	                program.loadTextureEnabled(gl, false);
	            }

	            // Turn off color modulation since we want to pick against the text box and not just the text.
	            program.loadModulateColor(gl, false);

	            // Suppress depth-buffer writes.
	            gl.depthMask(false);

	            // The currentTexture field is used to avoid re-specifying textures unnecessarily. Clear it to start.
	            Text.currentTexture = null;
	        };

	        // Internal. Intentionally not documented.
	        Text.prototype.endDrawing = function (dc) {
	            var gl = dc.currentGlContext,
	                program = dc.currentProgram;

	            // Clear the vertex attribute state.
	            gl.disableVertexAttribArray(program.vertexPointLocation);
	            gl.disableVertexAttribArray(program.vertexTexCoordLocation);

	            // Clear GL bindings.
	            gl.bindBuffer(gl.ARRAY_BUFFER, null);
	            gl.bindTexture(gl.TEXTURE_2D, null);

	            gl.depthMask(true);

	            // Avoid keeping a dangling reference to the current texture.
	            Text.currentTexture = null;
	        };

	        // Internal. Intentionally not documented.
	        Text.prototype.doDrawOrderedText = function (dc) {
	            var gl = dc.currentGlContext,
	                program = dc.currentProgram,
	                textureBound;

	            if (dc.pickingMode) {
	                this.pickColor = dc.uniquePickColor();
	            }

	            // Compute the effective visibility. Use the current value if picking.
	            if (!dc.pickingMode) {
	                if (this.currentVisibility != this.targetVisibility) {
	                    var visibilityDelta = (dc.timestamp - dc.previousRedrawTimestamp) / dc.fadeTime;
	                    if (this.currentVisibility < this.targetVisibility) {
	                        this.currentVisibility = Math.min(1, this.currentVisibility + visibilityDelta);
	                    } else {
	                        this.currentVisibility = Math.max(0, this.currentVisibility - visibilityDelta);
	                    }
	                    dc.redrawRequested = true;
	                }
	            }

	            if (this.currentVisibility > 0) {
	                // Draw the text, with its effective opacity scaled by the current visibility.

	                // Compute and specify the MVP matrix.
	                Text.matrix.copy(dc.screenProjection);
	                Text.matrix.multiplyMatrix(this.imageTransform);
	                program.loadModelviewProjection(gl, Text.matrix);

	                // Set the pick color for picking or the color, opacity and texture if not picking.
	                if (dc.pickingMode) {
	                    program.loadColor(gl, this.pickColor);
	                    program.loadTextureEnabled(gl, false);
	                } else {
	                    program.loadColor(gl, this.activeAttributes.color);
	                    program.loadOpacity(gl, this.layer.opacity * this.currentVisibility);

	                    this.texCoordMatrix.setToIdentity();
	                    if (this.activeTexture) {
	                        this.texCoordMatrix.multiplyByTextureTransform(this.activeTexture);
	                    }
	                    program.loadTextureMatrix(gl, this.texCoordMatrix);

	                    // Avoid unnecessary texture state changes
	                    if (this.activeTexture && this.activeTexture != Text.currentTexture) {
	                        textureBound = this.activeTexture.bind(dc); // returns false if texture is null or cannot be bound
	                        program.loadTextureEnabled(gl, textureBound);
	                        Text.currentTexture = this.activeTexture;
	                    }
	                }

	                // Turn off depth testing for the label unless it's been requested.
	                if (!this.activeAttributes.depthTest) {
	                    gl.disable(gl.DEPTH_TEST, false);
	                }
	                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
	                if (!this.activeAttributes.depthTest) {
	                    // Turn depth testing back on.
	                    gl.disable(gl.DEPTH_TEST, true);
	                }
	            }

	            if (this.currentVisibility < 1 && this.markerImageSource) {
	                // Draw an icon at the text's geographic position to indicate that something is there.

	                var markerTexture = dc.gpuResourceCache.resourceForKey(this.markerImageSource);
	                if (!markerTexture) {
	                    dc.gpuResourceCache.retrieveTexture(dc.currentGlContext, this.markerImageSource);
	                    return;
	                }

	                var s = this.markerImageScale;
	                var markerTransform = Matrix.fromIdentity();
	                markerTransform.setTranslation(
	                    this.screenPoint[0] - s * markerTexture.imageWidth / 2,
	                    this.screenPoint[1] - s * markerTexture.imageWidth / 2,
	                    this.screenPoint[2]);

	                markerTransform.setScale(markerTexture.imageWidth * s, markerTexture.imageHeight * s, 1);

	                Text.matrix.copy(dc.screenProjection);
	                Text.matrix.multiplyMatrix(markerTransform);
	                program.loadModelviewProjection(gl, Text.matrix);

	                if (dc.pickingMode) {
	                    program.loadColor(gl, this.pickColor);
	                    program.loadTextureEnabled(gl, false);
	                } else {
	                    program.loadColor(gl, this.activeAttributes.color);
	                    program.loadOpacity(gl, this.layer.opacity * ( 1 - this.currentVisibility));

	                    var tcMatrix = Matrix.fromIdentity();
	                    tcMatrix.multiplyByTextureTransform(markerTexture);
	                    program.loadTextureMatrix(gl, tcMatrix);

	                    // Avoid unnecessary texture state changes
	                    if (markerTexture != Text.currentTexture) {
	                        textureBound = markerTexture.bind(dc); // returns false if texture is null or cannot be bound
	                        program.loadTextureEnabled(gl, textureBound);
	                        Text.currentTexture = markerTexture;
	                    }
	                }

	                // Turn off depth testing unless it's been requested.
	                if (!this.activeAttributes.depthTest) {
	                    gl.disable(gl.DEPTH_TEST, false);
	                }
	                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
	                if (!this.activeAttributes.depthTest) {
	                    // Turn depth testing back on.
	                    gl.enable(gl.DEPTH_TEST, true);
	                }
	            }
	        };

	        return Text;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports Placemark
	 * @version $Id: Placemark.js 3345 2015-07-28 20:28:35Z dcollins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(30),
	        __webpack_require__(129),
	        __webpack_require__(52),
	        __webpack_require__(128),
	        __webpack_require__(32),
	        __webpack_require__(63),
	        __webpack_require__(87),
	        __webpack_require__(183),
	        __webpack_require__(130),
	        __webpack_require__(46),
	        __webpack_require__(35),
	        __webpack_require__(36)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
	              BasicTextureProgram,
	              Color,
	              Font,
	              Logger,
	              Matrix,
	              PickedObject,
	              PlacemarkAttributes,
	              Renderable,
	              Vec2,
	              Vec3,
	              WWMath) {
	        "use strict";

	        /**
	         * Constructs a placemark.
	         * @alias Placemark
	         * @constructor
	         * @augments Renderable
	         * @classdesc Represents a Placemark shape. A placemark displays an image, a label and a leader line connecting
	         * the placemark's geographic position to the ground. All three of these items are optional. By default, the
	         * leader line is not pickable. See [enableLeaderLinePicking]{@link Placemark#enableLeaderLinePicking}.
	         * <p>
	         * Placemarks may be drawn with either an image or as single-color square with a specified size. When the
	         * placemark attributes indicate a valid image, the placemark's image is drawn as a rectangle in the
	         * image's original dimensions, scaled by the image scale attribute. Otherwise, the placemark is drawn as a
	         * square with width and height equal to the value of the image scale attribute, in pixels, and color equal
	         * to the image color attribute.
	         * <p>
	         * By default, placemarks participate in decluttering with a [declutterGroupID]{@link Placemark#declutterGroup}
	         * of 2. Only placemark labels are decluttered relative to other placemark labels. The placemarks themselves
	         * are optionally scaled with eye distance to achieve decluttering of the placemark as a whole.
	         * See [eyeDistanceScaling]{@link Placemark#eyeDistanceScaling}.
	         * @param {Position} position The placemark's geographic position.
	         * @param {Boolean} eyeDistanceScaling Indicates whether the size of this placemark scales with eye distance.
	         * See [eyeDistanceScalingThreshold]{@link Placemark#eyeDistanceScalingThreshold} and
	         * [eyeDistanceScalingLabelThreshold]{@link Placemark#eyeDistanceScalingLabelThreshold}.
	         * @param {PlacemarkAttributes} attributes The attributes to associate with this placemark. May be null,
	         * in which case default attributes are associated.
	         * @throws {ArgumentError} If the specified position is null or undefined.
	         */
	        var Placemark = function (position, eyeDistanceScaling, attributes) {
	            if (!position) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Placemark", "constructor", "missingPosition"));
	            }

	            Renderable.call(this);

	            /**
	             * The placemark's attributes. If null and this placemark is not highlighted, this placemark is not
	             * drawn.
	             * @type {PlacemarkAttributes}
	             * @default see [PlacemarkAttributes]{@link PlacemarkAttributes}
	             */
	            this.attributes = attributes ? attributes : new PlacemarkAttributes(null);

	            /**
	             * The attributes used when this placemark's highlighted flag is true. If null and the
	             * highlighted flag is true, this placemark's normal attributes are used. If they, too, are null, this
	             * placemark is not drawn.
	             * @type {PlacemarkAttributes}
	             * @default null
	             */
	            this.highlightAttributes = null;

	            /**
	             * Indicates whether this placemark uses its highlight attributes rather than its normal attributes.
	             * @type {Boolean}
	             * @default false
	             */
	            this.highlighted = false;

	            /**
	             * This placemark's geographic position.
	             * @type {Position}
	             */
	            this.position = position;

	            /**
	             * Indicates whether this placemark's size is reduced at higher eye distances. If true, this placemark's
	             * size is scaled inversely proportional to the eye distance if the eye distance is greater than the
	             * value of the [eyeDistanceScalingThreshold]{@link Placemark#eyeDistanceScalingThreshold} property.
	             * When the eye distance is below the threshold, this placemark is scaled only according to the
	             * [imageScale]{@link PlacemarkAttributes#imageScale}.
	             * @type {Boolean}
	             */
	            this.eyeDistanceScaling = eyeDistanceScaling;

	            /**
	             * The eye distance above which to reduce the size of this placemark, in meters. If
	             * [eyeDistanceScaling]{@link Placemark#eyeDistanceScaling} is true, this placemark's image, label and leader
	             * line sizes are reduced as the eye distance increases beyond this threshold.
	             * @type {Number}
	             * @default 1e6 (meters)
	             */
	            this.eyeDistanceScalingThreshold = 1e6;

	            /**
	             * The eye altitude above which this placemark's label is not displayed.
	             * @type {number}
	             */
	            this.eyeDistanceScalingLabelThreshold = 1.5 * this.eyeDistanceScalingThreshold;

	            /**
	             * This placemark's textual label. If null, no label is drawn.
	             * @type {String}
	             * @default null
	             */
	            this.label = null;

	            /**
	             * This placemark's altitude mode. May be one of
	             * <ul>
	             *  <li>[WorldWind.ABSOLUTE]{@link WorldWind#ABSOLUTE}</li>
	             *  <li>[WorldWind.RELATIVE_TO_GROUND]{@link WorldWind#RELATIVE_TO_GROUND}</li>
	             *  <li>[WorldWind.CLAMP_TO_GROUND]{@link WorldWind#CLAMP_TO_GROUND}</li>
	             * </ul>
	             * @default WorldWind.ABSOLUTE
	             */
	            this.altitudeMode = WorldWind.ABSOLUTE;

	            /**
	             * Indicates whether this placemark has visual priority over other shapes in the scene.
	             * @type {Boolean}
	             * @default false
	             */
	            this.alwaysOnTop = false;

	            /**
	             * Indicates whether this placemark's leader line, if any, is pickable.
	             * @type {Boolean}
	             * @default false
	             */
	            this.enableLeaderLinePicking = false;

	            /**
	             * Indicates whether this placemark's image should be re-retrieved even if it has already been retrieved.
	             * Set this property to true when the image has changed but has the same image path.
	             * The property is set to false when the image is re-retrieved.
	             * @type {Boolean}
	             */
	            this.updateImage = true;

	            /**
	             * Indicates the group ID of the declutter group to include this Text shape. If non-zero, this shape
	             * is decluttered relative to all other shapes within its group.
	             * @type {Number}
	             * @default 2
	             */
	            this.declutterGroup = 2;

	            /**
	             * This shape's target visibility, a value between 0 and 1. During ordered rendering this shape modifies its
	             * [current visibility]{@link Text#currentVisibility} towards its target visibility at the rate
	             * specified by the draw context's [fade time]{@link DrawContext#fadeTime} property. The target
	             * visibility and current visibility are used to control the fading in and out of this shape.
	             * @type {Number}
	             * @default 1
	             */
	            this.targetVisibility = 1;

	            /**
	             * This shape's current visibility, a value between 0 and 1. This property scales the shape's effective
	             * opacity. It is incremented or decremented each frame according to the draw context's
	             * [fade time]{@link DrawContext#fadeTime} property in order to achieve this shape's current
	             * [target visibility]{@link Text#targetVisibility}. This current visibility and target visibility are
	             * used to control the fading in and out of this shape.
	             * @type {Number}
	             * @default 1
	             * @readonly
	             */
	            this.currentVisibility = 1;

	            /**
	             * The amount of rotation to apply to the image, measured in degrees clockwise and relative to this
	             * placemark's [imageRotationReference]{@link Placemark#imageRotationReference}.
	             * @type {Number}
	             * @default 0
	             */
	            this.imageRotation = 0;

	            /**
	             * The amount of tilt to apply to the image, measured in degrees away from the eye point and relative
	             * to this placemark's [imageTiltReference]{@link Placemark#imageTiltReference}. While any positive or
	             * negative number may be specified, values outside the range [0. 90] cause some or all of the image to
	             * be clipped.
	             * @type {Number}
	             * @default 0
	             */
	            this.imageTilt = 0;

	            /**
	             * Indicates whether to apply this placemark's image rotation relative to the screen or the globe.
	             * If WorldWind.RELATIVE_TO_SCREEN, this placemark's image is rotated in the plane of the screen and
	             * its orientation relative to the globe changes as the view changes.
	             * If WorldWind.RELATIVE_TO_GLOBE, this placemark's image is rotated in a plane tangent to the globe
	             * at this placemark's position and retains its orientation relative to the globe.
	             * @type {String}
	             * @default WorldWind.RELATIVE_TO_SCREEN
	             */
	            this.imageRotationReference = WorldWind.RELATIVE_TO_SCREEN;

	            /**
	             * Indicates whether to apply this placemark's image tilt relative to the screen or the globe.
	             * If WorldWind.RELATIVE_TO_SCREEN, this placemark's image is tilted inwards (for positive tilts)
	             * relative to the plane of the screen, and its orientation relative to the globe changes as the view
	             * changes. If WorldWind.RELATIVE_TO_GLOBE, this placemark's image is tilted towards the globe's surface,
	             * and retains its orientation relative to the surface.
	             * @type {string}
	             * @default WorldWind.RELATIVE_TO_SCREEN
	             */
	            this.imageTiltReference = WorldWind.RELATIVE_TO_SCREEN;

	            // Internal use only. Intentionally not documented.
	            this.activeAttributes = null;

	            // Internal use only. Intentionally not documented.
	            this.activeTexture = null;

	            // Internal use only. Intentionally not documented.
	            this.labelTexture = null;

	            // Internal use only. Intentionally not documented.
	            this.placePoint = new Vec3(0, 0, 0); // Cartesian point corresponding to this placemark's geographic position

	            // Internal use only. Intentionally not documented.
	            this.groundPoint = new Vec3(0, 0, 0); // Cartesian point corresponding to ground position below this placemark

	            // Internal use only. Intentionally not documented.
	            this.imageTransform = Matrix.fromIdentity();

	            // Internal use only. Intentionally not documented.
	            this.labelTransform = Matrix.fromIdentity();

	            // Internal use only. Intentionally not documented.
	            this.texCoordMatrix = Matrix.fromIdentity();

	            // Internal use only. Intentionally not documented.
	            this.imageBounds = null;

	            // Internal use only. Intentionally not documented.
	            this.layer = null;

	            // Internal use only. Intentionally not documented.
	            this.depthOffset = -0.003;
	        };

	        // Internal use only. Intentionally not documented.
	        Placemark.screenPoint = new Vec3(0, 0, 0); // scratch variable
	        Placemark.matrix = Matrix.fromIdentity(); // scratch variable
	        Placemark.scratchPoint = new Vec3(0, 0, 0); // scratch variable

	        Placemark.prototype = Object.create(Renderable.prototype);

	        Object.defineProperties(Placemark.prototype, {
	            /**
	             * Indicates the screen coordinate bounds of this shape during ordered rendering.
	             * @type {Rectangle}
	             * @readonly
	             * @memberof Placemark.prototype
	             */
	            screenBounds: {
	                get: function () {
	                    return this.labelBounds;
	                }
	            }
	        });

	        /**
	         * Copies the contents of a specified placemark to this placemark.
	         * @param {Placemark} that The placemark to copy.
	         */
	        Placemark.prototype.copy = function (that) {
	            this.position = that.position;
	            this.attributes = that.attributes;
	            this.highlightAttributes = that.highlightAttributes;
	            this.highlighted = that.highlighted;
	            this.enabled = that.enabled;
	            this.label = that.label;
	            this.altitudeMode = that.altitudeMode;
	            this.pickDelegate = that.pickDelegate;
	            this.alwaysOnTop = that.alwaysOnTop;
	            this.depthOffset = that.depthOffset;
	            this.targetVisibility = that.targetVisibility;
	            this.currentVisibility = that.currentVisibility;
	            this.imageRotation = that.imageRotation;
	            this.imageTilt = that.imageTilt;
	            this.imageRotationReference = that.imageRotationReference;
	            this.imageTiltReference = that.imageTiltReference;

	            return this;
	        };

	        /**
	         * Creates a new placemark that is a copy of this placemark.
	         * @returns {Placemark} The new placemark.
	         */
	        Placemark.prototype.clone = function () {
	            var clone = new Placemark(this.position);

	            clone.copy(this);
	            clone.pickDelegate = this.pickDelegate ? this.pickDelegate : this;

	            return clone;
	        };

	        /**
	         * Renders this placemark. This method is typically not called by applications but is called by
	         * {@link RenderableLayer} during rendering. For this shape this method creates and
	         * enques an ordered renderable with the draw context and does not actually draw the placemark.
	         * @param {DrawContext} dc The current draw context.
	         */
	        Placemark.prototype.render = function (dc) {
	            if (!this.enabled) {
	                return;
	            }

	            if (!dc.accumulateOrderedRenderables) {
	                return;
	            }

	            if (dc.globe.projectionLimits
	                && !dc.globe.projectionLimits.containsLocation(this.position.latitude, this.position.longitude)) {
	                return;
	            }

	            // Create an ordered renderable for this placemark. If one has already been created this frame then we're
	            // in 2D-continuous mode and another needs to be created for one of the alternate globe offsets.
	            var orderedPlacemark;
	            if (this.lastFrameTime !== dc.timestamp) {
	                orderedPlacemark = this.makeOrderedRenderable(dc);
	            } else {
	                var placemarkCopy = this.clone();
	                orderedPlacemark = placemarkCopy.makeOrderedRenderable(dc);
	            }

	            if (!orderedPlacemark) {
	                return;
	            }

	            if (!orderedPlacemark.isVisible(dc)) {
	                return;
	            }

	            orderedPlacemark.layer = dc.currentLayer;

	            this.lastFrameTime = dc.timestamp;
	            dc.addOrderedRenderable(orderedPlacemark);
	        };

	        /**
	         * Draws this shape as an ordered renderable. Applications do not call this function. It is called by
	         * [WorldWindow]{@link WorldWindow} during rendering.
	         * @param {DrawContext} dc The current draw context.
	         */
	        Placemark.prototype.renderOrdered = function (dc) {
	            this.drawOrderedPlacemark(dc);

	            if (dc.pickingMode) {
	                var po = new PickedObject(this.pickColor.clone(), this.pickDelegate ? this.pickDelegate : this,
	                    this.position, this.layer, false);

	                if (dc.pickPoint && this.mustDrawLabel()) {
	                    if (this.labelBounds.containsPoint(
	                            dc.navigatorState.convertPointToViewport(dc.pickPoint, Placemark.scratchPoint))) {
	                        po.labelPicked = true;
	                    }
	                }
	                dc.resolvePick(po);
	            }
	        };

	        /* INTENTIONALLY NOT DOCUMENTED
	         * Creates an ordered renderable for this shape.
	         * @protected
	         * @param {DrawContext} dc The current draw context.
	         * @returns {OrderedRenderable} The ordered renderable. May be null, in which case an ordered renderable
	         * cannot be created or should not be created at the time this method is called.
	         */
	        Placemark.prototype.makeOrderedRenderable = function (dc) {
	            var w, h, s,
	                offset;

	            this.determineActiveAttributes(dc);
	            if (!this.activeAttributes) {
	                return null;
	            }

	            // Compute the placemark's model point and corresponding distance to the eye point. If the placemark's
	            // position is terrain-dependent but off the terrain, then compute it ABSOLUTE so that we have a point for
	            // the placemark and are thus able to draw it. Otherwise its image and label portion that are potentially
	            // over the terrain won't get drawn, and would disappear as soon as there is no terrain at the placemark's
	            // position. This can occur at the window edges.
	            dc.surfacePointForMode(this.position.latitude, this.position.longitude, this.position.altitude,
	                this.altitudeMode, this.placePoint);

	            this.eyeDistance = this.alwaysOnTop ? 0 : dc.navigatorState.eyePoint.distanceTo(this.placePoint);

	            if (this.mustDrawLeaderLine(dc)) {
	                dc.surfacePointForMode(this.position.latitude, this.position.longitude, 0,
	                    this.altitudeMode, this.groundPoint);
	            }

	            // Compute the placemark's screen point in the OpenGL coordinate system of the WorldWindow by projecting its model
	            // coordinate point onto the viewport. Apply a depth offset in order to cause the placemark to appear above nearby
	            // terrain. When a placemark is displayed near the terrain portions of its geometry are often behind the terrain,
	            // yet as a screen element the placemark is expected to be visible. We adjust its depth values rather than moving
	            // the placemark itself to avoid obscuring its actual position.
	            if (!dc.navigatorState.projectWithDepth(this.placePoint, this.depthOffset, Placemark.screenPoint)) {
	                return null;
	            }

	            var visibilityScale = this.eyeDistanceScaling ?
	                Math.max(0.0, Math.min(1, this.eyeDistanceScalingThreshold / this.eyeDistance)) : 1;

	            // Compute the placemark's transform matrix and texture coordinate matrix according to its screen point, image size,
	            // image offset and image scale. The image offset is defined with its origin at the image's bottom-left corner and
	            // axes that extend up and to the right from the origin point. When the placemark has no active texture the image
	            // scale defines the image size and no other scaling is applied.
	            if (this.activeTexture) {
	                w = this.activeTexture.originalImageWidth;
	                h = this.activeTexture.originalImageHeight;
	                s = this.activeAttributes.imageScale * visibilityScale;
	                offset = this.activeAttributes.imageOffset.offsetForSize(w, h);

	                this.imageTransform.setTranslation(
	                    Placemark.screenPoint[0] - offset[0] * s,
	                    Placemark.screenPoint[1] - offset[1] * s,
	                    Placemark.screenPoint[2]);

	                this.imageTransform.setScale(w * s, h * s, 1);
	            } else {
	                s = this.activeAttributes.imageScale * visibilityScale;
	                offset = this.activeAttributes.imageOffset.offsetForSize(s, s);

	                this.imageTransform.setTranslation(
	                    Placemark.screenPoint[0] - offset[0],
	                    Placemark.screenPoint[1] - offset[1],
	                    Placemark.screenPoint[2]);

	                this.imageTransform.setScale(s, s, 1);
	            }

	            this.imageBounds = WWMath.boundingRectForUnitQuad(this.imageTransform);

	            // If there's a label, perform these same operations for the label texture, creating that texture if it
	            // doesn't already exist.

	            if (this.mustDrawLabel()) {
	                var labelFont = this.activeAttributes.labelAttributes.font,
	                    labelKey = this.label + labelFont.toString();

	                this.labelTexture = dc.gpuResourceCache.resourceForKey(labelKey);
	                if (!this.labelTexture) {
	                    this.labelTexture = dc.textSupport.createTexture(dc, this.label, labelFont, true);
	                    dc.gpuResourceCache.putResource(labelKey, this.labelTexture, this.labelTexture.size);
	                }

	                w = this.labelTexture.imageWidth;
	                h = this.labelTexture.imageHeight;
	                s = this.activeAttributes.labelAttributes.scale * visibilityScale;
	                offset = this.activeAttributes.labelAttributes.offset.offsetForSize(w, h);

	                this.labelTransform.setTranslation(
	                    Placemark.screenPoint[0] - offset[0] * s,
	                    Placemark.screenPoint[1] - offset[1] * s,
	                    Placemark.screenPoint[2]);

	                this.labelTransform.setScale(w * s, h * s, 1);

	                this.labelBounds = WWMath.boundingRectForUnitQuad(this.labelTransform);
	            }

	            return this;
	        };

	        // Internal. Intentionally not documented.
	        Placemark.prototype.determineActiveAttributes = function (dc) {
	            if (this.highlighted && this.highlightAttributes) {
	                this.activeAttributes = this.highlightAttributes;
	            } else {
	                this.activeAttributes = this.attributes;
	            }

	            if (this.activeAttributes && this.activeAttributes.imageSource) {
	                this.activeTexture = dc.gpuResourceCache.resourceForKey(this.activeAttributes.imageSource);

	                if (!this.activeTexture || this.updateImage) {
	                    this.activeTexture = dc.gpuResourceCache.retrieveTexture(dc.currentGlContext,
	                        this.activeAttributes.imageSource);
	                    this.updateImage = false;
	                }
	            }
	        };

	        // Internal. Intentionally not documented.
	        Placemark.prototype.isVisible = function (dc) {
	            if (dc.pickingMode) {
	                return dc.pickRectangle && (this.imageBounds.intersects(dc.pickRectangle)
	                    || (this.mustDrawLabel() && this.labelBounds.intersects(dc.pickRectangle))
	                    || (this.mustDrawLeaderLine(dc)
	                    && dc.pickFrustum.intersectsSegment(this.groundPoint, this.placePoint)));
	            } else {
	                return this.imageBounds.intersects(dc.navigatorState.viewport)
	                    || (this.mustDrawLabel() && this.labelBounds.intersects(dc.navigatorState.viewport))
	                    || (this.mustDrawLeaderLine(dc)
	                    && dc.navigatorState.frustumInModelCoordinates.intersectsSegment(this.groundPoint, this.placePoint));
	            }
	        };

	        // Internal. Intentionally not documented.
	        Placemark.prototype.drawOrderedPlacemark = function (dc) {
	            this.beginDrawing(dc);

	            try {
	                this.doDrawOrderedPlacemark(dc);
	                if (!dc.pickingMode) {
	                    this.drawBatchOrderedPlacemarks(dc);
	                }
	            } finally {
	                this.endDrawing(dc);
	            }
	        };

	        // Internal. Intentionally not documented.
	        Placemark.prototype.drawBatchOrderedPlacemarks = function (dc) {
	            // Draw any subsequent placemarks in the ordered renderable queue, removing each from the queue as it's
	            // processed. This avoids the overhead of setting up and tearing down OpenGL state for each placemark.

	            var or;

	            while ((or = dc.peekOrderedRenderable()) && or.doDrawOrderedPlacemark) {
	                dc.popOrderedRenderable(); // remove it from the queue

	                try {
	                    or.doDrawOrderedPlacemark(dc)
	                } catch (e) {
	                    Logger.logMessage(Logger.LEVEL_WARNING, 'Placemark', 'drawBatchOrderedPlacemarks',
	                        "Error occurred while rendering placemark using batching: " + e.message);
	                }
	                // Keep going. Render the rest of the ordered renderables.
	            }
	        };

	        // Internal. Intentionally not documented.
	        Placemark.prototype.beginDrawing = function (dc) {
	            var gl = dc.currentGlContext,
	                program;

	            dc.findAndBindProgram(BasicTextureProgram);

	            // Configure GL to use the draw context's unit quad VBOs for both model coordinates and texture coordinates.
	            // Most browsers can share the same buffer for vertex and texture coordinates, but Internet Explorer requires
	            // that they be in separate buffers, so the code below uses the 3D buffer for vertex coords and the 2D
	            // buffer for texture coords.
	            program = dc.currentProgram;
	            gl.bindBuffer(gl.ARRAY_BUFFER, dc.unitQuadBuffer());
	            gl.vertexAttribPointer(program.vertexTexCoordLocation, 2, gl.FLOAT, false, 0, 0);
	            gl.enableVertexAttribArray(program.vertexPointLocation);
	            gl.enableVertexAttribArray(program.vertexTexCoordLocation);

	            // Tell the program which texture unit to use.
	            program.loadTextureUnit(gl, gl.TEXTURE0);
	            program.loadModulateColor(gl, dc.pickingMode);
	        };

	        // Internal. Intentionally not documented.
	        Placemark.prototype.endDrawing = function (dc) {
	            var gl = dc.currentGlContext,
	                program = dc.currentProgram;

	            // Clear the vertex attribute state.
	            gl.disableVertexAttribArray(program.vertexPointLocation);
	            gl.disableVertexAttribArray(program.vertexTexCoordLocation);

	            // Clear GL bindings.
	            gl.bindBuffer(gl.ARRAY_BUFFER, null);
	            gl.bindTexture(gl.TEXTURE_2D, null);
	        };

	        // Internal. Intentionally not documented.
	        Placemark.prototype.doDrawOrderedPlacemark = function (dc) {
	            var gl = dc.currentGlContext,
	                program = dc.currentProgram,
	                depthTest = true,
	                textureBound;

	            if (dc.pickingMode) {
	                this.pickColor = dc.uniquePickColor();
	            }

	            if (this.eyeDistanceScaling && (this.eyeDistance > this.eyeDistanceScalingLabelThreshold)) {
	                // Target visibility is set to 0 to cause the label to be faded in or out. Nothing else
	                // here uses target visibility.
	                this.targetVisibility = 0;
	            }

	            // Compute the effective visibility. Use the current value if picking.
	            if (!dc.pickingMode && this.mustDrawLabel()) {
	                if (this.currentVisibility != this.targetVisibility) {
	                    var visibilityDelta = (dc.timestamp - dc.previousRedrawTimestamp) / dc.fadeTime;
	                    if (this.currentVisibility < this.targetVisibility) {
	                        this.currentVisibility = Math.min(1, this.currentVisibility + visibilityDelta);
	                    } else {
	                        this.currentVisibility = Math.max(0, this.currentVisibility - visibilityDelta);
	                    }
	                    dc.redrawRequested = true;
	                }
	            }

	            program.loadOpacity(gl, dc.pickingMode ? 1 : this.layer.opacity);

	            // Draw the leader line first so that the image and label have visual priority.
	            if (this.mustDrawLeaderLine(dc)) {
	                if (!this.leaderLinePoints) {
	                    this.leaderLinePoints = new Float32Array(6);
	                }

	                this.leaderLinePoints[0] = this.groundPoint[0]; // computed during makeOrderedRenderable
	                this.leaderLinePoints[1] = this.groundPoint[1];
	                this.leaderLinePoints[2] = this.groundPoint[2];
	                this.leaderLinePoints[3] = this.placePoint[0]; // computed during makeOrderedRenderable
	                this.leaderLinePoints[4] = this.placePoint[1];
	                this.leaderLinePoints[5] = this.placePoint[2];

	                if (!this.leaderLineCacheKey) {
	                    this.leaderLineCacheKey = dc.gpuResourceCache.generateCacheKey();
	                }

	                var leaderLineVboId = dc.gpuResourceCache.resourceForKey(this.leaderLineCacheKey);
	                if (!leaderLineVboId) {
	                    leaderLineVboId = gl.createBuffer();
	                    dc.gpuResourceCache.putResource(this.leaderLineCacheKey, leaderLineVboId,
	                        this.leaderLinePoints.length * 4);
	                }

	                program.loadTextureEnabled(gl, false);
	                program.loadColor(gl, dc.pickingMode ? this.pickColor :
	                    this.activeAttributes.leaderLineAttributes.outlineColor);

	                Placemark.matrix.copy(dc.navigatorState.modelviewProjection);
	                program.loadModelviewProjection(gl, Placemark.matrix);

	                if (!this.activeAttributes.leaderLineAttributes.depthTest) {
	                    gl.disable(gl.DEPTH_TEST);
	                }

	                gl.lineWidth(this.activeAttributes.leaderLineAttributes.outlineWidth);

	                gl.bindBuffer(gl.ARRAY_BUFFER, leaderLineVboId);
	                gl.bufferData(gl.ARRAY_BUFFER, this.leaderLinePoints, gl.STATIC_DRAW);
	                dc.frameStatistics.incrementVboLoadCount(1);
	                gl.vertexAttribPointer(program.vertexPointLocation, 3, gl.FLOAT, false, 0, 0);
	                gl.drawArrays(gl.LINES, 0, 2);
	            }

	            // Turn off depth testing for the placemark image if requested. The placemark label and leader line have
	            // their own depth-test controls.
	            if (!this.activeAttributes.depthTest) {
	                depthTest = false;
	                gl.disable(gl.DEPTH_TEST);
	            }

	            // Suppress frame buffer writes for the placemark image and its label.
	            // tag, 6/17/15: It's not clear why this call was here. It was carried over from WWJ.
	            //gl.depthMask(false);

	            gl.bindBuffer(gl.ARRAY_BUFFER, dc.unitQuadBuffer3());
	            gl.vertexAttribPointer(program.vertexPointLocation, 3, gl.FLOAT, false, 0, 0);

	            // Compute and specify the MVP matrix.
	            Placemark.matrix.copy(dc.screenProjection);
	            Placemark.matrix.multiplyMatrix(this.imageTransform);

	            var actualRotation = this.imageRotationReference === WorldWind.RELATIVE_TO_GLOBE ?
	                dc.navigatorState.heading - this.imageRotation : -this.imageRotation;
	            Placemark.matrix.multiplyByTranslation(0.5, 0.5, 0);
	            Placemark.matrix.multiplyByRotation(0, 0, 1, actualRotation);
	            Placemark.matrix.multiplyByTranslation(-0.5, -0.5, 0);

	            // Perform the tilt before applying the rotation so that the image tilts back from its base into
	            // the view volume.
	            var actualTilt = this.imageTiltReference === WorldWind.RELATIVE_TO_GLOBE ?
	            dc.navigatorState.tilt + this.imageTilt : this.imageTilt;
	            Placemark.matrix.multiplyByRotation(-1, 0, 0, actualTilt);

	            program.loadModelviewProjection(gl, Placemark.matrix);

	            // Enable texture for both normal display and for picking. If picking is enabled in the shader (set in
	            // beginDrawing() above) then the texture's alpha component is still needed in order to modulate the
	            // pick color to mask off transparent pixels.
	            program.loadTextureEnabled(gl, true);

	            if (dc.pickingMode) {
	                program.loadColor(gl, this.pickColor);
	            } else {
	                program.loadColor(gl, this.activeAttributes.imageColor);
	            }

	            this.texCoordMatrix.setToIdentity();
	            if (this.activeTexture) {
	                this.texCoordMatrix.multiplyByTextureTransform(this.activeTexture);
	            }
	            program.loadTextureMatrix(gl, this.texCoordMatrix);

	            if (this.activeTexture) {
	                textureBound = this.activeTexture.bind(dc); // returns false if active texture is null or cannot be bound
	                program.loadTextureEnabled(gl, textureBound);
	            } else {
	                program.loadTextureEnabled(gl, false);
	            }

	            // Draw the placemark's image quad.
	            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

	            if (this.mustDrawLabel() && this.currentVisibility > 0) {
	                program.loadOpacity(gl, dc.pickingMode ? 1 : this.layer.opacity * this.currentVisibility);

	                Placemark.matrix.copy(dc.screenProjection);
	                Placemark.matrix.multiplyMatrix(this.labelTransform);
	                program.loadModelviewProjection(gl, Placemark.matrix);

	                if (!dc.pickingMode && this.labelTexture) {
	                    this.texCoordMatrix.setToIdentity();
	                    this.texCoordMatrix.multiplyByTextureTransform(this.labelTexture);

	                    program.loadTextureMatrix(gl, this.texCoordMatrix);
	                    program.loadColor(gl, this.activeAttributes.labelAttributes.color);

	                    textureBound = this.labelTexture.bind(dc);
	                    program.loadTextureEnabled(gl, textureBound);
	                } else {
	                    program.loadTextureEnabled(gl, false);
	                    program.loadColor(gl, this.pickColor);
	                }

	                if (this.activeAttributes.labelAttributes.depthTest) {
	                    if (!depthTest) {
	                        depthTest = true;
	                        gl.enable(gl.DEPTH_TEST);
	                    }
	                } else {
	                    depthTest = false;
	                    gl.disable(gl.DEPTH_TEST);
	                }

	                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
	            }

	            if (!depthTest) {
	                gl.enable(gl.DEPTH_TEST);
	            }

	            // tag, 6/17/15: See note on depthMask above in this function.
	            //gl.depthMask(true);
	        };

	        // Internal. Intentionally not documented.
	        Placemark.prototype.mustDrawLabel = function () {
	            return this.label && this.label.length > 0 && this.activeAttributes.labelAttributes;
	        };

	        // Internal. Intentionally not documented.
	        Placemark.prototype.mustDrawLeaderLine = function (dc) {
	            return this.activeAttributes.drawLeaderLine && this.activeAttributes.leaderLineAttributes
	                && (!dc.pickingMode || this.enableLeaderLinePicking);
	        };

	        return Placemark;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

	var Events = __webpack_require__(5);
	module.exports = {
	    create: function (geoJson) {
	        geoJson.geometry.geometries.forEach(createGeometry);

	        function createGeometry(geometry) {
	            Events.post(Events.CREATE_GEO_JSON_OBJECT, {
	                type: 'Feature',
	                geometry: geometry,
	                properties: geoJson.properties,
	                id: geoJson.id
	            });
	        }
	    }
	};



/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

	var ColladaLodaer = __webpack_require__(190);
	var ColladaScene = __webpack_require__(197);
	var Utils = __webpack_require__(144);
	var Generalization = __webpack_require__(148);
	module.exports = {
	    create: createModel
	};

	function createModel(desc, addFunc) {
	    var url = desc.properties.file;

	    var request = new XMLHttpRequest();
	    request.open("get", url, true);
	    request.onload = function () {
	        loadCollada(this.response);
	    };
	    request.onerror = function (e) {
	        console.error(e);
	    };
	    request.send();

	    function loadCollada(data) {
	        var p = Utils.position(desc.geometry.coordinates);
	        var loader = new ColladaLodaer(p, {
	            dirPath: url.substring(0, url.lastIndexOf('/') + 1)
	        });
	        var scene = loader.parse(data);
	        scene.scale = desc.properties.scale || 1;
	        scene.source = desc;
	        scene.update = function(){
	            desc.properties.xRotation = 90 + (desc.properties.xRotation || 0);
	            ['xRotation', 'yRotation', 'zRotation'].forEach(defineProperty);
	            scene.generalization = new Generalization(desc.properties.generalization);
	        };
	        scene.update();
	        addFunc([scene]);
	        scene.altitudeMode = WorldWind.RELATIVE_TO_GROUND;
	        scene.oldMakeOrderedRenderable = scene.makeOrderedRenderable;

	        scene.makeOrderedRenderable = function(dc) {
	            var result = scene.oldMakeOrderedRenderable.call(this, dc);
	            if (!scene.generalization.isVisible(this.eyeDistance))
	                return;
	            var scale = scene.generalization.getScale(this.eyeDistance);
	            scene.scale = (desc.properties.scale || 1) * scale;
	            return result;
	        };

	        function defineProperty(p){
	            desc.properties[p] && (scene[p] = desc.properties[p]);
	        }
	    }


	}


/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports ColladaLoader
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(30),
	        __webpack_require__(191),
	        __webpack_require__(192),
	        __webpack_require__(194),
	        __webpack_require__(195),
	        __webpack_require__(196),
	        __webpack_require__(197),
	        __webpack_require__(193),
	        __webpack_require__(32)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
	              ColladaAsset,
	              ColladaImage,
	              ColladaMaterial,
	              ColladaMesh,
	              ColladaNode,
	              ColladaScene,
	              ColladaUtils,
	              Logger) {
	        "use strict";

	        /**
	         * Constructs a ColladaLoader
	         * @alias ColladaLoader
	         * @constructor
	         * @classdesc Represents a Collada Loader. Fetches and parses a collada document and returns the
	         * necessary information to render the collada model.
	         * @param {Position} position The model's geographic position.
	         * @param {Object} config Configuration options for the loader.
	         * <ul>
	         *  <li>dirPath - the path to the directory where the collada file is located</li>
	         * </ul>
	         */
	        var ColladaLoader = function (position, config) {

	            if (!position) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "ColladaLoader", "constructor", "missingPosition"));
	            }

	            this.position = position;

	            this.dirPath = '/';

	            this.init(config);
	        };

	        /**
	         * Initialization of the ColladaLoader
	         * @param {Object} config Configuration options for the loader.
	         * <ul>
	         *  <li>dirPath - the path to the directory where the collada file is located</li>
	         * </ul>
	         */
	        ColladaLoader.prototype.init = function (config) {
	            if (config) {
	                this.dirPath = config.dirPath || '/';
	            }

	            this.scene = {
	                type: "SceneTree",
	                dirPath: this.dirPath,
	                images: {},
	                metadata: {},
	                materials: {},
	                meshes: {},
	                root: {children: []}
	            };

	            this.xmlDoc = null;
	        };

	        /**
	         * Fetches and parses a collada file
	         * @param {String} url The url to the collada .dae file.
	         * @param {Function} cb A callback function to call with the result when the parsing is done.
	         * @returns {ColladaScene} A renderable shape.
	         */
	        ColladaLoader.prototype.load = function (url, cb) {

	            if (url.indexOf("://") === -1) {
	                url = this.dirPath + url;
	            }

	            ColladaUtils.fetchFile(url, function (data) {

	                if (!data) {
	                    var colladaScene = null;
	                }
	                else {

	                    try {
	                        colladaScene = this.parse(data);
	                    }
	                    catch (e) {
	                        colladaScene = null;
	                        Logger.log(Logger.LEVEL_SEVERE, "error parsing collada file: " + e);
	                    }
	                }

	                cb(colladaScene);

	            }.bind(this));
	        };

	        /**
	         * Parses a collada file
	         * @param {XML} data The raw XML data of the collada file.
	         * @returns {ColladaScene} A renderable shape.
	         */
	        ColladaLoader.prototype.parse = function (data) {

	            this.init();

	            var parser = new DOMParser();
	            this.xmlDoc = parser.parseFromString(data, "text/xml");

	            var iNodes = this.xmlDoc.querySelectorAll('library_nodes node');
	            var eNodes = this.xmlDoc.querySelectorAll("library_effects effect");

	            this.scene.metadata = ( new ColladaAsset(this.xmlDoc) ).parse();
	            this.parseLib('visual_scene', iNodes);
	            this.parseLib('library_geometries');
	            this.parseLib('library_materials', eNodes);
	            this.parseLib('library_images');

	            this.xmlDoc = null;

	            return new ColladaScene(this.position, this.scene);
	        };

	        /**
	         * Parses a collada library tag.
	         * @param {String} libName The library tag name.
	         * @param {NodeList} extraNodes Nodes from library_nodes or effects form library_effects
	         */
	        ColladaLoader.prototype.parseLib = function (libName, extraNodes) {

	            var libs = this.xmlDoc.getElementsByTagName(libName);
	            var libNodes = [];

	            if (libs && libs.length) {
	                libNodes = libs[0].childNodes;
	            }

	            for (var i = 0; i < libNodes.length; i++) {

	                var libNode = libNodes[i];

	                if (libNode.nodeType !== 1) {
	                    continue;
	                }

	                switch (libNode.nodeName) {

	                    case 'node':
	                        var node = ( new ColladaNode() ).parse(libNode, extraNodes);
	                        if (node) {
	                            this.scene.root.children.push(node);
	                        }
	                        break;

	                    case 'geometry':
	                        var geometryId = libNode.getAttribute("id");
	                        var xmlMesh = libNode.querySelector("mesh");
	                        var mesh = ( new ColladaMesh(geometryId) ).parse(xmlMesh);
	                        if (mesh) {
	                            this.scene.meshes[geometryId] = mesh;
	                        }
	                        break;

	                    case 'material':
	                        var materialId = libNode.getAttribute("id");
	                        var iEffect = libNode.querySelector("instance_effect");
	                        var effectId = iEffect.getAttribute("url").substr(1);
	                        var effect = ColladaUtils.querySelectorById(extraNodes, effectId);
	                        var material = ( new ColladaMaterial(materialId) ).parse(effect);
	                        if (material) {
	                            this.scene.materials[materialId] = material;
	                        }
	                        break;

	                    case 'image':
	                        var imageId = libNode.getAttribute("id");
	                        var imageName = libNode.getAttribute("name");
	                        var image = ( new ColladaImage(imageId, imageName) ).parse(libNode);
	                        if (image) {
	                            this.scene.images[imageId] = image;
	                        }
	                        break;

	                    default:
	                        break;
	                }
	            }

	        };

	        return ColladaLoader;

	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports ColladaAsset
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    "use strict";

	    /**
	     * Constructs a ColladaAsset
	     * @alias ColladaAsset
	     * @constructor
	     * @classdesc Represents a collada asset tag.
	     * @param {XML} xmlDoc The raw XML data of the collada file.
	     */
	    var ColladaAsset = function (xmlDoc) {
	        this.xmlAsset = xmlDoc.getElementsByTagName("asset")[0];
	        this.asset = {
	            daeVersion: xmlDoc.querySelector("COLLADA").getAttribute("version")
	        };
	    };

	    /**
	     * Parses the asset tag.
	     * Internal. Applications should not call this function.
	     */
	    ColladaAsset.prototype.parse = function () {

	        if (!this.xmlAsset) {
	            return null;
	        }

	        for (var i = 0; i < this.xmlAsset.childNodes.length; i++) {

	            var child = this.xmlAsset.childNodes.item(i);

	            if (child.nodeType !== 1) {
	                continue;
	            }

	            switch (child.nodeName) {
	                case "contributor":
	                    var tool = child.querySelector("authoring_tool");
	                    if (tool) {
	                        this.asset["authoring_tool"] = tool.textContext;
	                    }
	                    break;

	                case "unit":
	                    this.asset["unit"] = child.getAttribute("meter");
	                    break;

	                default:
	                    this.asset[child.localName] = child.textContent;
	                    break;
	            }
	        }

	        this.xmlAsset = null;

	        return this.asset;
	    };

	    return ColladaAsset;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports ColladaImage
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(193)], __WEBPACK_AMD_DEFINE_RESULT__ = function(ColladaUtils){
	    "use strict";

	    /**
	     * Constructs a ColladaImage
	     * @alias ColladaImage
	     * @constructor
	     * @classdesc Represents a collada image tag.
	     * @param {String} imageId The id of an image node
	     * @param {String} imageName The name of an image node
	     */
	    var ColladaImage = function (imageId, imageName) {
	        this.filename = '';
	        this.map = imageId;
	        this.name = imageName;
	        this.path = '';
	    };

	    /**
	     * Parses the images of a collada file.
	     * Internal. Applications should not call this function.
	     * @param {Node} element An image node
	     */
	    ColladaImage.prototype.parse = function (element) {

	        for (var i = 0; i < element.childNodes.length; i++) {

	            var child = element.childNodes[i];

	            if (child.nodeType !== 1) {
	                continue;
	            }

	            switch (child.nodeName){

	                case 'init_from':

	                    this.filename = ColladaUtils.getFilename(child.textContent);
	                    this.path = child.textContent;

	                    break;

	                default:
	                    break;
	            }
	        }

	        return this;

	    };

	    return ColladaImage;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(32)], __WEBPACK_AMD_DEFINE_RESULT__ = function (Logger) {
	    "use strict";

	    /**
	     * Provides utilities for the ColladaLoader.
	     * @exports ColladaUtils
	     */
	    var ColladaUtils = {

	        /**
	         * Packs data from a node in an array.
	         * Internal. Applications should not call this function.
	         * @param {Node} xmlNode A node from which to extract values.
	         */
	        getRawValues: function (xmlNode) {
	            if (!xmlNode) {
	                return null;
	            }

	            var text = xmlNode.textContent;
	            text = text.replace(/\n/gi, " ");
	            text = text.replace(/\s+/gi, " ");
	            text = text.trim();

	            if (text.length === 0) {
	                return null;
	            }

	            return text.split(" ");
	        },

	        /**
	         * Packs data from a node as a Float32Array.
	         * Internal. Applications should not call this function.
	         * @param {Node} xmlNode A node from which to extract values.
	         */
	        bufferDataFloat32: function (xmlNode) {

	            var rawValues = this.getRawValues(xmlNode);
	            if (!rawValues) {
	                return null;
	            }

	            var len = rawValues.length;

	            var bufferData = new Float32Array(len);
	            for (var i = 0; i < len; i++) {
	                bufferData[i] = parseFloat(rawValues[i]);
	            }

	            return bufferData;
	        },

	        /**
	         * Packs data from a node as a UInt32Array.
	         * Internal. Applications should not call this function.
	         * @param {Node} xmlNode A node from which to extract values.
	         */
	        bufferDataUInt32: function (xmlNode) {

	            var rawValues = this.getRawValues(xmlNode);
	            if (!rawValues) {
	                return null;
	            }

	            var len = rawValues.length;

	            var bufferData = new Uint32Array(len);
	            for (var i = 0; i < len; i++) {
	                bufferData[i] = parseInt(rawValues[i]);
	            }

	            return bufferData;
	        },

	        /**
	         * Returns the first child of a node.
	         * Internal. Applications should not call this function.
	         * @param {Node} xmlNode The tag to look in.
	         * @param {String} nodeName Optional parameter, the name of the child.
	         */
	        getFirstChildElement: function (xmlNode, nodeName) {

	            var childs = xmlNode.childNodes;

	            for (var i = 0; i < childs.length; ++i) {

	                var item = childs.item(i);

	                if (item.nodeType !== 1) {
	                    continue;
	                }

	                if ((item.nodeName && !nodeName) || (nodeName && nodeName === item.nodeName)) {
	                    return item;
	                }
	            }

	            return null;
	        },

	        /**
	         * Returns the filename without slashes.
	         * Internal. Applications should not call this function.
	         * @param {String} filePath
	         */
	        getFilename: function (filePath) {

	            var pos = filePath.lastIndexOf("\\");
	            if (pos !== -1) {
	                filePath = filePath.substr(pos + 1);
	            }

	            pos = filePath.lastIndexOf("/");
	            if (pos !== -1) {
	                filePath = filePath.substr(pos + 1);
	            }

	            return filePath;
	        },

	        /**
	         * Replaces the spaces in a string with an "_".
	         * Internal. Applications should not call this function.
	         * @param {String} str
	         */
	        replaceSpace: function (str) {
	            if (!str) {
	                return "";
	            }
	            return str.replace(/ /g, "_");
	        },

	        /**
	         * Finds a node by id.
	         * Internal. Applications should not call this function.
	         * @param {NodeList} nodes A list of nodes to look in.
	         * @param {String} id The id of the node to search for.
	         */
	        querySelectorById: function (nodes, id) {
	            for (var i = 0; i < nodes.length; i++) {
	                var attrId = nodes.item(i).getAttribute("id");
	                if (!attrId) {
	                    continue;
	                }
	                if (attrId.toString() === id) {
	                    return nodes.item(i);
	                }
	            }
	            return null;
	        },

	        /**
	         * Determines the rendering method for a texture.
	         * The method can be CLAMP or REPEAT.
	         * Internal. Applications should not call this function.
	         * @param {Number[]} uvs The uvs array.
	         */
	        getTextureType: function (uvs) {
	            var clamp = true;

	            for (var i = 0, len = uvs.length; i < len; i++) {
	                if (uvs[i] < 0 || uvs[i] > 1) {
	                    clamp = false;
	                    break;
	                }
	            }

	            return clamp;
	        },

	        /**
	         * Fetches a file.
	         * @param {String} url The path to the collada file.
	         * @param {Function} cb A callback function to call when the collada file loaded.
	         */
	        fetchFile: function (url, cb) {

	            var request = new XMLHttpRequest();

	            request.onload = function () {
	                if (this.status >= 200 && this.status < 400) {
	                    cb(this.response);
	                }
	                else {
	                    Logger.log(Logger.LEVEL_SEVERE, "sever error: " + this.status);
	                    cb(null);
	                }
	            };

	            request.onerror = function (e) {
	                Logger.log(Logger.LEVEL_SEVERE, "connection error: " + e);
	                cb(null);
	            };

	            request.open("get", url, true);

	            request.send();
	        }
	    };

	    return ColladaUtils;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports ColladaMaterial
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(193)], __WEBPACK_AMD_DEFINE_RESULT__ = function (ColladaUtils) {
	    "use strict";

	    /**
	     * Constructs a ColladaMaterial
	     * @alias ColladaMaterial
	     * @constructor
	     * @classdesc Represents a collada material and it's effects.
	     * @param {String} materialId The id of a material node
	     */
	    var ColladaMaterial = function (materialId) {
	        this.id = materialId;
	        this.newParams = [];
	    };

	    /**
	     * Parses an effect node.
	     * Internal. Applications should not call this function.
	     * @param {Node} element An effect node.
	     */
	    ColladaMaterial.prototype.parse = function (element) {

	        for (var i = 0; i < element.childNodes.length; i++) {

	            var child = element.childNodes[i];

	            if (child.nodeType !== 1) {
	                continue;
	            }

	            switch (child.nodeName) {

	                case 'profile_COMMON':
	                    this.parseProfileCommon(child);
	                    break;

	                default:
	                    break;
	            }
	        }

	        return this;
	    };

	    /**
	     * Parses the profile_COMMON node.
	     * Internal. Applications should not call this function.
	     * @param {Node} element The profile_COMMON node.
	     */
	    ColladaMaterial.prototype.parseProfileCommon = function (element) {

	        for (var i = 0; i < element.childNodes.length; i++) {

	            var child = element.childNodes[i];

	            if (child.nodeType !== 1) {
	                continue;
	            }

	            switch (child.nodeName) {

	                case 'newparam':
	                    this.parseNewparam(child);
	                    break;

	                case 'image':
	                    break;

	                case 'technique':
	                    this.parseTechnique(child);
	                    break;

	                default:
	                    break;
	            }
	        }

	    };

	    /**
	     * Parses the newparam node.
	     * Internal. Applications should not call this function.
	     * @param {Node} element The newparam node.
	     */
	    ColladaMaterial.prototype.parseNewparam = function (element) {
	        var sid = element.getAttribute('sid');

	        for (var i = 0; i < element.childNodes.length; i++) {

	            var child = element.childNodes[i];

	            if (child.nodeType !== 1) {
	                continue;
	            }

	            switch (child.nodeName) {

	                case 'surface':
	                    var initFrom = child.querySelector("init_from");
	                    if (initFrom) {
	                        this.newParams.push({
	                            sid: sid,
	                            type: 'surface',
	                            initFrom: initFrom.textContent
	                        });
	                    }
	                    break;

	                case 'sampler2D':
	                    var source = child.querySelector("source");
	                    this.newParams.push({
	                        sid: sid,
	                        type: 'sampler2D',
	                        source: source.textContent
	                    });
	                    break;

	                case 'extra':
	                    break;

	                default:
	                    break;

	            }

	        }
	    };

	    /**
	     * Parses the technique node.
	     * Internal. Applications should not call this function.
	     * @param {Node} element The technique node.
	     */
	    ColladaMaterial.prototype.parseTechnique = function (element) {

	        for (var i = 0; i < element.childNodes.length; i++) {

	            var child = element.childNodes[i];

	            if (child.nodeType !== 1) {
	                continue;
	            }

	            switch (child.nodeName) {

	                case 'constant':
	                case 'lambert':
	                case 'blinn':
	                case 'phong':
	                    this.techniqueType = child.nodeName;
	                    this.parseTechniqueType(child);
	                    break;

	                case 'extra':
	                    break;

	                default:
	                    break;

	            }

	        }
	    };

	    /**
	     * Parses the technique type for this effect.
	     * Internal. Applications should not call this function.
	     * @param {Node} element The technique type node.
	     */
	    ColladaMaterial.prototype.parseTechniqueType = function (element) {

	        for (var i = 0; i < element.childNodes.length; i++) {

	            var child = element.childNodes[i];

	            if (child.nodeType !== 1 || !child.nodeName) {
	                continue;
	            }

	            var nodeName = child.nodeName;

	            var nodeValue = ColladaUtils.getFirstChildElement(child);

	            if (!nodeValue) {
	                continue;
	            }

	            switch (nodeValue.nodeName) {

	                case 'color':
	                    this[nodeName] = ColladaUtils.bufferDataFloat32(nodeValue).subarray(0, 4);
	                    break;

	                case 'float':
	                    this[nodeName] = ColladaUtils.bufferDataFloat32(nodeValue)[0];
	                    break;

	                case 'texture':
	                    var texture = nodeValue.getAttribute("texture");

	                    var pos = this.newParams.map(function (newParam) {
	                        return newParam.sid;
	                    }).indexOf(texture);

	                    var source = this.newParams[pos].source;

	                    pos = this.newParams.map(function (newParam) {
	                        return newParam.sid;
	                    }).indexOf(source);

	                    var initFrom = this.newParams[pos].initFrom;

	                    if (!this.textures) {
	                        this.textures = {};
	                    }

	                    this.textures[nodeName] = {mapId: initFrom};

	                    break;

	                default:
	                    break;

	            }

	        }
	    };

	    return ColladaMaterial;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports ColladaMesh
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(193)], __WEBPACK_AMD_DEFINE_RESULT__ = function (ColladaUtils) {
	    "use strict";

	    /**
	     * Constructs a ColladaMesh
	     * @alias ColladaMesh
	     * @constructor
	     * @classdesc Represents a collada mesh tag.
	     * @param {String} geometryId The id of a geometry node
	     */
	    var ColladaMesh = function (geometryId) {
	        this.filename = geometryId || "";
	        this.name = geometryId || "";
	        this.buffers = [];
	    };

	    /**
	     * Parses and computes the geometry of a mesh.
	     * Internal. Applications should not call this function.
	     * @param {Node} element A mesh node.
	     */
	    ColladaMesh.prototype.parse = function (element) {

	        var sources = {},
	            meshData = {},
	            verticesInputs = {
	                id: '',
	                inputs: []
	            };

	        for (var i = 0; i < element.childNodes.length; i++) {

	            var child = element.childNodes[i];

	            if (child.nodeType !== 1) {
	                continue;
	            }

	            switch (child.nodeName) {

	                case 'source':
	                    if (!child.querySelector) {
	                        continue;
	                    }

	                    var floatArray = child.querySelector("float_array");
	                    if (!floatArray) {
	                        continue;
	                    }

	                    var values = ColladaUtils.bufferDataFloat32(floatArray);
	                    var accessor = child.querySelector("accessor");
	                    var stride = parseInt(accessor.getAttribute("stride"));

	                    sources[child.getAttribute("id")] = {stride: stride, data: values};
	                    break;

	                case 'vertices':
	                    this.parseVertices(child, verticesInputs);
	                    break;

	                case 'triangles':
	                    meshData = this.parsePolygons(child, sources, verticesInputs, 3);
	                    this.buffers.push(meshData);
	                    break;

	                case 'polygons':
	                    meshData = this.parsePolygons(child, sources, verticesInputs, 4);
	                    this.buffers.push(meshData);
	                    break;

	                case 'polylist':
	                    meshData = this.parsePolygons(child, sources, verticesInputs, null);
	                    this.buffers.push(meshData);
	                    break;

	                default:
	                    break;

	            }

	        }

	        return this;

	    };

	    /**
	     * Parses the vertices tag of a mesh.
	     * Internal. Applications should not call this function.
	     * @param {Node} element The node containing the primitives and inputs.
	     * @param {Object} verticesInputs An object in which to save the inputs of the vertices tag.
	     */
	    ColladaMesh.prototype.parseVertices = function (element, verticesInputs) {

	        verticesInputs.id = element.getAttribute("id");
	        var inputs = element.querySelectorAll("input");

	        for (var i = 0; i < inputs.length; i++) {

	            var input = inputs[i];
	            var source = input.getAttribute("source").substr(1);
	            var semantic = input.getAttribute("semantic").toUpperCase();

	            verticesInputs.inputs.push({
	                semantic: semantic,
	                source: source
	            });

	        }

	    };

	    /**
	     * Parses the polygons primitive and computes the indices and vertices.
	     * Internal. Applications should not call this function.
	     * @param {Node} element The node containing the primitives and inputs.
	     * @param {Object} sources An object containing the inputs for vertices, normals and uvs.
	     * @param {Object} verticesInputs An object containing the inputs links.
	     * @param {Number} vCount Optional parameter, specifies the the vertex count for a polygon
	     */
	    ColladaMesh.prototype.parsePolygons = function (element, sources, verticesInputs, vCount) {

	        var arrVCount = [];
	        if (vCount == null) {
	            var xmlVCount = element.querySelector("vcount");
	            arrVCount = xmlVCount.textContent.trim().split(" ");
	        }

	        var count = parseInt(element.getAttribute("count"));
	        var material = element.getAttribute("material");

	        var inputData = this.parseInputs(element, sources, verticesInputs);
	        var inputs = inputData.inputs;
	        var maxOffset = inputData.maxOffset;

	        var primitives = element.querySelector("p");
	        var primitiveData = [];
	        if (primitives) {
	            primitiveData = primitives.textContent.trim().split(" ");
	        }

	        var nrOfInputs = inputs.length;

	        var lastIndex = 0;
	        var indexMap = {};
	        var indicesArray = [];
	        var pos = 0;
	        var indexedRendering = false;

	        for (var i = 0; i < count; i++) {

	            if (arrVCount.length) {
	                var numVertices = parseInt(arrVCount[i]);
	            }
	            else {
	                numVertices = vCount;
	            }

	            var firstIndex = -1;
	            var currentIndex = -1;
	            var prevIndex = -1;

	            for (var k = 0; k < numVertices; k++) {

	                var vecId = primitiveData.slice(pos, pos + maxOffset).join(" ");

	                prevIndex = currentIndex;
	                if (indexMap.hasOwnProperty(vecId)) {
	                    currentIndex = indexMap[vecId];
	                    indexedRendering = true;
	                }
	                else {

	                    for (var j = 0; j < nrOfInputs; j++) {

	                        var input = inputs[j];
	                        var offset = input[4];
	                        var index = parseInt(primitiveData[pos + offset]);
	                        var array = input[1];
	                        var source = input[3];
	                        index *= input[2];

	                        for (var x = 0; x < input[2]; x++) {
	                            array.push(source[index + x]);
	                        }
	                    }

	                    currentIndex = lastIndex;
	                    lastIndex += 1;
	                    indexMap[vecId] = currentIndex;
	                }

	                if (numVertices > 3) {
	                    if (k === 0) {
	                        firstIndex = currentIndex;
	                    }
	                    if (k > 2 * maxOffset) {
	                        indicesArray.push(firstIndex);
	                        indicesArray.push(prevIndex);
	                    }
	                }

	                indicesArray.push(currentIndex);
	                pos += maxOffset;

	            }
	        }

	        var mesh = {
	            vertices: new Float32Array(inputs[0][1]),
	            indexedRendering: indexedRendering,
	            material: material
	        };

	        this.transformMeshInfo(mesh, inputs, indicesArray);

	        return mesh;

	    };

	    /**
	     * Parses the inputs of a mesh.
	     * Internal. Applications should not call this function.
	     * @param {Node} element The node containing the primitives and inputs.
	     * @param {Object} sources An object containing the vertices source and stride.
	     * @param {Object} verticesInputs An object containing the inputs links.
	     */
	    ColladaMesh.prototype.parseInputs = function (element, sources, verticesInputs) {

	        var inputs = [], maxOffset = 0;

	        var xmlInputs = element.querySelectorAll("input");

	        for (var i = 0; i < xmlInputs.length; i++) {
	            var xmlInput = xmlInputs.item(i);
	            if (!xmlInput.getAttribute) {
	                continue;
	            }

	            var semantic = xmlInput.getAttribute("semantic").toUpperCase();
	            var sourceUrl = xmlInput.getAttribute("source").substr(1);
	            var offset = parseInt(xmlInput.getAttribute("offset"));

	            maxOffset = ( maxOffset < offset + 1 ) ? offset + 1 : maxOffset;

	            //indicates which inputs should be grouped together as a single set.
	            //multiple inputs may share the same semantics.
	            var dataSet = 0;
	            if (xmlInput.getAttribute("set")) {
	                dataSet = parseInt(xmlInput.getAttribute("set"));
	            }

	            if (verticesInputs.id === sourceUrl) {
	                var vInputs = verticesInputs.inputs;
	                for (var j = 0; j < vInputs.length; j++) {
	                    var source = sources[vInputs[j].source];
	                    if (source) {
	                        inputs.push([vInputs[j].semantic, [], source.stride, source.data, offset, dataSet]);
	                    }
	                }
	            }
	            else {
	                source = sources[sourceUrl];
	                inputs.push([semantic, [], source.stride, source.data, offset, dataSet]);
	            }

	        }

	        return {inputs: inputs, maxOffset: maxOffset};
	    };

	    /**
	     * Packs the data in the mesh object.
	     * Internal. Applications should not call this function.
	     * @param {Object} mesh The mesh that will be returned.
	     * @param {Array} inputs The array containing the inputs of the mesh.
	     * @param {Number[]} indicesArray An array containing the indices.
	     */
	    ColladaMesh.prototype.transformMeshInfo = function (mesh, inputs, indicesArray) {
	        var translator = {
	            "normal": "normals",
	            "texcoord": "uvs"
	        };

	        for (var i = 1; i < inputs.length; i++) {

	            var name = inputs[i][0].toLowerCase(); //the semantic
	            var data = inputs[i][1]; //the final data (normals, uvs)

	            if (!data.length) {
	                continue;
	            }

	            if (translator[name]) {
	                name = translator[name];
	            }

	            if (mesh[name]) {
	                name = name + inputs[i][5];
	            }

	            mesh[name] = new Float32Array(data);

	            if (name === 'uvs') {
	                mesh.isClamp = ColladaUtils.getTextureType(data);
	            }
	        }

	        if (mesh.indexedRendering) {
	            mesh.indices = new Uint16Array(indicesArray);
	        }

	        return mesh;
	    };

	    return ColladaMesh;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports ColladaNode
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(193), __webpack_require__(63), __webpack_require__(35)], __WEBPACK_AMD_DEFINE_RESULT__ = function (ColladaUtils, Matrix, Vec3) {
	    "use strict";

	    /**
	     * Constructs a ColladaNode
	     * @alias ColladaNode
	     * @constructor
	     * @classdesc Represents a collada node tag.
	     */
	    var ColladaNode = function () {
	        this.id = "";
	        this.name = "";
	        this.sid = "";
	        this.children = [];
	        this.materials = [];
	        this.mesh = "";
	        this.localMatrix = Matrix.fromIdentity();
	        this.worldMatrix = Matrix.fromIdentity();
	    };

	    /**
	     * Parses a visual_scene node.
	     * Internal. Applications should not call this function.
	     * @param {Node} element A visual_scene node.
	     * @param {NodeList} iNodes Nodes from library_nodes.
	     * @param {Matrix} parentWorldMatrix The transformation matrix of it's parent.
	     */
	    ColladaNode.prototype.parse = function (element, iNodes, parentWorldMatrix) {

	        this.id = element.getAttribute('id');
	        this.sid = element.getAttribute('sid');
	        this.name = element.getAttribute('name');

	        this.children = [];
	        this.materials = [];
	        this.mesh = "";
	        this.localMatrix = Matrix.fromIdentity();
	        this.worldMatrix = Matrix.fromIdentity();

	        this.setNodeTransforms(element, parentWorldMatrix);

	        for (var i = 0; i < element.childNodes.length; i++) {

	            var child = element.childNodes[i];

	            if (child.nodeType !== 1) {
	                continue;
	            }

	            switch (child.nodeName) {

	                case 'node':
	                    this.children.push(( new ColladaNode() ).parse(child, iNodes, this.worldMatrix));
	                    break;

	                case 'instance_geometry':

	                    this.mesh = child.getAttribute("url").substr(1);

	                    var materials = child.querySelectorAll("instance_material");

	                    for (var j = 0; j < materials.length; j++) {

	                        var material = materials.item(j);

	                        this.materials.push({
	                            id: material.getAttribute("target").substr(1),
	                            symbol: material.getAttribute("symbol")
	                        });
	                    }

	                    break;

	                case 'instance_node':
	                    var iNodeId = child.getAttribute('url').substr(1);
	                    var iNode = this.getLibraryNode(iNodes, iNodeId);

	                    if (iNode) {
	                        this.children.push(( new ColladaNode() ).parse(iNode, iNodes, this.worldMatrix));
	                    }
	                    break;

	                default:
	                    break;

	            }

	        }

	        return this;

	    };

	    /**
	     * Computes the transformation and normal matrix of a node
	     * Internal. Applications should not call this function.
	     * @param {Node} element A visual_scene node.
	     * @param {Matrix} parentWorldMatrix The transformation matrix of it's parent.
	     */
	    ColladaNode.prototype.setNodeTransforms = function (element, parentWorldMatrix) {

	        var matrix = Matrix.fromIdentity(),
	            rotationMatrix = Matrix.fromIdentity(),
	            translationMatrix = Matrix.fromIdentity(),
	            scaleMatrix = Matrix.fromIdentity();

	        if (!parentWorldMatrix) {
	            parentWorldMatrix = Matrix.fromIdentity();
	        }

	        var transforms = [];

	        for (var i = 0; i < element.childNodes.length; i++) {

	            var child = element.childNodes[i];

	            if (child.nodeType !== 1) {
	                continue;
	            }

	            switch (child.nodeName) {

	                case 'matrix':
	                    var values = ColladaUtils.bufferDataFloat32(child);
	                    matrix.copy(values);
	                    transforms.push(matrix);
	                    break;

	                case 'rotate':
	                    values = ColladaUtils.bufferDataFloat32(child);
	                    rotationMatrix.multiplyByRotation(values[0], values[1], values[2], values[3]);
	                    transforms.push(rotationMatrix);
	                    break;

	                case 'translate':
	                    values = ColladaUtils.bufferDataFloat32(child);
	                    translationMatrix.multiplyByTranslation(values[0], values[1], values[2]);
	                    transforms.push(translationMatrix);
	                    break;

	                case 'scale':
	                    values = ColladaUtils.bufferDataFloat32(child);
	                    scaleMatrix.multiplyByScale(values[0], values[1], values[2]);
	                    transforms.push(scaleMatrix);
	                    break;

	                default:
	                    break;

	            }
	        }

	        for (i = 0; i < transforms.length; i++) {
	            this.localMatrix.multiplyMatrix(transforms[i]);
	        }

	        this.worldMatrix.setToMultiply(parentWorldMatrix, this.localMatrix);

	        this.normalMatrix = Matrix.fromIdentity();

	        var rotationAngles = new Vec3(0,0,0);
	        this.worldMatrix.extractRotationAngles(rotationAngles);

	        this.normalMatrix.multiplyByRotation(-1, 0, 0, rotationAngles[0]);
	        this.normalMatrix.multiplyByRotation(0, -1, 0, rotationAngles[1]);
	        this.normalMatrix.multiplyByRotation(0, 0, -1, rotationAngles[2]);

	    };

	    /**
	     * Retrieves a node form library_nodes
	     * Internal. Applications should not call this function.
	     * @param {NodeList} iNodes Nodes from library_nodes
	     * @param {String} id The id of the node to retrieve
	     */
	    ColladaNode.prototype.getLibraryNode = function (iNodes, id) {

	        for (var i = 0; i < iNodes.length; i++) {

	            var attObj = iNodes[i].attributes.getNamedItem('id');
	            if (attObj && attObj.value === id) {
	                return iNodes[i];
	            }
	        }

	        return null;
	    };

	    return ColladaNode;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports ColladaScene
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(30),
	        __webpack_require__(129),
	        __webpack_require__(52),
	        __webpack_require__(32),
	        __webpack_require__(63),
	        __webpack_require__(47),
	        __webpack_require__(87),
	        __webpack_require__(130),
	        __webpack_require__(35)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
	              BasicTextureProgram,
	              Color,
	              Logger,
	              Matrix,
	              Position,
	              PickedObject,
	              Renderable,
	              Vec3) {
	        "use strict";

	        /**
	         * Constructs a collada scene
	         * @alias ColladaScene
	         * @constructor
	         * @augments Renderable
	         * @classdesc Represents a scene. A scene is a collection of nodes with meshes, materials and textures.
	         * @param {Position} position The scene's geographic position.
	         * @param {Object} sceneData The scene's data containing the nodes, meshes, materials, textures and other
	         * info needed to render the scene.
	         */
	        var ColladaScene = function (position, sceneData) {

	            if (!position) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "ColladaScene", "constructor", "missingPosition"));
	            }

	            Renderable.call(this);

	            // Documented in defineProperties below.
	            this._position = position;

	            // Documented in defineProperties below.
	            this._nodes = [];
	            this._meshes = {};
	            this._materials = {};
	            this._images = {};
	            this._upAxis = '';
	            this._dirPath = '';

	            // Documented in defineProperties below.
	            this._xRotation = 0;
	            this._yRotation = 0;
	            this._zRotation = 0;

	            // Documented in defineProperties below.
	            this._xTranslation = 0;
	            this._yTranslation = 0;
	            this._zTranslation = 0;

	            // Documented in defineProperties below.
	            this._scale = 1;

	            // Documented in defineProperties below.
	            this._altitudeMode = WorldWind.ABSOLUTE;

	            // Documented in defineProperties below.
	            this._localTransforms = true;

	            // Documented in defineProperties below.
	            this._useTexturePaths = true;

	            // Documented in defineProperties below.
	            this._nodesToHide = [];
	            this._hideNodes = false;

	            this.setSceneData(sceneData);

	            // Documented in defineProperties below.
	            this._placePoint = new Vec3(0, 0, 0);

	            // Documented in defineProperties below.
	            this._transformationMatrix = Matrix.fromIdentity();

	            // Documented in defineProperties below.
	            this._normalMatrix = Matrix.fromIdentity();

	            this._texCoordMatrix = Matrix.fromIdentity().setToUnitYFlip();

	            this._activeTexture = null;

	        };

	        ColladaScene.prototype = Object.create(Renderable.prototype);
	        ColladaScene.prototype.constructor = ColladaScene;

	        Object.defineProperties(ColladaScene.prototype, {

	            /**
	             * The scene's geographic position.
	             * @memberof ColladaScene.prototype
	             * @type {Position}
	             */
	            position: {
	                get: function () {
	                    return this._position;
	                },
	                set: function (value) {
	                    this._position = value;
	                }
	            },

	            /**
	             * An array of nodes extracted from the collada file.
	             * @memberof ColladaScene.prototype
	             * @type {ColladaNode[]}
	             */
	            nodes: {
	                get: function () {
	                    return this._nodes;
	                },
	                set: function (value) {
	                    this._nodes = value;
	                }
	            },

	            /**
	             * An object with meshes extracted from the collada file.
	             * @memberof ColladaScene.prototype
	             * @type {{ColladaMesh}}
	             */
	            meshes: {
	                get: function () {
	                    return this._meshes;
	                },
	                set: function (value) {
	                    this._meshes = value;
	                }
	            },

	            /**
	             * An object with materials and their effects extracted from the collada file.
	             * @memberof ColladaScene.prototype
	             * @type {ColladaMaterial}
	             */
	            materials: {
	                get: function () {
	                    return this._materials;
	                },
	                set: function (value) {
	                    this._materials = value;
	                }
	            },

	            /**
	             * An object with images extracted from the collada file.
	             * @memberof ColladaScene.prototype
	             * @type {ColladaImage}
	             */
	            images: {
	                get: function () {
	                    return this._images;
	                },
	                set: function (value) {
	                    this._images = value;
	                }
	            },

	            /**
	             * The up axis of the collada model extracted from the collada file.
	             * @memberof ColladaScene.prototype
	             * @type {String}
	             */
	            upAxis: {
	                get: function () {
	                    return this._upAxis;
	                },
	                set: function (value) {
	                    this._upAxis = value;
	                }
	            },

	            /**
	             * The path to the directory of the collada file.
	             * @memberof ColladaScene.prototype
	             * @type {String}
	             */
	            dirPath: {
	                get: function () {
	                    return this._dirPath;
	                },
	                set: function (value) {
	                    this._dirPath = value;
	                }
	            },

	            /**
	             * The scene's rotation angle in degrees for the x axis.
	             * @memberof ColladaScene.prototype
	             * @type {Number}
	             */
	            xRotation: {
	                get: function () {
	                    return this._xRotation;
	                },
	                set: function (value) {
	                    this._xRotation = value;
	                }
	            },

	            /**
	             * The scene's rotation angle in degrees for the x axis.
	             * @memberof ColladaScene.prototype
	             * @type {Number}
	             */
	            yRotation: {
	                get: function () {
	                    return this._yRotation;
	                },
	                set: function (value) {
	                    this._yRotation = value;
	                }
	            },

	            /**
	             * The scene's rotation angle in degrees for the x axis.
	             * @memberof ColladaScene.prototype
	             * @type {Number}
	             */
	            zRotation: {
	                get: function () {
	                    return this._zRotation;
	                },
	                set: function (value) {
	                    this._zRotation = value;
	                }
	            },

	            /**
	             * The scene's translation for the x axis.
	             * @memberof ColladaScene.prototype
	             * @type {Number}
	             */
	            xTranslation: {
	                get: function () {
	                    return this._xTranslation;
	                },
	                set: function (value) {
	                    this._xTranslation = value;
	                }
	            },

	            /**
	             * The scene's translation for the y axis.
	             * @memberof ColladaScene.prototype
	             * @type {Number}
	             */
	            yTranslation: {
	                get: function () {
	                    return this._yTranslation;
	                },
	                set: function (value) {
	                    this._yTranslation = value;
	                }
	            },

	            /**
	             * The scene's translation for the z axis.
	             * @memberof ColladaScene.prototype
	             * @type {Number}
	             */
	            zTranslation: {
	                get: function () {
	                    return this._zTranslation;
	                },
	                set: function (value) {
	                    this._zTranslation = value;
	                }
	            },

	            /**
	             * The scene's scale.
	             * @memberof ColladaScene.prototype
	             * @type {Number}
	             */
	            scale: {
	                get: function () {
	                    return this._scale;
	                },
	                set: function (value) {
	                    this._scale = value;
	                }
	            },

	            /**
	             * The scene's Cartesian point on the globe for the specified position.
	             * @memberof ColladaScene.prototype
	             * @type {Vec3}
	             */
	            placePoint: {
	                get: function () {
	                    return this._placePoint;
	                },
	                set: function (value) {
	                    this._placePoint = value;
	                }
	            },

	            /**
	             * The scene's altitude mode. May be one of
	             * <ul>
	             *  <li>[WorldWind.ABSOLUTE]{@link WorldWind#ABSOLUTE}</li>
	             *  <li>[WorldWind.RELATIVE_TO_GROUND]{@link WorldWind#RELATIVE_TO_GROUND}</li>
	             *  <li>[WorldWind.CLAMP_TO_GROUND]{@link WorldWind#CLAMP_TO_GROUND}</li>
	             * </ul>
	             * @default WorldWind.ABSOLUTE
	             * @memberof ColladaScene.prototype
	             * @type {String}
	             */
	            altitudeMode: {
	                get: function () {
	                    return this._altitudeMode;
	                },
	                set: function (value) {
	                    this._altitudeMode = value;
	                }
	            },

	            /**
	             * The scene's transformation matrix containing the scale, rotations and translations
	             * @memberof ColladaScene.prototype
	             * @type {Matrix}
	             */
	            transformationMatrix: {
	                get: function () {
	                    return this._transformationMatrix;
	                },
	                set: function (value) {
	                    this._transformationMatrix = value;
	                }
	            },

	            /**
	             * The scene's normal matrix
	             * @memberof ColladaScene.prototype
	             * @type {Matrix}
	             */
	            normalMatrix: {
	                get: function () {
	                    return this._normalMatrix;
	                },
	                set: function (value) {
	                    this._normalMatrix = value;
	                }
	            },

	            /**
	             * Force the use of the nodes transformation info. Some 3d software may break the transformations when
	             * importing/exporting models to collada format. Set to false to ignore the the nodes transformation.
	             * Only use this option if the model does not render properly.
	             * @memberof ColladaScene.prototype
	             * @default true
	             * @type {Boolean}
	             */
	            localTransforms: {
	                get: function () {
	                    return this._localTransforms;
	                },
	                set: function (value) {
	                    this._localTransforms = value;
	                }
	            },

	            /**
	             * Force the use of the texture path specified in the collada file. Set to false to ignore the paths of the
	             * textures in the collada file and instead get the textures from the same dir as the collada file.
	             * @memberof ColladaScene.prototype
	             * @default true
	             * @type {Boolean}
	             */
	            useTexturePaths: {
	                get: function () {
	                    return this._useTexturePaths;
	                },
	                set: function (value) {
	                    this._useTexturePaths = value;
	                }
	            },

	            /**
	             * An array of node id's to not render.
	             * @memberof ColladaScene.prototype
	             * @type {String[]}
	             */
	            nodesToHide: {
	                get: function () {
	                    return this._nodesToHide;
	                },
	                set: function (value) {
	                    this._nodesToHide = value;
	                }
	            },

	            /**
	             * Set to true to force the renderer to not draw the nodes passed to the nodesToHide list.
	             * @memberof ColladaScene.prototype
	             * @default false
	             * @type {Boolean}
	             */
	            hideNodes: {
	                get: function () {
	                    return this._hideNodes;
	                },
	                set: function (value) {
	                    this._hideNodes = value;
	                }
	            }

	        });

	        // Internal. Intentionally not documented.
	        ColladaScene.prototype.setSceneData = function (sceneData) {
	            if (sceneData) {
	                this.nodes = sceneData.root.children;
	                this.meshes = sceneData.meshes;
	                this.materials = sceneData.materials;
	                this.images = sceneData.images;
	                this.upAxis = sceneData.metadata.up_axis;
	                this.dirPath = sceneData.dirPath;
	            }
	        };

	        // Internal. Intentionally not documented.
	        ColladaScene.prototype.render = function (dc) {

	            var orderedScene;

	            if (!this.enabled) {
	                return;
	            }

	            if (this.lastFrameTime !== dc.timestamp) {
	                orderedScene = this.makeOrderedRenderable(dc);
	            }

	            if (!orderedScene) {
	                return;
	            }

	            orderedScene.layer = dc.currentLayer;

	            this.lastFrameTime = dc.timestamp;

	            dc.addOrderedRenderable(orderedScene);
	        };

	        // Internal. Intentionally not documented.
	        ColladaScene.prototype.makeOrderedRenderable = function (dc) {

	            dc.surfacePointForMode(this.position.latitude, this.position.longitude, this.position.altitude,
	                this.altitudeMode, this.placePoint);

	            this.eyeDistance = dc.navigatorState.eyePoint.distanceTo(this.placePoint);

	            return this;

	        };

	        // Internal. Intentionally not documented.
	        ColladaScene.prototype.renderOrdered = function (dc) {

	            this.drawOrderedScene(dc);

	            if (dc.pickingMode) {
	                var po = new PickedObject(this.pickColor.clone(), this,
	                    this.position, this.layer, false);

	                dc.resolvePick(po);
	            }
	        };

	        // Internal. Intentionally not documented.
	        ColladaScene.prototype.drawOrderedScene = function (dc) {

	            this.beginDrawing(dc);

	            try {
	                this.doDrawOrderedScene(dc);
	            }
	            finally {
	                this.endDrawing(dc);
	            }

	        };

	        // Internal. Intentionally not documented.
	        ColladaScene.prototype.beginDrawing = function (dc) {

	            var gl = dc.currentGlContext;

	            dc.findAndBindProgram(BasicTextureProgram);

	            gl.disable(gl.CULL_FACE);
	            gl.enable(gl.DEPTH_TEST);
	        };

	        // Internal. Intentionally not documented.
	        ColladaScene.prototype.doDrawOrderedScene = function (dc) {

	            if (dc.pickingMode) {
	                this.pickColor = dc.uniquePickColor();
	            }

	            this.computeTransformationMatrix(dc.globe);

	            for (var i = 0, nodesLen = this.nodes.length; i < nodesLen; i++) {
	                this.traverseNodeTree(dc, this.nodes[i]);
	            }
	        };

	        // Internal. Intentionally not documented.
	        ColladaScene.prototype.traverseNodeTree = function (dc, node) {

	            var renderNode = this.mustRenderNode(node.id);

	            if (renderNode) {

	                if (node.mesh) {
	                    var meshKey = node.mesh;
	                    var buffers = this.meshes[meshKey].buffers;

	                    for (var i = 0, bufLen = buffers.length; i < bufLen; i++) {

	                        var materialBuf = buffers[i].material;

	                        for (var j = 0; j < node.materials.length; j++) {
	                            if (materialBuf === node.materials[j].symbol) {
	                                var materialKey = node.materials[j].id;
	                                break;
	                            }
	                        }

	                        var material = this.materials[materialKey];

	                        this.draw(dc, buffers[i], material, node.worldMatrix, node.normalMatrix);
	                    }
	                }

	                for (var k = 0; k < node.children.length; k++) {
	                    this.traverseNodeTree(dc, node.children[k]);
	                }
	            }

	        };

	        // Internal. Intentionally not documented.
	        ColladaScene.prototype.draw = function (dc, buffers, material, nodeWorldMatrix, nodeNormalMatrix) {

	            var gl = dc.currentGlContext,
	                program = dc.currentProgram,
	                vboId;

	            this.applyVertices(dc, buffers);

	            program.loadTextureEnabled(gl, false);

	            this.applyColor(dc, material);

	            var hasTexture = (material && material.textures != null && buffers.uvs && buffers.uvs.length > 0);
	            if (hasTexture) {
	                this.applyTexture(dc, buffers, material);
	            }

	            var hasLighting = (buffers.normals != null && buffers.normals.length > 0);
	            if (hasLighting && !dc.pickingMode) {
	                this.applyLighting(dc, buffers);
	            }

	            this.applyMatrix(dc, hasLighting, hasTexture , nodeWorldMatrix, nodeNormalMatrix);

	            if (buffers.indexedRendering) {
	                this.applyIndices(dc, buffers);
	                gl.drawElements(gl.TRIANGLES, buffers.indices.length, gl.UNSIGNED_SHORT, 0);
	            }
	            else {
	                gl.drawArrays(gl.TRIANGLES, 0, Math.floor(buffers.vertices.length / 3));
	            }

	            this.resetDraw(dc, hasLighting, hasTexture);

	        };

	        // Internal. Intentionally not documented.
	        ColladaScene.prototype.applyVertices = function (dc, buffers) {

	            var gl = dc.currentGlContext,
	                program = dc.currentProgram,
	                vboId;

	            if (!buffers.verticesVboCacheKey) {
	                buffers.verticesVboCacheKey = dc.gpuResourceCache.generateCacheKey();
	            }

	            vboId = dc.gpuResourceCache.resourceForKey(buffers.verticesVboCacheKey);
	            if (!vboId) {
	                vboId = gl.createBuffer();
	                dc.gpuResourceCache.putResource(buffers.verticesVboCacheKey, vboId,
	                    buffers.vertices.length);
	                buffers.refreshVertexBuffer = true;
	            }

	            gl.bindBuffer(gl.ARRAY_BUFFER, vboId);
	            if (buffers.refreshVertexBuffer) {
	                gl.bufferData(gl.ARRAY_BUFFER, buffers.vertices, gl.STATIC_DRAW);
	                dc.frameStatistics.incrementVboLoadCount(1);
	                buffers.refreshVertexBuffer = false;
	            }

	            gl.enableVertexAttribArray(program.vertexPointLocation);
	            gl.vertexAttribPointer(program.vertexPointLocation, 3, gl.FLOAT, false, 0, 0);

	        };

	        // Internal. Intentionally not documented.
	        ColladaScene.prototype.applyColor = function (dc, material) {

	            var gl = dc.currentGlContext,
	                program = dc.currentProgram;

	            if (material) {
	                if (material.techniqueType === 'constant') {
	                    var diffuse = material.reflective;
	                }
	                else {
	                    diffuse = material.diffuse;
	                }
	            }

	            var opacity;
	            var r = 1, g = 1, b = 1, a = 1;

	            if (diffuse) {
	                r = diffuse[0];
	                g = diffuse[1];
	                b = diffuse[2];
	                a = diffuse[3] != null ? diffuse[3] : 1;
	            }

	            var color = new Color(r, g, b, a);
	            opacity = a * dc.currentLayer.opacity;
	            gl.depthMask(opacity >= 1 || dc.pickingMode);
	            program.loadColor(gl, dc.pickingMode ? this.pickColor : color);
	            program.loadOpacity(gl, dc.pickingMode ? (opacity > 0 ? 1 : 0) : opacity);
	        };

	        // Internal. Intentionally not documented.
	        ColladaScene.prototype.applyTexture = function (dc, buffers, material) {

	            var textureBound, vboId,
	                gl = dc.currentGlContext,
	                program = dc.currentProgram,
	                wrapMode;

	            if (material.textures.diffuse) {
	                var imageKey = material.textures.diffuse.mapId;
	            }
	            else {
	                imageKey = material.textures.reflective.mapId;
	            }

	            var image = this.useTexturePaths ? this.images[imageKey].path : this.images[imageKey].filename;

	            this._activeTexture = dc.gpuResourceCache.resourceForKey(this.dirPath + image + "");
	            if (!this._activeTexture) {
	                wrapMode = buffers.isClamp ? gl.CLAMP_TO_EDGE : gl.REPEAT;
	                this._activeTexture = dc.gpuResourceCache.retrieveTexture(gl, this.dirPath + image + "", wrapMode);
	            }
	            textureBound = this._activeTexture && this._activeTexture.bind(dc);

	            if (textureBound) {
	                if (!buffers.texCoordsVboCacheKey) {
	                    buffers.texCoordsVboCacheKey = dc.gpuResourceCache.generateCacheKey();
	                }

	                vboId = dc.gpuResourceCache.resourceForKey(buffers.texCoordsVboCacheKey);
	                if (!vboId) {
	                    vboId = gl.createBuffer();
	                    dc.gpuResourceCache.putResource(buffers.texCoordsVboCacheKey, vboId, buffers.uvs.length);
	                    buffers.refreshTexCoordBuffer = true;
	                }

	                gl.bindBuffer(gl.ARRAY_BUFFER, vboId);
	                if (buffers.refreshTexCoordBuffer) {
	                    gl.bufferData(gl.ARRAY_BUFFER, buffers.uvs, gl.STATIC_DRAW);
	                    dc.frameStatistics.incrementVboLoadCount(1);
	                    buffers.refreshTexCoordBuffer = false;
	                }

	                program.loadTextureEnabled(gl, true);
	                gl.enableVertexAttribArray(program.vertexTexCoordLocation);
	                gl.vertexAttribPointer(program.vertexTexCoordLocation, 2, gl.FLOAT, false, 0, 0);
	                program.loadTextureUnit(gl, gl.TEXTURE0);
	                program.loadModulateColor(gl, dc.pickingMode);
	            }
	        };

	        // Internal. Intentionally not documented.
	        ColladaScene.prototype.applyLighting = function (dc, buffers) {

	            var vboId,
	                gl = dc.currentGlContext,
	                program = dc.currentProgram;

	            program.loadApplyLighting(gl, true);
	            if (!buffers.normalsVboCacheKey) {
	                buffers.normalsVboCacheKey = dc.gpuResourceCache.generateCacheKey();
	            }

	            vboId = dc.gpuResourceCache.resourceForKey(buffers.normalsVboCacheKey);
	            if (!vboId) {
	                vboId = gl.createBuffer();
	                dc.gpuResourceCache.putResource(buffers.normalsVboCacheKey, vboId, buffers.normals.length);
	                buffers.refreshNormalBuffer = true;
	            }

	            gl.bindBuffer(gl.ARRAY_BUFFER, vboId);
	            if (buffers.refreshNormalBuffer) {
	                gl.bufferData(gl.ARRAY_BUFFER, buffers.normals, gl.STATIC_DRAW);
	                dc.frameStatistics.incrementVboLoadCount(1);
	                buffers.refreshNormalBuffer = false;
	            }

	            gl.enableVertexAttribArray(program.normalVectorLocation);
	            gl.vertexAttribPointer(program.normalVectorLocation, 3, gl.FLOAT, false, 0, 0);
	        };

	        // Internal. Intentionally not documented.
	        ColladaScene.prototype.applyMatrix = function (dc, hasLighting, hasTexture, nodeWorldMatrix, nodeNormalMatrix) {

	            var mvpMatrix = Matrix.fromIdentity();

	            mvpMatrix.copy(dc.navigatorState.modelviewProjection);

	            mvpMatrix.multiplyMatrix(this.transformationMatrix);

	            if (nodeWorldMatrix && this.localTransforms) {
	                mvpMatrix.multiplyMatrix(nodeWorldMatrix);
	            }

	            if (hasLighting && !dc.pickingMode) {

	                var normalMatrix = Matrix.fromIdentity();

	                normalMatrix.copy(dc.navigatorState.modelviewNormalTransform);

	                normalMatrix.multiplyMatrix(this.normalMatrix);

	                if (nodeNormalMatrix && this.localTransforms) {
	                    normalMatrix.multiplyMatrix(nodeNormalMatrix);
	                }

	                dc.currentProgram.loadModelviewInverse(dc.currentGlContext, normalMatrix);
	            }

	            if (hasTexture && this._activeTexture){
	                dc.currentProgram.loadTextureMatrix(dc.currentGlContext, this._texCoordMatrix);
	                this._activeTexture = null;
	            }

	            dc.currentProgram.loadModelviewProjection(dc.currentGlContext, mvpMatrix);

	        };

	        // Internal. Intentionally not documented.
	        ColladaScene.prototype.applyIndices = function (dc, buffers) {

	            var gl = dc.currentGlContext,
	                vboId;

	            if (!buffers.indicesVboCacheKey) {
	                buffers.indicesVboCacheKey = dc.gpuResourceCache.generateCacheKey();
	            }

	            vboId = dc.gpuResourceCache.resourceForKey(buffers.indicesVboCacheKey);
	            if (!vboId) {
	                vboId = gl.createBuffer();
	                dc.gpuResourceCache.putResource(buffers.indicesVboCacheKey, vboId, buffers.indices.length);
	                buffers.refreshIndicesBuffer = true;
	            }

	            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vboId);
	            if (buffers.refreshIndicesBuffer) {
	                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, buffers.indices, gl.STATIC_DRAW);
	                dc.frameStatistics.incrementVboLoadCount(1);
	                buffers.refreshIndicesBuffer = false;
	            }

	        };

	        // Internal. Intentionally not documented.
	        ColladaScene.prototype.resetDraw = function (dc, hasLighting, hasTexture) {

	            var gl = dc.currentGlContext,
	                program = dc.currentProgram;

	            if (hasLighting && !dc.pickingMode) {
	                program.loadApplyLighting(gl, false);
	                gl.disableVertexAttribArray(program.normalVectorLocation);
	            }

	            if (hasTexture) {
	                gl.disableVertexAttribArray(program.vertexTexCoordLocation);
	            }

	            gl.disableVertexAttribArray(program.vertexPointLocation);
	        };

	        // Internal. Intentionally not documented.
	        ColladaScene.prototype.endDrawing = function (dc) {
	            dc.bindProgram(null);
	        };

	        // Internal. Intentionally not documented.
	        ColladaScene.prototype.computeTransformationMatrix = function (globe) {

	            this.transformationMatrix = Matrix.fromIdentity();

	            this.transformationMatrix.multiplyByLocalCoordinateTransform(this.placePoint, globe);

	            this.transformationMatrix.multiplyByRotation(1, 0, 0, this.xRotation);
	            this.transformationMatrix.multiplyByRotation(0, 1, 0, this.yRotation);
	            this.transformationMatrix.multiplyByRotation(0, 0, 1, this.zRotation);

	            this.transformationMatrix.multiplyByScale(this.scale, this.scale, this.scale);

	            this.transformationMatrix.multiplyByTranslation(this.xTranslation, this.yTranslation, this.zTranslation);

	            this.computeNormalMatrix();

	        };

	        // Internal. Intentionally not documented.
	        ColladaScene.prototype.computeNormalMatrix = function () {

	            var rotAngles = new Vec3(0, 0, 0);

	            this.transformationMatrix.extractRotationAngles(rotAngles);

	            this.normalMatrix = Matrix.fromIdentity();

	            this.normalMatrix.multiplyByRotation(-1, 0, 0, rotAngles[0]);
	            this.normalMatrix.multiplyByRotation(0, -1, 0, rotAngles[1]);
	            this.normalMatrix.multiplyByRotation(0, 0, -1, rotAngles[2]);
	        };

	        // Internal. Intentionally not documented.
	        ColladaScene.prototype.mustRenderNode = function (nodeId) {
	            var draw = true;
	            if (this.hideNodes) {
	                var pos = this.nodesToHide.indexOf(nodeId);
	                draw = (pos === -1);
	            }
	            return draw;
	        };

	        return ColladaScene;

	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

	var PlacemarkAttributes = __webpack_require__(183);
	var ImageSource = __webpack_require__(51);
	var Placemark = __webpack_require__(187);
	var Offset = __webpack_require__(45);
	var Events = __webpack_require__(5);
	var Utils = __webpack_require__(144);
	var Generalization = __webpack_require__(148);
	var canvas = document.createElement('canvas');

	module.exports = {
	    create: createBillboard
	};

	function createBillboard(desc, addFunc) {
	    var p = desc.properties;
	    var size = p.quality || 100;
	    canvas.setAttribute('width', size);
	    canvas.setAttribute('height', size);
	    var ctx = canvas.getContext("2d");
	    var pad = p.padding || 2;
	    var bbox = desc.geometry.properties.bbox;
	    var k = (size-2*pad) / getMaxDimension(bbox);

	    var position = Utils.position(p.anchorPoint.coordinates);
	    var billboard = new Placemark(position, false, null);
	    billboard.source = desc;

	    var ox = p.offsetX || 0;
	    var oy = p.offsetY || 0;
	    var f = WorldWind.OFFSET_FRACTION;
	    var offsetX = ((ox-bbox.min[0])*k + pad)/size;
	    var offsetY = (oy*k + pad)/size;
	    var scale = p.scale || 1;

	    billboard.attributes = new PlacemarkAttributes({
	        _imageColor: Utils.extractColor(p, null, 1),
	        _depthTest: p.depth !== false,
	        _imageOffset: new Offset(f, offsetX, f, offsetY)
	    });
	    draw(false);
	    billboard.attributes._imageSource = getImageData();
	    draw(true);
	    billboard.attributes._whiteImageSource = getImageData();
	    billboard.highlightAttributes = new PlacemarkAttributes(billboard.attributes);
	    billboard.highlightAttributes.imageColor = Utils.extractColor(p, null, 1);
	    billboard.enabled = p.visible !== false;
	    billboard.altitudeMode = p.altitudeMode || WorldWind.RELATIVE_TO_GROUND;
	    billboard.attributes.imageScale = 0;
	    billboard.generalization = new Generalization(billboard.source.properties.generalization);
	    var oldMustDrawLabel = billboard.mustDrawLabel;
	    billboard.mustDrawLabel = function () {
	        billboard.attributes.imageScale =
	            billboard.highlightAttributes.imageScale =
	                billboard.generalization.getScale(this.eyeDistance) * scale;

	        oldMustDrawLabel.call(billboard);
	    };

	    var oldIsVisible = billboard.isVisible;
	    billboard.isVisible = function(dc){
	        return oldIsVisible.call(billboard, dc) &&
	            billboard.generalization.isVisible(this.eyeDistance);
	    };

	    addFunc([billboard]);

	    setTimeout(function(){
	        Events.post(Events.REDRAW);
	    }, 100);

	    function draw(white) {
	        ctx.clearRect(0, 0, size, size);
	        desc.geometry.geometries.forEach(function (element) {

	            var ep = element.properties;
	            var c = element.coordinates;

	            if (element.type === 'Point') {
	                ctx.textAlign = "center";
	                ctx.fillStyle = white ? 'white' : '#' + ep.color.substring(0, 6);
	                ctx.font = Math.floor(ep.fontSize * k) + 'px ' + ep.fontName;
	                ctx.textBaseline = "middle";
	                ctx.fillText(ep.text, coord(c, 0), coord(c, 1));
	                return;
	            }

	            ctx.beginPath();

	            if (element.type === 'Polygon') c = c[0];

	            var moveTo = c[0];
	            ctx.moveTo(coord(moveTo, 0), coord(moveTo, 1));
	            c.forEach(function (crd, i) {
	                i && ctx.lineTo(coord(crd, 0), coord(crd, 1));
	            });

	            if (element.type === 'LineString') {
	                ctx.lineWidth = ep.widthMultiplier;
	                ctx.strokeStyle = white ? 'white' : '#' + ep.stroke.substring(0, 6);
	                ctx.stroke();
	            }

	            if (element.type === 'Polygon') {
	                ctx.fillStyle = white ? 'white' : '#' + ep.fill.substring(0, 6);
	                ctx.fill();
	            }

	            ctx.closePath();
	        });
	    }

	    function coord(c, i) {
	        var value = pad + k * (c[i] - bbox.min[i]);
	        return i === 1 ? size - value : value;
	    }

	    function getImageData() {
	        return new ImageSource(ctx.getImageData(0, 0, size, size));
	    }
	}

	function getMaxDimension(bbox) {
	    return Math.max(
	        bbox.max[0] - bbox.min[0],
	        bbox.max[1] - bbox.min[1]
	    );
	}



/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

	var Events = __webpack_require__(5);
	var Position = __webpack_require__(47);
	var Utils = __webpack_require__(144);
	var GoToAnimator = __webpack_require__(120);

	module.exports = function (earth) {

	    var animator = new GoToAnimator(earth);
	    animator.animationFrequency = 10;
	    animator.travelTime = 1000;

	    earth.canvas.addEventListener('dblclick', doubleClickHandler);

	    Events.listen(Events.ROTATE_TO, goTo);
	    Events.listen(Events.SET_LOCATION, setLocation);

	    function doubleClickHandler(e) {
	        var clickCoordinates = earth.canvasCoordinates(e.clientX, e.clientY);
	        var clickPosition = earth.pickTerrain(clickCoordinates);
	        if (clickPosition.objects.length) {
	            var pos = clickPosition.objects[0].position;
	            var eye = earth.navigator.currentState().eyePoint;
	            var eyePos = earth.globe.computePositionFromPoint(eye[0], eye[1], eye[2], new Position());
	            goTo({
	                lat: pos.latitude,
	                lon: pos.longitude,
	                alt: eyePos.altitude / 3.0
	            });
	        }
	    }

	    function setLocation(location) {
	        var loc = Utils.location(location);
	        earth.navigator.lookAtLocation.longitude = loc.longitude;
	        earth.navigator.lookAtLocation.latitude = loc.latitude;
	        // earth.navigator.range = loc.latitude;
	        Events.post(Events.REDRAW);
	    }

	    function goTo(location) {
	        block(true);
	        animator.goTo(location.alt ? Utils.position(location) : Utils.location(location), block.bind(this, false));
	    }

	    function block(isBlocked){
	        Events.post(Events._BLOCK_NAVIGATOR_EVENTS_LISTENERS, isBlocked);
	    }
	};


/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

	var Events = __webpack_require__(5);
	var Globe3D = __webpack_require__(113);
	var Globe = __webpack_require__(113);
	var EarthElevationModel = __webpack_require__(110);
	var ZeroElevationModel = __webpack_require__(119);

	var ProjectionMercator = __webpack_require__(106);
	var ProjectionEquirectangular = __webpack_require__(108);

	var zeroElevationModel = new ZeroElevationModel();
	engine.zeroElevationModel = zeroElevationModel;
	var projections2d = {
	    mercator: new ProjectionMercator(),
	    equirectangular: new ProjectionEquirectangular()
	};

	var currentProjection = "equirectangular";



	var globe3d = new Globe3D(zeroElevationModel, null);
	var globe2d = new Globe(zeroElevationModel, projections2d.mercator);

	engine.globe3d = globe3d;

	module.exports = function (engine) {
	    switchGlobe(engine);

	    Events.listen(Events.SWITCH_GLOBE, function () {
	        switchGlobe(engine);
	    });

	    Events.listen(Events.SWITCH_2D_PROJECTION, function (name) {
	        if (!name) { // find next projection
	            var keys = Object.keys(projections2d);
	            var index = keys.indexOf(currentProjection) + 1;
	            name = keys[index === keys.length ? 0 : index];
	        }
	        currentProjection = name;
	        globe2d.projection = projections2d[name];
	        Events.post(Events.REDRAW);
	    });

	    Events.listen(Events._CHANGE_ELEVATION_MODEL, function(elevationModel){
	        globe3d.elevationModel = elevationModel;
	    });
	};

	function switchGlobe(engine) {
	    engine.globe = engine.globe === globe3d ? globe2d : globe3d;
	    Events.post(Events.REDRAW);
	}




/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

	var Events = __webpack_require__(5);
	var HttpTiledImageLayer = __webpack_require__(202);
	var SingleImageLayer = __webpack_require__(206);
	var WmtsLayer = __webpack_require__(207);
	var WmtsCapabilities = __webpack_require__(209);

	var WmsLayer = __webpack_require__(218);
	var WmsCapabilities = __webpack_require__(215);


	var ElevationModel = __webpack_require__(97);
	var ElevationImage = __webpack_require__(98);

	var Globe = __webpack_require__(113);
	var ZeroElevationModel = __webpack_require__(119);
	var EarthElevationModel = __webpack_require__(110);
	var WcsEarthElevationModel = __webpack_require__(220);
	var EarthRestElevationModel = __webpack_require__(222);

	var CustomEarthElevationModel = __webpack_require__(224);

	var GeoTiffReader = __webpack_require__(225);

	var WmtsImageLayer = __webpack_require__(233);
	var WmsImageLayer  = __webpack_require__(234);
	/***
	 *
	 * @param name
	 * @returns {WmsLayerCapabilities}
	 */
	WmsCapabilities.prototype.getNamedLayer = function (name) {
	    if (!name || (name.length === 0)) {
	        throw new ArgumentError(
	            Logger.logMessage(Logger.LEVEL_SEVERE, "WmsCapabilities", "getNamedLayer", "No WMS layer name provided."));
	    }

	    var namedLayers = this.getNamedLayers();

	    for (var i = 0, len = namedLayers.length; i < len; i++) {
	        if (name === namedLayers[i].name) {
	            return namedLayers[i];
	        }
	    }

	    return null;
	};

	/***
	 *
	 */
	WmsCapabilities.prototype.getNamedLayers = function () {
	    return this.accumulateNamedLayers(this.capability.layers);
	};

	/***
	 *
	 * @param startLayers
	 * @param namedLayersArray
	 * @returns {*|Array}
	 */
	WmsCapabilities.prototype.accumulateNamedLayers = function (startLayers, namedLayersArray) {
	    var namedLayers = namedLayersArray || [];

	    if (!startLayers) {
	        return namedLayers;
	    }

	    for (var i = 0, len = startLayers.length; i < len; i++) {
	        var layer = startLayers[i];
	        if (layer.name) {
	            namedLayers.push(layer);
	        }
	        if (layer.layers) {
	            this.accumulateNamedLayers(layer.layers, namedLayers);
	        }
	    }

	    return namedLayers;
	};

	//https://geoservice.dlr.de/eoc/atmosphere/wms
	//https://tiles.geoservice.dlr.de/service/wmts?SERVICE=WMTS&REQUEST=GetCapabilities&VERSION=1.0.0"
	var MAP_MANAGER = {

	    DEFAULT_TILE_URL: 'tiles/worldmap/z{z}/{y}/{x}.png',
	    DEFAULT_GROUND_PATH: 'images/ground/worldmap.2048x1024.jpg',

	    DEFAULT_WMS_GET_MAP: {
	        service: 'WMS',
	        request: 'GetMap',
	        version: '1.1.1',
	        layers: '',
	        styles: '',
	        format: 'image/jpeg',
	        transparent: false
	    },
	    DEFAULT_WMTS_GET_CAPABILITIES: {
	        SERVICE: 'WMTS',
	        REQUEST: 'GetCapabilities',
	        VERSION: '1.0.0'
	    },
	    DEFAULT_WMS_GET_CAPABILITIES: {
	        SERVICE: 'WMS',
	        REQUEST: 'GetCapabilities',
	        VERSION: '1.0.0'
	    }

	    //CRS : 'EPSG:3857'

	}

	var MapLayerManager = function () {

	    /***
	     *
	     * @param obj
	     * @param existingUrl
	     * @returns {string}
	     */
	    this.getParamString = function (obj, existingUrl) {
	        var params = [];
	        for (var i in obj) {
	            if (obj.hasOwnProperty(i)) {
	                params.push(i + '=' + obj[i]);
	            }
	        }
	        return ((!existingUrl || existingUrl.indexOf('?') === -1) ? '?' : '&') + params.join('&');
	    }

	    this.guid = function () {
	        function s4() {
	            return Math.floor((1 + Math.random()) * 0x10000)
	                .toString(16)
	                .substring(1);
	        }

	        return s4() + s4() + '-' + s4() + '-' + s4() + '-' +
	            s4() + '-' + s4() + s4() + s4();
	    };

	    /**
	     *
	     * @param dest
	     * @returns {*}
	     */
	    this.extend = function (dest) { // (Object[, Object, ...]) ->
	        var sources = Array.prototype.slice.call(arguments, 1),
	            i, j, len, src;

	        for (j = 0, len = sources.length; j < len; j++) {
	            src = sources[j] || {};
	            for (i in src) {
	                if (src.hasOwnProperty(i)) {
	                    dest[i] = src[i];
	                }
	            }
	        }
	        return dest;
	    };


	};

	/**
	 *
	 * @param parameters
	 * @returns {HttpTiledImageLayer}
	 */
	MapLayerManager.prototype.createTileMapLayer = function (parameters) {
	    var self = this;
	    parameters = parameters || {};

	    if (!parameters.patternUrl) {
	        parameters.patternUrl = MAP_MANAGER.DEFAULT_TILE_URL;
	    }

	    if (!parameters.name) {
	        parameters.name = 'map' + self.guid();
	    }
	    var lay = new HttpTiledImageLayer(parameters);

	    if (parameters.detail )
	      if (parameters.detail >= 1.0 && parameters.detail <= 2.2 )
	        lay.detailControl = parameters.detail;
	    return lay;
	};


	//MapLayerManager.prototype.createWMTSMapLayer2 = function (parameters) {
	// var self = this;
	// parameters = parameters || {};
	// var xmlDom = null;
	// var wmtsCapabilities  = WmtsCapabilities(xmlDom);
	// var wmtsLayerCapabilities = wmtsCapabilities.getLayer(layerIdentifier);
	// // Form a configuration object from the WmtsLayerCapabilities object
	// var wmtsConfig = WmtsLayer.formLayerConfiguration(wmtsLayerCapabilities);
	// // Create the WMTS Layer from the configuration object
	// var wmtsLayer = new WmtsLayer(wmtsConfig);
	//};

	/**
	 *
	 * @param parameters
	 * @param callback
	 */
	MapLayerManager.prototype.getWMTSCapabilities = function (parameters, callback) {
	    var self = this;
	    var url = parameters.patternUrl + self.getParamString(parameters.params, parameters.patternUrl);
	    var xhr = new XMLHttpRequest();
	    xhr.open('GET', url, false);
	    xhr.send();

	    if (xhr.status != 200) {
	        // обработать ошибку
	        var errMgs = xhr.status + ': ' + xhr.statusText;
	        //alert(errMgs); // 404: Not Found
	        if (callback) {
	            callback(errMgs);
	        }
	    } else {
	        var parser = new DOMParser();
	        var xmlDoc = parser.parseFromString(xhr.responseText, "text/xml");
	        // вывести результат
	        var wmtsCapabilities = new WmtsCapabilities(xmlDoc); //xhr.responseXML.getElementById('author')
	        if (callback) {
	            callback(wmtsCapabilities);
	        }
	    }
	};


	MapLayerManager.prototype.getWMSCapabilities = function (parameters, callback) {
	    var self = this;

	    var url = parameters.patternUrl + self.getParamString(parameters.params, parameters.patternUrl);

	    if (parameters.proxy ) {
	        url = parameters.proxy + url;
	    }
	    var xhr = new XMLHttpRequest();
	    xhr.open('GET', url, false);
	    xhr.send();

	    if (xhr.status != 200) {
	        // обработать ошибку
	        var errMgs = xhr.status + ': ' + xhr.statusText;
	        //alert(errMgs); // 404: Not Found
	        if (callback) {
	            callback(errMgs);
	        }
	    } else {
	        var parser = new DOMParser();
	        var xmlDoc = parser.parseFromString(xhr.responseText, "text/xml");
	        // вывести результат
	        var wmsCapabilities = new WmsCapabilities(xmlDoc); //xhr.responseXML.getElementById('author')
	        if (callback) {
	            callback(wmsCapabilities);
	        }
	    }
	};


	/**
	 *
	 * @param parameters
	 * @returns {SingleImageLayer}
	 */
	MapLayerManager.prototype.createGroundMapLayer = function (parameters) {
	    parameters = parameters || {};

	    if (!parameters.ground) {
	        parameters.ground = MAP_MANAGER.DEFAULT_GROUND_PATH;
	    }
	    return new SingleImageLayer(parameters.ground)
	};


	//module.exports = MapLayerManager;
	module.exports = function (engine) {
	    var mlm = new MapLayerManager();
	    var groundMapLayer;
	    var mapLayer;
	    var mapLayers = [];


	    /**
	     * */
	    Events.listen(Events._DESTROY_GROUND_MAP_LAYER, destroyGroundMapLayer);

	    Events.listen(Events._CREATE_GROUND_MAP_LAYER, function (path) {
	        destroyGroundMapLayer();
	        groundMapLayer = mlm.createGroundMapLayer(path);
	        //engine.insertLayer(0, groundMapLayer);
	        Events.post(Events._INSERT_LAYER, {index: 0, layer: groundMapLayer});
	        Events.post(Events.REDRAW);
	    });

	    Events.listen(Events._DESTROY_MAP_LAYER, destroyMapLayer);

	    Events.listen(Events._CREATE_WMS_MAP_LAYER, function (parameters) {
	        destroyMapLayer();
	        createWMSLayers(parameters, mapLayers);
	    });

	    Events.listen(Events._CREATE_WMTS_MAP_LAYER, function (parameters) {
	        destroyMapLayer();
	        createWMTS(parameters, mapLayers);
	    });


	    Events.listen(Events._CREATE_TILE_MAP_LAYER, function (parameters) {
	        destroyMapLayer();
	        mapLayer = mlm.createTileMapLayer(parameters);
	        //engine.insertLayer(1, mapLayer);
	        Events.post(Events._INSERT_LAYER, {index: 1, layer: mapLayer});
	        Events.post(Events.REDRAW);
	    });


	    //User listeners

	    Events.listen(Events.CHANGE_MAP, changeMapLayer);

	    Events.listen(Events.GET_OGC_LAYERS, getOGCLayers);

	    Events.listen(Events.CHANGE_ELEVATION_MODEL, changeElevationModel);


	    /***
	     *
	     */
	    function destroyGroundMapLayer() {
	        if (groundMapLayer) {
	            //engine.removeLayer(groundMapLayer);
	            Events.post(Events._REMOVE_LAYER, groundMapLayer);
	            Events.post(Events.REDRAW);
	        }
	    }

	    /***
	     *
	     */
	    function destroyMapLayer() {
	        if (mapLayer) {
	            Events.post(Events._REMOVE_LAYER, mapLayer);
	        }

	        if (mapLayers) {
	            mapLayers.forEach(function (lay, i, arr) {
	                Events.post(Events._REMOVE_LAYER, lay);
	            });
	            mapLayers = [];
	        }

	        Events.post(Events.REDRAW);
	    }

	    /**
	     *
	     * @param parameters
	     */
	    function createWMSLayers(parameters, mapLayers) {
	        var parameters = parameters || {};
	        var wmsLayers = mapLayers || [];
	        var showIndexes = [];

	        if (!parameters.patternUrl) {
	            return;
	        }

	        if (!parameters.params) {
	            parameters.params = MAP_MANAGER.DEFAULT_WMS_GET_CAPABILITIES;
	        }

	        if (parameters.layers && Array.isArray(parameters.layers)) {
	            showIndexes = parameters.layers;
	        }

	        var getCapa = function (wmsCapabilities) {
	            if (wmsCapabilities != null && wmsCapabilities.capability) {
	                var wmsCapaLayers = wmsCapabilities.getNamedLayers();
	                if (wmsCapaLayers != null && wmsCapaLayers.length > 0) {
	                    for (var i = 0; i < wmsCapaLayers.length - 1; i++) {
	                        var wmsConfig = WmsLayer.formLayerConfiguration(wmsCapaLayers[i]);

	                        if (parameters.proxy)
	                            wmsConfig.proxy = parameters.proxy;

	                        var wmsLayer = new WmsImageLayer(wmsConfig);

	                        wmsLayers.push(wmsLayer);
	                    }
	                    //Events.post(Events._SHOW_WMS_LAYERS, {layers: showIndexes});
	                    Events.post(Events.GET_OGC_LAYERS, {requestType: "wms", visibleIndices: showIndexes, layers: wmsLayers});
	                }
	            }
	        }
	        mlm.getWMSCapabilities(parameters, getCapa);
	    }

	    /**
	     *
	     * @param parameters
	     */
	    function createWMTS(parameters, mapLayers) {
	        var wmtsLayers = mapLayers || [];
	        var parameters = parameters || {};
	        var showIndexes = [];

	        if (!parameters.patternUrl) {
	            return;
	        }

	        if (!parameters.params) {
	            parameters.params = MAP_MANAGER.DEFAULT_WMTS_GET_CAPABILITIES;
	        }

	        if (parameters.layers && Array.isArray(parameters.layers)) {
	            showIndexes = parameters.layers;
	        }

	        var getCapa = function (wmtsCapabilities) {
	            if (wmtsCapabilities != null && wmtsCapabilities.contents) {
	                var wmtsCapaLayers = wmtsCapabilities.contents.layer;
	                for (var i = 0; i < wmtsCapaLayers.length; i++) {
	                    var wmtsLayerCapa = wmtsCapabilities.contents.layer[i];
	                    var wmtsLayer = new WmtsImageLayer(wmtsLayerCapa);
	                    wmtsLayers.push(wmtsLayer);
	                }
	                //Events.post(Events._SHOW_WMTS_LAYERS, {layers: showIndexes});
	                Events.post(Events.GET_OGC_LAYERS, {requestType: "wmts", visibleIndices: showIndexes, layers: wmtsLayers});
	            }
	        }
	        mlm.getWMTSCapabilities(parameters, getCapa);
	    }


	    /**
	     *
	     * */
	    function changeMapLayer(data) {
	        if (data) {
	            //Земельна подложка добавляется всегда
	            Events.post(Events._CREATE_GROUND_MAP_LAYER, data);

	            if (!data.type || data.type === 'tile') {
	                Events.post(Events._CREATE_TILE_MAP_LAYER, data);
	            } else if (data.type === 'wmts') {
	                Events.post(Events._CREATE_WMTS_MAP_LAYER, data);
	            } else if (data.type === 'wms') {
	                Events.post(Events._CREATE_WMS_MAP_LAYER, data);
	            }
	        }
	    }




	    /***
	     *
	     * @param parameters
	     */
	    function changeElevationModel(parameters) {
	        if (!parameters.type || parameters.type === 'none') {
	            engine.globe3d.elevationModel = engine.zeroElevationModel;
	        } else if (parameters.url) {
	            if (parameters.type === 'rest') {
	                var displayName = "elev" + mlm.guid();
	                var pathToData =  "elevation/DTED0";
	                engine.globe3d.elevationModel = new EarthRestElevationModel(null, pathToData, displayName);
	            } else {
	                engine.globe3d.elevationModel = new CustomEarthElevationModel(parameters);
	            }
	        }
	        Events.post(Events.REDRAW);
	    }

	    /**
	     *
	     * @param data
	     */
	    function getOGCLayers(data) {
	        //Don`t override this
	        if (data && data.visibleIndices && Array.isArray(data.visibleIndices)) {
	            data.visibleIndices.forEach(function (ilayer, i, arr) {
	                if (typeof ilayer === 'number') {
	                    if ( Array.isArray(data.layers) && ilayer >= 0 && ilayer < data.layers.length) {
	                        Events.post(Events._INSERT_LAYER, {index: i + 1, layer: data.layers[ilayer]});
	                    }
	                }
	            });
	        }
	        // Other event
	    }


	    /***
	     * OVERRIDE ElevationModel
	     */
	    ElevationModel.prototype.loadElevationImage = function (tile, xhr) {
	        var elevationImage = new ElevationImage(tile.imagePath, tile.sector, tile.tileWidth, tile.tileHeight);

	        if (this.retrievalImageFormat == "image/tiff") {
	            var tif = new GeoTiffReader("0");
	            tif.parse(xhr.response);
	            var arr = tif.createTypedElevationArray();

	            elevationImage.imageData = arr;
	            elevationImage.size = elevationImage.imageData.length;
	        } else
	        if (this.retrievalImageFormat == "application/bil16") {
	            elevationImage.imageData = new Int16Array(xhr.response);
	            elevationImage.size = elevationImage.imageData.length * 2;
	        } else if (this.retrievalImageFormat == "application/bil32") {
	            elevationImage.imageData = new Float32Array(xhr.response);
	            elevationImage.size = elevationImage.imageData.length * 4;
	        }

	        if (elevationImage.imageData) {
	            elevationImage.findMinAndMaxElevation();
	            this.imageCache.putEntry(tile.imagePath, elevationImage, elevationImage.size);
	            this.timestamp = Date.now();
	        }
	    };


	};

/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

	var MercatorTiledImageLayer = __webpack_require__(203);
	var Color = __webpack_require__(52);
	var Location = __webpack_require__(28);
	var Sector = __webpack_require__(75);

	var Events = __webpack_require__(5);

	var limit = 85.05;

	var HttpTiledImageLayer = function (params) {
	    var self = this;

	    this.emptyImageUrl = 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=';

	    this.options = {
	            minZoom: 0,
	            maxZoom: 18,
	            tileSize: 256,
	            subdomains: '123',
	            errorTileUrl: '',
	            attribution: '',
	            zoomOffset: 0,
	            opacity: 1,
	            suffix : 'jpg',
	            name : 'tileLayer'
	    };

	    this.tileLoadingLimit = 5;
	    this.tileLoadingIsBlocked = false;
	    this.options = setOptions(this, params);
	    this.imageSize = this.options.tileSize;

	    MercatorTiledImageLayer.call(
	        this,
	        new Sector(-limit, limit, -180, 180),
	        new Location(limit, 180),
	        this.options.maxZoom,
	        'image/' + this.options.suffix,
	        this.options.name,
	        this.options.tileSize,
	        this.options.tileSize
	    );

	    this.displayName = 'HttpTiledImageLayer';

	    this.urlBuilder = {
	        urlForTile: function (tile) {
	            return formatUrl (
	                tile.level.levelNumber + 1,
	                tile.column,
	                tile.row,
	                self.options.patternUrl
	            );
	        }
	    };

	    /***
	     *
	     * @param str
	     * @param data
	     * @returns {XML|string|void}
	     */
	    var _template = function (str, data) {
	        return str.replace(/\{ *([\w_]+) *\}/g, function (str, key) {
	            var value = data[key];
	            if (!data.hasOwnProperty(key)) {
	                throw new Error('No value provided for variable ' + str);
	            }
	            return value;
	        });
	    };

	    /***
	     *
	     * @param tilePoint
	     * @returns {*}
	     * @private
	     */
	    var _getSubdomain = function (x, y) {
	        var index = (x + y) % self.options.subdomains.length;
	        return self.options.subdomains[index];
	    };

	    /**
	     *
	     * @param x
	     * @param y
	     * @param z
	     * @returns {string}
	     */
	    var _quadKey = function (x, y, z) {
	        var quadKey = [];
	        for (var i = z; i > 0; i--) {
	            var digit = '0';
	            var mask = 1 << (i - 1);
	            if ((x & mask) != 0) {
	                digit++;
	            }
	            if ((y & mask) != 0) {
	                digit++;
	                digit++;
	            }
	            quadKey.push(digit);
	        }
	        return quadKey.join('');
	    };

	    /**
	     *
	     * @param level
	     * @param row
	     * @param col
	     * @param pattern
	     * @returns {XML|string|void}
	     */
	    function formatUrl(level, row, col, pattern) {
	        return _template(pattern,
	            {
	                x : row,
	                y : col,
	                z : level,
	                s : _getSubdomain(row, col),
	                q : _quadKey(row, col, level)
	            });
	    };

	    /**
	     *
	     * @param dest
	     * @returns {*}
	     */
	    function extend(dest) { // (Object[, Object, ...]) ->
	        var sources = Array.prototype.slice.call(arguments, 1),
	            i, j, len, src;

	        for (j = 0, len = sources.length; j < len; j++) {
	            src = sources[j] || {};
	            for (i in src) {
	                if (src.hasOwnProperty(i)) {
	                    dest[i] = src[i];
	                }
	            }
	        }
	        return dest;
	    };

	    /**
	     *
	     * @param obj
	     * @param options
	     * @returns {void|*}
	     */
	    function setOptions (obj, options) {
	        obj.options = extend({}, obj.options, options);
	        return obj.options;
	    };

	    /**
	     *
	     * @param obj
	     * @returns {boolean}
	     */
	    this.isArray = function (obj) {
	        return (Object.prototype.toString.call(obj) === '[object Array]');
	    };

	    /**
	     *
	     * @param str
	     * @returns {Array}
	     */
	    this.splitWords = function (str) {
	        return str.replace(/^\s+|\s+$/g, '').split(/\s+/);
	    };

	    /**
	     *
	     * @param tileCoord[ z x y ]
	     * @returns {string}
	     */
	    this.quadKey = function(tileCoord) {
	        var z = tileCoord[0];
	        var digits = new Array(z);
	        var mask = 1 << (z - 1);
	        var i, charCode;
	        for (i = 0; i < z; ++i) {
	            // 48 is charCode for 0 - '0'.charCodeAt(0)
	            charCode = 48;
	            if (tileCoord[1] & mask) {
	                charCode += 1;
	            }
	            if (tileCoord[2] & mask) {
	                charCode += 2;
	            }
	            digits[i] = String.fromCharCode(charCode);
	            mask >>= 1;
	        }
	        return digits.join('');
	    };

	    Events.listen(Events._BLOCK_TILE_LOADING, this.blockTileLoading.bind(this));
	};

	HttpTiledImageLayer.prototype = Object.create(MercatorTiledImageLayer.prototype);

	HttpTiledImageLayer.prototype.getEmptyImageUrl = function () {
	  return this.emptyImageUrl;
	};

	HttpTiledImageLayer.prototype.doRender = function (dc) {
	     MercatorTiledImageLayer.prototype.doRender.call(this, dc);
	     if (this.inCurrentFrame) {
	//         // dc.screenCreditController.addStringCredit(defaultName, Color.DARK_GRAY);
	     }
	 };

	HttpTiledImageLayer.prototype.createTopLevelTiles = function (dc) {
	    var self = this;

	    self.topLevelTiles = [
	        [0, 0], [0, 1],
	        [1, 0], [1, 1]
	    ].map(function (xy) {
	        return self.createTile(null, self.levels.firstLevel(), xy[0], xy[1]);
	    });
	};

	HttpTiledImageLayer.prototype.mapSizeForLevel = function (levelNumber) {
	    return 256 << (levelNumber + 1);
	};

	module.exports = HttpTiledImageLayer;

	HttpTiledImageLayer.prototype.removeFromCurrentRetrievals = function (imagePath) {
	    MercatorTiledImageLayer.prototype.removeFromCurrentRetrievals.call(this, imagePath);
	    Events.post(Events.WAIT, this.currentRetrievals.length);
	};

	// block tile loading crutches (performance)

	HttpTiledImageLayer.prototype.blockTileLoading = function () {
	    this.tileLoadingIsBlocked = true;
	    this.currentRetrievals = [];
	    if (this.unblockTileLoadingTimeout) {
	        clearTimeout(this.unblockTileLoadingTimeout);
	    }

	    this.unblockTileLoadingTimeout = setTimeout(this.unblockTileLoading.bind(this), 300);
	};

	HttpTiledImageLayer.prototype.unblockTileLoading = function () {
	    this.tileLoadingIsBlocked = false;
	    this.refresh();
	    Events.post(Events.REDRAW);
	};

	HttpTiledImageLayer.prototype.canLoadNextTile = function () {
	    return this.currentRetrievals.length < this.tileLoadingLimit && !this.tileLoadingIsBlocked;
	};

	HttpTiledImageLayer.prototype.retrieveTileImage = function (dc, tile, supressDraw) {
	    if (!this.canLoadNextTile()) {
	        return;
	    }
	    Events.post(Events.WAIT, true);
	    MercatorTiledImageLayer.prototype.retrieveTileImage.call(this, dc, tile, supressDraw);
	};

	//HttpTiledImageLayer.prototype.createTexture = function (dc, tile, image) {
	//    if (!this.canLoadNextTile()) {
	//        return;
	//    }
	//    return MercatorTiledImageLayer.prototype.createTexture.call(this, dc, tile, image);
	//};
	//
	// HttpTiledImageLayer.prototype.fadeOutgoingTiles = function (dc) {
	//     if (!this.canLoadNextTile()) {
	//         return;
	//     }
	//     MercatorTiledImageLayer.prototype.fadeOutgoingTiles.call(this, dc);
	// };


/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports MercatorTiledImageLayer
	 * @version $Id: MercatorTiledImageLayer.js 3120 2015-05-28 02:32:45Z tgaskins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(52),
	        __webpack_require__(75),
	        __webpack_require__(204),
	        __webpack_require__(46),
	        __webpack_require__(36)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Color,
	              Sector,
	              TiledImageLayer,
	              Vec2,
	              WWMath) {
	        "use strict";

	        /**
	         * Constructs a layer supporting Mercator imagery.
	         * @alias MercatorTiledImageLayer
	         * @constructor
	         * @augments TiledImageLayer
	         * @classdesc Provides an abstract layer to support Mercator layers.
	         *
	         * @param {Sector} sector The sector this layer covers.
	         * @param {Location} levelZeroDelta The size in latitude and longitude of level zero (lowest resolution) tiles.
	         * @param {Number} numLevels The number of levels to define for the layer. Each level is successively one power
	         * of two higher resolution than the next lower-numbered level. (0 is the lowest resolution level, 1 is twice
	         * that resolution, etc.)
	         * Each level contains four times as many tiles as the next lower-numbered level, each 1/4 the geographic size.
	         * @param {String} imageFormat The mime type of the image format for the layer's tiles, e.g., <em>image/png</em>.
	         * @param {String} cachePath A string uniquely identifying this layer relative to other layers.
	         * @param {Number} tileWidth The horizontal size of image tiles in pixels.
	         * @param {Number} tileHeight The vertical size of image tiles in pixels.
	         * @throws {ArgumentError} If any of the specified sector, level-zero delta, cache path or image format arguments are
	         * null or undefined, or if the specified number of levels, tile width or tile height is less than 1.
	         */
	        var MercatorTiledImageLayer = function (sector, levelZeroDelta, numLevels, imageFormat, cachePath,
	                                                tileWidth, tileHeight) {
	            TiledImageLayer.call(this,
	                sector, levelZeroDelta, numLevels, imageFormat, cachePath, tileWidth, tileHeight);

	            this.detectBlankImages = false;

	            // These pixels are tested in retrieved images to determine whether the image is blank.
	            this.testPixels = [
	                new Vec2(20, 20),
	                new Vec2(235, 20),
	                new Vec2(20, 235),
	                new Vec2(235, 235)
	            ];

	            // Create a canvas we can use when unprojecting retrieved images.
	            this.destCanvas = document.createElement("canvas");
	            this.destContext = this.destCanvas.getContext("2d");
	        };

	        MercatorTiledImageLayer.prototype = Object.create(TiledImageLayer.prototype);

	        // Overridden from TiledImageLayer. Computes a tile's sector and creates the tile.
	        // Unlike typical tiles, Tiles at the same level do not have the same sector size.
	        MercatorTiledImageLayer.prototype.createTile = function (sector, level, row, column) {
	            var mapSize = this.mapSizeForLevel(level.levelNumber),
	                swX = WWMath.clamp(column * this.imageSize, 0, mapSize),
	                neY = WWMath.clamp(row * this.imageSize, 0, mapSize),
	                neX = WWMath.clamp(swX + (this.imageSize), 0, mapSize),
	                swY = WWMath.clamp(neY + (this.imageSize), 0, mapSize),
	                x, y, swLat, swLon, neLat, neLon;

	            x = (swX / mapSize) - 0.5;
	            y = 0.5 - (swY / mapSize);
	            swLat = 90 - 360 * Math.atan(Math.exp(-y * 2 * Math.PI)) / Math.PI;
	            swLon = 360 * x;

	            x = (neX / mapSize) - 0.5;
	            y = 0.5 - (neY / mapSize);
	            neLat = 90 - 360 * Math.atan(Math.exp(-y * 2 * Math.PI)) / Math.PI;
	            neLon = 360 * x;

	            sector = new Sector(swLat, neLat, swLon, neLon);

	            return TiledImageLayer.prototype.createTile.call(this, sector, level, row, column);
	        };

	        // Overridden from TiledImageLayer to unproject the retrieved image prior to creating a texture for it.
	        MercatorTiledImageLayer.prototype.createTexture = function (dc, tile, image) {
	            var srcCanvas = dc.canvas2D,
	                srcContext = dc.ctx2D,
	                srcImageData,
	                destCanvas = this.destCanvas,
	                destContext = this.destContext,
	                destImageData = destContext.createImageData(image.width, image.height),
	                sector = tile.sector,
	                tMin = WWMath.gudermannianInverse(sector.minLatitude),
	                tMax = WWMath.gudermannianInverse(sector.maxLatitude),
	                lat, g, srcRow, kSrc, kDest, sy, dy;

	            srcCanvas.width = image.width;
	            srcCanvas.height = image.height;
	            destCanvas.width = image.width;
	            destCanvas.height = image.height;

	            // Draw the original image to a canvas so image data can be had for it.
	            srcContext.drawImage(image, 0, 0, image.width, image.height);
	            srcImageData = srcContext.getImageData(0, 0, image.width, image.height);

	            // If it's a blank image, mark it as permanently absent.
	            if (this.detectBlankImages && this.isBlankImage(image, srcImageData)) {
	                this.absentResourceList.markResourceAbsentPermanently(tile.imagePath);
	                return null;
	            }

	            // Unproject the retrieved image.
	            for (var n = 0; n < 1; n++) {
	                for (var y = 0; y < image.height; y++) {
	                    sy = 1 - y / (image.height - 1);
	                    lat = sy * sector.deltaLatitude() + sector.minLatitude;
	                    g = WWMath.gudermannianInverse(lat);
	                    dy = 1 - (g - tMin) / (tMax - tMin);
	                    dy = WWMath.clamp(dy, 0, 1);
	                    srcRow = Math.floor(dy * (image.height - 1));
	                    for (var x = 0; x < image.width; x++) {
	                        kSrc = 4 * (x + srcRow * image.width);
	                        kDest = 4 * (x + y * image.width);

	                        destImageData.data[kDest] = srcImageData.data[kSrc];
	                        destImageData.data[kDest + 1] = srcImageData.data[kSrc + 1];
	                        destImageData.data[kDest + 2] = srcImageData.data[kSrc + 2];
	                        destImageData.data[kDest + 3] = srcImageData.data[kSrc + 3];
	                    }
	                }
	            }

	            destContext.putImageData(destImageData, 0, 0);

	            return TiledImageLayer.prototype.createTexture.call(this, dc, tile, destCanvas);
	        };

	        // Determines whether a retrieved image is blank.
	        MercatorTiledImageLayer.prototype.isBlankImage = function (image, srcImageData) {
	            var pixel, k, pixelValue = null;

	            for (var i = 0, len = this.testPixels.length; i < len; i++) {
	                pixel = this.testPixels[i];
	                k = 4 * (pixel[0] + pixel[1] * image.width);

	                if (!pixelValue) {
	                    pixelValue = [
	                        srcImageData.data[k],
	                        srcImageData.data[k + 1],
	                        srcImageData.data[k + 2]
	                    ];
	                } else {
	                    if (srcImageData.data[k] != pixelValue[0]
	                        || srcImageData.data[k + 1] != pixelValue[1]
	                        || srcImageData.data[k + 2] != pixelValue[2]) {
	                        return false;
	                    }
	                }
	            }

	            return true;
	        };

	        return MercatorTiledImageLayer;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports TiledImageLayer
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(50),
	        __webpack_require__(30),
	        __webpack_require__(205),
	        __webpack_require__(126),
	        __webpack_require__(100),
	        __webpack_require__(32),
	        __webpack_require__(53),
	        __webpack_require__(54),
	        __webpack_require__(77),
	        __webpack_require__(83)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (AbsentResourceList,
	              ArgumentError,
	              ImageTile,
	              Layer,
	              LevelSet,
	              Logger,
	              MemoryCache,
	              Texture,
	              Tile,
	              WWUtil) {
	        "use strict";

	        /**
	         * Constructs a tiled image layer.
	         * @alias TiledImageLayer
	         * @constructor
	         * @classdesc
	         * Provides a layer that displays multi-resolution imagery arranged as adjacent tiles in a pyramid.
	         * This is the primary World Wind base class for displaying imagery of this type. While it may be used as a
	         * stand-alone class, it is typically subclassed by classes that identify the remote image server.
	         * <p>
	         * While the image tiles for this class are typically drawn from a remote server such as a WMS server. The actual
	         * retrieval protocol is independent of this class and encapsulated by a class implementing the {@link UrlBuilder}
	         * interface and associated with instances of this class as a property.
	         * <p>
	         * There is no requirement that image tiles of this class be remote, they may be local or procedurally generated. For
	         * such cases the subclass overrides this class' [retrieveTileImage]{@link TiledImageLayer#retrieveTileImage} method.
	         * <p>
	         * Layers of this type are by default not pickable. Their pick-enabled flag is initialized to false.
	         *
	         * @augments Layer
	         * @param {Sector} sector The sector this layer covers.
	         * @param {Location} levelZeroDelta The size in latitude and longitude of level zero (lowest resolution) tiles.
	         * @param {Number} numLevels The number of levels to define for the layer. Each level is successively one power
	         * of two higher resolution than the next lower-numbered level. (0 is the lowest resolution level, 1 is twice
	         * that resolution, etc.)
	         * Each level contains four times as many tiles as the next lower-numbered level, each 1/4 the geographic size.
	         * @param {String} imageFormat The mime type of the image format for the layer's tiles, e.g., <em>image/png</em>.
	         * @param {String} cachePath A string uniquely identifying this layer relative to other layers.
	         * @param {Number} tileWidth The horizontal size of image tiles in pixels.
	         * @param {Number} tileHeight The vertical size of image tiles in pixels.
	         * @throws {ArgumentError} If any of the specified sector, level-zero delta, cache path or image format arguments are
	         * null or undefined, or if the specified number of levels, tile width or tile height is less than 1.
	         *
	         */
	        var TiledImageLayer = function (sector, levelZeroDelta, numLevels, imageFormat, cachePath, tileWidth, tileHeight) {
	            if (!sector) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "TiledImageLayer", "constructor", "missingSector"));
	            }

	            if (!levelZeroDelta) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "TiledImageLayer", "constructor",
	                        "The specified level-zero delta is null or undefined."));
	            }

	            if (!imageFormat) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "TiledImageLayer", "constructor",
	                        "The specified image format is null or undefined."));
	            }

	            if (!cachePath) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "TiledImageLayer", "constructor",
	                        "The specified cache path is null or undefined."));
	            }

	            if (!numLevels || numLevels < 1) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "TiledImageLayer", "constructor",
	                        "The specified number of levels is less than one."));
	            }

	            if (!tileWidth || !tileHeight || tileWidth < 1 || tileHeight < 1) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "TiledImageLayer", "constructor",
	                        "The specified tile width or height is less than one."));
	            }

	            Layer.call(this, "Tiled Image Layer");

	            this.retrievalImageFormat = imageFormat;
	            this.cachePath = cachePath;

	            this.levels = new LevelSet(sector, levelZeroDelta, numLevels, tileWidth, tileHeight);

	            /**
	             * Controls the level of detail switching for this layer. The next highest resolution level is
	             * used when an image's texel size is greater than this number of pixels, up to the maximum resolution
	             * of this layer.
	             * @type {Number}
	             * @default 1.75
	             */
	            this.detailControl = 1.75;

	            /* Intentionally not documented.
	             * Indicates the time at which this layer's imagery expire. Expired images are re-retrieved
	             * when the current time exceeds the specified expiry time. If null, images do not expire.
	             * @type {Date}
	             */
	            this.expiration = null;

	            this.currentTiles = [];
	            this.currentTilesInvalid = true;
	            this.tileCache = new MemoryCache(500000, 400000);
	            this.currentRetrievals = [];
	            this.absentResourceList = new AbsentResourceList(3, 50e3);

	            this.pickEnabled = false;
	        };

	        TiledImageLayer.prototype = Object.create(Layer.prototype);

	        // Inherited from Layer.
	        TiledImageLayer.prototype.refresh = function () {
	            this.expiration = new Date();
	            this.currentTilesInvalid = true;
	        };

	        /**
	         * Initiates retrieval of this layer's level 0 images. Use
	         * [isPrePopulated]{@link TiledImageLayer#isPrePopulated} to determine when the images have been retrieved
	         * and associated with the level 0 tiles.
	         * Pre-populating is not required. It is used to eliminate the visual effect of loading tiles incrementally,
	         * but only for level 0 tiles. An application might pre-populate a layer in order to delay displaying it
	         * within a time series until all the level 0 images have been retrieved and added to memory.
	         * @param {WorldWindow} wwd The world window for which to pre-populate this layer.
	         * @throws {ArgumentError} If the specified world window is null or undefined.
	         */
	        TiledImageLayer.prototype.prePopulate = function (wwd) {
	            if (!wwd) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "TiledImageLayer", "prePopulate", "missingWorldWindow"));
	            }

	            var dc = wwd.drawContext;

	            if (!this.topLevelTiles || (this.topLevelTiles.length === 0)) {
	                this.createTopLevelTiles(dc);
	            }

	            for (var i = 0; i < this.topLevelTiles.length; i++) {
	                var tile = this.topLevelTiles[i];

	                if (!this.isTileTextureInMemory(dc, tile)) {
	                    this.retrieveTileImage(dc, tile, true); // suppress redraw upon successful retrieval
	                }
	            }
	        };

	        /**
	         * Initiates retrieval of this layer's tiles that are visible in the specified World Window. Pre-populating is
	         * not required. It is used to eliminate the visual effect of loading tiles incrementally.
	         * @param {WorldWindow} wwd The world window for which to pre-populate this layer.
	         * @throws {ArgumentError} If the specified world window is null or undefined.
	         */
	        TiledImageLayer.prototype.prePopulateCurrentTiles = function (wwd) {
	            if (!wwd) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "TiledImageLayer", "prePopulate", "missingWorldWindow"));
	            }

	            var dc = wwd.drawContext;
	            this.assembleTiles(dc);

	            for (var i = 0, len = this.currentTiles.length; i < len; i++) {
	                var tile = this.currentTiles[i];

	                if (!this.isTileTextureInMemory(dc, tile)) {
	                    this.retrieveTileImage(dc, tile, true); // suppress redraw upon successful retrieval
	                }
	            }
	        };

	        /**
	         * Indicates whether this layer's level 0 tile images have been retrieved and associated with the tiles.
	         * Use [prePopulate]{@link TiledImageLayer#prePopulate} to initiate retrieval of level 0 images.
	         * @param {WorldWindow} wwd The world window associated with this layer.
	         * @returns {Boolean} true if all level 0 images have been retrieved, otherwise false.
	         * @throws {ArgumentError} If the specified world window is null or undefined.
	         */
	        TiledImageLayer.prototype.isPrePopulated = function (wwd) {
	            if (!wwd) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "TiledImageLayer", "isPrePopulated", "missingWorldWindow"));
	            }

	            for (var i = 0; i < this.topLevelTiles.length; i++) {
	                if (!this.isTileTextureInMemory(wwd.drawContext, this.topLevelTiles[i])) {
	                    return false;
	                }
	            }

	            return true;
	        };

	        // Intentionally not documented.
	        TiledImageLayer.prototype.createTile = function (sector, level, row, column) {
	            var path = this.cachePath + "-layer/" + level.levelNumber + "/" + row + "/" + row + "_" + column + "."
	                + WWUtil.suffixForMimeType(this.retrievalImageFormat);

	            return new ImageTile(sector, level, row, column, path);
	        };

	        // Documented in superclass.
	        TiledImageLayer.prototype.doRender = function (dc) {
	            if (!dc.terrain)
	                return;

	            if (this.currentTilesInvalid
	                || !this.lasTtMVP || !dc.navigatorState.modelviewProjection.equals(this.lasTtMVP)
	                || dc.globeStateKey != this.lastGlobeStateKey) {
	                this.currentTilesInvalid = false;

	                // Tile fading works visually only when the surface tiles are opaque, otherwise the surface flashes
	                // when two tiles are drawn over the same area, even though one of them is semi-transparent.
	                // So do not provide fading when the surface opacity is less than 1;
	                if (dc.surfaceOpacity >= 1 && this.opacity >= 1) {
	                    // Fading of outgoing tiles requires determination of the those tiles. Prepare an object with all of
	                    // the preceding frame's tiles so that we can subsequently compare the list of newly selected tiles
	                    // with the previously selected tiles.
	                    this.previousTiles = {};
	                    for (var j = 0; j < this.currentTiles.length; j++) {
	                        this.previousTiles[this.currentTiles[j].imagePath] = this.currentTiles[j];
	                    }

	                    this.assembleTiles(dc);
	                    this.fadeOutgoingTiles(dc);
	                } else {
	                    this.assembleTiles(dc);
	                }

	            }

	            this.lasTtMVP = dc.navigatorState.modelviewProjection;
	            this.lastGlobeStateKey = dc.globeStateKey;

	            if (this.currentTiles.length > 0) {
	                dc.surfaceTileRenderer.renderTiles(dc, this.currentTiles, this.opacity, dc.surfaceOpacity >= 1);
	                dc.frameStatistics.incrementImageTileCount(this.currentTiles.length);
	                this.inCurrentFrame = true;
	            }
	        };

	        TiledImageLayer.prototype.fadeOutgoingTiles = function (dc) {
	            // Determine which files are outgoing and fade their disappearance. Must be called after this frame's
	            // current tiles for this layer have been determined.

	            var visibilityDelta = (dc.timestamp - dc.previousRedrawTimestamp) / dc.fadeTime;

	            // Create a hash table of the current tiles so that we can check for tile inclusion below.
	            var current = {};
	            for (var i = 0; i < this.currentTiles.length; i++) {
	                var tile = this.currentTiles[i];
	                current[tile.imagePath] = tile;
	            }

	            // Determine whether the tile was in the previous frame but is not in this one.  If that's the case,
	            // then the tile is outgoing and its opacity needs to be reduced.
	            for (var tileImagePath in this.previousTiles) {
	                if (this.previousTiles.hasOwnProperty(tileImagePath)) {
	                    tile = this.previousTiles[tileImagePath];

	                    if (tile.opacity > 0 && !current[tile.imagePath]) {
	                        // Compute the reduced.
	                        tile.opacity = Math.max(0, tile.opacity - visibilityDelta);

	                        // If not fully faded, add the tile to the list of current tiles and request a redraw so that
	                        // we'll be called continuously until all tiles have faded completely. Note that order in the
	                        // current tiles list is important: the non-opaque tiles must be drawn after the opaque tiles.
	                        if (tile.opacity > 0) {
	                            this.currentTiles.push(tile);
	                            this.currentTilesInvalid = true;
	                            dc.redrawRequested = true;
	                        }
	                    }
	                }
	            }
	        };

	        // Documented in superclass.
	        TiledImageLayer.prototype.isLayerInView = function (dc) {
	            return dc.terrain && dc.terrain.sector && dc.terrain.sector.intersects(this.levels.sector);
	        };

	        // Documented in superclass.
	        TiledImageLayer.prototype.createTopLevelTiles = function (dc) {
	            this.topLevelTiles = [];
	            Tile.createTilesForLevel(this.levels.firstLevel(), this, this.topLevelTiles);
	        };

	        // Intentionally not documented.
	        TiledImageLayer.prototype.assembleTiles = function (dc) {
	            this.currentTiles = [];

	            if (!this.topLevelTiles || (this.topLevelTiles.length === 0)) {
	                this.createTopLevelTiles(dc);
	            }

	            for (var i = 0, len = this.topLevelTiles.length; i < len; i++) {
	                var tile = this.topLevelTiles[i];

	                tile.update(dc);

	                this.currentAncestorTile = null;

	                if (this.isTileVisible(dc, tile)) {
	                    this.addTileOrDescendants(dc, tile);
	                }
	            }
	        };

	        // Intentionally not documented.
	        TiledImageLayer.prototype.addTileOrDescendants = function (dc, tile) {
	            if (this.tileMeetsRenderingCriteria(dc, tile)) {
	                this.addTile(dc, tile);
	                return;
	            }

	            var ancestorTile = null;

	            try {
	                if (this.isTileTextureInMemory(dc, tile) || tile.level.levelNumber === 0) {
	                    ancestorTile = this.currentAncestorTile;
	                    this.currentAncestorTile = tile;
	                }

	                var nextLevel = this.levels.level(tile.level.levelNumber + 1),
	                    subTiles = tile.subdivideToCache(nextLevel, this, this.tileCache);

	                for (var i = 0, len = subTiles.length; i < len; i++) {
	                    var child = subTiles[i];

	                    child.update(dc);

	                    if (this.levels.sector.intersects(child.sector) && this.isTileVisible(dc, child)) {
	                        this.addTileOrDescendants(dc, child);
	                    }
	                }
	            } finally {
	                if (ancestorTile) {
	                    this.currentAncestorTile = ancestorTile;
	                }
	            }
	        };

	        // Intentionally not documented.
	        TiledImageLayer.prototype.addTile = function (dc, tile) {
	            tile.fallbackTile = null;

	            var texture = dc.gpuResourceCache.resourceForKey(tile.imagePath);
	            if (texture) {
	                tile.opacity = 1;;
	                this.currentTiles.push(tile);

	                // If the tile's texture has expired, cause it to be re-retrieved. Note that the current,
	                // expired texture is still used until the updated one arrives.
	                if (this.expiration && this.isTextureExpired(texture)) {
	                    this.retrieveTileImage(dc, tile);
	                }

	                return;
	            }

	            this.retrieveTileImage(dc, tile);

	            if (this.currentAncestorTile) {
	                if (this.isTileTextureInMemory(dc, this.currentAncestorTile)) {
	                    // Set up to map the ancestor tile into the current one.
	                    tile.fallbackTile = this.currentAncestorTile;
	                    tile.fallbackTile.opacity = 1;
	                    this.currentTiles.push(tile);
	                }
	            }
	        };

	        // Intentionally not documented.
	        TiledImageLayer.prototype.isTileVisible = function (dc, tile) {
	            if (dc.globe.projectionLimits && !tile.sector.overlaps(dc.globe.projectionLimits)) {
	                return false;
	            }

	            return tile.extent.intersectsFrustum(dc.navigatorState.frustumInModelCoordinates);
	        };

	        // Intentionally not documented.
	        TiledImageLayer.prototype.tileMeetsRenderingCriteria = function (dc, tile) {
	            var s = this.detailControl;
	            if (tile.sector.minLatitude >= 75 || tile.sector.maxLatitude <= -75) {
	                s *= 1.2;
	            }
	            return tile.level.isLastLevel() || !tile.mustSubdivide(dc, s);
	        };

	        // Intentionally not documented.
	        TiledImageLayer.prototype.isTileTextureInMemory = function (dc, tile) {
	            return dc.gpuResourceCache.containsResource(tile.imagePath);
	        };

	        // Intentionally not documented.
	        TiledImageLayer.prototype.isTextureExpired = function (texture) {
	            return this.expiration && (texture.creationTime.getTime() <= this.expiration.getTime());
	        };

	        /**
	         * Retrieves the image for the specified tile. Subclasses should override this method in order to retrieve,
	         * compute or otherwise create the image.
	         * @param {DrawContext} dc The current draw context.
	         * @param {ImageTile} tile The tile for which to retrieve the resource.
	         * @param {Boolean} suppressRedraw true to suppress generation of redraw events when an image is successfully
	         * retrieved, otherwise false.
	         * @protected
	         */
	        TiledImageLayer.prototype.retrieveTileImage = function (dc, tile, suppressRedraw) {
	            if (this.currentRetrievals.indexOf(tile.imagePath) < 0) {
	                if (this.absentResourceList.isResourceAbsent(tile.imagePath)) {
	                    return;
	                }

	                var url = this.resourceUrlForTile(tile, this.retrievalImageFormat),
	                    image = new Image(),
	                    imagePath = tile.imagePath,
	                    cache = dc.gpuResourceCache,
	                    canvas = dc.currentGlContext.canvas,
	                    layer = this;

	                if (!url) {
	                    this.currentTilesInvalid = true;
	                    return;
	                }

	                image.onload = function () {
	                    Logger.log(Logger.LEVEL_INFO, "Image retrieval succeeded: " + url);
	                    var texture = layer.createTexture(dc, tile, image);
	                    layer.removeFromCurrentRetrievals(imagePath);

	                    if (texture) {
	                        cache.putResource(imagePath, texture, texture.size);

	                        layer.currentTilesInvalid = true;
	                        layer.absentResourceList.unmarkResourceAbsent(imagePath);

	                        if (!suppressRedraw) {
	                            // Send an event to request a redraw.
	                            var e = document.createEvent('Event');
	                            e.initEvent(WorldWind.REDRAW_EVENT_TYPE, true, true);
	                            canvas.dispatchEvent(e);
	                        }
	                    }
	                };

	                image.onerror = function () {
	                    layer.removeFromCurrentRetrievals(imagePath);
	                    layer.absentResourceList.markResourceAbsent(imagePath);
	                    Logger.log(Logger.LEVEL_WARNING, "Image retrieval failed: " + url);
	                };

	                this.currentRetrievals.push(imagePath);
	                image.crossOrigin = 'anonymous';
	                image.src = url;
	            }
	        };

	        // Intentionally not documented.
	        TiledImageLayer.prototype.createTexture = function (dc, tile, image) {
	            return new Texture(dc.currentGlContext, image);
	        };

	        // Intentionally not documented.
	        TiledImageLayer.prototype.removeFromCurrentRetrievals = function (imagePath) {
	            var index = this.currentRetrievals.indexOf(imagePath);
	            if (index > -1) {
	                this.currentRetrievals.splice(index, 1);
	            }
	        };

	        /**
	         * Returns the URL string for the resource.
	         * @param {ImageTile} tile The tile whose image is returned
	         * @param {String} imageFormat The mime type of the image format desired.
	         * @returns {String} The URL string, or null if the string can not be formed.
	         * @protected
	         */
	        TiledImageLayer.prototype.resourceUrlForTile = function (tile, imageFormat) {
	            if (this.urlBuilder) {
	                return this.urlBuilder.urlForTile(tile, imageFormat);
	            } else {
	                return null;
	            }
	        };

	        return TiledImageLayer;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports ImageTile
	 * @version $Id: ImageTile.js 2941 2015-03-30 21:11:43Z tgaskins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(30),
	        __webpack_require__(32),
	        __webpack_require__(76),
	        __webpack_require__(77)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
	              Logger,
	              TextureTile,
	              Tile) {
	        "use strict";

	        /**
	         * Constructs an image tile.
	         * @alias ImageTile
	         * @constructor
	         * @classdesc Represents an image applied to a portion of a globe's terrain. Applications typically do not
	         * interact with this class.
	         * @augments TextureTile
	         * @param {Sector} sector The sector this tile covers.
	         * @param {Level} level The level this tile is associated with.
	         * @param {Number} row This tile's row in the associated level.
	         * @param {Number} column This tile's column in the associated level.
	         * @param {String} imagePath The full path to the image.
	         * @throws {ArgumentError} If the specified sector or level is null or undefined, the row or column arguments
	         * are less than zero, or the specified image path is null, undefined or empty.
	         *
	         */
	        var ImageTile = function (sector, level, row, column, imagePath) {
	            if (!imagePath || (imagePath.length < 1)) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "ImageTile", "constructor",
	                        "The specified image path is null, undefined or zero length."));
	            }

	            TextureTile.call(this, sector, level, row, column); // args are checked in the superclass' constructor

	            /**
	             * This tile's image path.
	             * @type {String}
	             */
	            this.imagePath = imagePath;

	            /**
	             * The tile whose texture to use when this tile's texture is not available.
	             * @type {Matrix}
	             */
	            this.fallbackTile = null;

	            // Assign imagePath to gpuCacheKey (inherited from TextureTile).
	            this.gpuCacheKey = imagePath;
	        };

	        ImageTile.prototype = Object.create(TextureTile.prototype);

	        /**
	         * Returns the size of the this tile in bytes.
	         * @returns {Number} The size of this tile in bytes, not including the associated texture size.
	         */
	        ImageTile.prototype.size = function () {
	            return this.__proto__.__proto__.size.call(this) + this.imagePath.length + 8;
	        };

	        /**
	         * Causes this tile's texture to be active. Implements [SurfaceTile.bind]{@link SurfaceTile#bind}.
	         * @param {DrawContext} dc The current draw context.
	         * @returns {Boolean} true if the texture was bound successfully, otherwise false.
	         */
	        ImageTile.prototype.bind = function (dc) {
	            // Attempt to bind in TextureTile first.
	            var isBound = this.__proto__.__proto__.bind.call(this, dc);
	            if (isBound) {
	                return true;
	            }

	            if (this.fallbackTile) {
	                return this.fallbackTile.bind(dc);
	            }

	            return false;
	        };

	        /**
	         * If this tile's fallback texture is used, applies the appropriate texture transform to a specified matrix.
	         * @param {DrawContext} dc The current draw context.
	         * @param {Matrix} matrix The matrix to apply the transform to.
	         */
	        ImageTile.prototype.applyInternalTransform = function (dc, matrix) {
	            if (this.fallbackTile && !(dc.gpuResourceCache.resourceForKey(this.imagePath))) {
	                // Must apply a texture transform to map the tile's sector into its fallback's image.
	                this.applyFallbackTransform(matrix);
	            }
	        };

	        // Intentionally not documented.
	        ImageTile.prototype.applyFallbackTransform = function (matrix) {
	            var deltaLevel = this.level.levelNumber - this.fallbackTile.level.levelNumber;
	            if (deltaLevel <= 0)
	                return;

	            var fbTileDeltaLat = this.fallbackTile.sector.deltaLatitude(),
	                fbTileDeltaLon = this.fallbackTile.sector.deltaLongitude(),
	                sx = this.sector.deltaLongitude() / fbTileDeltaLon,
	                sy = this.sector.deltaLatitude() / fbTileDeltaLat,
	                tx = (this.sector.minLongitude - this.fallbackTile.sector.minLongitude) / fbTileDeltaLon,
	                ty = (this.sector.minLatitude - this.fallbackTile.sector.minLatitude) / fbTileDeltaLat;

	            // Apply a transform to the matrix that maps texture coordinates for this tile to texture coordinates for the
	            // fallback tile. Rather than perform the full set of matrix operations, a single multiply is performed with the
	            // precomputed non-zero values:
	            //
	            // Matrix trans = Matrix.fromTranslation(tx, ty, 0);
	            // Matrix scale = Matrix.fromScale(sxy, sxy, 1);
	            // matrix.multiply(trans);
	            // matrix.multiply(scale);

	            matrix.multiply(
	                sx, 0, 0, tx,
	                0, sy, 0, ty,
	                0, 0, 1, 0,
	                0, 0, 0, 1);
	        };

	        return ImageTile;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

	var RenderableLayer = __webpack_require__(140);
	var Sector = __webpack_require__(75);
	var SurfaceImage = __webpack_require__(86);

	var SingleImageLayer = function (src) {

	    RenderableLayer.call(this, "Single image layer");

	    this.addRenderable(new SurfaceImage(Sector.FULL_SPHERE, src));

	    this.minActiveAltitude = 0; // 3e6;
	};

	SingleImageLayer.prototype = Object.create(RenderableLayer.prototype);

	module.exports = SingleImageLayer;

/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2015 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports WmtsLayer
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(50),
	        __webpack_require__(30),
	        __webpack_require__(32),
	        __webpack_require__(75),
	        __webpack_require__(126),
	        __webpack_require__(53),
	        __webpack_require__(54),
	        __webpack_require__(111),
	        __webpack_require__(208),
	        __webpack_require__(36),
	        __webpack_require__(83)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (AbsentResourceList,
	              ArgumentError,
	              Logger,
	              Sector,
	              Layer,
	              MemoryCache,
	              Texture,
	              WmsUrlBuilder,
	              WmtsLayerTile,
	              WWMath,
	              WWUtil) {
	        "use strict";

	        // TODO: Test Mercator layers.
	        // TODO: Support tile matrix limits.
	        // TODO: Extensibility for other projections.
	        // TODO: Finish parsing capabilities document (ServiceIdentification and ServiceProvider).
	        // TODO: Time dimensions.

	        /**
	         * Constructs a WMTS image layer.
	         * @alias WmtsLayer
	         * @constructor
	         * @augments Layer
	         * @classdesc Displays a WMTS image layer.
	         * @param {WmtsLayerCapabilities} layerCaps The WMTS layer capabilities describing this layer.
	         * @param {String} styleIdentifier The style to use for this layer. Must be one of those listed in the accompanying
	         * layer capabilities. May be null, in which case the WMTS server's default style is used.
	         * @param {String} timeString The time parameter passed to the WMTS server when imagery is requested. May be
	         * null, in which case no time parameter is passed to the server.
	         * @throws {ArgumentError} If the specified layer capabilities reference is null or undefined.
	         */
	        var WmtsLayer = function (layerCaps, styleIdentifier, timeString) {
	            if (!layerCaps) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "WmtsLayer", "constructor",
	                        "No layer configuration specified."));
	            }

	            Layer.call(this, "WMTS Layer");

	            /**
	             * The WMTS layer identifier of this layer.
	             * @type {String}
	             * @readonly
	             */
	            this.layerIdentifier = layerCaps.identifier;

	            /**
	             * The style identifier specified to this layer's constructor.
	             * @type {String}
	             * @readonly
	             */
	            this.styleIdentifier = styleIdentifier;

	            /**
	             * The time string passed to this layer's constructor.
	             * @type {String}
	             * @readonly
	             */
	            this.timeString = timeString;

	            // Determine image format
	            var formats = layerCaps.format;

	            if (formats.indexOf("image/png") >= 0) {
	                this.imageFormat = "image/png";
	            } else if (formats.indexOf("image/jpeg") >= 0) {
	                this.imageFormat = "image/jpeg";
	            } else if (formats.indexOf("image/tiff") >= 0) {
	                this.imageFormat = "image/tiff";
	            } else if (formats.indexOf("image/gif") >= 0) {
	                this.imageFormat = "image/gif";
	            } else {
	                this.imageFormat = formats[0];
	            }

	            if (!this.imageFormat) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "WmtsLayer", "constructor",
	                        "Layer does not provide a supported image format."));
	            }

	            if (layerCaps.resourceUrl && (layerCaps.resourceUrl.length > 1)) {
	                for (var i = 0; i < layerCaps.resourceUrl.length; i++) {
	                    if (this.imageFormat === layerCaps.resourceUrl[i].format) {
	                        this.resourceUrl = layerCaps.resourceUrl[i].template;
	                        break;
	                    }
	                }
	            } else { // resource-oriented interface not supported, so use KVP interface
	                this.serviceUrl = layerCaps.capabilities.getGetTileKvpAddress();
	                if (this.serviceUrl) {
	                    this.serviceUrl = WmsUrlBuilder.fixGetMapString(this.serviceUrl);
	                }
	            }

	            if (!this.resourceUrl && !this.serviceUrl) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "WmtsLayer", "constructor",
	                        "No resource URL or KVP GetTile service URL specified in WMTS capabilities."));
	            }

	            // Validate that the specified style identifier exists, or determine one if not specified.
	            if (this.styleIdentifier) {
	                var styleIdentifierFound = false;
	                for (var i = 0; i < layerCaps.style.length; i++) {
	                    if (layerCaps.style[i].identifier === this.styleIdentifier) {
	                        styleIdentifierFound = true;
	                        break;
	                    }
	                }

	                if (!styleIdentifierFound) {
	                    Logger.logMessage(Logger.LEVEL_WARNING, "WmtsLayer", "constructor",
	                        "The specified style identifier is not available. The server's default style will be used.");
	                    this.styleIdentifier = null;
	                }
	            }

	            if (!this.styleIdentifier && layerCaps.style) {
	                for (i = 0; i < layerCaps.style.length; i++) {
	                    if (layerCaps.style[i].isDefault) {
	                        this.styleIdentifier = layerCaps.style[i].identifier;
	                        break;
	                    }
	                }
	            }

	            if (!this.styleIdentifier) {
	                Logger.logMessage(Logger.LEVEL_WARNING, "WmtsLayer", "constructor",
	                    "No default style available. A style will not be specified in tile requests.");
	            }

	            // Find the tile matrix set we want to use. Prefer EPSG:4326, then EPSG:3857.
	            var tms, tms4326 = null, tms3857 = null;
	            for (i = 0; i < layerCaps.tileMatrixSetLink.length; i++) {
	                tms = layerCaps.tileMatrixSetLink[i].tileMatrixSetRef;

	                if (WmtsLayer.isEpsg4326Crs(tms.supportedCRS)) {
	                    tms4326 = tms4326 || tms;
	                } else if (WmtsLayer.isEpsg3857Crs(tms.supportedCRS)) {
	                    tms3857 = tms3857 || tms;
	                }
	            }

	            this.tileMatrixSet = tms4326 || tms3857;

	            if (!this.tileMatrixSet) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "WmtsLayer", "constructor",
	                        "No supported Tile Matrix Set could be found."));
	            }

	            // Determine the layer's sector if possible. Mandatory for EPSG:4326 tile matrix sets. (Others compute
	            // it from tile Matrix Set metadata.)
	            if (layerCaps.wgs84BoundingBox) {
	                this.sector = new Sector(
	                    layerCaps.wgs84BoundingBox.lowerCorner[1],
	                    layerCaps.wgs84BoundingBox.upperCorner[1],
	                    layerCaps.wgs84BoundingBox.lowerCorner[0],
	                    layerCaps.wgs84BoundingBox.upperCorner[0]);
	            } else if (this.tileMatrixSet.boundingBox &&
	                WmtsLayerCapabilities.isEpsg4326Crs(this.tileMatrixSet.boundingBox.crs)) {
	                this.sector = new Sector(
	                    this.tileMatrixSet.boundingBox.lowerCorner[1],
	                    this.tileMatrixSet.boundingBox.upperCorner[1],
	                    this.tileMatrixSet.boundingBox.lowerCorner[0],
	                    this.tileMatrixSet.boundingBox.upperCorner[0]);
	            } else if (WmtsLayerCapabilities.isEpsg4326Crs(this.tileMatrixSet.supportedCRS)) {
	                // Throw an exception if there is no 4326 bounding box.
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "WmtsLayer", "constructor",
	                        "No EPSG:4326 bounding box was specified in the layer or tile matrix set capabilities."));
	            }

	            // Form a unique string to identify cache entries.
	            this.cachePath = (this.resourceUrl || this.serviceUrl) +
	                this.layerIdentifier + this.styleIdentifier + this.tileMatrixSet.identifier;
	            if (timeString) {
	                this.cachePath = this.cachePath + timeString;
	            }

	            // Determine a default display name.
	            if (layerCaps.title.length > 0) {
	                this.displayName = layerCaps.title[0].value;
	            } else {
	                this.displayName = layerCaps.identifier;
	            }

	            this.pickEnabled = false;

	            this.currentTiles = [];
	            this.currentTilesInvalid = true;
	            this.tileCache = new MemoryCache(500, 400);
	            this.currentRetrievals = [];
	            this.absentResourceList = new AbsentResourceList(3, 50e3);

	            this.pickEnabled = false;

	            /**
	             * Controls the level of detail switching for this layer. The next highest resolution level is
	             * used when an image's texel size is greater than this number of pixels, up to the maximum resolution
	             * of this layer.
	             * @type {Number}
	             * @default 1.75
	             */
	            this.detailControl = 1.75;
	        };

	        WmtsLayer.prototype = Object.create(Layer.prototype);

	        WmtsLayer.prototype.doRender = function (dc) {
	            if (!dc.terrain)
	                return;

	            if (this.currentTilesInvalid
	                || !this.lasTtMVP || !dc.navigatorState.modelviewProjection.equals(this.lasTtMVP)
	                || dc.globeStateKey != this.lastGlobeStateKey) {
	                this.currentTilesInvalid = false;
	                this.assembleTiles(dc);
	            }

	            this.lasTtMVP = dc.navigatorState.modelviewProjection;
	            this.lastGlobeStateKey = dc.globeStateKey;

	            if (this.currentTiles.length > 0) {
	                dc.surfaceTileRenderer.renderTiles(dc, this.currentTiles, this.opacity);
	                dc.frameStatistics.incrementImageTileCount(this.currentTiles.length);
	                this.inCurrentFrame = true;
	            }
	        };

	        WmtsLayer.prototype.isLayerInView = function (dc) {
	            return dc.terrain && dc.terrain.sector && dc.terrain.sector.intersects(this.sector);
	        };

	        WmtsLayer.prototype.isTileVisible = function (dc, tile) {
	            if (dc.globe.projectionLimits && !tile.sector.overlaps(dc.globe.projectionLimits)) {
	                return false;
	            }

	            return tile.extent.intersectsFrustum(dc.navigatorState.frustumInModelCoordinates);
	        };

	        WmtsLayer.prototype.assembleTiles = function (dc) {
	            this.currentTiles = [];

	            if (!this.topLevelTiles || (this.topLevelTiles.length === 0)) {
	                this.createTopLevelTiles(dc);
	            }

	            for (var i = 0, len = this.topLevelTiles.length; i < len; i++) {
	                var tile = this.topLevelTiles[i];

	                tile.update(dc);

	                this.currentAncestorTile = null;

	                if (this.isTileVisible(dc, tile)) {
	                    this.addTileOrDescendants(dc, tile);
	                }
	            }
	        };

	        WmtsLayer.prototype.addTileOrDescendants = function (dc, tile) {
	            if (this.tileMeetsRenderingCriteria(dc, tile)) {
	                this.addTile(dc, tile);
	                return;
	            }

	            var ancestorTile = null;

	            try {
	                if (this.isTileTextureInMemory(dc, tile) || tile.tileMatrix.levelNumber === 0) {
	                    ancestorTile = this.currentAncestorTile;
	                    this.currentAncestorTile = tile;
	                }

	                var nextLevel = this.tileMatrixSet.tileMatrix[tile.tileMatrix.levelNumber + 1],
	                    subTiles = tile.subdivideToCache(nextLevel, this, this.tileCache);

	                for (var i = 0, len = subTiles.length; i < len; i++) {
	                    var child = subTiles[i];

	                    child.update(dc);

	                    if (this.sector.intersects(child.sector) && this.isTileVisible(dc, child)) {
	                        this.addTileOrDescendants(dc, child);
	                    }
	                }
	            } finally {
	                if (ancestorTile) {
	                    this.currentAncestorTile = ancestorTile;
	                }
	            }
	        };

	        WmtsLayer.prototype.addTile = function (dc, tile) {
	            tile.fallbackTile = null;

	            var texture = dc.gpuResourceCache.resourceForKey(tile.imagePath);
	            if (texture) {
	                this.currentTiles.push(tile);

	                // If the tile's texture has expired, cause it to be re-retrieved. Note that the current,
	                // expired texture is still used until the updated one arrives.
	                if (this.expiration && this.isTextureExpired(texture)) {
	                    this.retrieveTileImage(dc, tile);
	                }

	                return;
	            }

	            this.retrieveTileImage(dc, tile);

	            if (this.currentAncestorTile) {
	                if (this.isTileTextureInMemory(dc, this.currentAncestorTile)) {
	                    this.currentTiles.push(this.currentAncestorTile);
	                }
	            }
	        };

	        WmtsLayer.prototype.isTextureExpired = function (texture) {
	            return this.expiration && (texture.creationTime.getTime() <= this.expiration.getTime());
	        };

	        WmtsLayer.prototype.isTileTextureInMemory = function (dc, tile) {
	            return dc.gpuResourceCache.containsResource(tile.imagePath);
	        };

	        WmtsLayer.prototype.tileMeetsRenderingCriteria = function (dc, tile) {
	            var s = this.detailControl;
	            if (tile.sector.minLatitude >= 75 || tile.sector.maxLatitude <= -75) {
	                s *= 1.2;
	            }
	            return tile.tileMatrix.levelNumber === (this.tileMatrixSet.tileMatrix.length - 1) || !tile.mustSubdivide(dc, s);
	        };

	        WmtsLayer.prototype.retrieveTileImage = function (dc, tile) {
	            if (this.currentRetrievals.indexOf(tile.imagePath) < 0) {
	                if (this.absentResourceList.isResourceAbsent(tile.imagePath)) {
	                    return;
	                }

	                var url = this.resourceUrlForTile(tile, this.imageFormat),
	                    image = new Image(),
	                    imagePath = tile.imagePath,
	                    cache = dc.gpuResourceCache,
	                    canvas = dc.currentGlContext.canvas,
	                    layer = this;

	                if (!url) {
	                    this.currentTilesInvalid = true;
	                    return;
	                }

	                image.onload = function () {
	                    Logger.log(Logger.LEVEL_INFO, "Image retrieval succeeded: " + url);
	                    var texture = layer.createTexture(dc, tile, image);
	                    layer.removeFromCurrentRetrievals(imagePath);

	                    if (texture) {
	                        cache.putResource(imagePath, texture, texture.size);

	                        layer.currentTilesInvalid = true;
	                        layer.absentResourceList.unmarkResourceAbsent(imagePath);

	                        // Send an event to request a redraw.
	                        var e = document.createEvent('Event');
	                        e.initEvent(WorldWind.REDRAW_EVENT_TYPE, true, true);
	                        canvas.dispatchEvent(e);
	                    }
	                };

	                image.onerror = function () {
	                    layer.removeFromCurrentRetrievals(imagePath);
	                    layer.absentResourceList.markResourceAbsent(imagePath);
	                    Logger.log(Logger.LEVEL_WARNING, "Image retrieval failed: " + url);
	                };

	                this.currentRetrievals.push(imagePath);
	                image.crossOrigin = 'anonymous';
	                image.src = url;
	            }
	        };

	        WmtsLayer.prototype.resourceUrlForTile = function (tile, imageFormat) {
	            var url;

	            if (this.resourceUrl) {
	                url = this.resourceUrl.replace("{Style}", this.styleIdentifier).
	                    replace("{TileMatrixSet}", this.tileMatrixSet.identifier).
	                    replace("{TileMatrix}", tile.tileMatrix.identifier).
	                    replace("{TileCol}", tile.column).replace("{TileRow}", tile.row);

	                if (this.timeString) {
	                    url.replace("{Time}", this.timeString);
	                }
	            } else {
	                url = this.serviceUrl + "service=WMTS&request=GetTile&version=1.0.0";

	                url += "&Layer=" + this.layerIdentifier;

	                if (this.styleIdentifier) {
	                    url += "&Style=" + this.styleIdentifier;
	                }

	                url += "&Format=" + imageFormat;

	                if (this.timeString) {
	                    url += "&Time=" + this.timeString;
	                }

	                url += "&TileMatrixSet=" + this.tileMatrixSet.identifier;
	                url += "&TileMatrix=" + tile.tileMatrix.identifier;
	                url += "&TileRow=" + tile.row;
	                url += "&TileCol=" + tile.column;
	            }

	            return url;
	        };

	        WmtsLayer.prototype.removeFromCurrentRetrievals = function (imagePath) {
	            var index = this.currentRetrievals.indexOf(imagePath);
	            if (index > -1) {
	                this.currentRetrievals.splice(index, 1);
	            }
	        };

	        WmtsLayer.prototype.createTopLevelTiles = function (dc) {
	            var tileMatrix = this.tileMatrixSet.tileMatrix[0];

	            this.topLevelTiles = [];

	            for (var j = 0; j < tileMatrix.matrixHeight; j++) {
	                for (var i = 0; i < tileMatrix.matrixWidth; i++) {
	                    this.topLevelTiles.push(this.createTile(tileMatrix, j, i));
	                }
	            }
	        };

	        WmtsLayer.prototype.createTile = function (tileMatrix, row, column) {
	            if (WmtsLayer.isEpsg4326Crs(this.tileMatrixSet.supportedCRS)) {
	                return this.createTile4326(tileMatrix, row, column);
	            } else if (WmtsLayer.isEpsg3857Crs(this.tileMatrixSet.supportedCRS)) {
	                return this.createTile3857(tileMatrix, row, column);
	            }
	        };

	        WmtsLayer.prototype.createTile4326 = function (tileMatrix, row, column) {
	            var tileDeltaLat = this.sector.deltaLatitude() / tileMatrix.matrixHeight, // TODO: calculate from metadata
	                tileDeltaLon = this.sector.deltaLongitude() / tileMatrix.matrixWidth,
	                maxLat = tileMatrix.topLeftCorner[0] - row * tileDeltaLat,
	                minLat = maxLat - tileDeltaLat,
	                minLon = tileMatrix.topLeftCorner[1] + tileDeltaLon * column,
	                maxLon = minLon + tileDeltaLon;

	            var sector = new Sector(minLat, maxLat, minLon, maxLon);

	            return this.makeTile(sector, tileMatrix, row, column);
	        };

	        WmtsLayer.prototype.createTile3857 = function (tileMatrix, row, column) {
	            if (!tileMatrix.mapWidth) {
	                this.computeTileMatrixValues3857(tileMatrix);
	            }

	            var swX = WWMath.clamp(column * tileMatrix.tileWidth - 0.5, 0, tileMatrix.mapWidth),
	                neY = WWMath.clamp(row * tileMatrix.tileHeight - 0.5, 0, tileMatrix.mapHeight),
	                neX = WWMath.clamp(swX + (tileMatrix.tileWidth) + 0.5, 0, tileMatrix.mapWidth),
	                swY = WWMath.clamp(neY + (tileMatrix.tileHeight) + 0.5, 0, tileMatrix.mapHeight),
	                x, y, swLat, swLon, neLat, neLon;

	            x = swX / tileMatrix.mapWidth;
	            y = swY / tileMatrix.mapHeight;
	            swLon = tileMatrix.topLeftCorner[0] + x * tileMatrix.tileMatrixDeltaX;
	            swLat = tileMatrix.topLeftCorner[1] - y * tileMatrix.tileMatrixDeltaY;
	            var swDegrees = WWMath.epsg3857ToEpsg4326(swLon, swLat);

	            x = neX / tileMatrix.mapWidth;
	            y = neY / tileMatrix.mapHeight;
	            neLon = tileMatrix.topLeftCorner[0] + x * tileMatrix.tileMatrixDeltaX;
	            neLat = tileMatrix.topLeftCorner[1] - y * tileMatrix.tileMatrixDeltaY;
	            var neDegrees = WWMath.epsg3857ToEpsg4326(neLon, neLat);

	            var sector = new Sector(swDegrees[0], neDegrees[0], swDegrees[1], neDegrees[1]);

	            return this.makeTile(sector, tileMatrix, row, column);
	        };

	        WmtsLayer.prototype.computeTileMatrixValues3857 = function (tileMatrix) {
	            var pixelSpan = tileMatrix.scaleDenominator * 0.28e-3,
	                tileSpanX = tileMatrix.tileWidth * pixelSpan,
	                tileSpanY = tileMatrix.tileHeight * pixelSpan,
	                tileMatrixMaxX = tileMatrix.topLeftCorner[0] + tileSpanX * tileMatrix.matrixWidth,
	                tileMatrixMinY = tileMatrix.topLeftCorner[1] - tileSpanY * tileMatrix.matrixHeight,
	                bottomRightCorner = [tileMatrixMaxX, tileMatrixMinY],
	                topLeftCorner = tileMatrix.topLeftCorner;

	            tileMatrix.tileMatrixDeltaX = bottomRightCorner[0] - topLeftCorner[0];
	            tileMatrix.tileMatrixDeltaY = topLeftCorner[1] - bottomRightCorner[1];
	            tileMatrix.mapWidth = tileMatrix.tileWidth * tileMatrix.matrixWidth;
	            tileMatrix.mapHeight = tileMatrix.tileHeight * tileMatrix.matrixHeight;
	        };

	        WmtsLayer.prototype.makeTile = function (sector, tileMatrix, row, column) {
	            var path = this.cachePath + "-layer/" + tileMatrix.identifier + "/" + row + "/" + column + "."
	                + WWUtil.suffixForMimeType(this.imageFormat);

	            return new WmtsLayerTile(sector, tileMatrix, row, column, path);
	        };

	        WmtsLayer.prototype.createTexture = function (dc, tile, image) {
	            if (WmtsLayer.isEpsg4326Crs(this.tileMatrixSet.supportedCRS)) {
	                return new Texture(dc.currentGlContext, image);
	            } else if (WmtsLayer.isEpsg3857Crs(this.tileMatrixSet.supportedCRS)) {
	                return this.createTexture3857(dc, tile, image);
	            }
	        };

	        WmtsLayer.prototype.createTexture3857 = function (dc, tile, image) {
	            if (!this.destCanvas) {
	                // Create a canvas we can use when unprojecting retrieved images.
	                this.destCanvas = document.createElement("canvas");
	                this.destContext = this.destCanvas.getContext("2d");
	            }

	            var srcCanvas = dc.canvas2D,
	                srcContext = dc.ctx2D,
	                srcImageData,
	                destCanvas = this.destCanvas,
	                destContext = this.destContext,
	                destImageData = destContext.createImageData(image.width, image.height),
	                sector = tile.sector,
	                tMin = WWMath.gudermannianInverse(sector.minLatitude),
	                tMax = WWMath.gudermannianInverse(sector.maxLatitude),
	                lat, g, srcRow, kSrc, kDest, sy, dy;

	            srcCanvas.width = image.width;
	            srcCanvas.height = image.height;
	            destCanvas.width = image.width;
	            destCanvas.height = image.height;

	            // Draw the original image to a canvas so image data can be had for it.
	            srcContext.drawImage(image, 0, 0, image.width, image.height);
	            srcImageData = srcContext.getImageData(0, 0, image.width, image.height);

	            // Unproject the retrieved image.
	            for (var n = 0; n < 1; n++) {
	                for (var y = 0; y < image.height; y++) {
	                    sy = 1 - y / (image.height - 1);
	                    lat = sy * sector.deltaLatitude() + sector.minLatitude;
	                    g = WWMath.gudermannianInverse(lat);
	                    dy = 1 - (g - tMin) / (tMax - tMin);
	                    dy = WWMath.clamp(dy, 0, 1);
	                    srcRow = Math.floor(dy * (image.height - 1));
	                    for (var x = 0; x < image.width; x++) {
	                        kSrc = 4 * (x + srcRow * image.width);
	                        kDest = 4 * (x + y * image.width);

	                        destImageData.data[kDest] = srcImageData.data[kSrc];
	                        destImageData.data[kDest + 1] = srcImageData.data[kSrc + 1];
	                        destImageData.data[kDest + 2] = srcImageData.data[kSrc + 2];
	                        destImageData.data[kDest + 3] = srcImageData.data[kSrc + 3];
	                    }
	                }
	            }

	            destContext.putImageData(destImageData, 0, 0);

	            return new Texture(dc.currentGlContext, destCanvas);
	        };

	        WmtsLayer.isEpsg4326Crs = function (crs) {
	            return (crs.indexOf("EPSG") >= 0) && (crs.indexOf("4326") >= 0);
	        };

	        WmtsLayer.isEpsg3857Crs = function (crs) {
	            return (crs.indexOf("EPSG") >= 0)
	                && ((crs.indexOf("3857") >= 0) || (crs.indexOf("900913") >= 0)); // 900913 is google's 3857 alias
	        };

	        return WmtsLayer;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(29),
	        __webpack_require__(30),
	        __webpack_require__(78),
	        __webpack_require__(32),
	        __webpack_require__(35),
	        __webpack_require__(83)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Angle,
	              ArgumentError,
	              BoundingBox,
	              Logger,
	              Vec3,
	              WWUtil) {
	        "use strict";

	        // This is an internal class and is intentionally not documented.
	        var WmtsLayerTile = function (sector, tileMatrix, row, column, imagePath) {
	            this.sector = sector;
	            this.tileMatrix = tileMatrix;
	            this.row = row;
	            this.column = column;
	            this.imagePath = imagePath;

	            this.texelSize = (sector.deltaLatitude() * Angle.DEGREES_TO_RADIANS) / tileMatrix.tileHeight;

	            this.tileKey = tileMatrix.levelNumber.toString() + "." + row.toString() + "." + column.toString();

	            this.gpuCacheKey = imagePath;
	        };

	        WmtsLayerTile.prototype.isEqual = function (that) {
	            if (!that)
	                return false;

	            if (!that.tileKey)
	                return false;

	            return this.tileKey == that.tileKey;
	        };

	        WmtsLayerTile.prototype.distanceTo = function (vector) {
	            if (!vector) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Tile", "distanceTo", "missingVector"));
	            }

	            var px = vector[0], py = vector[1], pz = vector[2],
	                dx, dy, dz,
	                points = this.samplePoints,
	                distance = Number.POSITIVE_INFINITY;

	            for (var i = 0, len = points.length; i < len; i += 3) {
	                dx = px - points[i];
	                dy = py - points[i + 1];
	                dz = pz - points[i + 2];
	                distance = Math.min(distance, dx * dx + dy * dy + dz * dz); // minimum squared distance
	            }

	            return Math.sqrt(distance);
	        };

	        WmtsLayerTile.prototype.subdivide = function (tileMatrix, tileFactory) {
	            if (!tileMatrix) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "WmtsLayerTile", "subdivide",
	                        "The specified tile matrix is null or undefined."));
	            }

	            if (!tileFactory) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "WmtsLayerTile", "subdivide",
	                        "The specified tile factory is null or undefined."));
	            }

	            var subFactorLat,
	                subFactorLon,
	                subRow,
	                subCol,
	                children = [];

	            subFactorLat = tileMatrix.matrixHeight / this.tileMatrix.matrixHeight;
	            subFactorLon = tileMatrix.matrixWidth / this.tileMatrix.matrixWidth;

	            subRow = subFactorLat * this.row;
	            subCol = subFactorLon * this.column;
	            children.push(tileFactory.createTile(tileMatrix, subRow, subCol));

	            subRow = subFactorLat * this.row;
	            subCol = subFactorLon * this.column + 1;
	            children.push(tileFactory.createTile(tileMatrix, subRow, subCol));

	            subRow = subFactorLat * this.row + 1;
	            subCol = subFactorLon * this.column;
	            children.push(tileFactory.createTile(tileMatrix, subRow, subCol));

	            subRow = subFactorLat * this.row + 1;
	            subCol = subFactorLon * this.column + 1;
	            children.push(tileFactory.createTile(tileMatrix, subRow, subCol));

	            return children;
	        };

	        WmtsLayerTile.prototype.subdivideToCache = function (tileMatrix, tileFactory, cache) {
	            if (!tileMatrix) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Tile", "subdivideToCache",
	                        "The specified tile matrix is null or undefined."));
	            }

	            if (!tileFactory) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Tile", "subdivideToCache",
	                        "The specified tile factory is null or undefined."));
	            }

	            var childList = cache ? cache.entryForKey(this.tileKey) : null;
	            if (!childList) {
	                childList = this.subdivide(tileMatrix, tileFactory);
	                if (childList && cache) {
	                    cache.putEntry(this.tileKey, childList, childList.length);
	                }
	            }

	            return childList;
	        };

	        WmtsLayerTile.prototype.mustSubdivide = function (dc, detailFactor) {
	            var cellSize = dc.globe.equatorialRadius * this.texelSize,
	                distance = this.distanceTo(dc.navigatorState.eyePoint),
	                pixelSize = dc.navigatorState.pixelSizeAtDistance(distance);

	            return cellSize > Math.max(detailFactor * pixelSize, 0.5);
	        };

	        WmtsLayerTile.prototype.update = function (dc) {
	            var elevationTimestamp = dc.globe.elevationTimestamp(),
	                verticalExaggeration = dc.verticalExaggeration,
	                globeStateKey = dc.globeStateKey;

	            if (this.updateTimestamp != elevationTimestamp
	                || this.updateVerticalExaggeration != verticalExaggeration
	                || this.updateGlobeStateKey != globeStateKey) {

	                this.doUpdate(dc);
	                dc.frameStatistics.incrementTileUpdateCount(1);

	                // Set the geometry extent to the globe's elevation timestamp on which the geometry is based. This
	                // ensures that the geometry timestamp can be reliably compared to the elevation timestamp in subsequent
	                // frames.
	                this.updateTimestamp = elevationTimestamp;
	                this.updateVerticalExaggeration = verticalExaggeration;
	                this.updateGlobeStateKey = globeStateKey;
	            }
	        };

	        WmtsLayerTile.prototype.doUpdate = function (dc) {
	            // Compute the minimum and maximum world coordinate height for this tile's sector by multiplying the minimum
	            // and maximum elevations by the scene's vertical exaggeration. This ensures that the elevations to used
	            // build the terrain are contained by this tile's extent. Use zero if the globe as no elevations in this
	            // tile's sector.
	            var globe = dc.globe,
	                verticalExaggeration = dc.verticalExaggeration,
	                extremes = globe.minAndMaxElevationsForSector(this.sector),
	                minHeight = extremes ? (extremes[0] * verticalExaggeration) : 0,
	                maxHeight = extremes ? (extremes[1] * verticalExaggeration) : 0;
	            if (minHeight == maxHeight) {
	                minHeight = maxHeight + 10; // TODO: Determine if this is necessary.
	            }

	            // Compute a bounding box for this tile that contains the terrain surface in the tile's coverage area.
	            if (!this.extent) {
	                this.extent = new BoundingBox();
	            }
	            this.extent.setToSector(this.sector, globe, minHeight, maxHeight);

	            // Compute the cartesian points for a 3x3 geographic grid. This grid captures sufficiently close sample
	            // points in order to estimate the distance from the viewer to this tile.
	            if (!this.samplePoints) {
	                this.sampleElevations = new Float64Array(9);
	                this.samplePoints = new Float64Array(3 * this.sampleElevations.length);
	            }
	            WWUtil.fillArray(this.sampleElevations, 0.5 * (minHeight + maxHeight));
	            globe.computePointsForGrid(this.sector, 3, 3, this.sampleElevations, Vec3.ZERO, this.samplePoints);

	            // Compute the reference point used as a local coordinate origin for the tile.
	            if (!this.referencePoint) {
	                this.referencePoint = new Vec3(0, 0, 0);
	            }

	            globe.computePointFromPosition(this.sector.centroidLatitude(), this.sector.centroidLongitude(), 0,
	                this.referencePoint);
	        };

	        WmtsLayerTile.prototype.bind = function (dc) {
	            var texture = dc.gpuResourceCache.resourceForKey(this.gpuCacheKey);

	            if (texture && texture.bind(dc)) {
	                return true;
	            }

	            if (this.fallbackTile) {
	                return this.fallbackTile.bind(dc);
	            }

	            return false;
	        };

	        WmtsLayerTile.prototype.applyInternalTransform = function (dc, matrix) {
	            // This type of tile does not apply an internal transform.
	        };

	        return WmtsLayerTile;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2015 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports WmtsCapabilities
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(30),
	        __webpack_require__(32),
	        __webpack_require__(210),
	        __webpack_require__(211),
	        __webpack_require__(213),
	        __webpack_require__(214),
	        __webpack_require__(215),
	        __webpack_require__(217)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
	              Logger,
	              OwsLanguageString,
	              OwsOperationsMetadata,
	              OwsServiceIdentification,
	              OwsServiceProvider,
	              WmsCapabilities,
	              WmtsLayerCapabilities) {
	        "use strict";

	        /**
	         * Constructs an OGC WMTS capabilities document from an XML DOM.
	         * @alias WmtsCapabilities
	         * @constructor
	         * @classdesc Represents an OGC WMTS capabilities document.
	         * This object holds as properties all the fields specified in the OGC WMTS capabilities document.
	         * Most fields can be accessed as properties named according to their document names converted to camel case.
	         * For example, "serviceIdentification" and "contents".
	         * @param {{}} xmlDom An XML DOM representing the OGC WMTS capabilities document.
	         * @throws {ArgumentError} If the specified XML DOM is null or undefined.
	         */
	        var WmtsCapabilities = function (xmlDom) {
	            if (!xmlDom) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "WmtsCapabilities", "constructor", "No XML DOM specified."));
	            }

	            this.assembleDocument(xmlDom);
	        };

	        WmtsCapabilities.prototype.assembleDocument = function (dom) {
	            var root = dom.documentElement;

	            this.version = root.getAttribute("version");
	            this.updateSequence = root.getAttribute("updateSequence");

	            var children = root.children || root.childNodes;
	            for (var c = 0; c < children.length; c++) {
	                var child = children[c];

	                if (child.localName === "ServiceIdentification") {
	                    this.serviceIdentification = new OwsServiceIdentification(child);
	                } else if (child.localName === "ServiceProvider") {
	                    this.serviceProvider = new OwsServiceProvider(child);
	                } else if (child.localName === "OperationsMetadata") {
	                    this.operationsMetadata = new OwsOperationsMetadata(child);
	                } else if (child.localName === "Contents") {
	                    this.contents = this.assembleContents(child);
	                }
	                // TODO: Themes
	            }

	            this.resolveTileMatrixSetLinks();
	        };

	        WmtsCapabilities.prototype.assembleContents = function (element) {
	            var contents = {};

	            var children = element.children || element.childNodes;
	            for (var c = 0; c < children.length; c++) {
	                var child = children[c];

	                if (child.localName === "Layer") {
	                    contents.layer = contents.layer || [];
	                    try {
	                        contents.layer.push(new WmtsLayerCapabilities(child, this));
	                    } catch (e) {
	                        Logger.logMessage(Logger.LEVEL_SEVERE, "WmtsCapabilities", "constructor",
	                            "Exception reading WMTS layer description: " + e.message);
	                    }
	                } else if (child.localName === "TileMatrixSet") {
	                    contents.tileMatrixSet = contents.tileMatrixSet || [];
	                    try {
	                        contents.tileMatrixSet.push(WmtsCapabilities.assembleTileMatrixSet(child));
	                    } catch (e) {
	                        Logger.logMessage(Logger.LEVEL_SEVERE, "WmtsCapabilities", "constructor",
	                            "Exception reading WMTS tile matrix set description: " + e.message);
	                    }
	                }
	                // TODO: OtherSource
	            }

	            return contents;
	        };

	        WmtsCapabilities.assembleTileMatrixSet = function (element) {
	            var tileMatrixSet = {};

	            var children = element.children || element.childNodes;
	            for (var c = 0; c < children.length; c++) {
	                var child = children[c];

	                if (child.localName === "Identifier") {
	                    tileMatrixSet.identifier = child.textContent;
	                } else if (child.localName === "SupportedCRS") {
	                    tileMatrixSet.supportedCRS = child.textContent;
	                } else if (child.localName === "WellKnownScaleSet") {
	                    tileMatrixSet.wellKnownScaleSet = child.textContent;
	                } else if (child.localName === "BoundingBox") {
	                    tileMatrixSet.boundingBox = WmtsLayerCapabilities.assembleBoundingBox(child);
	                } else if (child.localName === "TileMatrix") {
	                    tileMatrixSet.tileMatrix = tileMatrixSet.tileMatrix || [];
	                    tileMatrixSet.tileMatrix.push(WmtsCapabilities.assembleTileMatrix(child));
	                } else if (child.localName === "Title") {
	                    tileMatrixSet.title = tileMatrixSet.title || [];
	                    tileMatrixSet.title.push(new OwsLanguageString(child));
	                } else if (child.localName === "Abstract") {
	                    tileMatrixSet.abstract = tileMatrixSet.abstract || [];
	                    tileMatrixSet.abstract.push(new OwsLanguageString(child));
	                }
	                // TODO: Keywords
	            }

	            for (var i = 0; i < tileMatrixSet.tileMatrix.length; i++) {
	                tileMatrixSet.tileMatrix[i].levelNumber = i;
	            }

	            return tileMatrixSet;
	        };

	        WmtsCapabilities.assembleTileMatrix = function (element) {
	            var tileMatrix = {};

	            var children = element.children || element.childNodes;
	            for (var c = 0; c < children.length; c++) {
	                var child = children[c];

	                if (child.localName === "Identifier") {
	                    tileMatrix.identifier = child.textContent;
	                } else if (child.localName === "Title") {
	                    tileMatrix.title = tileMatrixSet.title || [];
	                    tileMatrix.title.push(new OwsLanguageString(child));
	                } else if (child.localName === "Abstract") {
	                    tileMatrix.abstract = tileMatrixSet.abstract || [];
	                    tileMatrix.abstract.push(new OwsLanguageString(child));
	                } else if (child.localName === "ScaleDenominator") {
	                    tileMatrix.scaleDenominator = parseFloat(child.textContent);
	                } else if (child.localName === "TileWidth") {
	                    tileMatrix.tileWidth = parseFloat(child.textContent);
	                } else if (child.localName === "TileHeight") {
	                    tileMatrix.tileHeight = parseFloat(child.textContent);
	                } else if (child.localName === "MatrixWidth") {
	                    tileMatrix.matrixWidth = parseFloat(child.textContent);
	                } else if (child.localName === "MatrixHeight") {
	                    tileMatrix.matrixHeight = parseFloat(child.textContent);
	                } else if (child.localName === "TopLeftCorner") {
	                    var values = child.textContent.split(" ");
	                    tileMatrix.topLeftCorner = [parseFloat(values[0]), parseFloat(values[1])];
	                }

	                // TODO: Keywords
	            }

	            return tileMatrix;
	        };

	        WmtsCapabilities.prototype.resolveTileMatrixSetLinks = function() {
	            for (var i = 0; i < this.contents.layer.length; i++) {
	                var layer = this.contents.layer[i];

	                for (var j = 0; j < layer.tileMatrixSetLink.length; j++) {
	                    var link = layer.tileMatrixSetLink[j];

	                    for (var k = 0; k < this.contents.tileMatrixSet.length; k++) {
	                        if (this.contents.tileMatrixSet[k].identifier === link.tileMatrixSet) {
	                            link.tileMatrixSetRef = this.contents.tileMatrixSet[k];
	                            break;
	                        }
	                    }
	                }
	            }
	        };

	        WmtsCapabilities.prototype.getGetTileKvpAddress = function () {
	            for (var i = 0; i < this.operationsMetadata.operation.length; i++) {
	                var operation = this.operationsMetadata.operation[i];

	                if (operation.name === "GetTile") {
	                    return operation.dcp[0].http.get[0].href;
	                }
	            }

	            return null;
	        };

	        return WmtsCapabilities;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
	;

/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2015 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports OwsLanguageString
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(30),
	        __webpack_require__(32)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
	              Logger) {
	        "use strict";

	        /**
	         * Constructs an OWS Constraint instance from an XML DOM.
	         * @alias OwsLanguageString
	         * @constructor
	         * @classdesc Represents an OWS LanguageString element of an OGC document.
	         * This object holds as properties all the fields specified in the OWS LanguageString definition.
	         * Fields can be accessed as properties named according to their document names converted to camel case.
	         * For example, "value".
	         * @param {Element} element An XML DOM element representing the OWS LanguageString element.
	         * @throws {ArgumentError} If the specified XML DOM element is null or undefined.
	         */
	        var OwsLanguageString = function (element) {
	            if (!element) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "LanguageString", "constructor", "missingDomElement"));
	            }

	            this.value = element.textContent;

	            var lang = element.getAttribute("lang");
	            if (lang) {
	                this.lang = lang;
	            }
	        };

	        return OwsLanguageString;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2015 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports OwsOperationsMetadata
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(30),
	        __webpack_require__(32),
	        __webpack_require__(212)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
	              Logger,
	              OwsConstraint) {
	        "use strict";

	        /**
	         * Constructs an OWS Operations Metadata instance from an XML DOM.
	         * @alias OwsOperationsMetadata
	         * @constructor
	         * @classdesc Represents an OWS Operations Metadata section of an OGC capabilities document.
	         * This object holds as properties all the fields specified in the OWS Operations Metadata section.
	         * Most fields can be accessed as properties named according to their document names converted to camel case.
	         * For example, "operations".
	         * @param {Element} element An XML DOM element representing the OWS Service Provider section.
	         * @throws {ArgumentError} If the specified XML DOM element is null or undefined.
	         */
	        var OwsOperationsMetadata = function (element) {
	            if (!element) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "OwsOperationsMetadata", "constructor", "missingDomElement"));
	            }

	            var children = element.children;
	            for (var c = 0; c < children.length; c++) {
	                var child = children[c];

	                if (child.localName === "Operation") {
	                    this.operation = this.operation || [];
	                    this.operation.push(OwsOperationsMetadata.assembleOperation(child));
	                }
	                // TODO: Parameter, Constraint, ExtendedCapabilities
	            }
	        };

	        OwsOperationsMetadata.assembleOperation = function (element) {
	            var operation = {};

	            operation.name = element.getAttribute("name");

	            var children = element.children;
	            for (var c = 0; c < children.length; c++) {
	                var child = children[c];

	                if (child.localName === "DCP") {
	                    operation.dcp = operation.dcp || [];
	                    operation.dcp.push(OwsOperationsMetadata.assembleDcp(child));
	                }
	                // TODO: Parameter, Constraint, Metadata
	            }

	            return operation;
	        };

	        OwsOperationsMetadata.assembleDcp = function (element) {
	            var dcp = {};

	            var children = element.children;
	            for (var c = 0; c < children.length; c++) {
	                var child = children[c];

	                if (child.localName === "HTTP") {
	                    dcp.http = OwsOperationsMetadata.assembleHttp(child);
	                }
	            }

	            return dcp;
	        };

	        OwsOperationsMetadata.assembleHttp = function (element) {
	            var result = {};

	            var children = element.children;
	            for (var c = 0; c < children.length; c++) {
	                var child = children[c];

	                if (child.localName === "Get") {
	                    result.get = result.get || [];
	                    result.get.push(OwsOperationsMetadata.assembleGet(child));
	                }

	                // TODO: Post
	            }

	            return result;
	        };

	        OwsOperationsMetadata.assembleGet = function (element) {
	            var result = {};

	            result.href = element.getAttribute("xlink:href");

	            var children = element.children;
	            for (var c = 0; c < children.length; c++) {
	                var child = children[c];

	                if (child.localName === "Constraint") {
	                    result.constraint = result.constraint || [];
	                    result.constraint.push(new OwsConstraint(child));
	                }
	            }

	            return result;
	        };

	        return OwsOperationsMetadata;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2015 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports OwsConstraint
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(30),
	        __webpack_require__(32)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
	              Logger) {
	        "use strict";

	        /**
	         * Constructs an OWS Constraint instance from an XML DOM.
	         * @alias OwsConstraint
	         * @constructor
	         * @classdesc Represents an OWS Constraint element of an OGC capabilities document.
	         * This object holds as properties all the fields specified in the OWS Constraint definition.
	         * Fields can be accessed as properties named according to their document names converted to camel case.
	         * For example, "operation".
	         * @param {Element} element An XML DOM element representing the OWS Constraint element.
	         * @throws {ArgumentError} If the specified XML DOM element is null or undefined.
	         */
	        var OwsConstraint = function (element) {
	            if (!element) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "OwsConstraint", "constructor", "missingDomElement"));
	            }

	            this.name = element.getAttribute("name");

	            var children = element.children;
	            for (var c = 0; c < children.length; c++) {
	                var child = children[c];

	                if (child.localName === "AllowedValues") {
	                    this.allowedValues = this.allowedValues || [];

	                    for (var cc = 0; cc < child.children.length; cc++) {
	                        if (child.children[cc].localName === "Value") {
	                            this.allowedValues.push(child.children[cc].textContent);
	                        }
	                    }
	                } else if (child.localName === "AnyValue") {
	                    this.anyValue = true;
	                } else if (child.localName === "NoValues") {
	                    this.noValues = true;
	                }
	                // TODO: ValuesReference
	            }

	        };

	        return OwsConstraint;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2015 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports OwsServiceIdentification
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(30),
	        __webpack_require__(32)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
	              Logger) {
	        "use strict";

	        /**
	         * Constructs an OWS Service Identification instance from an XML DOM.
	         * @alias OwsServiceIdentification
	         * @constructor
	         * @classdesc Represents an OWS Service Identification section of an OGC capabilities document.
	         * This object holds as properties all the fields specified in the OWS Service Identification.
	         * Fields can be accessed as properties named according to their document names converted to camel case.
	         * For example, "serviceType" and "title".
	         * Note that fields with multiple possible values are returned as arrays, such as "titles" and "abstracts".
	         * @param {Element} element An XML DOM element representing the OWS Service Identification section.
	         * @throws {ArgumentError} If the specified XML DOM element is null or undefined.
	         */
	        var OwsServiceIdentification = function (element) {
	            if (!element) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "OwsServiceIdentification", "constructor", "missingDomElement"));
	            }

	            var children = element.children;
	            for (var c = 0; c < children.length; c++) {
	                var child = children[c];

	                if (child.localName === "ServiceType") {
	                    this.serviceType = child.textContent;
	                } else if (child.localName === "ServiceTypeVersion") {
	                    this.serviceTypeVersion = child.textContent;
	                } else if (child.localName === "Profile") {
	                    this.profile = this.profiles || [];
	                    this.profile.push(child.textContent);
	                } else if (child.localName === "Title") {
	                    this.title = this.title|| [];
	                    this.title.push(child.textContent);
	                } else if (child.localName === "Abstract") {
	                    this.abstract = this.title|| [];
	                    this.abstract.push(child.textContent);
	                } else if (child.localName === "Fees") {
	                    this.fees = child.textContent;
	                } else if (child.localName === "AccessConstraints") {
	                    this.accessConstraints = this.accessConstraints || [];
	                    this.accessConstraints.push(child.textContent);
	                }
	                // TODO: Keywords
	            }
	        };

	        return OwsServiceIdentification;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2015 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports OwsServiceProvider
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(30),
	        __webpack_require__(32)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
	              Logger) {
	        "use strict";

	        /**
	         * Constructs an OWS Service Provider instance from an XML DOM.
	         * @alias OwsServiceProvider
	         * @constructor
	         * @classdesc Represents an OWS Service Provider section of an OGC capabilities document.
	         * This object holds as properties all the fields specified in the OWS Service Provider section.
	         * Fields can be accessed as properties named according to their document names converted to camel case.
	         * For example, "providerName".
	         * @param {Element} element An XML DOM element representing the OWS Service Provider section.
	         * @throws {ArgumentError} If the specified XML DOM element is null or undefined.
	         */
	        var OwsServiceProvider = function (element) {
	            if (!element) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "OwsServiceProvider", "constructor", "missingDomElement"));
	            }

	            var children = element.children;
	            for (var c = 0; c < children.length; c++) {
	                var child = children[c];

	                if (child.localName === "ProviderName") {
	                    this.providerName = child.textContent;
	                } else if (child.localName === "ProviderSite") {
	                    this.providerSite = child.getAttribute("xlink:href");
	                }
	                // TODO: Service Contact
	            }
	        };

	        return OwsServiceProvider;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports WmsCapabilities
	 * @version $Id: WmsCapabilities.js 3055 2015-04-29 21:39:51Z tgaskins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(30),
	        __webpack_require__(32),
	        __webpack_require__(216)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
	              Logger,
	              WmsLayerCapabilities) {
	        "use strict";

	        /**
	         * Constructs an WMS Capabilities instance from an XML DOM.
	         * @alias WMSCapabilities
	         * @constructor
	         * @classdesc Represents a WMS Capabilities document. This object holds as properties all the fields
	         * specified in the given WMS Capabilities document. Most fields can be accessed as properties named
	         * according to their document names converted to camel case. For example, "version", "service.title",
	         * "service.contactInformation.contactPersonPrimary". The exceptions are online resources, whose property
	         * path has been shortened. For example "capability.request.getMap.formats" and "capability.request.getMap.url".
	         * @param {{}} xmlDom An XML DOM representing the WMS Capabilities document.
	         * @throws {ArgumentError} If the specified XML DOM is null or undefined.
	         */
	        var WmsCapabilities = function (xmlDom) {
	            if (!xmlDom) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "WmsCapabilities", "constructor", "No XML DOM specified."));
	            }

	            this.assembleDocument(xmlDom);
	        };

	        WmsCapabilities.prototype.assembleDocument = function (dom) {
	            var root = dom.documentElement;

	            this.version = root.getAttribute("version");
	            this.updateSequence = root.getAttribute("updateSequence");

	            var children = root.children || root.childNodes;
	            for (var c = 0; c < children.length; c++) {
	                var child = children[c];

	                if (child.localName === "Service") {
	                    this.service = this.assembleService(child);
	                } else if (child.localName === "Capability") {
	                    this.capability = this.assembleCapability(child);
	                }
	            }
	        };

	        WmsCapabilities.prototype.assembleService = function (element) {
	            var service = {
	                capsDoc: this
	            };

	            var children = element.children || element.childNodes;
	            for (var c = 0; c < children.length; c++) {
	                var child = children[c];

	                if (child.localName === "Name") {
	                    service.name = child.textContent;
	                } else if (child.localName === "Title") {
	                    service.title = child.textContent;
	                } else if (child.localName === "Abstract") {
	                    service.abstract = child.textContent;
	                } else if (child.localName === "KeywordList") {
	                    service.keywordList = this.assembleKeywordList(child);
	                } else if (child.localName === "OnlineResource") {
	                    service.onlineResource = child.getAttribute("xlink:href");
	                } else if (child.localName === "Fees") {
	                    service.fees = child.textContent;
	                } else if (child.localName === "AccessConstraints") {
	                    service.accessConstraints = child.textContent;
	                } else if (child.localName == "LayerLimit") {
	                    service.layerLimit = parseInt(child.textContent);
	                } else if (child.localName == "MaxWidth") {
	                    service.maxWidth = parseInt(child.textContent);
	                } else if (child.localName == "MaxHeight") {
	                    service.maxHeight = parseInt(child.textContent);
	                } else if (child.localName === "ContactInformation") {
	                    service.contactInformation = this.assembleContactInformation(child);
	                }
	            }

	            return service;
	        };

	        WmsCapabilities.prototype.assembleKeywordList = function (element) {
	            var keywords = [];

	            var children = element.children || element.childNodes;
	            for (var c = 0; c < children.length; c++) {
	                var child = children[c];

	                if (child.localName === "Keyword") {
	                    keywords.push(child.textContent);
	                }
	            }

	            return keywords;
	        };

	        WmsCapabilities.prototype.assembleContactInformation = function (element) {
	            var contactInfo = {};

	            var children = element.children || element.childNodes;
	            for (var c = 0; c < children.length; c++) {
	                var child = children[c];

	                if (child.localName === "ContactPersonPrimary") {
	                    contactInfo.contactPersonPrimary = this.assembleContactPersonPrimary(child);
	                } else if (child.localName === "ContactPosition") {
	                    contactInfo.contactPosition = child.textContent;
	                } else if (child.localName === "ContactVoiceTelephone") {
	                    contactInfo.contactVoiceTelephone = child.textContent;
	                } else if (child.localName === "ContactFacsimileTelephone") {
	                    contactInfo.contactFacsimileTelephone = child.textContent;
	                } else if (child.localName === "ContactElectronicMailAddress") {
	                    contactInfo.contactElectronicMailAddress = child.textContent;
	                } else if (child.localName === "ContactAddress") {
	                    contactInfo.contactAddress = this.assembleContactAddress(child);
	                }
	            }

	            return contactInfo;
	        };

	        WmsCapabilities.prototype.assembleContactPersonPrimary = function (element) {
	            var info = {};

	            var children = element.children || element.childNodes;
	            for (var c = 0; c < children.length; c++) {
	                var child = children[c];

	                if (child.localName === "ContactPerson") {
	                    info.contactPerson = child.textContent;
	                } else if (child.localName === "ContactOrganization") {
	                    info.contactOrganization = child.textContent;
	                }
	            }

	            return info;
	        };

	        WmsCapabilities.prototype.assembleContactAddress = function (element) {
	            var address = {};

	            var children = element.children || element.childNodes;
	            for (var c = 0; c < children.length; c++) {
	                var child = children[c];

	                if (child.localName === "AddressType") {
	                    address.addressType = child.textContent;
	                } else if (child.localName === "Address") {
	                    address.address = child.textContent;
	                } else if (child.localName === "City") {
	                    address.city = child.textContent;
	                } else if (child.localName === "StateOrProvince") {
	                    address.stateOrProvince = child.textContent;
	                } else if (child.localName === "PostCode") {
	                    address.postCode = child.textContent;
	                } else if (child.localName === "Country") {
	                    address.country = child.textContent;
	                }
	            }

	            return address;
	        };

	        WmsCapabilities.prototype.assembleCapability = function (element) {
	            var capability = {
	                capsDoc: this
	            };

	            var children = element.children || element.childNodes;
	            for (var c = 0; c < children.length; c++) {
	                var child = children[c];

	                if (child.localName === "Request") {
	                    capability.request = this.assembleRequests(child);
	                } else if (child.localName === "Exception") {
	                    capability.exception = this.assembleException(child);
	                } else if (child.localName === "Layer") {
	                    capability.layers = capability.layers || [];
	                    capability.layers.push(new WmsLayerCapabilities(child, capability));
	                }
	            }

	            return capability;
	        };

	        WmsCapabilities.prototype.assembleRequests = function (element) {
	            var requests = {};

	            var children = element.children || element.childNodes;
	            for (var c = 0; c < children.length; c++) {
	                var child = children[c];

	                if (child.localName === "GetCapabilities") {
	                    requests.getCapabilities = this.assembleRequest(child);
	                } else if (child.localName === "GetMap") {
	                    requests.getMap = this.assembleRequest(child);
	                } else if (child.localName === "GetFeatureInfo") {
	                    requests.getFeatureInfo = this.assembleRequest(child);
	                }
	            }

	            return requests;
	        };

	        WmsCapabilities.prototype.assembleRequest = function (element) {
	            var request = {
	                name: element.localName
	            };

	            var children = element.children || element.childNodes;
	            for (var c = 0; c < children.length; c++) {
	                var child = children[c];

	                if (child.localName === "Format") {
	                    request.formats = request.formats || [];
	                    request.formats.push(child.textContent);
	                } else if (child.localName === "DCPType") {
	                    var children2 = child.children || child.childNodes;
	                    for (var c2 = 0; c2 < children2.length; c2++) {
	                        var child2 = children2[c2];
	                        if (child2.localName === "HTTP") {
	                            var children3 = child2.children || child2.childNodes;
	                            for (var c3 = 0; c3 < children3.length; c3++) {
	                                var child3 = children3[c3];
	                                if (child3.localName === "Get") {
	                                    var children4 = child3.children || child3.childNodes;
	                                    for (var c4 = 0; c4 < children4.length; c4++) {
	                                        var child4 = children4[c4];
	                                        if (child4.localName === "OnlineResource") {
	                                            request.url = child4.getAttribute("xlink:href");
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }

	            return request;
	        };

	        WmsCapabilities.prototype.assembleException = function (element) {
	            var exception = {};

	            var children = element.children || element.childNodes;
	            for (var c = 0; c < children.length; c++) {
	                var child = children[c];

	                if (child.localName === "Format") {
	                    exception.formats = exception.formats || [];
	                    exception.formats.push(child.textContent);
	                }
	            }

	            return exception;
	        };

	        return WmsCapabilities;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports WmsLayerCapabilities
	 * @version $Id: WmsLayerCapabilities.js 3055 2015-04-29 21:39:51Z tgaskins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(30),
	        __webpack_require__(32)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
	              Logger) {
	        "use strict";

	        /**
	         * Constructs an WMS Layer instance from an XML DOM.
	         * @alias WmsLayerCapabilities
	         * @constructor
	         * @classdesc Represents a WMS layer description from a WMS Capabilities document. This object holds all the
	         * fields specified in the associated WMS Capabilities document.
	         * @param {{}} layerElement A WMS Layer element describing the layer.
	         * @param {{}} parentNode An object indicating the new layer object's parent object.
	         * @throws {ArgumentError} If the specified layer element is null or undefined.
	         */
	        var WmsLayerCapabilities = function (layerElement, parentNode) {
	            if (!layerElement) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "WmsLayerCapabilities", "constructor",
	                        "Layer element is null or undefined."));
	            }

	            /**
	             * The parent object, as specified to the constructor of this object.
	             * @type {{}}
	             * @readonly
	             */
	            this.parent = parentNode;

	            /**
	             * The layers that are children of this layer.
	             * @type {WmsLayerCapabilities[]}
	             * @readonly
	             */
	            this.layers;

	            /**
	             * The name of this layer description.
	             * @type {String}
	             * @readonly
	             */
	            this.name;

	            /**
	             * The title of this layer.
	             * @type {String}
	             * @readonly
	             */
	            this.title;

	            /**
	             * The abstract of this layer.
	             * @type {String}
	             * @readonly
	             */
	            this.abstract;

	            /**
	             * The list of keywords associated with this layer description.
	             * @type {String[]}
	             * @readonly
	             */
	            this.keywordList;

	            /**
	             * The identifiers associated with this layer description. Each identifier has the following properties:
	             * authority, content.
	             * @type {Object[]}
	             */
	            this.identifiers;

	            /**
	             * The metadata URLs associated with this layer description. Each object in the returned array has the
	             * following properties: type, format, url.
	             * @type {Object[]}
	             * @readonly
	             */
	            this.metadataUrls;

	            /**
	             * The data URLs associated with this layer description. Each object in the returned array has the
	             * following properties: format, url.
	             * @type {Object[]}
	             * @readonly
	             */
	            this.dataUrls;

	            /**
	             * The feature list URLs associated with this layer description. Each object in the returned array has the
	             * following properties: format, url.
	             * @type {Object[]}
	             * @readonly
	             */
	            this.featureListUrls;

	            this.assembleLayer(layerElement);
	        };

	        Object.defineProperties(WmsLayerCapabilities.prototype, {
	            /**
	             * The WMS capability section containing this layer description.
	             * @type {{}}
	             * @readonly
	             * @memberof WmsLayerCapabilities.prototype
	             */
	            capability: {
	                get: function () {
	                    var o = this;

	                    while (o && (o instanceof WmsLayerCapabilities)) {
	                        o = o.parent;
	                    }

	                    return o;
	                }
	            },

	            /**
	             * The WMS queryable attribute.
	             * @type {Boolean}
	             * @readonly
	             * @memberof WmsLayerCapabilities.prototype
	             */
	            queryable: {
	                get: function () {
	                    return WmsLayerCapabilities.replace(this, "_queryable");
	                }
	            },

	            /**
	             * The WMS cascaded attribute.
	             * @type {Boolean}
	             * @readonly
	             * @memberof WmsLayerCapabilities.prototype
	             */
	            cascaded: {
	                get: function () {
	                    return WmsLayerCapabilities.replace(this, "_cascaded");
	                }
	            },

	            /**
	             * The WMS opaque attribute.
	             * @type {Boolean}
	             * @readonly
	             * @memberof WmsLayerCapabilities.prototype
	             */
	            opaque: {
	                get: function () {
	                    return WmsLayerCapabilities.replace(this, "_opaque");
	                }
	            },

	            /**
	             * The WMS noSubsets attribute.
	             * @type {Boolean}
	             * @readonly
	             * @memberof WmsLayerCapabilities.prototype
	             */
	            noSubsets: {
	                get: function () {
	                    return WmsLayerCapabilities.replace(this, "_noSubsets");
	                }
	            },

	            /**
	             * The WMS fixedWidth attribute.
	             * @type {Number}
	             * @readonly
	             * @memberof WmsLayerCapabilities.prototype
	             */
	            fixedWidth: {
	                get: function () {
	                    return WmsLayerCapabilities.replace(this, "_fixedWidth");
	                }
	            },

	            /**
	             * The WMS fixedHeight attribute.
	             * @type {Number}
	             * @readonly
	             * @memberof WmsLayerCapabilities.prototype
	             */
	            fixedHeight: {
	                get: function () {
	                    return WmsLayerCapabilities.replace(this, "_fixedHeight");
	                }
	            },

	            /**
	             * The list of styles associated with this layer description, accumulated from this layer and its parent
	             * layers. Each object returned may have the following properties: name {String}, title {String},
	             * abstract {String}, legendUrls {Object[]}, styleSheetUrl, styleUrl. Legend urls may have the following
	             * properties: width, height, format, url. Style sheet urls and style urls have the following properties:
	             * format, url.
	             * @type {Object[]}
	             * @readonly
	             * @memberof WmsLayerCapabilities.prototype
	             */
	            styles: {
	                get: function () {
	                    return WmsLayerCapabilities.accumulate(this, "_styles", []);
	                }
	            },

	            /**
	             * The list of coordinate system descriptions associated with this layer, accumulated from this layer
	             * and its parent layers. WMS servers implementing WMS version 1.3.0 and above have this field.
	             * @type {String[]}
	             * @readonly
	             * @memberof WmsLayerCapabilities.prototype
	             */
	            crses: {
	                get: function () {
	                    return WmsLayerCapabilities.accumulate(this, "_crses", []);
	                }
	            },

	            /**
	             * The list of coordinate system descriptions associated with this layer, accumulated from this layer
	             * and its parent layers. WMS servers implementing WMS version 1.1.1 and below have this field.
	             * @type {String[]}
	             * @readonly
	             * @memberof WmsLayerCapabilities.prototype
	             */
	            srses: {
	                get: function () {
	                    return WmsLayerCapabilities.accumulate(this, "_srses", []);
	                }
	            },

	            /**
	             * This layer description's geographic bounding box. WMS servers implementing WMS 1.3.0 and above have
	             * this field. The returned object has properties for each of the WMS-specified fields. For example,
	             * "westBoundingLongitude".
	             * @type {{}}
	             * @readonly
	             * @memberof WmsLayerCapabilities.prototype
	             */
	            geographicBoundingBox: {
	                get: function () {
	                    return WmsLayerCapabilities.replace(this, "_geographicBoundingBox");
	                }
	            },

	            /**
	             * This layer description's geographic bounding box. WMS servers implementing WMS 1.1.1 and below have
	             * this field. The returned object has properties for each of the WMS-specified fields. For example,
	             * "maxx".
	             * @type {{}}
	             * @readonly
	             * @memberof WmsLayerCapabilities.prototype
	             */
	            latLonBoundingBox: { // WMS 1.1.1
	                get: function () {
	                    return WmsLayerCapabilities.replace(this, "_latLonBoundingBox");
	                }
	            },

	            /**
	             * The bounding boxes associated with this layer description. The returned object has properties for each
	             * of the defined attributes. For example, "minx".
	             * @type {{}}
	             * @readonly
	             * @memberof WmsLayerCapabilities.prototype
	             */
	            boundingBoxes: {
	                get: function () {
	                    return WmsLayerCapabilities.replace(this, "_boundingBoxes");
	                }
	            },

	            /**
	             * The list of dimensions associated with this layer description, accumulated from this layer and its
	             * parent layers. WMS servers implementing WMS version 1.3.0 and above provide this field.
	             * @type {String[]}
	             * @readonly
	             * @memberof WmsLayerCapabilities.prototype
	             */
	            dimensions: {
	                get: function () {
	                    var accumulatedDimensions = [],
	                        layer = this;

	                    // Accumulate only dimensions with unique names with descendants overriding ancestors.
	                    while (layer && (layer instanceof WmsLayerCapabilities)) {
	                        if (layer._dimensions && layer._dimensions.length > 0) {
	                            layer._dimensions.forEach(function (ancestorDimension) {
	                                var name = ancestorDimension.name;
	                                var include = true;
	                                accumulatedDimensions.forEach(function (descendantDimension) {
	                                    if (descendantDimension.name === name) {
	                                        include = false;
	                                    }
	                                });
	                                if (include) {
	                                    accumulatedDimensions.push(ancestorDimension);
	                                }
	                            });
	                        }

	                        layer = layer.parent;
	                    }

	                    return accumulatedDimensions.length > 0 ? accumulatedDimensions : undefined;
	                }
	            },

	            /**
	             * The list of extents associated with this layer description, accumulated from this layer and its
	             * parent layers. WMS servers implementing WMS version 1.3.0 and above provide this field.
	             * @type {String[]}
	             * @readonly
	             * @memberof WmsLayerCapabilities.prototype
	             */
	            extents: {
	                get: function () {
	                    var accumulatedDimensions = [],
	                        layer = this;

	                    // Accumulate only extents with unique names with descendants overriding ancestors.
	                    while (layer && (layer instanceof WmsLayerCapabilities)) {
	                        if (layer._extents && layer._extents.length > 0) {
	                            layer._extents.forEach(function (ancestorDimension) {
	                                var name = ancestorDimension.name;
	                                var include = true;
	                                accumulatedDimensions.forEach(function (descendantDimension) {
	                                    if (descendantDimension.name === name) {
	                                        include = false;
	                                    }
	                                });
	                                if (include) {
	                                    accumulatedDimensions.push(ancestorDimension);
	                                }
	                            });
	                        }

	                        layer = layer.parent;
	                    }

	                    return accumulatedDimensions.length > 0 ? accumulatedDimensions : undefined;
	                }
	            },

	            /**
	             * The attribution element associated with this layer description. The returned object has the following
	             * properties: title {String}, url {String}, logoUrl {{format, url}}.
	             * @type {{}}
	             * @readonly
	             * @memberof WmsLayerCapabilities.prototype
	             */
	            attribution: {
	                get: function () {
	                    return WmsLayerCapabilities.replace(this, "_attribution");
	                }
	            },

	            /**
	             * The authority URLs associated with this layer description, accumulated from this layer and its parent
	             * layers. The returned objects have the following properties: name {String}, url {String}.
	             * @type {Object[]}
	             * @readonly
	             * @memberof WmsLayerCapabilities.prototype
	             */
	            authorityUrls: {
	                get: function () {
	                    return WmsLayerCapabilities.accumulate(this, "_authorityUrls", []);
	                }
	            },

	            /**
	             * The minimum-scale-denominator associated with this layer description.
	             * WMS servers implementing WMS version 1.3.0 and above provide this field.
	             * @type {Number}
	             * @readonly
	             * @memberof WmsLayerCapabilities.prototype
	             */
	            minScaleDenominator: {
	                get: function () {
	                    return WmsLayerCapabilities.replace(this, "_minScaleDenominator");
	                }
	            },

	            /**
	             * The maximum-scale-denominator associated with this layer description.
	             * WMS servers implementing WMS version 1.3.0 and above provide this field.
	             * @type {Number}
	             * @readonly
	             * @memberof WmsLayerCapabilities.prototype
	             */
	            maxScaleDenominator: {
	                get: function () {
	                    return WmsLayerCapabilities.replace(this, "_maxScaleDenominator");
	                }
	            },

	            /**
	             * The scale hint associated with this layer description.
	             * WMS servers implementing WMS version 1.1.1 and below provide this field.
	             * @type {Number}
	             * @readonly
	             * @memberof WmsLayerCapabilities.prototype
	             */
	            scaleHint: {
	                get: function () {
	                    return WmsLayerCapabilities.replace(this, "_scaleHint");
	                }
	            }
	        });

	        WmsLayerCapabilities.accumulate = function (layer, propertyName, accumulation) {
	            // Accumulate all of the named properties in the specified layer and its ancestors.
	            while (layer && (layer instanceof WmsLayerCapabilities)) {
	                var property = layer[propertyName];

	                if (property) {
	                    for (var i = 0; i < property.length; i++) {
	                        accumulation.push(property[i]);
	                    }
	                }

	                layer = layer.parent;
	            }

	            return accumulation.length > 0 ? accumulation : null;
	        };

	        WmsLayerCapabilities.replace = function (layer, propertyName) {
	            // Find the first property instance encountered from the specified layer upwards through its ancestors.
	            while (layer && (layer instanceof WmsLayerCapabilities)) {
	                var property = layer[propertyName];

	                if (property) {
	                    return property;
	                } else {
	                    layer = layer.parent;
	                }
	            }
	        };

	        WmsLayerCapabilities.prototype.assembleLayer = function (layerElement) {
	            var elements, attrValue, c, e;

	            attrValue = layerElement.getAttribute("queryable");
	            if (attrValue) {
	                this._queryable = attrValue === "1" || attrValue === "true"
	            }

	            attrValue = layerElement.getAttribute("opaque");
	            if (attrValue) {
	                this._opaque = attrValue === "1" || attrValue === "true"
	            }

	            attrValue = layerElement.getAttribute("noSubsets");
	            if (attrValue) {
	                this._noSubsets = attrValue === "1" || attrValue === "true"
	            }

	            attrValue = layerElement.getAttribute("cascaded");
	            if (attrValue) {
	                this._cascaded = parseInt("10");
	            }

	            attrValue = layerElement.getAttribute("fixedWidth");
	            if (attrValue) {
	                this._fixedWidth = parseInt("10");
	            }

	            attrValue = layerElement.getAttribute("fixedHeight");
	            if (attrValue) {
	                this._fixedHeight = parseInt("10");
	            }

	            var children = layerElement.children || layerElement.childNodes;
	            for (c = 0; c < children.length; c++) {
	                var childElement = children[c];

	                if (childElement.localName === "Layer") {
	                    if (!this.layers) {
	                        this.layers = [];
	                    }
	                    this.layers.push(new WmsLayerCapabilities(childElement, this));

	                } else if (childElement.localName === "Name") {
	                    this.name = childElement.textContent;

	                } else if (childElement.localName === "Title") {
	                    this.title = childElement.textContent;

	                } else if (childElement.localName === "Abstract") {
	                    this.abstract = childElement.textContent;

	                } else if (childElement.localName === "KeywordList") {
	                    this.keywordList = this.keywordList || [];

	                    var children2 = childElement.children || childElement.childNodes;
	                    for (var c2 = 0; c2 < children2.length; c2++) {
	                        var child2 = children2[c2];

	                        if (child2.localName === "Keyword") {
	                            this.keywordList.push(child2.textContent);
	                        }
	                    }
	                } else if (childElement.localName === "Style") {
	                    if (!this._styles) {
	                        this._styles = [];
	                    }
	                    this._styles.push(WmsLayerCapabilities.assembleStyle(childElement))

	                } else if (childElement.localName === "CRS") {
	                    if (!this._crses) {
	                        this._crses = [];
	                    }
	                    this._crses.push(childElement.textContent);

	                } else if (childElement.localName === "SRS") { // WMS 1.1.1
	                    if (!this._srses) {
	                        this._srses = [];
	                    }
	                    this._srses.push(childElement.textContent);

	                } else if (childElement.localName === "EX_GeographicBoundingBox") {
	                    this._geographicBoundingBox = WmsLayerCapabilities.assembleGeographicBoundingBox(childElement);

	                } else if (childElement.localName === "LatLonBoundingBox") { // WMS 1.1.1
	                    this._geographicBoundingBox = WmsLayerCapabilities.assembleLatLonBoundingBox(childElement);

	                } else if (childElement.localName === "BoundingBox") {
	                    if (!this._boundingBoxes) {
	                        this._boundingBoxes = [];
	                    }
	                    this._boundingBoxes.push(WmsLayerCapabilities.assembleBoundingBox(childElement));

	                } else if (childElement.localName === "Dimension") {
	                    if (!this._dimensions) {
	                        this._dimensions = [];
	                    }
	                    this._dimensions.push(WmsLayerCapabilities.assembleDimension(childElement));

	                } else if (childElement.localName === "Extent") { // WMS 1.1.1
	                    if (!this._extents) {
	                        this._extents = [];
	                    }
	                    this._extents.push(WmsLayerCapabilities.assembleDimension(childElement)); // same schema as 1.3.0 Dimension

	                } else if (childElement.localName === "Attribution") {
	                    this._attribution = WmsLayerCapabilities.assembleAttribution(childElement);

	                } else if (childElement.localName === "AuthorityURL") {
	                    if (!this._authorityUrls) {
	                        this._authorityUrls = [];
	                    }
	                    this._authorityUrls.push(WmsLayerCapabilities.assembleAuthorityUrl(childElement));

	                } else if (childElement.localName === "Identifier") {
	                    if (!this.identifiers) {
	                        this.identifiers = [];
	                    }
	                    this.identifiers.push(WmsLayerCapabilities.assembleIdentifier(childElement));

	                } else if (childElement.localName === "MetadataURL") {
	                    if (!this.metadataUrls) {
	                        this.metadataUrls = [];
	                    }
	                    this.metadataUrls.push(WmsLayerCapabilities.assembleMetadataUrl(childElement));

	                } else if (childElement.localName === "DataURL") {
	                    if (!this.dataUrls) {
	                        this.dataUrls = [];
	                    }
	                    this.dataUrls.push(WmsLayerCapabilities.assembleUrl(childElement));

	                } else if (childElement.localName === "FeatureListURL") {
	                    if (!this.featureListUrls) {
	                        this.featureListUrls = [];
	                    }
	                    this.featureListUrls.push(WmsLayerCapabilities.assembleUrl(childElement));

	                } else if (childElement.localName === "MinScaleDenominator") {
	                    this._minScaleDenominator = parseFloat(childElement.textContent);

	                } else if (childElement.localName === "MaxScaleDenominator") {
	                    this._maxScaleDenominator = parseFloat(childElement.textContent);

	                } else if (childElement.localName === "ScaleHint") { // WMS 1.1.1
	                    this._scaleHint = {};
	                    this._scaleHint.min = WmsLayerCapabilities.getFloatAttribute(childElement, "min");
	                    this._scaleHint.max = WmsLayerCapabilities.getFloatAttribute(childElement, "max");
	                }
	            }
	        };

	        WmsLayerCapabilities.assembleStyle = function (styleElement) {
	            var result = {};

	            var children = styleElement.children || styleElement.childNodes;
	            for (var c = 0; c < children.length; c++) {
	                var childElement = children[c];

	                if (childElement.localName === "Name") {
	                    result.name = childElement.textContent;

	                } else if (childElement.localName === "Title") {
	                    result.title = childElement.textContent;

	                } else if (childElement.localName === "Abstract") {
	                    result.abstract = childElement.textContent;

	                } else if (childElement.localName === "LegendURL") {
	                    if (!result.legendUrls) {
	                        result.legendUrls = [];
	                    }
	                    result.legendUrls.push(WmsLayerCapabilities.assembleLegendUrl(childElement));

	                } else if (childElement.localName === "StyleSheetURL") {
	                    result.styleSheetUrl = WmsLayerCapabilities.assembleUrl(childElement);

	                } else if (childElement.localName === "StyleURL") {
	                    result.styleUrl = WmsLayerCapabilities.assembleUrl(childElement);
	                }
	            }

	            return result;
	        };

	        WmsLayerCapabilities.assembleGeographicBoundingBox = function (bboxElement) {
	            var result = {};

	            var children = bboxElement.children || bboxElement.childNodes;
	            for (var c = 0; c < children.length; c++) {
	                var childElement = children[c];

	                if (childElement.localName === "westBoundLongitude") {
	                    result.westBoundLongitude = parseFloat(childElement.textContent);

	                } else if (childElement.localName === "eastBoundLongitude") {
	                    result.eastBoundLongitude = parseFloat(childElement.textContent);

	                } else if (childElement.localName === "southBoundLatitude") {
	                    result.southBoundLatitude = parseFloat(childElement.textContent);

	                } else if (childElement.localName === "northBoundLatitude") {
	                    result.northBoundLatitude = parseFloat(childElement.textContent);
	                }
	            }

	            return result;
	        };

	        WmsLayerCapabilities.assembleLatLonBoundingBox = function (bboxElement) { // WMS 1.1.1
	            var result = {};

	            result.minx = WmsLayerCapabilities.getFloatAttribute(bboxElement, "minx");
	            result.miny = WmsLayerCapabilities.getFloatAttribute(bboxElement, "miny");
	            result.maxx = WmsLayerCapabilities.getFloatAttribute(bboxElement, "maxx");
	            result.maxy = WmsLayerCapabilities.getFloatAttribute(bboxElement, "maxy");

	            return result;
	        };

	        WmsLayerCapabilities.assembleBoundingBox = function (bboxElement) {
	            var result = {};

	            result.crs = bboxElement.getAttribute("CRS");
	            result.minx = WmsLayerCapabilities.getFloatAttribute(bboxElement, "minx");
	            result.miny = WmsLayerCapabilities.getFloatAttribute(bboxElement, "miny");
	            result.maxx = WmsLayerCapabilities.getFloatAttribute(bboxElement, "maxx");
	            result.maxy = WmsLayerCapabilities.getFloatAttribute(bboxElement, "maxy");
	            result.resx = WmsLayerCapabilities.getFloatAttribute(bboxElement, "resx");
	            result.resy = WmsLayerCapabilities.getFloatAttribute(bboxElement, "resy");

	            return result;
	        };

	        WmsLayerCapabilities.assembleDimension = function (dimensionElement) {
	            var result = {};

	            result.name = dimensionElement.getAttribute("name");
	            result.units = dimensionElement.getAttribute("units");
	            result.unitSymbol = dimensionElement.getAttribute("unitSymbol");
	            result.default = dimensionElement.getAttribute("default");
	            result.multipleValues = dimensionElement.getAttribute("multipleValues");
	            if (result.multipleValues) {
	                result.multipleValues = result.multipleValues === "true" || result.multipleValues === "1";
	            }
	            result.nearestValue = dimensionElement.getAttribute("nearestValue");
	            if (result.nearestValue) {
	                result.nearestValue = result.nearestValue === "true" || result.nearestValue === "1";
	            }
	            result.current = dimensionElement.getAttribute("current");
	            if (result.current) {
	                result.current = result.current === "true" || result.current === "1";
	            }

	            result.content = dimensionElement.textContent;

	            return result;
	        };

	        WmsLayerCapabilities.assembleAttribution = function (attributionElement) {
	            var result = {};

	            var children = attributionElement.children || attributionElement.childNodes;
	            for (var c = 0; c < children.length; c++) {
	                var childElement = children[c];

	                if (childElement.localName === "Title") {
	                    result.title = childElement.textContent;

	                } else if (childElement.localName === "OnlineResource") {
	                    result.url = childElement.getAttribute("xlink:href");

	                } else if (childElement.localName === "LogoUrul") {
	                    result.logoUrl = WmsLayerCapabilities.assembleLogoUrl(childElement);
	                }
	            }

	            return result;
	        };

	        WmsLayerCapabilities.assembleAuthorityUrl = function (urlElement) {
	            var result = {};

	            result.name = urlElement.getAttribute("name");

	            var children = urlElement.children || urlElement.childNodes;
	            for (var c = 0; c < children.length; c++) {
	                var childElement = children[c];

	                if (childElement.localName === "OnlineResource") {
	                    result.url = childElement.getAttribute("xlink:href");
	                }
	            }

	            return result;
	        };

	        WmsLayerCapabilities.assembleIdentifier = function (identifierElement) {
	            var result = {};

	            result.authority = identifierElement.getAttribute("authority");
	            result.content = identifierElement.textContent;

	            return result;
	        };

	        WmsLayerCapabilities.assembleMetadataUrl = function (urlElement) {
	            var result = {};

	            result.type = urlElement.getAttribute("type");

	            var children = urlElement.children || urlElement.childNodes;
	            for (var c = 0; c < children.length; c++) {
	                var childElement = children[c];

	                if (childElement.localName === "Format") {
	                    result.format = childElement.textContent;

	                } else if (childElement.localName === "OnlineResource") {
	                    result.url = childElement.getAttribute("xlink:href");
	                }
	            }

	            return result;
	        };

	        WmsLayerCapabilities.assembleLegendUrl = function (urlElement) {
	            var result = {};

	            result.width = WmsLayerCapabilities.getIntegerAttribute(urlElement, "width");
	            result.height = WmsLayerCapabilities.getIntegerAttribute(urlElement, "height");

	            var children = urlElement.children || urlElement.childNodes;
	            for (var c = 0; c < children.length; c++) {
	                var childElement = children[c];

	                if (childElement.localName === "Format") {
	                    result.format = childElement.textContent;

	                } else if (childElement.localName === "OnlineResource") {
	                    result.url = childElement.getAttribute("xlink:href");
	                }
	            }

	            return result;
	        };

	        WmsLayerCapabilities.assembleLogoUrl = function (urlElement) {
	            var result = {};

	            result.width = WmsLayerCapabilities.getIntegerAttribute(urlElement, "width");
	            result.height = WmsLayerCapabilities.getIntegerAttribute(urlElement, "height");

	            var children = urlElement.children || urlElement.childNodes;
	            for (var c = 0; c < children.length; c++) {
	                var childElement = children[c];

	                if (childElement.localName === "Format") {
	                    result.format = childElement.textContent;

	                } else if (childElement.localName === "OnlineResource") {
	                    result.url = childElement.getAttribute("xlink:href");
	                }
	            }

	            return result;
	        };

	        WmsLayerCapabilities.assembleUrl = function (urlElement) {
	            var result = {};

	            var children = urlElement.children || urlElement.childNodes;
	            for (var c = 0; c < children.length; c++) {
	                var childElement = children[c];

	                if (childElement.localName === "Format") {
	                    result.format = childElement.textContent;

	                } else if (childElement.localName === "OnlineResource") {
	                    result.url = childElement.getAttribute("xlink:href");
	                }
	            }

	            return result;
	        };

	        WmsLayerCapabilities.getIntegerAttribute = function (element, attrName) {
	            var result = element.getAttribute(attrName);

	            if (result) {
	                result = parseInt(result);
	            } else {
	                result = undefined;
	            }

	            return result;
	        };

	        WmsLayerCapabilities.getFloatAttribute = function (element, attrName) {
	            var result = element.getAttribute(attrName);

	            if (result) {
	                result = parseFloat(result);
	            } else {
	                result = undefined;
	            }

	            return result;
	        };

	        return WmsLayerCapabilities;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
	;

/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2015 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports WmtsLayerCapabilities
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(30),
	        __webpack_require__(32),
	        __webpack_require__(210),
	        __webpack_require__(215)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
	              Logger,
	              OwsLanguageString,
	              WmsCapabilities) {
	        "use strict";

	        /**
	         * Constructs an WMTS Layer instance from an XML DOM.
	         * @alias WmtsLayerCapabilities
	         * @constructor
	         * @classdesc Represents a WMTS layer description from a WMTS Capabilities document. This object holds all the
	         * fields specified in the associated WMTS Capabilities document.
	         * @param {{}} layerElement A WMTS Layer element describing the layer.
	         * @param {{}} capabilities The WMTS capabilities documented containing this layer.
	         * @throws {ArgumentError} If the specified layer element is null or undefined.
	         */
	        var WmtsLayerCapabilities = function (layerElement, capabilities) {
	            if (!layerElement) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "WmtsLayerCapabilities", "constructor", "missingDomElement"));
	            }

	            /**
	             * This layer's WMTS capabilities document, as specified to the constructor of this object.
	             * @type {{}}
	             * @readonly
	             */
	            this.capabilities = capabilities;

	            /**
	             * The identifier of this layer description.
	             * @type {String}
	             * @readonly
	             */
	            this.identifier;

	            /**
	             * The titles of this layer.
	             * @type {String[]}
	             * @readonly
	             */
	            this.title;

	            /**
	             * The abstracts of this layer.
	             * @type {String[]}
	             * @readonly
	             */
	            this.abstract;

	            /**
	             * The list of keywords associated with this layer description.
	             * @type {String[]}
	             * @readonly
	             */
	            this.keywords;

	            /**
	             * The WGS84 bounding box associated with this layer. The returned object has the following properties:
	             * "lowerCorner", "upperCorner".
	             * @type {{}}
	             * @readonly
	             */
	            this.wgs84BoundingBox;

	            /**
	             * The bounding boxes associated with this layer. The returned array contains objects with the following
	             * properties: TODO
	             * @type {Object[]}
	             * @readonly
	             */
	            this.boundingBox;

	            /**
	             * The list of styles associated with this layer description, accumulated from this layer and its parent
	             * layers. Each object returned may have the following properties: name {String}, title {String},
	             * abstract {String}, legendUrls {Object[]}, styleSheetUrl, styleUrl. Legend urls may have the following
	             * properties: width, height, format, url. Style sheet urls and style urls have the following properties:
	             * format, url.
	             * @type {Object[]}
	             * @readonly
	             */
	            this.styles;

	            /**
	             * The formats supported by this layer.
	             * @type {String[]}
	             * @readonly
	             */
	            this.formats;

	            /**
	             * The Feature Info formats supported by this layer.
	             * @type {String[]}
	             * @readonly
	             */
	            this.infoFormat;

	            /**
	             * The dimensions associated with this layer. The returned array contains objects with the following
	             * properties: TODO
	             */
	            this.dimension;

	            /**
	             * The metadata associated with this layer description. Each object in the returned array has the
	             * following properties: type, format, url.
	             * @type {Object[]}
	             * @readonly
	             */
	            this.metadata;

	            /**
	             * The tile matris sets associated with this layer.
	             * @type {Object[]}
	             * @readonly
	             */
	            this.tileMatrixSetLink;

	            /**
	             * The resource URLs associated with this layer description. Each object in the returned array has the
	             * following properties: format, url.
	             * @type {Object[]}
	             * @readonly
	             */
	            this.resourceUrl;

	            this.assembleLayer(layerElement);
	        };

	        WmtsLayerCapabilities.prototype.assembleLayer = function (element) {
	            var children = element.children || element.childNodes;
	            for (var c = 0; c < children.length; c++) {
	                var child = children[c];

	                if (child.localName === "Identifier") {
	                    this.identifier = child.textContent;
	                } else if (child.localName === "Title") {
	                    this.title = this.title || [];
	                    this.title.push(new OwsLanguageString(child));
	                } else if (child.localName === "Abstract") {
	                    this.abstract = this.abstract || [];
	                    this.abstract.push(new OwsLanguageString(child));
	                } else if (child.localName === "WGS84BoundingBox") {
	                    this.wgs84BoundingBox = WmtsLayerCapabilities.assembleBoundingBox(child);
	                } else if (child.localName === "BoundingBox") {
	                    this.boundingBox = this.boundingBox || [];
	                    this.boundingBox.push(WmtsLayerCapabilities.assembleBoundingBox(child));
	                } else if (child.localName === "Style") {
	                    this.style = this.style || [];
	                    this.style.push(WmtsLayerCapabilities.assembleStyle(child));
	                } else if (child.localName === "Format") {
	                    this.format = this.format || [];
	                    this.format.push(child.textContent);
	                } else if (child.localName === "InfoFormat") {
	                    this.infoFormat = this.infoFormat || [];
	                    this.infoFormat.push(child.textContent);
	                } else if (child.localName === "Dimension") {
	                    this.dimension = this.dimension || [];
	                    this.dimension.push(WmtsLayerCapabilities.assembleDimension(child));
	                } else if (child.localName === "Metadata") {
	                    this.metadata = this.metadata || [];
	                    this.metadata.push(WmtsLayerCapabilities.assembleMetadata(child));
	                } else if (child.localName === "ResourceURL") {
	                    this.resourceUrl = this.resourceUrl || [];
	                    this.resourceUrl.push(WmtsLayerCapabilities.assembleResourceUrl(child));
	                } else if (child.localName === "TileMatrixSetLink") {
	                    this.tileMatrixSetLink = this.tileMatrixSetLink || [];
	                    this.tileMatrixSetLink.push(WmtsLayerCapabilities.assembleTileMatrixSetLink(child));
	                }
	                // TODO: Keywords
	            }

	        };

	        WmtsLayerCapabilities.assembleStyle = function (element) {
	            var result = {};

	            result.isDefault = element.getAttribute("isDefault");

	            var children = element.children || element.childNodes;
	            for (var c = 0; c < children.length; c++) {
	                var child = children[c];

	                if (child.localName === "Identifier") {
	                    result.identifier = child.textContent;
	                } else if (child.localName === "Title") {
	                    result.title = result.title || [];
	                    result.title.push(new OwsLanguageString(child));
	                } else if (child.localName === "Abstract") {
	                    result.abstract = result.abstract || [];
	                    result.abstract.push(new OwsLanguageString(child));
	                } else if (child.localName === "LegendURL") {
	                    result.legendUrl = result.legendUrl || [];
	                    result.legendUrl.push(WmtsLayerCapabilities.assembleLegendUrl(child));
	                }
	                // TODO: keywords
	            }

	            return result;
	        };

	        WmtsLayerCapabilities.assembleBoundingBox = function (element) {
	            var result = {};

	            var crs = element.getAttribute("crs");
	            if (crs) {
	                result.crs = crs;
	            }

	            var children = element.children || element.childNodes;
	            for (var c = 0; c < children.length; c++) {
	                var child = children[c];

	                if (child.localName === "LowerCorner") {
	                    var lc = child.textContent.split(" ");
	                    result.lowerCorner = [parseFloat(lc[0]), parseFloat(lc[1])];
	                } else if (child.localName === "UpperCorner") {
	                    var uc = child.textContent.split(" ");
	                    result.upperCorner = [parseFloat(uc[0]), parseFloat(uc[1])];
	                }
	            }

	            return result;
	        };

	        WmtsLayerCapabilities.assembleDimension = function (element) {
	            var result = {};

	            var children = element.children || element.childNodes;
	            for (var c = 0; c < children.length; c++) {
	                var child = children[c];

	                if (child.localName === "Identifier") {
	                    result.identifier = child.textContent;
	                } else if (child.localName === "Title") {
	                    result.title = result.title || [];
	                    result.title.push(new OwsLanguageString(child));
	                } else if (child.localName === "Abstract") {
	                    result.abstract = result.abstract || [];
	                    result.abstract.push(new OwsLanguageString(child));
	                } else if (child.localName === "UOM") {
	                    result.uom = {
	                        name: child.getAttribute("name"),
	                        reference: child.getAttribute("reference")
	                    }
	                } else if (child.localName == "UnitSymbol") {
	                    result.unitSymbol = child.textContent;
	                } else if (child.localName === "Default") {
	                    result.default = child.textContent;
	                } else if (child.localName === "Current") {
	                    result.current = (child.textContent === "true");
	                } else if (child.localName === "Value") {
	                    result.value = result.value || [];
	                    result.value.push(child.textContent);
	                }
	            }

	            return result;
	        };

	        WmtsLayerCapabilities.assembleMetadata = function (element) { // TODO
	            var result = {};

	            return result;
	        };

	        WmtsLayerCapabilities.assembleResourceUrl = function (element) {
	            var result = {};

	            result.format = element.getAttribute("format");
	            result.resourceType = element.getAttribute("resourceType");
	            result.template = element.getAttribute("template");

	            return result;
	        };

	        WmtsLayerCapabilities.assembleLegendUrl = function (element) {
	            var result = {};

	            result.format = element.getAttribute("format");
	            result.minScaleDenominator = element.getAttribute("minScaleDenominator");
	            result.maxScaleDenominator = element.getAttribute("maxScaleDenominator");
	            result.href = element.getAttribute("xlink:href");
	            result.width = element.getAttribute("width");
	            result.height = element.getAttribute("height");

	            return result;
	        };

	        WmtsLayerCapabilities.assembleTileMatrixSetLink = function (element) {
	            var result = {};

	            var children = element.children || element.childNodes;
	            for (var c = 0; c < children.length; c++) {
	                var child = children[c];

	                if (child.localName === "TileMatrixSet") {
	                    result.tileMatrixSet = child.textContent;
	                } else if (child.localName === "TileMatrixSetLimits") {
	                    result.tileMatrixSetLimits = WmtsLayerCapabilities.assembleTileMatrixSetLimits(child);
	                }
	            }

	            return result;
	        };

	        WmtsLayerCapabilities.assembleTileMatrixSetLimits = function (element) {
	            var result = {};

	            var children = element.children || element.childNodes;
	            for (var c = 0; c < children.length; c++) {
	                var child = children[c];

	                if (child.localName === "TileMatrixLimits") {
	                    result.tileMatrixLimits = result.tileMatrixLimits || [];
	                    result.tileMatrixLimits.push(WmtsLayerCapabilities.assembleTileMatrixLimits(child));
	                }
	            }

	            return result;
	        };

	        WmtsLayerCapabilities.assembleTileMatrixLimits = function (element) {
	            var result = {};

	            var children = element.children || element.childNodes;
	            for (var c = 0; c < children.length; c++) {
	                var child = children[c];

	                if (child.localName === "TileMatrix") {
	                    result.tileMatrix = child.textContent;
	                } else if (child.localName === "MinTileRow") {
	                    result.minTileRow = parseInt(child.textContent);
	                } else if (child.localName === "MaxTileRow") {
	                    result.maxTileRow = parseInt(child.textContent);
	                } else if (child.localName === "MinTileCol") {
	                    result.minTileCol = parseInt(child.textContent);
	                } else if (child.localName === "maxTileCol") {
	                    result.maxTileCol = parseInt(child.textContent);
	                }
	            }

	            return result;
	        };

	        return WmtsLayerCapabilities;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports WmsLayer
	 * @version $Id: WmsLayer.js 3362 2015-07-31 19:29:12Z tgaskins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(30),
	        __webpack_require__(28),
	        __webpack_require__(32),
	        __webpack_require__(219),
	        __webpack_require__(75),
	        __webpack_require__(204),
	        __webpack_require__(111)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
	              Location,
	              Logger,
	              PeriodicTimeSequence,
	              Sector,
	              TiledImageLayer,
	              WmsUrlBuilder) {
	        "use strict";

	        /**
	         * Constructs a WMS image layer.
	         * @alias WmsLayer
	         * @constructor
	         * @augments TiledImageLayer
	         * @classdesc Displays a WMS image layer.
	         * @param {{}} config Specifies configuration information for the layer. Must contain the following
	         * properties:
	         * <ul>
	         *     <li>service: {String} The URL of the WMS server.</li>
	         *     <li>layerNames: {String} A comma separated list of the names of the WMS layers to include in this layer.</li>
	         *     <li>sector: {Sector} The sector spanned by this layer.</li>
	         *     <li>levelZeroDelta: {Location} The level-zero tile delta to use for this layer.</li>
	         *     <li>numLevels: {Number} The number of levels to make for this layer.</li>
	         *     <li>format: {String} The mime type of the image format to request, e.g., image/png.</li>
	         *     <li>size: {Number} The size in pixels of tiles for this layer.</li>
	         *     <li>coordinateSystem (optional): {String} The coordinate system to use for this layer, e.g., EPSG:4326.</li>
	         *     <li>styleNames (optional): {String} A comma separated list of the styles to include in this layer.</li>
	         * </ul>
	         * The function [WmsLayer.formLayerConfiguration]{@link WmsLayer#formLayerConfiguration} will create an
	         * appropriate configuration object given a {@link WmsLayerCapabilities} object.
	         * @param {String} timeString The time parameter passed to the WMS server when imagery is requested. May be
	         * null, in which case no time parameter is passed to the server.
	         * @throws {ArgumentError} If the specified configuration is null or undefined.
	         */
	        var WmsLayer = function (config, timeString) {
	            if (!config) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "WmsLayer", "constructor", "No configuration specified."));
	            }

	            var cachePath = config.service + config.layerNames + config.styleNames;
	            if (timeString) {
	                cachePath = cachePath + timeString;
	            }

	            TiledImageLayer.call(this, config.sector, config.levelZeroDelta, config.numLevels, config.format,
	                cachePath, config.size, config.size);

	            this.displayName = config.title;
	            this.pickEnabled = false;

	            this.urlBuilder = new WmsUrlBuilder(config.service, config.layerNames, config.styleNames, config.version,
	                timeString);
	            if (config.coordinateSystem) {
	                this.urlBuilder.crs = config.coordinateSystem;
	            }

	            /**
	             * The time string passed to this layer's constructor.
	             * @type {String}
	             * @readonly
	             */
	            this.timeString = timeString;
	        };

	        WmsLayer.prototype = Object.create(TiledImageLayer.prototype);

	        /**
	         * Forms a configuration object for a specified {@link WmsLayerCapabilities} layer description. The
	         * configuration object created and returned is suitable for passing to the WmsLayer constructor.
	         * <p>
	         *     This method also parses any time dimensions associated with the layer and returns them in the
	         *     configuration object's "timeSequences" property. This property is a mixed array of Date objects
	         *     and {@link PeriodicTimeSequence} objects describing the dimensions found.
	         * @param wmsLayerCapabilities {WmsLayerCapabilities} The WMS layer capabilities to create a configuration for.
	         * @returns {{}} A configuration object.
	         * @throws {ArgumentError} If the specified WMS layer capabilities is null or undefined.
	         */
	        WmsLayer.formLayerConfiguration = function (wmsLayerCapabilities) {
	            var config = {
	                title: wmsLayerCapabilities.title,
	                version: wmsLayerCapabilities.capability.capsDoc.version
	            };

	            // Determine the layer's sector.
	            var bbox = wmsLayerCapabilities.geographicBoundingBox || wmsLayerCapabilities.latLonBoundingBox;
	            if (bbox && bbox.westBoundLongitude) {
	                config.sector = new Sector(bbox.southBoundLatitude, bbox.northBoundLatitude,
	                    bbox.westBoundLongitude, bbox.eastBoundLongitude);
	            } else if (bbox && bbox.minx) {
	                config.sector = new Sector(bbox.miny, bbox.maxy, bbox.minx, bbox.maxx);
	            } else {
	                config.sector = Sector.FULL_SPHERE;
	            }

	            // Determine level 0 delta.
	            config.levelZeroDelta = new Location(36, 36); // TODO: How to determine best delta

	            // Determine number of levels.
	            config.numLevels = 19; // TODO: How to determine appropriate num levels

	            config.size = 256;

	            // Assign layer name.
	            config.layerNames = wmsLayerCapabilities.name;

	            // Determine image format
	            var getMapInfo = wmsLayerCapabilities.capability.request.getMap,
	                formats = getMapInfo.formats;

	            if (formats.indexOf("image/png") >= 0) {
	                config.format = "image/png";
	            } else if (formats.indexOf("image/jpeg") >= 0) {
	                config.format = "image/jpeg";
	            } else if (formats.indexOf("image/tiff") >= 0) {
	                config.format = "image/tiff";
	            } else if (formats.indexOf("image/gif") >= 0) {
	                config.format = "image/gif";
	            }

	            // Determine the GetMap service address.
	            config.service = getMapInfo.url;

	            // Determine the coordinate system to use.
	            var coordinateSystems = wmsLayerCapabilities.crses; // WMS 1.3.0 and greater
	            if (!coordinateSystems) {
	                coordinateSystems = wmsLayerCapabilities.srses; // WMS 1.1.1 and lower
	            }

	            if (coordinateSystems) {
	                if ((coordinateSystems.indexOf("EPSG:4326") >= 0) || (coordinateSystems.indexOf("epsg:4326") >= 0)) {
	                    config.coordinateSystem = "EPSG:4326";
	                } else if ((coordinateSystems.indexOf("CRS84") >= 0) || (coordinateSystems.indexOf("CRS:84") >= 0)) {
	                    config.coordinateSystem = "CRS:84";
	                }
	            }

	            var dimensions = WmsLayer.parseTimeDimensions(wmsLayerCapabilities);
	            if (dimensions && dimensions.length > 0) {
	                config.timeSequences = dimensions;
	            }

	            return config;
	        };

	        WmsLayer.parseTimeDimensions = function (wmsLayerCapabilities) {
	            var dimensions = wmsLayerCapabilities.extents || wmsLayerCapabilities.dimensions,
	                parsedDimensions = null;

	            if (dimensions) {
	                parsedDimensions = [];

	                for (var i = 0; i < dimensions.length; i++) {
	                    var dimension = dimensions[i];

	                    if (dimension.name.toLowerCase() === "time" &&
	                        (!dimension.units || dimension.units.toLowerCase() === "iso8601")) {
	                        var individualDimensions = dimension.content.split(",");

	                        for (var j = 0; j < individualDimensions.length; j++) {
	                            var individualDimension = individualDimensions[j],
	                                splitDimension = individualDimension.split("/");

	                            if (splitDimension.length === 1) {
	                                parsedDimensions.push(new Date(individualDimension));
	                            } else if (splitDimension.length === 3) {
	                                parsedDimensions.push(new PeriodicTimeSequence(individualDimension));
	                            }
	                        }
	                    }
	                }
	            }

	            return parsedDimensions;
	        };

	        return WmsLayer;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports PeriodicTimeSequence
	 * @version $Id: PeriodicTimeSequence.js 3362 2015-07-31 19:29:12Z tgaskins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(30),
	        __webpack_require__(32)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
	              Logger) {
	        "use strict";

	        /**
	         * Constructs a time sequence from an ISO 8601 string.
	         * @alias PeriodicTimeSequence
	         * @constructor
	         * @classdesc Represents a time sequence described as an ISO 8601 time-format string as required by WMS.
	         * The string must be in the form start/end/period, where start and end are ISO 8601 time values and
	         * period is an ISO 8601 period specification. This class provides iteration over the sequence in steps
	         * specified by the period. If the start and end dates are different, iteration will start at the start
	         * date and end at the end date. If the start and end dates are the same, iteration will start at the
	         * specified date and will never end.
	         * @param {String} sequenceString The string describing the time sequence.
	         * @throws {ArgumentError} If the specified intervalString is null, undefined or not a valid time interval
	         * string.
	         */
	        var PeriodicTimeSequence = function (sequenceString) {
	            if (!sequenceString) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "PeriodicTimeSequence", "constructor", "missingString"));
	            }

	            var intervalParts = sequenceString.split("/");
	            if (intervalParts.length !== 3) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "PeriodicTimeSequence", "constructor",
	                        "The interval string " + sequenceString + " does not contain 3 elements."));
	            }

	            /**
	             * This sequence's sequence string, as specified to the constructor.
	             * @type {String}
	             * @readonly
	             */
	            this.sequenceString = sequenceString;

	            /**
	             * This sequence's start time.
	             * @type {Date}
	             * @readonly
	             */
	            this.startTime = new Date(intervalParts[0]);

	            /**
	             * This sequence's end time.
	             * @type {Date}
	             * @readonly
	             */
	            this.endTime = new Date(intervalParts[1]);

	            // Intentionally not documented.
	            this.intervalMilliseconds = this.endTime.getTime() - this.startTime.getTime();

	            // Documented with property accessor below.
	            this._currentTime = this.startTime;

	            /**
	             * Indicates whether this sequence is an infinite sequence -- the start and end dates are the same.
	             * @type {Boolean}
	             * @readonly
	             */
	            this.infiniteInterval = this.startTime.getTime() == this.endTime.getTime();

	            // Intentionally not documented. The array of sequence increments:
	            // year, month, week, day, hours, minutes, seconds
	            this.period = PeriodicTimeSequence.parsePeriodString(intervalParts[2], false);
	        };

	        Object.defineProperties(PeriodicTimeSequence.prototype, {
	            /**
	             * This sequence's current time.
	             * @type {Date}
	             * @default This sequence's start time.
	             * @memberof PeriodicTimeSequence.prototype
	             */
	            currentTime: {
	                get: function () {
	                    return this._currentTime;
	                },
	                set: function (value) {
	                    this._currentTime = value;
	                }
	            },
	            /**
	             * Indicates the position of this sequence's current time relative to the sequence's total interval,
	             * in the range [0, 1]. A value of 0 indicates this sequence's start time. A value of 1 indicates
	             * this sequence's end time. A value of 0.5 indicates a current time that's exactly mid-way between
	             * this sequence's start time and end time.
	             * @type {Number}
	             * @memberof PeriodicTimeSequence.prototype
	             */
	            scaleForCurrentTime: {
	                get: function () {
	                    if (!this.currentTime) {
	                        return 1;
	                    } else {
	                        return (this.currentTime.getTime() - this.startTime.getTime()) / this.intervalMilliseconds;
	                    }
	                }
	            }
	        });

	        /**
	         * Sets this sequence's current time to the next time in the sequence and returns that time.
	         * @returns {Date|null} The next time of this sequence, or null if no more times are in the sequence.
	         * Use [reset]{@link PeriodicTimeSequence#reset} to re-start this sequence.
	         * Use [previous]{@link PeriodicTimeSequence#previous} to step backwards through this sequence.
	         */
	        PeriodicTimeSequence.prototype.next = function () {
	            if (!this.currentTime) {
	                this.currentTime = this.startTime;
	            } else if ((this.currentTime.getTime() >= this.endTime.getTime()) && !this.infiniteInterval) {
	                this.currentTime = null;
	            } else {
	                this.currentTime = PeriodicTimeSequence.incrementTime(this.currentTime, this.period);
	            }

	            return this.currentTime;
	        };

	        /**
	         * Sets this sequence's current time to the previous time in the sequence and returns that time.
	         * @returns {Date|null} The previous time of this sequence, or null if the sequence is currently at its start
	         * time.
	         * Use [next]{@link PeriodicTimeSequence#next} to step forwards through this sequence.
	         */
	        PeriodicTimeSequence.prototype.previous = function () {
	            if (!this.currentTime) {
	                this.currentTime = this.endTime;
	            } else if (this.currentTime.getTime() === this.startTime.getTime()) {
	                this.currentTime = null;
	            } else {
	                this.currentTime = this.getTimeForScale(0.9999 * this.scaleForCurrentTime);
	            }

	            return this.currentTime;
	        };

	        /**
	         * Resets this sequence's current time to its start time.
	         * Use [next]{@link PeriodicTimeSequence#next} to step forwards through this sequence.
	         * Use [previous]{@link PeriodicTimeSequence#previous} to step backwards through this sequence.
	         */
	        PeriodicTimeSequence.prototype.reset = function () {
	            this.currentTime = null;
	        };

	        /**
	         * Returns the time associated with a specified value in the range [0, 1]. A value of 0 returns this
	         * sequence's start time. A value of 1 returns this sequence's end time. A value of 0.5 returs a time
	         * mid-way between this sequence's start and end times.
	         * @param scale The scale value. This value is clamped to the range [0, 1] before the time is determined.
	         * @returns {Date}
	         */
	        PeriodicTimeSequence.prototype.getTimeForScale = function (scale) {
	            if (scale <= 0) {
	                return this.startTime;
	            }

	            if (scale >= 1) {
	                return this.endTime;
	            }

	            var time = new Date(this.startTime.getTime()),
	                previousTime = time,
	                s = 0;

	            for (s = 0; s < scale; s = (time.getTime() - this.startTime.getTime()) / this.intervalMilliseconds) {
	                previousTime = time;
	                time = PeriodicTimeSequence.incrementTime(time, this.period);
	            }

	            return previousTime;
	        };

	        // Intentionally not documented. Adds this sequence's period to a specified time.
	        PeriodicTimeSequence.incrementTime = function (currentTime, period) {
	            var newTime = new Date(currentTime.getTime());

	            if (period[0] != 0) {
	                newTime.setUTCFullYear(newTime.getUTCFullYear() + period[0]);
	            }

	            if (period[1] != 0) {
	                PeriodicTimeSequence.addMonths(newTime, period[1]);
	            }

	            if (period[2] != 0) {
	                newTime.setUTCDate(newTime.getUTCDate() + 7 * period[2]);
	            }

	            if (period[3] != 0) {
	                newTime.setUTCDate(newTime.getUTCDate() + period[3]);
	            }

	            if (period[4] != 0) {
	                newTime.setUTCHours(newTime.getUTCHours() + period[4]);
	            }

	            if (period[5] != 0) {
	                newTime.setUTCMinutes(newTime.getUTCMinutes() + period[5]);
	            }

	            if (period[6] != 0) {
	                newTime.setUTCSeconds(newTime.getUTCSeconds() + period[6]);
	            }

	            return newTime;
	        };

	        // Intentionally not documented.
	        PeriodicTimeSequence.isLeapYear = function (year) {
	            return (((year % 4 === 0) && (year % 100 !== 0)) || (year % 400 === 0));
	        };

	        // Intentionally not documented.
	        PeriodicTimeSequence.getDaysInMonth = function (year, month) {
	            return [31, (PeriodicTimeSequence.isLeapYear(year) ? 29 : 28), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month];
	        };

	        // Intentionally not documented.
	        PeriodicTimeSequence.addMonths = function (date, numMonths) {
	            var n = date.getUTCDate();
	            date.setUTCDate(1);
	            date.setUTCMonth(date.getUTCMonth() + numMonths);
	            date.setUTCDate(Math.min(n, PeriodicTimeSequence.getDaysInMonth(date.getUTCFullYear(), date.getUTCMonth())));
	            return date;
	        };

	        /*
	         * Parses a ISO8601 period string.
	         * @param {String} period iso8601 period string
	         * @param {Boolean} distributeOverflow if 'true', the unit overflows are merge into the next higher units.
	         */
	        PeriodicTimeSequence.parsePeriodString = function (period, distributeOverflow) {
	            // Taken from https://github.com/nezasa/iso8601-js-period/blob/master/iso8601.js

	            // regex splits as follows
	            // grp0 omitted as it is equal to the sample
	            //
	            // | sample            | grp1   | grp2 | grp3 | grp4 | grp5 | grp6       | grp7 | grp8 | grp9 |
	            // --------------------------------------------------------------------------------------------
	            // | P1Y2M3W           | 1Y2M3W | 1Y   | 2M   | 3W   | 4D   | T12H30M17S | 12H  | 30M  | 17S  |
	            // | P3Y6M4DT12H30M17S | 3Y6M4D | 3Y   | 6M   |      | 4D   | T12H30M17S | 12H  | 30M  | 17S  |
	            // | P1M               | 1M     |      | 1M   |      |      |            |      |      |      |
	            // | PT1M              | 3Y6M4D |      |      |      |      | T1M        |      | 1M   |      |
	            // --------------------------------------------------------------------------------------------

	            var _distributeOverflow = (distributeOverflow) ? distributeOverflow : false;
	            var valueIndexes = [2, 3, 4, 5, 7, 8, 9];
	            var duration = [0, 0, 0, 0, 0, 0, 0];
	            var overflowLimits = [0, 12, 4, 7, 24, 60, 60];
	            var struct;

	            // upcase the string just in case people don't follow the letter of the law
	            period = period.toUpperCase();

	            // input validation
	            if (!period)
	                return duration;
	            else if (typeof period !== "string") {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "PeriodicTimeSequence", "parsePeriodString",
	                        "Invalid ISO8601 period string '" + period + "'"));
	            }

	            // parse the string
	            if (struct = /^P((\d+Y)?(\d+M)?(\d+W)?(\d+D)?)?(T(\d+H)?(\d+M)?(\d+S)?)?$/.exec(period)) {

	                // remove letters, replace by 0 if not defined
	                for (var i = 0; i < valueIndexes.length; i++) {
	                    var structIndex = valueIndexes[i];
	                    duration[i] = struct[structIndex] ? +struct[structIndex].replace(/[A-Za-z]+/g, '') : 0;
	                }
	            }
	            else {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "PeriodicTimeSequence", "parsePeriodString",
	                        "String '" + period + "' is not a valid ISO8601 period."));
	            }

	            if (_distributeOverflow) {
	                // note: stop at 1 to ignore overflow of years
	                for (i = duration.length - 1; i > 0; i--) {
	                    if (duration[i] >= overflowLimits[i]) {
	                        duration[i - 1] = duration[i - 1] + Math.floor(duration[i] / overflowLimits[i]);
	                        duration[i] = duration[i] % overflowLimits[i];
	                    }
	                }
	            }

	            return duration;
	        };

	        return PeriodicTimeSequence;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
	;

/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports WcsEarthElevationModel
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(28),
	        __webpack_require__(75),
	        __webpack_require__(97),
	        __webpack_require__(221)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Location,
	              Sector,
	              ElevationModel,
	              WcsTileUrlBuilder) {
	        "use strict";

	        /**
	         * Constructs an Earth elevation model.
	         * @alias WcsEarthElevationModel
	         * @constructor
	         * @augments ElevationModel
	         * @classdesc Provides elevations for Earth. Elevations are drawn from the NASA World Wind elevation service.
	         */
	        var WcsEarthElevationModel = function () {
	            ElevationModel.call(this,
	                Sector.FULL_SPHERE, new Location(45, 45), 12, "image/tiff", "EarthElevations256", 256, 256);

	            this.displayName = "WCS Earth Elevation Model";
	            this.minElevation = -11000; // Depth of Marianas Trench, in meters
	            this.maxElevation = 8850; // Height of Mt. Everest
	            this.pixelIsPoint = false; // World Wind WMS elevation layers return pixel-as-area images

	            this.urlBuilder = new WcsTileUrlBuilder("https://worldwind26.arc.nasa.gov/wms2",
	                "NASA_SRTM30_900m_Tiled", "1.0.0");
	        };

	        WcsEarthElevationModel.prototype = Object.create(ElevationModel.prototype);

	        return WcsEarthElevationModel;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports WcsTileUrlBuilder
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(30),
	        __webpack_require__(32)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
	              Logger) {
	        "use strict";

	        /**
	         * Constructs a WCS tile URL builder.
	         * @alias WcsTileUrlBuilder
	         * @constructor
	         * @classdesc Provides a factory to create URLs for WCS Get Coverage requests.
	         * @param {String} serviceAddress The address of the WCS server.
	         * @param {String} coverageName The name of the coverage to retrieve.
	         * @param {String} wcsVersion The version of the WCS server. May be null, in which case version 1.0.0 is
	         * assumed.
	         * @constructor
	         */
	        var WcsTileUrlBuilder = function (serviceAddress, coverageName, wcsVersion) {
	            if (!serviceAddress || (serviceAddress.length === 0)) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "WcsTileUrlBuilder", "constructor",
	                        "The WCS service address is missing."));
	            }

	            if (!coverageName || (coverageName.length === 0)) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "WcsTileUrlBuilder", "constructor",
	                        "The WCS coverage name is missing."));
	            }

	            /**
	             * The address of the WCS server.
	             * @type {String}
	             */
	            this.serviceAddress = serviceAddress;

	            /**
	             * The name of the coverage to retrieve.
	             * @type {String}
	             */
	            this.coverageName = coverageName;

	            /**
	             * The WCS version to specify when requesting resources.
	             * @type {String}
	             * @default 1.0.0
	             */
	            this.wcsVersion = (wcsVersion && wcsVersion.length > 0) ? wcsVersion : "1.0.0";

	            /**
	             * The coordinate reference system to use when requesting coverages.
	             * @type {String}
	             * @default EPSG:4326
	             */
	            this.crs = "EPSG:4326";
	        };

	        /**
	         * Creates the URL string for a WCS Get Coverage request.
	         * @param {Tile} tile The tile for which to create the URL.
	         * @param {String} coverageFormat The coverage format to request.
	         * @throws {ArgumentError} If the specified tile or coverage format are null or undefined.
	         */
	        WcsTileUrlBuilder.prototype.urlForTile = function (tile, coverageFormat) {

	            if (!tile) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "WcsUrlBuilder", "urlForTile", "missingTile"));
	            }

	            if (!coverageFormat) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "WcsUrlBuilder", "urlForTile",
	                        "The coverage format is null or undefined."));
	            }

	            var sector = tile.sector;

	            var sb = WcsTileUrlBuilder.fixGetCoverageString(this.serviceAddress);

	            if (sb.search(/service=wcs/i) < 0) {
	                sb = sb + "service=WCS";
	            }

	            sb = sb + "&request=GetCoverage";
	            sb = sb + "&version=" + this.wcsVersion;
	            sb = sb + "&coverage=" + this.coverageName;
	            sb = sb + "&format=" + coverageFormat;
	            sb = sb + "&width=" + tile.tileWidth;
	            sb = sb + "&height=" + tile.tileHeight;

	            sb = sb + "&crs=" + this.crs;
	            sb = sb + "&bbox=";
	            sb = sb + sector.minLongitude + "," + sector.minLatitude + ",";
	            sb = sb + sector.maxLongitude + "," +sector. maxLatitude;

	            sb = sb.replace(" ", "%20");

	            return sb;
	        };

	        // Intentionally not documented.
	        WcsTileUrlBuilder.fixGetCoverageString = function (serviceAddress) {
	            if (!serviceAddress) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "WcsTileUrlBuilder", "fixGetCoverageString",
	                        "The specified service address is null or undefined."));
	            }

	            var index = serviceAddress.indexOf("?");

	            if (index < 0) { // if string contains no question mark
	                serviceAddress = serviceAddress + "?"; // add one
	            } else if (index !== serviceAddress.length - 1) { // else if question mark not at end of string
	                index = serviceAddress.search(/&$/);
	                if (index < 0) {
	                    serviceAddress = serviceAddress + "&"; // add a parameter separator
	                }
	            }

	            return serviceAddress;
	        };

	        return WcsTileUrlBuilder;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports EarthRestElevationModel
	 * @version $Id: EarthElevationModel.js 2638 2015-01-05 20:44:18Z tgaskins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(28),
	        __webpack_require__(75),
	        __webpack_require__(97),
	        __webpack_require__(223)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Location,
	              Sector,
	              ElevationModel,
	              LevelRowColumnUrlBuilder) {
	        "use strict";

	        // THIS CLASS IS NOT YET MEANT TO BE EXPOSED.
	        ///**
	        // * Constructs an elevation model for Earth using a REST interface to retrieve the elevations from the server.
	        // * @alias EarthRestElevationModel
	        // * @constructor
	        // * @classdesc Represents an Earth elevation model spanning the globe and using a REST interface to retrieve
	        // * the elevations from the server.
	        // * See [LevelRowColumnUrlBuilder]{@link LevelRowColumnUrlBuilder} for a description of the REST interface.
	        // * @param {String} serverAddress The server address of the tile service. May be null, in which case the
	        // * current origin is used (see <code>window.location</code>.
	        // * @param {String} pathToData The path to the data directory relative to the specified server address.
	        // * May be null, in which case the server address is assumed to be the full path to the data directory.
	        // * @param {String} displayName The display name to associate with this elevation model.
	        // */
	        var EarthRestElevationModel = function (serverAddress, pathToData, displayName) {
	            ElevationModel.call(this,
	                Sector.FULL_SPHERE, new Location(60, 60), 5, "application/bil16", "EarthElevations", 512, 512);

	            this.displayName = displayName;
	            this.minElevation = -11000; // Depth of Marianas Trench, in meters
	            this.maxElevation = 8850; // Height of Mt. Everest
	            this.urlBuilder = new LevelRowColumnUrlBuilder(serverAddress, pathToData);
	        };

	        EarthRestElevationModel.prototype = Object.create(ElevationModel.prototype);

	        return EarthRestElevationModel;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports LevelRowColumnUrlBuilder
	 * @version $Id: LevelRowColumnUrlBuilder.js 2643 2015-01-09 20:37:58Z tgaskins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(30),
	        __webpack_require__(32),
	        __webpack_require__(83)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
	              Logger,
	              WWUtil) {
	        "use strict";

	        /**
	         * Constructs a URL builder for level/row/column tiles.
	         * @alias LevelRowColumnUrlBuilder
	         * @constructor
	         * @classdesc Provides a factory to create URLs for level/row/column tile REST requests.
	         * <p>
	         * URLs are formed by appending the specified server address with the specified path and appending
	         * a path of the form <em>/level/row/row_column.image-format</em>, where image-format is the corresponding
	         * suffix to the image mime type specified when a URL is requested. For example, if the specified server
	         * address is <em>http://worldwindserver.net/webworldwind</em> and the specified path-to-data is
	         * <em>../data/Earth/BMNG256</em>, and the requested tile's level, row and column are 0, 5 and 9 respectively,
	         * and the image format is <em>image/jpeg</em>, the composed URL is
	         * <em>http://worldwindserver.net/webworldwind/../data/Earth/BMNG256/0/5/5_9.jpg.
	         *
	         * @param {String} serverAddress The server address. May be null, in which case the address is assumed to be
	         * the current location (see <code>window.location</code>) minus the last path component.
	         * @param {String} pathToData The path to the dataset on the server. May be null or empty to indicate that
	         * the data is directly relative to the specified server address.
	         *
	         */
	        var LevelRowColumnUrlBuilder = function (serverAddress, pathToData) {
	            /**
	             * The server address.
	             * @type {String}
	             */
	            this.serverAddress = serverAddress;
	            if (!serverAddress || serverAddress.length === 0) {
	                this.serverAddress = WWUtil.currentUrlSansFilePart();
	            }

	            /**
	             * The server-side path to the dataset.
	             * @type {String}
	             */
	            this.pathToData = pathToData;
	        };

	        /**
	         * Creates the URL string for a WMS Get Map request.
	         * @param {Tile} tile The tile for which to create the URL.
	         * @param {String} imageFormat The image format to request.
	         * @throws {ArgumentError} If the specified tile or image format are null or undefined.
	         */
	        LevelRowColumnUrlBuilder.prototype.urlForTile = function (tile, imageFormat) {
	            if (!tile) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "WmsUrlBuilder", "urlForTile", "missingTile"));
	            }

	            if (!imageFormat) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "WmsUrlBuilder", "urlForTile",
	                        "The image format is null or undefined."));
	            }

	            var sb = this.serverAddress;

	            if (this.pathToData) {
	                sb = sb + "/" + this.pathToData;
	            }

	            sb = sb + "/" + tile.level.levelNumber.toString();
	            sb = sb + "/" + tile.row.toString();
	            sb = sb + "/" + tile.row.toString() + "_" + tile.column.toString();
	            sb = sb + "." + WWUtil.suffixForMimeType(imageFormat);

	            sb = sb.replace(" ", "%20");

	            return sb;
	        };

	        return LevelRowColumnUrlBuilder;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

	var ElevationModel = __webpack_require__(97);
	var Sector = __webpack_require__(75);
	var Location = __webpack_require__(28);
	var WcsTileUrlBuilder = __webpack_require__(221);
	var WmsUrlBuilder = __webpack_require__(111);
	var LevelRowColumnUrlBuilder = __webpack_require__(223);

	var CustomEarthElevationModel = function (parameters) {
	    var self = this;

	    this.parameters = parameters;
	    this.displayName = "Custom Earth Elevation Model ("+self.parameters.type+")";
	    this.minElevation = -11000; // Марианска впадина
	    this.maxElevation = 8850; // Эверест
	    this.pixelIsPoint = false;

	    var format = "image/tiff";

	    if ( self.parameters.type === "wcs"){
	        format = "image/tiff";
	        this.urlBuilder = new WcsTileUrlBuilder((!self.parameters.url || self.parameters.url === "*") ? "https://worldwind26.arc.nasa.gov/wms2":
	            self.parameters.url, (self.parameters.layers) ? self.parameters.layers :  "NASA_SRTM30_900m_Tiled", "1.0.0");
	    } else if ( self.parameters.type === "wms"){
	        format = "application/bil16";
	        this.urlBuilder = new WmsUrlBuilder((!self.parameters.url || self.parameters.url === "*") ? "https://worldwind26.arc.nasa.gov/elev":
	            self.parameters.url, (self.parameters.layers) ? self.parameters.layers :  "GEBCO,aster_v2,USGS-NED", "", "1.3.0");
	    }

	    ElevationModel.call(this,
	        Sector.FULL_SPHERE, new Location(45, 45), 12, format, "EarthElevations256", 256, 256);
	};

	CustomEarthElevationModel.prototype = Object.create(ElevationModel.prototype);

	module.exports = CustomEarthElevationModel;

/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports GeoTiffReader
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(31),
	        __webpack_require__(30),
	        __webpack_require__(226),
	        __webpack_require__(227),
	        __webpack_require__(228),
	        __webpack_require__(229),
	        __webpack_require__(28),
	        __webpack_require__(75),
	        __webpack_require__(32),
	        __webpack_require__(231),
	        __webpack_require__(230),
	        __webpack_require__(232),
	        __webpack_require__(83)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (AbstractError,
	              ArgumentError,
	              GeoTiffConstants,
	              GeoTiffKeyEntry,
	              GeoTiffMetadata,
	              GeoTiffUtil,
	              Location,
	              Sector,
	              Logger,
	              Proj4,
	              TiffConstants,
	              TiffIFDEntry,
	              WWUtil) {
	        "use strict";

	        /**
	         * Constructs a geotiff reader object for a specified geotiff URL.
	         * Call [readAsImage]{@link GeoTiffReader#readAsImage} to retrieve the image as a canvas or
	         * [readAsData]{@link GeoTiffReader#readAsData} to retrieve the elevations as an array of elevation values.
	         * @alias GeoTiffReader
	         * @constructor
	         * @classdesc Parses a geotiff and creates an image or an elevation array representing its contents.
	         * @param {String} url The location of the geotiff.
	         * @throws {ArgumentError} If the specified URL is null or undefined.
	         */
	        var GeoTiffReader = function (url) {
	            if (!url) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "GeoTiffReader", "constructor", "missingUrl"));
	            }

	            // Documented in defineProperties below.
	            this._url = url;

	            // Documented in defineProperties below.
	            this._isLittleEndian = false;

	            // Documented in defineProperties below.
	            this._imageFileDirectories = [];

	            // Documented in defineProperties below.
	            this._geoTiffData = null;

	            // Documented in defineProperties below.
	            this._metadata = new GeoTiffMetadata();
	        };

	        Object.defineProperties(GeoTiffReader.prototype, {

	            /**
	             * The geotiff URL as specified to this GeoTiffReader's constructor.
	             * @memberof GeoTiffReader.prototype
	             * @type {String}
	             * @readonly
	             */
	            url: {
	                get: function () {
	                    return this._url;
	                }
	            },

	            /**
	             *Indicates whether the geotiff byte order is little endian..
	             * @memberof GeoTiffReader.prototype
	             * @type {Boolean}
	             * @readonly
	             */
	            isLittleEndian: {
	                get: function () {
	                    return this._isLittleEndian;
	                }
	            },

	            /**
	             * An array containing all the image file directories of the geotiff file.
	             * @memberof GeoTiffReader.prototype
	             * @type {TiffIFDEntry[]}
	             * @readonly
	             */
	            imageFileDirectories: {
	                get: function () {
	                    return this._imageFileDirectories;
	                }
	            },

	            /**
	             * The buffer descriptor of the geotiff file's content.
	             * @memberof GeoTiffReader.prototype
	             * @type {ArrayBuffer}
	             * @readonly
	             */
	            geoTiffData: {
	                get: function () {
	                    return this._geoTiffData;
	                }
	            },

	            /**
	             * An objct containing all tiff and geotiff metadata of the geotiff file.
	             * @memberof GeoTiffReader.prototype
	             * @type {GeoTiffMetadata}
	             * @readonly
	             */
	            metadata: {
	                get: function () {
	                    return this._metadata;
	                }
	            }
	        });

	        // Get geotiff file as an array buffer using XMLHttpRequest. Internal use only.
	        GeoTiffReader.prototype.requestUrl = function (url, callback) {
	            var xhr = new XMLHttpRequest();

	            xhr.open("GET", url, true);
	            xhr.responseType = 'arraybuffer';
	            xhr.onreadystatechange = (function () {
	                if (xhr.readyState === 4) {
	                    if (xhr.status === 200) {
	                        var arrayBuffer = xhr.response;
	                        if (arrayBuffer) {
	                            this.parse(arrayBuffer);
	                            callback();
	                        }
	                    }
	                    else {
	                        Logger.log(Logger.LEVEL_WARNING,
	                            "GeoTiff retrieval failed (" + xhr.statusText + "): " + url);
	                    }
	                }
	            }).bind(this);

	            xhr.onerror = function () {
	                Logger.log(Logger.LEVEL_WARNING, "GeoTiff retrieval failed: " + url);
	            };

	            xhr.ontimeout = function () {
	                Logger.log(Logger.LEVEL_WARNING, "GeoTiff retrieval timed out: " + url);
	            };

	            xhr.send(null);
	        };

	        // Parse geotiff file. Internal use only
	        GeoTiffReader.prototype.parse = function (arrayBuffer) {
	            this._geoTiffData = new DataView(arrayBuffer);
	            this.getEndianness();

	            if (!this.isTiffFileType()) {
	                throw new AbstractError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "GeoTiffReader", "parse", "invalidTiffFileType"));
	            }

	            var firstIFDOffset = GeoTiffUtil.getBytes(this.geoTiffData, 4, 4, this.isLittleEndian);

	            this.parseImageFileDirectory(firstIFDOffset);
	            this.getMetadataFromImageFileDirectory();
	            this.parseGeoKeys();
	            this.setBBox();
	        };

	        // Get byte order of the geotiff file. Internal use only.
	        GeoTiffReader.prototype.getEndianness = function () {
	            var byteOrderValue = GeoTiffUtil.getBytes(this.geoTiffData, 0, 2, this.isLittleEndian);
	            if (byteOrderValue === 0x4949) {
	                this._isLittleEndian = true;
	            }
	            else if (byteOrderValue === 0x4D4D) {
	                this._isLittleEndian = false;
	            }
	            else {
	                throw new AbstractError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "GeoTiffReader", "getEndianness", "invalidByteOrderValue"));
	            }
	        };

	        /**
	         * Indicates whether this geotiff is a tiff file type.
	         *
	         * @return {Boolean} True if this geotiff file is a tiff file type.
	         */
	        GeoTiffReader.prototype.isTiffFileType = function () {
	            var fileTypeValue = GeoTiffUtil.getBytes(this.geoTiffData, 2, 2, this.isLittleEndian);
	            if (fileTypeValue === 42) {
	                return true;
	            }
	            else {
	                return false;
	            }
	        };

	        /**
	         * Indicates whether this geotiff is a geotiff file type.
	         *
	         * @return {Boolean} True if this geotiff file is a geotiff file type.
	         */
	        GeoTiffReader.prototype.isGeoTiff = function () {
	            if (this.getIFDByTag(GeoTiffConstants.Tag.GEO_KEY_DIRECTORY)) {
	                return true;
	            }
	            else {
	                return false;
	            }
	        };

	        /**
	         * Retrieves the GeoTiff file, parses it and creates a canvas of its content. The canvas is passed
	         * to the callback function as a parameter.
	         *
	         * @param {Function} callback A function called when GeoTiff parsing is complete.
	         */
	        GeoTiffReader.prototype.readAsImage = function (callback) {
	            this.requestUrl(this.url, (function () {
	                var bitsPerSample = this.metadata.bitsPerSample;
	                var samplesPerPixel = this.metadata.samplesPerPixel;
	                var photometricInterpretation = this.metadata.photometricInterpretation;
	                var imageLength = this.metadata.imageLength;
	                var imageWidth = this.metadata.imageWidth;

	                if (this.metadata.colorMap) {
	                    var colorMapValues = this.metadata.colorMap;
	                    var colorMapSampleSize = Math.pow(2, bitsPerSample[0]);
	                }

	                var canvas = document.createElement('canvas');
	                canvas.width = imageWidth;
	                canvas.height = imageLength;
	                var ctx = canvas.getContext("2d");

	                if (this.metadata.stripOffsets) {
	                    var strips = this.parseStrips(false);
	                    if (this.metadata.rowsPerStrip) {
	                        var rowsPerStrip = this.metadata.rowsPerStrip;
	                    } else {
	                        var rowsPerStrip = imageLength;
	                    }
	                    var numOfStrips = strips.length;
	                    var numRowsInPreviousStrip = 0;
	                    var numRowsInStrip = rowsPerStrip;
	                    var imageLengthModRowsPerStrip = imageLength % rowsPerStrip;
	                    var rowsInLastStrip = (imageLengthModRowsPerStrip === 0) ? rowsPerStrip :
	                        imageLengthModRowsPerStrip;

	                    for (var i = 0; i < numOfStrips; i++) {
	                        if ((i + 1) === numOfStrips) {
	                            numRowsInStrip = rowsInLastStrip;
	                        }

	                        var numOfPixels = strips[i].length;
	                        var yPadding = numRowsInPreviousStrip * i;

	                        for (var y = 0, j = 0; y < numRowsInStrip, j < numOfPixels; y++) {
	                            for (var x = 0; x < imageWidth; x++, j++) {
	                                var pixelSamples = strips[i][j];

	                                ctx.fillStyle = this.getFillStyle(
	                                    pixelSamples,
	                                    photometricInterpretation,
	                                    bitsPerSample,
	                                    samplesPerPixel,
	                                    colorMapValues,
	                                    colorMapSampleSize
	                                );
	                                ctx.fillRect(x, yPadding + y, 1, 1);
	                            }
	                        }
	                        numRowsInPreviousStrip = rowsPerStrip;
	                    }
	                }
	                else if (this.metadata.tileOffsets) {
	                    var tiles = this.parseTiles(false);
	                    var tileWidth = this.metadata.tileWidth;
	                    var tileLength = this.metadata.tileLength;
	                    var tilesAcross = Math.ceil(imageWidth / tileWidth);

	                    for (var y = 0; y < imageLength; y++) {
	                        for (var x = 0; x < imageWidth; x++) {
	                            var tileAcross = Math.floor(x / tileWidth);
	                            var tileDown = Math.floor(y / tileLength);
	                            var tileIndex = tileDown * tilesAcross + tileAcross;
	                            var xInTile = x % tileWidth;
	                            var yInTile = y % tileLength;
	                            var sampleIndex = yInTile * tileWidth + xInTile;
	                            var pixelSamples = tiles[tileIndex][sampleIndex];
	                            ctx.fillStyle = this.getFillStyle(
	                                pixelSamples,
	                                photometricInterpretation,
	                                bitsPerSample,
	                                samplesPerPixel,
	                                colorMapValues,
	                                colorMapSampleSize
	                            );
	                            ctx.fillRect(x, y, 1, 1);
	                        }
	                    }
	                }

	                this._geoTiffData = null;
	                callback(canvas);
	            }).bind(this));
	        };

	        // Get pixel fill style. Internal use only.
	        GeoTiffReader.prototype.getFillStyle = function (pixelSamples, photometricInterpretation, bitsPerSample,
	                                                         samplesPerPixel, colorMapValues, colorMapSampleSize) {
	            var red = 0.0;
	            var green = 0.0;
	            var blue = 0.0;
	            var opacity = 1.0;

	            if (this.metadata.noData && pixelSamples[0] == this.metadata.noData) {
	                opacity = 0.0;
	            }

	            switch (photometricInterpretation) {
	                case TiffConstants.PhotometricInterpretation.WHITE_IS_ZERO:
	                    var invertValue = Math.pow(2, bitsPerSample) - 1;
	                    pixelSamples[0] = invertValue - pixelSamples[0];
	                case TiffConstants.PhotometricInterpretation.BLACK_IS_ZERO:
	                    red = green = blue = GeoTiffUtil.clampColorSample(
	                        pixelSamples[0],
	                        bitsPerSample[0]);
	                    break;
	                case TiffConstants.PhotometricInterpretation.RGB:
	                    red = GeoTiffUtil.clampColorSample(pixelSamples[0], bitsPerSample[0]);
	                    green = GeoTiffUtil.clampColorSample(pixelSamples[1], bitsPerSample[1]);
	                    blue = GeoTiffUtil.clampColorSample(pixelSamples[2], bitsPerSample[2]);

	                    if (samplesPerPixel === 4 && this.metadata.extraSamples[0] === 2) {
	                        var maxValue = Math.pow(2, bitsPerSample[3]);
	                        opacity = pixelSamples[3] / maxValue;
	                    }
	                    break;
	                case TiffConstants.PhotometricInterpretation.RGB_PALETTE:
	                    if (colorMapValues) {
	                        var colorMapIndex = pixelSamples[0];

	                        red = GeoTiffUtil.clampColorSample(
	                            colorMapValues[colorMapIndex],
	                            16);
	                        green = GeoTiffUtil.clampColorSample(
	                            colorMapValues[colorMapSampleSize + colorMapIndex],
	                            16);
	                        blue = GeoTiffUtil.clampColorSample(
	                            colorMapValues[(2 * colorMapSampleSize) + colorMapIndex],
	                            16);
	                    }
	                    break;
	                case TiffConstants.PhotometricInterpretation.TRANSPARENCY_MASK:
	                    //todo
	                    Logger.log(Logger.LEVEL_WARNING, "Photometric interpretation not yet implemented: " +
	                        "TRANSPARENCY_MASK");
	                    break;
	                case TiffConstants.PhotometricInterpretation.CMYK:
	                    //todo
	                    Logger.log(Logger.LEVEL_WARNING, "Photometric interpretation not yet implemented: CMYK");
	                    break;
	                case TiffConstants.PhotometricInterpretation.Y_Cb_Cr:
	                    //todo
	                    Logger.log(Logger.LEVEL_WARNING, "Photometric interpretation not yet implemented: Y_Cb_Cr");
	                    break;
	                case TiffConstants.PhotometricInterpretation.CIE_LAB:
	                    //todo
	                    Logger.log(Logger.LEVEL_WARNING, "Photometric interpretation not yet implemented: CIE_LAB");
	                    break;
	                default:
	                    //todo
	                    Logger.log("Unknown photometric interpretation: " + photometricInterpretation);
	                    break;
	            }

	            return GeoTiffUtil.getRGBAFillValue(red, green, blue, opacity);
	        }

	        GeoTiffReader.prototype.createTypedElevationArray = function () {
	            var elevationArray = [], typedElevationArray;
	            var bitsPerSample = this.metadata.bitsPerSample[0];

	            if (this.metadata.stripOffsets) {
	                var strips = this.parseStrips(true);

	                for (var i = 0; i < strips.length; i++) {
	                    elevationArray = elevationArray.concat(strips[i]);
	                }
	            }
	            else if (this.metadata.tileOffsets) {
	                var tiles = this.parseTiles(true);
	                var imageWidth = this.metadata.imageWidth;
	                var imageLength = this.metadata.imageLength;
	                var tileWidth = this.metadata.tileWidth;
	                var tileLength = this.metadata.tileLength;
	                var tilesAcross = Math.ceil(imageWidth / tileWidth);

	                for (var y = 0; y < imageLength; y++) {
	                    for (var x = 0; x < imageWidth; x++) {
	                        var tileAcross = Math.floor(x / tileWidth);
	                        var tileDown = Math.floor(y / tileLength);
	                        var tileIndex = tileDown * tilesAcross + tileAcross;
	                        var xInTile = x % tileWidth;
	                        var yInTile = y % tileLength;
	                        var sampleIndex = yInTile * tileWidth + xInTile;
	                        var pixelSamples = tiles[tileIndex][sampleIndex];
	                        elevationArray.push(pixelSamples);//todo de 0??? servet
	                    }
	                }
	            }

	            if (this.metadata.sampleFormat) {
	                var sampleFormat = this.metadata.sampleFormat[0];
	            }
	            else {
	                var sampleFormat = TiffConstants.SampleFormat.UNSIGNED;
	            }

	            switch (bitsPerSample) {
	                case 8:
	                    if (sampleFormat === TiffConstants.SampleFormat.SIGNED) {
	                        typedElevationArray = new Int8Array(elevationArray);
	                    }
	                    else {
	                        typedElevationArray = new Uint8Array(elevationArray);
	                    }
	                    break
	                case 16:
	                    if (sampleFormat === TiffConstants.SampleFormat.SIGNED) {
	                        typedElevationArray = new Int16Array(elevationArray);
	                    }
	                    else {
	                        typedElevationArray = new Uint16Array(elevationArray);
	                    }
	                    break;
	                case 32:
	                    if (sampleFormat === TiffConstants.SampleFormat.SIGNED) {
	                        typedElevationArray = new Int32Array(elevationArray);
	                    }
	                    else if (sampleFormat === TiffConstants.SampleFormat.IEEE_FLOAT) {
	                        typedElevationArray = new Float32Array(elevationArray);
	                    }
	                    else {
	                        typedElevationArray = new Uint32Array(elevationArray);
	                    }
	                    break;
	                case 64:
	                    typedElevationArray = new Float64Array(elevationArray);
	                    break;
	                default:
	                    break;
	            }

	            return typedElevationArray;
	        }

	        /**
	         * Retrieves the GeoTiff file, parses it and creates a typed array of its content. The array is passed
	         * to the callback function as a parameter.
	         *
	         * @param {Function} callback A function called when GeoTiff parsing is complete.
	         */
	        GeoTiffReader.prototype.readAsData = function (callback) {
	            this.requestUrl(this.url, (function () {
	                callback(
	                    this.createTypedElevationArray()
	                );
	            }).bind(this));
	        };

	        // Parse geotiff strips. Internal use only
	        GeoTiffReader.prototype.parseStrips = function (returnElevation) {
	            var samplesPerPixel = this.metadata.samplesPerPixel;
	            var bitsPerSample = this.metadata.bitsPerSample;
	            var stripOffsets = this.metadata.stripOffsets;
	            var stripByteCounts = this.metadata.stripByteCounts;
	            var compression = this.metadata.compression;
	            if (this.metadata.sampleFormat) {
	                var sampleFormat = this.metadata.sampleFormat;
	            }
	            else {
	                var sampleFormat = TiffConstants.SampleFormat.UNSIGNED;
	            }

	            var bitsPerPixel = samplesPerPixel * bitsPerSample[0];
	            var bytesPerPixel = bitsPerPixel / 8;

	            var strips = [];
	            // Loop through strips
	            for (var i = 0; i < stripOffsets.length; i++) {
	                var stripOffset = stripOffsets[i];
	                var stripByteCount = stripByteCounts[i];

	                strips[i] = this.parseBlock(returnElevation, compression, bytesPerPixel, stripByteCount, stripOffset,
	                    bitsPerSample, sampleFormat);
	            }

	            return strips;
	        }

	        // Parse geotiff block. A block may be a strip or a tile. Internal use only.
	        GeoTiffReader.prototype.parseBlock = function (returnElevation, compression, bytesPerPixel, blockByteCount,
	                                                       blockOffset, bitsPerSample, sampleFormat) {
	            var block = [];
	            switch (compression) {
	                case TiffConstants.Compression.UNCOMPRESSED:
	                    // Loop through pixels.
	                    for (var byteOffset = 0, increment = bytesPerPixel;
	                         byteOffset < blockByteCount; byteOffset += increment) {
	                        // Loop through samples (sub-pixels).
	                        for (var m = 0, pixel = []; m < bitsPerSample.length; m++) {
	                            var bytesPerSample = bitsPerSample[m] / 8;
	                            var sampleOffset = m * bytesPerSample;

	                            pixel.push(GeoTiffUtil.getSampleBytes(
	                                this.geoTiffData,
	                                blockOffset + byteOffset + sampleOffset,
	                                bytesPerSample,
	                                sampleFormat[m],
	                                this.isLittleEndian));
	                        }
	                        if (returnElevation) {
	                            block.push(pixel[0]);
	                        }
	                        else {
	                            block.push(pixel);
	                        }
	                    }
	                    break;
	                case TiffConstants.Compression.CCITT_1D:
	                    //todo
	                    Logger.log(Logger.LEVEL_WARNING, "Compression type not yet implemented: CCITT_1D");
	                    break;
	                case TiffConstants.Compression.GROUP_3_FAX:
	                    //todo
	                    Logger.log(Logger.LEVEL_WARNING, "Compression type not yet implemented: GROUP_3_FAX");
	                    break;
	                case TiffConstants.Compression.GROUP_4_FAX:
	                    //todo
	                    Logger.log(Logger.LEVEL_WARNING, "Compression type not yet implemented: GROUP_4_FAX");
	                    break;
	                case TiffConstants.Compression.LZW:
	                    //todo
	                    Logger.log(Logger.LEVEL_WARNING, "Compression type not yet implemented: LZW");
	                    break;
	                case TiffConstants.Compression.JPEG:
	                    //todo
	                    Logger.log(Logger.LEVEL_WARNING, "Compression type not yet implemented: JPEG");
	                    break;
	                case TiffConstants.Compression.PACK_BITS:
	                    if (this.metadata.tileOffsets) {
	                        var tileWidth = this.metadata.tileWidth;
	                        var tileLength = this.metadata.tileWidth;
	                        var arrayBuffer = new ArrayBuffer(tileWidth * tileLength * bytesPerPixel);
	                    }
	                    else {
	                        var rowsPerStrip = this.metadata.rowsPerStrip;
	                        var imageWidth = this.metadata.imageWidth;
	                        var arrayBuffer = new ArrayBuffer(rowsPerStrip * imageWidth * bytesPerPixel);
	                    }

	                    var uncompressedDataView = new DataView(arrayBuffer);

	                    var newBlock = true;
	                    var pixel = [];
	                    var blockLength = 0;
	                    var numOfIterations = 0;
	                    var uncompressedOffset = 0;


	                    for (var byteOffset = 0; byteOffset < blockByteCount; byteOffset += 1) {

	                        if (newBlock) {
	                            blockLength = 1;
	                            numOfIterations = 1;
	                            newBlock = false;

	                            var nextSourceByte = this.geoTiffData.getInt8(blockOffset + byteOffset,
	                                this.isLittleEndian);

	                            if (nextSourceByte >= 0 && nextSourceByte <= 127) {
	                                blockLength = nextSourceByte + 1;
	                            }
	                            else if (nextSourceByte >= -127 && nextSourceByte <= -1) {
	                                numOfIterations = -nextSourceByte + 1;
	                            }
	                            else {
	                                newBlock = true;
	                            }
	                        }
	                        else {
	                            var currentByte = GeoTiffUtil.getBytes(
	                                this.geoTiffData,
	                                blockOffset + byteOffset,
	                                1,
	                                this.isLittleEndian);

	                            for (var currentIteration = 0; currentIteration < numOfIterations; currentIteration++) {
	                                uncompressedDataView.setInt8(uncompressedOffset, currentByte);
	                                uncompressedOffset++;
	                            }

	                            blockLength--;

	                            if (blockLength === 0) {
	                                newBlock = true;
	                            }
	                        }
	                    }

	                    for (var byteOffset = 0, increment = bytesPerPixel;
	                         byteOffset < arrayBuffer.byteLength; byteOffset += increment) {
	                        // Loop through samples (sub-pixels).
	                        for (var m = 0, pixel = []; m < bitsPerSample.length; m++) {
	                            var bytesPerSample = bitsPerSample[m] / 8;
	                            var sampleOffset = m * bytesPerSample;

	                            pixel.push(GeoTiffUtil.getSampleBytes(
	                                uncompressedDataView,
	                                byteOffset + sampleOffset,
	                                bytesPerSample,
	                                sampleFormat[m],
	                                this.isLittleEndian));
	                        }
	                        if (returnElevation) {
	                            block.push(pixel[0]);
	                        }
	                        else {
	                            block.push(pixel);
	                        }
	                    }
	                    break;
	            }

	            return block;
	        }

	        // Parse geotiff tiles. Internal use only
	        GeoTiffReader.prototype.parseTiles = function (returnElevation) {
	            var samplesPerPixel = this.metadata.samplesPerPixel;
	            var bitsPerSample = this.metadata.bitsPerSample;
	            var compression = this.metadata.compression;
	            if (this.metadata.sampleFormat) {
	                var sampleFormat = this.metadata.sampleFormat;
	            }
	            else {
	                var sampleFormat = new Array(samplesPerPixel);
	                WWUtil.fillArray(sampleFormat, TiffConstants.SampleFormat.UNSIGNED);
	            }
	            var bitsPerPixel = samplesPerPixel * bitsPerSample[0];
	            var bytesPerPixel = bitsPerPixel / 8;
	            var tileWidth = this.metadata.tileWidth;
	            var tileLength = this.metadata.tileLength;
	            var tileOffsets = this.metadata.tileOffsets;
	            var tileByteCounts = this.metadata.tileByteCounts;
	            var imageLength = this.metadata.imageLength;
	            var imageWidth = this.metadata.imageWidth;

	            var tilesAcross = Math.ceil(imageWidth / tileWidth);
	            var tilesDown = Math.ceil(imageLength / tileLength);

	            var tiles = [];

	            for (var i = 0; i < tilesDown; i++) {
	                for (var j = 0; j < tilesAcross; j++) {
	                    var index = tilesAcross * i + j;
	                    var tileOffset = tileOffsets[index];
	                    var tileByteCount = tileByteCounts[index];
	                    tiles[index] = this.parseBlock(returnElevation, compression, bytesPerPixel, tileByteCount,
	                        tileOffset, bitsPerSample, sampleFormat);
	                }
	            }

	            return tiles;
	        }

	        // Translate a pixel/line coordinates to projection coordinate. Internal use only.
	        GeoTiffReader.prototype.geoTiffImageToPCS = function (xValue, yValue) {
	            if (xValue === null || xValue === undefined) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "GeoTiffReader", "geoTiffImageToPCS", "missingXValue"));
	            }
	            if (yValue === null || yValue === undefined) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "GeoTiffReader", "geoTiffImageToPCS", "missingYValue"));
	            }

	            var res = [xValue, yValue];

	            var tiePointValues = this.metadata.modelTiepoint;
	            var modelPixelScaleValues = this.metadata.modelPixelScale;
	            var modelTransformationValues = this.metadata.modelTransformation;

	            var tiePointCount = tiePointValues ? tiePointValues.length : 0;
	            var modelPixelScaleCount = modelPixelScaleValues ? modelPixelScaleValues.length : 0;
	            var modelTransformationCount = modelTransformationValues ? modelTransformationValues.length : 0;

	            if (tiePointCount > 6 && modelPixelScaleCount === 0) {
	                //todo
	            }
	            else if (modelTransformationCount === 16) {
	                var x_in = xValue;
	                var y_in = yValue;

	                xValue = x_in * modelTransformationValues[0] + y_in * modelTransformationValues[1] +
	                    modelTransformationValues[3];
	                yValue = x_in * modelTransformationValues[4] + y_in * modelTransformationValues[5] +
	                    modelTransformationValues[7];

	                res = [xValue, yValue];
	            }
	            else if (modelPixelScaleCount < 3 || tiePointCount < 6) {
	                res = [xValue, yValue];
	            }
	            else {
	                xValue = (xValue - tiePointValues[0]) * modelPixelScaleValues[0] + tiePointValues[3];
	                yValue = (yValue - tiePointValues[1]) * (-1 * modelPixelScaleValues[1]) + tiePointValues[4];

	                res = [xValue, yValue];
	            }

	            Proj4.defs([
	                [
	                    'EPSG:26771',
	                    '+proj=tmerc +lat_0=36.66666666666666 +lon_0=-88.33333333333333 +k=0.9999749999999999 +' +
	                    'x_0=152400.3048006096 +y_0=0 +ellps=clrk66 +datum=NAD27 +to_meter=0.3048006096012192 +no_defs '
	                ],
	                [
	                    'EPSG:32633',
	                    '+proj=utm +zone=33 +datum=WGS84 +units=m +no_defs'
	                ]
	            ]);

	            if (this.metadata.projectedCSType) {
	                res = Proj4('EPSG:' + this.metadata.projectedCSType, 'EPSG:4326', res);
	            }

	            return new Location(res[1], res[0]);
	        };

	        /**
	         * Set the bounding box of the geotiff file. Internal use only.
	         */
	        GeoTiffReader.prototype.setBBox = function () {
	            var upperLeft = this.geoTiffImageToPCS(0, 0);
	            var upperRight = this.geoTiffImageToPCS(this.metadata.imageWidth, 0);
	            var lowerLeft = this.geoTiffImageToPCS(0, this.metadata.imageLength);
	            var lowerRight = this.geoTiffImageToPCS(
	                this.metadata.imageWidth, this.metadata.imageLength);

	            this.metadata.bbox = new Sector(
	                lowerLeft.latitude,
	                upperLeft.latitude,
	                upperLeft.longitude,
	                upperRight.longitude
	            );
	        }

	        // Get metadata from image file directory. Internal use only.
	        GeoTiffReader.prototype.getMetadataFromImageFileDirectory = function () {
	            for (var i = 0; i < this.imageFileDirectories[0].length; i++) {

	                switch (this.imageFileDirectories[0][i].tag) {
	                    case TiffConstants.Tag.BITS_PER_SAMPLE:
	                        this.metadata.bitsPerSample = this.imageFileDirectories[0][i].getIFDEntryValue();
	                        break;
	                    case TiffConstants.Tag.COLOR_MAP:
	                        this.metadata.colorMap = this.imageFileDirectories[0][i].getIFDEntryValue();
	                        break;
	                    case TiffConstants.Tag.COMPRESSION:
	                        this.metadata.compression = this.imageFileDirectories[0][i].getIFDEntryValue()[0];
	                        break;
	                    case TiffConstants.Tag.EXTRA_SAMPLES:
	                        this.metadata.extraSamples = this.imageFileDirectories[0][i].getIFDEntryValue();
	                        break;
	                    case TiffConstants.Tag.IMAGE_LENGTH:
	                        this.metadata.imageLength = this.imageFileDirectories[0][i].getIFDEntryValue()[0];
	                        break;
	                    case TiffConstants.Tag.IMAGE_WIDTH:
	                        this.metadata.imageWidth = this.imageFileDirectories[0][i].getIFDEntryValue()[0];
	                        break;
	                    case TiffConstants.Tag.MAX_SAMPLE_VALUE:
	                        this.metadata.maxSampleValue = this.imageFileDirectories[0][i].getIFDEntryValue()[0];
	                        break;
	                    case TiffConstants.Tag.MIN_SAMPLE_VALUE:
	                        this.metadata.minSampleValue = this.imageFileDirectories[0][i].getIFDEntryValue()[0];
	                        break;
	                    case TiffConstants.Tag.ORIENTATION:
	                        this.metadata.orientation = this.imageFileDirectories[0][i].getIFDEntryValue()[0];
	                        break;
	                    case TiffConstants.Tag.PHOTOMETRIC_INTERPRETATION:
	                        this.metadata.photometricInterpretation = this.imageFileDirectories[0][i].getIFDEntryValue()[0];
	                        break;
	                    case TiffConstants.Tag.PLANAR_CONFIGURATION:
	                        this.metadata.planarConfiguration = this.imageFileDirectories[0][i].getIFDEntryValue()[0];
	                        break;
	                    case TiffConstants.Tag.ROWS_PER_STRIP:
	                        this.metadata.rowsPerStrip = this.imageFileDirectories[0][i].getIFDEntryValue()[0];
	                        break;
	                    case TiffConstants.Tag.RESOLUTION_UNIT:
	                        this.metadata.resolutionUnit = this.imageFileDirectories[0][i].getIFDEntryValue()[0];
	                        break;
	                    case TiffConstants.Tag.SAMPLES_PER_PIXEL:
	                        this.metadata.samplesPerPixel = this.imageFileDirectories[0][i].getIFDEntryValue()[0];
	                        break;
	                    case TiffConstants.Tag.SAMPLE_FORMAT:
	                        this.metadata.sampleFormat = this.imageFileDirectories[0][i].getIFDEntryValue();
	                        break;
	                    case TiffConstants.Tag.SOFTWARE:
	                        this.metadata.software = this.imageFileDirectories[0][i].getIFDEntryValue();
	                        break;
	                    case TiffConstants.Tag.STRIP_BYTE_COUNTS:
	                        this.metadata.stripByteCounts = this.imageFileDirectories[0][i].getIFDEntryValue();
	                        break;
	                    case TiffConstants.Tag.STRIP_OFFSETS:
	                        this.metadata.stripOffsets = this.imageFileDirectories[0][i].getIFDEntryValue();
	                        break;
	                    case TiffConstants.Tag.TILE_BYTE_COUNTS:
	                        this.metadata.tileByteCounts = this.imageFileDirectories[0][i].getIFDEntryValue();
	                        break;
	                    case TiffConstants.Tag.TILE_OFFSETS:
	                        this.metadata.tileOffsets = this.imageFileDirectories[0][i].getIFDEntryValue();
	                        break;
	                    case TiffConstants.Tag.TILE_LENGTH:
	                        this.metadata.tileLength = this.imageFileDirectories[0][i].getIFDEntryValue();
	                        break;
	                    case TiffConstants.Tag.TILE_WIDTH:
	                        this.metadata.tileWidth = this.imageFileDirectories[0][i].getIFDEntryValue();
	                        break;
	                    case TiffConstants.Tag.X_RESOLUTION:
	                        this.metadata.xResolution = this.imageFileDirectories[0][i].getIFDEntryValue();
	                        break;
	                    case TiffConstants.Tag.Y_RESOLUTION:
	                        this.metadata.tileWidth = this.imageFileDirectories[0][i].getIFDEntryValue();
	                        break;

	                    //geotiff
	                    case GeoTiffConstants.Tag.GEO_ASCII_PARAMS:
	                        this.metadata.geoAsciiParams = this.imageFileDirectories[0][i].getIFDEntryValue();
	                        break;
	                    case GeoTiffConstants.Tag.GEO_DOUBLE_PARAMS:
	                        this.metadata.geoDubleParams = this.imageFileDirectories[0][i].getIFDEntryValue();
	                        break;
	                    case GeoTiffConstants.Tag.GEO_KEY_DIRECTORY:
	                        this.metadata.geoKeyDirectory = this.imageFileDirectories[0][i].getIFDEntryValue();
	                        break;
	                    case GeoTiffConstants.Tag.MODEL_PIXEL_SCALE:
	                        this.metadata.modelPixelScale = this.imageFileDirectories[0][i].getIFDEntryValue();
	                        break;
	                    case GeoTiffConstants.Tag.MODEL_TIEPOINT:
	                        this.metadata.modelTiepoint = this.imageFileDirectories[0][i].getIFDEntryValue();
	                        break;
	                    case GeoTiffConstants.Tag.GDAL_NODATA:
	                        this.metadata.noData = this.imageFileDirectories[0][i].getIFDEntryValue();
	                        break;
	                    default:
	                        Logger.log(Logger.LEVEL_WARNING, "Ignored GeoTiff tag: " + this.imageFileDirectories[0][i].tag);
	                }
	            }
	        }

	        // Get metadata from GeoKeys. Internal use only.
	        GeoTiffReader.prototype.getMetadataFromGeoKeys = function () {
	            for (var i = 0; i < this.geoKeys.length; i++) {
	                var keyAsString = GeoTiffUtil.getTagValueAsString(GeoTiffConstants.Key, this.geoKeys[i].keyId);

	                if (keyAsString) {
	                    this._metadata.geotiff.geoKeys[keyAsString] = this.geoKeys[i].getGeoKeyValue(
	                        this.metadata.geoDoubleParams,
	                        this.metadata.geoAsciiParams);
	                }
	                else {
	                    Logger.log(Logger.LEVEL_WARNING, "Unknown GeoTiff key: " + this.geoKeys[i].keyId);
	                }
	            }
	        }

	        // Parse GeoKeys. Internal use only.
	        GeoTiffReader.prototype.parseGeoKeys = function () {
	            if (!this.isGeoTiff()) {
	                throw new AbstractError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "GeoTiffReader", "parse", "invalidGeoTiffFile"));
	            }

	            var geoKeyDirectory = this.metadata.geoKeyDirectory;
	            if (geoKeyDirectory) {
	                var keyDirectoryVersion = geoKeyDirectory[0];
	                var keyRevision = geoKeyDirectory[1];
	                var minorRevision = geoKeyDirectory[2];
	                var numberOfKeys = geoKeyDirectory[3];

	                for (var i = 0; i < numberOfKeys; i++) {
	                    var keyId = geoKeyDirectory[4 + i * 4];
	                    var tiffTagLocation = geoKeyDirectory[5 + i * 4];
	                    var count = geoKeyDirectory[6 + i * 4];
	                    var valueOffset = geoKeyDirectory[7 + i * 4];

	                    switch (keyId) {
	                        case GeoTiffConstants.Key.GTModelTypeGeoKey:
	                            this.metadata.gtModelTypeGeoKey =
	                                new GeoTiffKeyEntry(keyId, tiffTagLocation, count, valueOffset).getGeoKeyValue(
	                                    this.metadata.geoDoubleParams,
	                                    this.metadata.geoAsciiParams);
	                            break;
	                        case GeoTiffConstants.Key.GTRasterTypeGeoKey:
	                            this.metadata.gtRasterTypeGeoKey =
	                                new GeoTiffKeyEntry(keyId, tiffTagLocation, count, valueOffset).getGeoKeyValue(
	                                    this.metadata.geoDoubleParams,
	                                    this.metadata.geoAsciiParams);
	                            break;
	                        case GeoTiffConstants.Key.GTCitationGeoKey:
	                            this.metadata.gtCitationGeoKey =
	                                new GeoTiffKeyEntry(keyId, tiffTagLocation, count, valueOffset).getGeoKeyValue(
	                                    this.metadata.geoDoubleParams,
	                                    this.metadata.geoAsciiParams);
	                            break;
	                        case GeoTiffConstants.Key.GeographicTypeGeoKey:
	                            this.metadata.geographicTypeGeoKey =
	                                new GeoTiffKeyEntry(keyId, tiffTagLocation, count, valueOffset).getGeoKeyValue(
	                                    this.metadata.geoDoubleParams,
	                                    this.metadata.geoAsciiParams);
	                            break;
	                        case GeoTiffConstants.Key.GeogCitationGeoKey:
	                            this.metadata.geogCitationGeoKey =
	                                new GeoTiffKeyEntry(keyId, tiffTagLocation, count, valueOffset).getGeoKeyValue(
	                                    this.metadata.geoDoubleParams,
	                                    this.metadata.geoAsciiParams);
	                            break;
	                        case GeoTiffConstants.Key.GeogAngularUnitsGeoKey:
	                            this.metadata.geogAngularUnitsGeoKey =
	                                new GeoTiffKeyEntry(keyId, tiffTagLocation, count, valueOffset).getGeoKeyValue(
	                                    this.metadata.geoDoubleParams,
	                                    this.metadata.geoAsciiParams);
	                            break;
	                        case GeoTiffConstants.Key.GeogAngularUnitSizeGeoKey:
	                            this.metadata.geogAngularUnitSizeGeoKey =
	                                new GeoTiffKeyEntry(keyId, tiffTagLocation, count, valueOffset).getGeoKeyValue(
	                                    this.metadata.geoDoubleParams,
	                                    this.metadata.geoAsciiParams);
	                            break;
	                        case GeoTiffConstants.Key.GeogSemiMajorAxisGeoKey:
	                            this.metadata.geogSemiMajorAxisGeoKey =
	                                new GeoTiffKeyEntry(keyId, tiffTagLocation, count, valueOffset).getGeoKeyValue(
	                                    this.metadata.geoDoubleParams,
	                                    this.metadata.geoAsciiParams);
	                            break;
	                        case GeoTiffConstants.Key.GeogInvFlatteningGeoKey:
	                            this.metadata.geogInvFlatteningGeoKey =
	                                new GeoTiffKeyEntry(keyId, tiffTagLocation, count, valueOffset).getGeoKeyValue(
	                                    this.metadata.geoDoubleParams,
	                                    this.metadata.geoAsciiParams);
	                            break;
	                        case GeoTiffConstants.Key.ProjectedCSTypeGeoKey:
	                            this.metadata.projectedCSType =
	                                new GeoTiffKeyEntry(keyId, tiffTagLocation, count, valueOffset).getGeoKeyValue(
	                                    this.metadata.geoDoubleParams,
	                                    this.metadata.geoAsciiParams);
	                            break;
	                        default:
	                            Logger.log(Logger.LEVEL_WARNING, "Ignored GeoTiff key: " + keyId);
	                            break;

	                    }
	                }
	            }
	            else {
	                throw new AbstractError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "GeoTiffReader", "parseGeoKeys",
	                        "missingGeoKeyDirectoryTag"));
	            }
	        };

	        // Parse image file directory. Internal use only.
	        GeoTiffReader.prototype.parseImageFileDirectory = function (offset) {
	            if (!offset) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "GeoTiffReader", "parseImageFileDirectory",
	                        "missingOffset"));
	            }

	            var noOfDirectoryEntries = GeoTiffUtil.getBytes(this.geoTiffData, offset, 2, this.isLittleEndian);

	            var directoryEntries = [];

	            for (var i = offset + 2, directoryEntryCounter = 0; directoryEntryCounter < noOfDirectoryEntries;
	                 i += 12, directoryEntryCounter++) {
	                var tag = GeoTiffUtil.getBytes(this.geoTiffData, i, 2, this.isLittleEndian);
	                var type = GeoTiffUtil.getBytes(this.geoTiffData, i + 2, 2, this.isLittleEndian);
	                var count = GeoTiffUtil.getBytes(this.geoTiffData, i + 4, 4, this.isLittleEndian);
	                var valueOffset = GeoTiffUtil.getBytes(this.geoTiffData, i + 8, 4, this.isLittleEndian);

	                directoryEntries.push(new TiffIFDEntry(
	                    tag,
	                    type,
	                    count,
	                    valueOffset,
	                    this.geoTiffData,
	                    this.isLittleEndian));
	            }

	            this._imageFileDirectories.push(directoryEntries);

	            var nextIFDOffset = GeoTiffUtil.getBytes(this.geoTiffData, i, 4, this.isLittleEndian);

	            if (nextIFDOffset === 0) {
	                return;
	            }
	            else {
	                this.parseImageFileDirectory(nextIFDOffset);
	            }
	        };

	        // Get image file directory by tag value. Internal use only.
	        GeoTiffReader.prototype.getIFDByTag = function (tag) {
	            if (!tag) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "GeoTiffReader", "getIFDByTag", "missingTag"));
	            }

	            for (var i = 0; i < this.imageFileDirectories[0].length; i++) {
	                if (this.imageFileDirectories[0][i].tag === tag) {
	                    return this.imageFileDirectories[0][i];
	                }
	            }

	            return null;
	        }

	        return GeoTiffReader;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports GeoTiffConstants
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	        "use strict";

	        /**
	         * Provides all of the GeoTIFF tag constants.
	         * @alias GeoTiff
	         * @constructor
	         * @classdesc Contains all of the TIFF tags that are used to store GeoTIFF information of any type.
	         */
	        var GeoTiffConstants = {
	            /**
	             * An object containing all GeoTiff specific tags.
	             * @memberof GeoTiff
	             * @type {Object}
	             */
	            Tag: {
	                'MODEL_PIXEL_SCALE': 33550,
	                'MODEL_TRANSFORMATION': 34264,
	                'MODEL_TIEPOINT': 33922,
	                'GEO_KEY_DIRECTORY': 34735,
	                'GEO_DOUBLE_PARAMS': 34736,
	                'GEO_ASCII_PARAMS': 34737,

	                //gdal
	                'GDAL_NODATA': 42113,
	                'GDAL_METADATA': 42112
	            },

	            /**
	             * An object containing all GeoTiff specific keys.
	             * @memberof GeoTiff
	             * @type {Object}
	             */
	            Key: {
	                // GeoTIFF Configuration Keys
	                'GTModelTypeGeoKey': 1024,
	                'GTRasterTypeGeoKey': 1025,
	                'GTCitationGeoKey': 1026,

	                // Geographic CS Parameter Keys
	                'GeographicTypeGeoKey': 2048,
	                'GeogCitationGeoKey': 2049,
	                'GeogGeodeticDatumGeoKey': 2050,
	                'GeogPrimeMeridianGeoKey': 2051,
	                'GeogLinearUnitsGeoKey': 2052,
	                'GeogLinearUnitSizeGeoKey': 2053,
	                'GeogAngularUnitsGeoKey': 2054,
	                'GeogAngularUnitSizeGeoKey': 2055,
	                'GeogEllipsoidGeoKey': 2056,
	                'GeogSemiMajorAxisGeoKey': 2057,
	                'GeogSemiMinorAxisGeoKey': 2058,
	                'GeogInvFlatteningGeoKey': 2059,
	                'GeogAzimuthUnitsGeoKey': 2060,
	                'GeogPrimeMeridianLongGeoKey': 2061,
	                'GeogTOWGS84GeoKey': 2062,

	                // Projected CS Parameter Keys
	                'ProjectedCSTypeGeoKey': 3072,
	                'PCSCitationGeoKey': 3073,
	                'ProjectionGeoKey': 3074,
	                'ProjCoordTransGeoKey': 3075,
	                'ProjLinearUnitsGeoKey': 3076,
	                'ProjLinearUnitSizeGeoKey': 3077,
	                'ProjStdParallel1GeoKey': 3078,
	                'ProjStdParallel2GeoKey': 3079,
	                'ProjNatOriginLongGeoKey': 3080,
	                'ProjNatOriginLatGeoKey': 3081,
	                'ProjFalseEastingGeoKey': 3082,
	                'ProjFalseNorthingGeoKey': 3083,
	                'ProjFalseOriginLongGeoKey': 3084,
	                'ProjFalseOriginLatGeoKey': 3085,
	                'ProjFalseOriginEastingGeoKey': 3086,
	                'ProjFalseOriginNorthingGeoKey': 3087,
	                'ProjCenterLongGeoKey': 3088,
	                'ProjCenterLatGeoKey': 3089,
	                'ProjCenterEastingGeoKey': 3090,
	                'ProjCenterNorthingGeoKey': 3091,
	                'ProjScaleAtNatOriginGeoKey': 3092,
	                'ProjScaleAtCenterGeoKey': 3093,
	                'ProjAzimuthAngleGeoKey': 3094,
	                'ProjStraightVertPoleLongGeoKey': 3095,

	                // Vertical CS Keys
	                'VerticalCSTypeGeoKey': 4096,
	                'VerticalCitationGeoKey': 4097,
	                'VerticalDatumGeoKey': 4098,
	                'VerticalUnitsGeoKey': 4099
	            }
	        };

	        return GeoTiffConstants;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports GeoTiffKeyEntry
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(31),
	        __webpack_require__(30),
	        __webpack_require__(226),
	        __webpack_require__(32)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (AbstractError,
	              ArgumentError,
	              GeoTiffConstants,
	              Logger) {
	        "use strict";

	        /**
	         * Constructs a geotiff KeyEntry. Applications typically do not call this constructor. It is called
	         * by {@link GeoTiffReader} as GeoTIFF geo keys are read.
	         * @alias GeoTiffKeyEntry
	         * @constructor
	         * @classdesc Contains the data associated with a GeoTIFF KeyEntry. Each KeyEntry is modeled on the
	         * "TiffIFDEntry" format of the TIFF directory header.
	         * @param {Number} keyId Gives the key-ID value of the Key (identical in function
	         * to TIFF tag ID, but completely independent of TIFF tag-space).
	         * @param {Number} tiffTagLocation Indicates which TIFF tag contains the value(s) of the Key.
	         * @param {Number} count Indicates the number of values in this key.
	         * @param {Number} valueOffset  Indicates the index offset into the TagArray indicated by tiffTagLocation.
	         * @throws {ArgumentError} If either the specified keyId, tiffTagLocation, count or valueOffset
	         * are null or undefined.
	         */
	        var GeoTiffKeyEntry = function (keyId, tiffTagLocation, count, valueOffset) {
	            if (!keyId) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "GeoTiffKeyEntry", "constructor", "missingKeyId"));
	            }

	            if (tiffTagLocation === null || tiffTagLocation === undefined) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "GeoTiffKeyEntry", "constructor", "missingTiffTagLocation"));
	            }

	            if (!count) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "GeoTiffKeyEntry", "constructor", "missingCount"));
	            }

	            if (valueOffset === null || valueOffset === undefined) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "GeoTiffKeyEntry", "constructor", "missingValueOffset"));
	            }

	            // Documented in defineProperties below.
	            this._keyId = keyId;

	            // Documented in defineProperties below.
	            this._tiffTagLocation = tiffTagLocation;

	            // Documented in defineProperties below.
	            this._count = count;

	            // Documented in defineProperties below.
	            this._valueOffset = valueOffset;
	        };

	        Object.defineProperties(GeoTiffKeyEntry.prototype, {

	            /**
	             * The key-ID value of the Key as specified to this GeoTiffKeyEntry's constructor.
	             * @memberof GeoTiffKeyEntry.prototype
	             * @type {Number}
	             * @readonly
	             */
	            keyId: {
	                get: function () {
	                    return this._keyId;
	                }
	            },

	            /**
	             * The location of the TIFF tag as specified to this GeoTiffKeyEntry's constructor.
	             * @memberof GeoTiffKeyEntry.prototype
	             * @type {Number}
	             * @readonly
	             */
	            tiffTagLocation: {
	                get: function () {
	                    return this._tiffTagLocation;
	                }
	            },

	            /**
	             * The number of values in the key as specified to this GeoTiffKeyEntry's constructor.
	             * @memberof GeoTiffKeyEntry.prototype
	             * @type {Number}
	             * @readonly
	             */
	            count: {
	                get: function () {
	                    return this._count;
	                }
	            },

	            /**
	             * The index offset into the TagArray as specified to this GeoTiffKeyEntry's constructor.
	             * @memberof GeoTiffKeyEntry.prototype
	             * @type {Number}
	             * @readonly
	             */
	            valueOffset: {
	                get: function () {
	                    return this._valueOffset;
	                }
	            }
	        });

	        /**
	         * Get the value of a GeoKey.
	         * @returns {Number}
	         */
	        GeoTiffKeyEntry.prototype.getGeoKeyValue = function (geoDoubleParamsValue, geoAsciiParamsValue) {
	            var keyValue;

	            if (this.tiffTagLocation === 0){
	                keyValue = this.valueOffset
	            }
	            else if (this.tiffTagLocation === GeoTiffConstants.Tag.GEO_ASCII_PARAMS) {
	                var retVal = "";

	                if (geoAsciiParamsValue){
	                    for (var i=this.valueOffset; i < this.count - 1; i++){
	                        retVal += geoAsciiParamsValue[i];
	                    }
	                    if (geoAsciiParamsValue[this.count - 1] != '|'){
	                        retVal += geoAsciiParamsValue[this.count - 1];
	                    }

	                    keyValue = retVal;
	                }
	            }
	            else if (this.tiffTagLocation === GeoTiffConstants.Tag.GEO_DOUBLE_PARAMS) {
	                if (geoDoubleParamsValue){
	                    keyValue = geoDoubleParamsValue[this.valueOffset];
	                }
	            }

	            return keyValue;
	        };

	        return GeoTiffKeyEntry;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports GeoTiffMetadata
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	        "use strict";

	        /**
	         * Provides GeoTIFF metadata.
	         * @alias GeoTiffMetadata
	         * @constructor
	         * @classdesc Contains all of the TIFF and GeoTIFF metadata for a geotiff file.
	         */
	        var GeoTiffMetadata = function () {

	            // Documented in defineProperties below.
	            this._bitsPerSample = null;

	            // Documented in defineProperties below.
	            this._colorMap = null;

	            // Documented in defineProperties below.
	            this._compression = null;

	            // Documented in defineProperties below.
	            this._extraSamples = null;

	            // Documented in defineProperties below.
	            this._imageLength = null;

	            // Documented in defineProperties below.
	            this._imageWidth = null;

	            // Documented in defineProperties below.
	            this._maxSampleValue = null;

	            // Documented in defineProperties below.
	            this._minSampleValue = null;

	            // Documented in defineProperties below.
	            this._orientation = 0;

	            // Documented in defineProperties below.
	            this._photometricInterpretation = null;

	            // Documented in defineProperties below.
	            this._planarConfiguration = null;

	            // Documented in defineProperties below.
	            this._resolutionUnit = null;

	            // Documented in defineProperties below.
	            this._rowsPerStrip = null;

	            // Documented in defineProperties below.
	            this._samplesPerPixel = null;

	            // Documented in defineProperties below.
	            this._sampleFormat = null;

	            // Documented in defineProperties below.
	            this._software = null;

	            // Documented in defineProperties below.
	            this._stripByteCounts = null;

	            // Documented in defineProperties below.
	            this._stripOffsets = null;

	            // Documented in defineProperties below.
	            this._tileByteCounts = null;

	            // Documented in defineProperties below.
	            this._tileOffsets = null;

	            // Documented in defineProperties below.
	            this._tileLength = null;

	            // Documented in defineProperties below.
	            this._tileWidth = null;

	            // Documented in defineProperties below.
	            this._xResolution = null;

	            // Documented in defineProperties below.
	            this._yResolution = null;

	            // Documented in defineProperties below.
	            this._geoAsciiParams = null;

	            // Documented in defineProperties below.
	            this._geoDoubleParams = null;

	            // Documented in defineProperties below.
	            this._geoKeyDirectory = null;

	            // Documented in defineProperties below.
	            this._modelPixelScale = null;

	            // Documented in defineProperties below.
	            this._modelTiepoint = null;

	            // Documented in defineProperties below.
	            this._modelTransformation = null;

	            // Documented in defineProperties below.
	            this._noData = null;

	            // Documented in defineProperties below.
	            this._bbox = null;

	            // Documented in defineProperties below.
	            this._gtModelTypeGeoKey = null;

	            // Documented in defineProperties below.
	            this._gtRasterTypeGeoKey = null;

	            // Documented in defineProperties below.
	            this._gtCitationGeoKey = null;

	            // Documented in defineProperties below.
	            this._geographicTypeGeoKey = null;

	            // Documented in defineProperties below.
	            this._geogCitationGeoKey = null;

	            // Documented in defineProperties below.
	            this._geogAngularUnitsGeoKey = null;

	            // Documented in defineProperties below.
	            this._geogAngularUnitSizeGeoKey = null;

	            // Documented in defineProperties below.
	            this._geogSemiMajorAxisGeoKey = null;

	            // Documented in defineProperties below.
	            this._geogInvFlatteningGeoKey = null;

	            // Documented in defineProperties below.
	            this._projectedCSType = null;
	        };

	        Object.defineProperties(GeoTiffMetadata.prototype, {

	            /**
	             * Contains the number of bits per component.
	             * @memberof GeoTiffMetadata.prototype
	             * @type {Number[]}
	             */
	            bitsPerSample: {
	                get: function () {
	                    return this._bitsPerSample;
	                },

	                set: function(value){
	                    this._bitsPerSample = value;
	                }
	            },

	            /**
	             * Defines a Red-Green-Blue color map (often called a lookup table) for palette color images.
	             * In a palette-color image, a pixel value is used to index into an RGB-lookup table.
	             * @memberof GeoTiffMetadata.prototype
	             * @type {Number[]}
	             */
	            colorMap: {
	                get: function () {
	                    return this._colorMap;
	                },

	                set: function(value){
	                    this._colorMap = value;
	                }
	            },

	            /**
	             * Contains the compression type of geotiff data.
	             * @memberof GeoTiffMetadata.prototype
	             * @type {Number}
	             */
	            compression: {
	                get: function () {
	                    return this._compression;
	                },

	                set: function(value){
	                    this._compression = value;
	                }
	            },

	            /**
	             * Contains the description of extra components.
	             * @memberof GeoTiffMetadata.prototype
	             * @type {Number[]}
	             */
	            extraSamples: {
	                get: function () {
	                    return this._extraSamples;
	                },

	                set: function(value){
	                    this._extraSamples = value;
	                }
	            },

	            /**
	             * Contains the number of rows in the image.
	             * @memberof GeoTiffMetadata.prototype
	             * @type {Number}
	             */
	            imageLength: {
	                get: function () {
	                    return this._imageLength;
	                },

	                set: function(value){
	                    this._imageLength = value;
	                }
	            },

	            /**
	             * Contains the number of columns in the image.
	             * @memberof GeoTiffMetadata.prototype
	             * @type {Number}
	             */
	            imageWidth: {
	                get: function () {
	                    return this._imageWidth;
	                },

	                set: function(value){
	                    this._imageWidth = value;
	                }
	            },

	            /**
	             * Contains the maximum component value used.
	             * @memberof GeoTiffMetadata.prototype
	             * @type {Number}
	             */
	            maxSampleValue: {
	                get: function () {
	                    return this._maxSampleValue;
	                },

	                set: function(value){
	                    this._maxSampleValue = value;
	                }
	            },

	            /**
	             * Contains the minimum component value used.
	             * @memberof GeoTiffMetadata.prototype
	             * @type {Number}
	             */
	            minSampleValue: {
	                get: function () {
	                    return this._minSampleValue;
	                },

	                set: function(value){
	                    this._minSampleValue = value;
	                }
	            },

	            /**
	             * Contains the orientation of the image with respect to the rows and columns.
	             * @memberof GeoTiffMetadata.prototype
	             * @type {Number}
	             */
	            orientation: {
	                get: function () {
	                    return this._orientation;
	                },

	                set: function(value){
	                    this._orientation = value;
	                }
	            },

	            /**
	             * Contains the photometric interpretation type of the geotiff file.
	             * @memberof GeoTiffMetadata.prototype
	             * @type {Number}
	             */
	            photometricInterpretation: {
	                get: function () {
	                    return this._photometricInterpretation;
	                },

	                set: function(value){
	                    this._photometricInterpretation = value;
	                }
	            },

	            /**
	             * Contains the planar configuration type of the geotiff file.
	             * @memberof GeoTiffMetadata.prototype
	             * @type {Number}
	             */
	            planarConfiguration: {
	                get: function () {
	                    return this._planarConfiguration;
	                },

	                set: function(value){
	                    this._planarConfiguration = value;
	                }
	            },

	            /**
	             * Contains the unit of measurement for XResolution and YResolution. The specified values are:
	             * <ul>
	             *     <li>1 = No absolute unit of measurement</li>
	             *     <li>2 = Inch</li>
	             *     <li>3 = Centimeter</li>
	             * </ul>
	             * @memberof GeoTiffMetadata.prototype
	             * @type {Number}
	             */
	            resolutionUnit: {
	                get: function () {
	                    return this._resolutionUnit;
	                },

	                set: function(value){
	                    this._resolutionUnit = value;
	                }
	            },

	            /**
	             * Contains the number of rows per strip.
	             * @memberof GeoTiffMetadata.prototype
	             * @type {Number}
	             */
	            rowsPerStrip: {
	                get: function () {
	                    return this._rowsPerStrip;
	                },

	                set: function(value){
	                    this._rowsPerStrip = value;
	                }
	            },

	            /**
	             * Contains the number of components per pixel.
	             * @memberof GeoTiffMetadata.prototype
	             * @type {Number}
	             */
	            samplesPerPixel: {
	                get: function () {
	                    return this._samplesPerPixel;
	                },

	                set: function(value){
	                    this._samplesPerPixel = value;
	                }
	            },

	            /**
	             * This field specifies how to interpret each data sample in a pixel. Possible values are:
	             * <ul>
	             *     <li>unsigned integer data</li>
	             *     <li>two's complement signed integer data</li>
	             *     <li>IEEE floating point data</li>
	             *     <li>undefined data format</li>
	             * </ul>
	             * @memberof GeoTiffMetadata.prototype
	             * @type {Number}
	             */
	            sampleFormat: {
	                get: function () {
	                    return this._sampleFormat;
	                },

	                set: function(value){
	                    this._sampleFormat = value;
	                }
	            },

	            software: {
	                get: function () {
	                    return this._software;
	                },

	                set: function(value){
	                    this._software = value;
	                }
	            },

	            /**
	             * Contains the number of bytes in that strip after any compression, for each strip.
	             * @memberof GeoTiffMetadata.prototype
	             * @type {Number[]}
	             */
	            stripByteCounts: {
	                get: function () {
	                    return this._stripByteCounts;
	                },

	                set: function(value){
	                    this._stripByteCounts = value;
	                }
	            },

	            /**
	             * Contains the byte offset of that strip, for each strip.
	             * @memberof GeoTiffMetadata.prototype
	             * @type {Number[]}
	             */
	            stripOffsets: {
	                get: function () {
	                    return this._stripOffsets;
	                },

	                set: function(value){
	                    this._stripOffsets = value;
	                }
	            },

	            tileByteCounts: {
	                get: function () {
	                    return this._tileByteCounts;
	                },

	                set: function(value){
	                    this._tileByteCounts = value;
	                }
	            },

	            /**
	             * Contains the byte offset of that tile, for each tile.
	             * @memberof GeoTiffMetadata.prototype
	             * @type {Number[]}
	             */
	            tileOffsets: {
	                get: function () {
	                    return this._tileOffsets;
	                },

	                set: function(value){
	                    this._tileOffsets = value;
	                }
	            },

	            tileLength: {
	                get: function () {
	                    return this._tileLength;
	                },

	                set: function(value){
	                    this._tileLength = value;
	                }
	            },

	            tileWidth: {
	                get: function () {
	                    return this._tileWidth;
	                },

	                set: function(value){
	                    this._tileWidth = value;
	                }
	            },

	            //geotiff
	            /**
	             * Contains all of the ASCII valued GeoKeys, referenced by the GeoKeyDirectoryTag.
	             * @memberof GeoTiffMetadata.prototype
	             * @type {String[]}
	             */
	            geoAsciiParams: {
	                get: function () {
	                    return this._geoAsciiParams;
	                },

	                set: function(value){
	                    this._geoAsciiParams = value;
	                }
	            },

	            /**
	             * Contains all of the DOUBLE valued GeoKeys, referenced by the GeoKeyDirectoryTag.
	             * @memberof GeoTiffMetadata.prototype
	             * @type {Nmber[]}
	             */
	            geoDoubleParams: {
	                get: function () {
	                    return this._geoDoubleParams;
	                },

	                set: function(value){
	                    this._geoDoubleParams = value;
	                }
	            },

	            /**
	             * Contains the values of GeoKeyDirectoryTag.
	             * @memberof GeoTiffMetadata.prototype
	             * @type {Nmber[]}
	             */
	            geoKeyDirectory: {
	                get: function () {
	                    return this._geoKeyDirectory;
	                },

	                set: function(value){
	                    this._geoKeyDirectory = value;
	                }
	            },

	            /**
	             * Contains the values of ModelPixelScaleTag. The ModelPixelScaleTag tag may be used to specify the size
	             * of raster pixel spacing in the model space units, when the raster space can be embedded in the model
	             * space coordinate system without rotation
	             * @memberof GeoTiffMetadata.prototype
	             * @type {Nmber[]}
	             */
	            modelPixelScale: {
	                get: function () {
	                    return this._modelPixelScale;
	                },

	                set: function(value){
	                    this._modelPixelScale = value;
	                }
	            },

	            /**
	             * Stores raster->model tiepoint pairs in the order ModelTiepointTag = (...,I,J,K, X,Y,Z...),
	             * where (I,J,K) is the point at location (I,J) in raster space with pixel-value K,
	             * and (X,Y,Z) is a vector in model space.
	             * @memberof GeoTiffMetadata.prototype
	             * @type {Nmber[]}
	             */
	            modelTiepoint: {
	                get: function () {
	                    return this._modelTiepoint;
	                },

	                set: function(value){
	                    this._modelTiepoint = value;
	                }
	            },

	            /**
	             * Contains the information that may be used to specify the transformation matrix between the raster space
	             * (and its dependent pixel-value space) and the model space.
	             * @memberof GeoTiffMetadata.prototype
	             * @type {Nmber[]}
	             */
	            modelTransformation: {
	                get: function () {
	                    return this._modelTransformation;
	                },

	                set: function(value){
	                    this._modelTransformation = value;
	                }
	            },

	            /**
	             * Contains the NODATA value.
	             * @memberof GeoTiffMetadata.prototype
	             * @type {String}
	             */
	            noData: {
	                get: function () {
	                    return this._noData;
	                },

	                set: function(value){
	                    this._noData = value;
	                }
	            },

	            /**
	             * Contains the extent of the geotiff.
	             * @memberof GeoTiffMetadata.prototype
	             * @type {Sector}
	             */
	            bbox: {
	                get: function () {
	                    return this._bbox;
	                },

	                set: function(value){
	                    this._bbox = value;
	                }
	            },

	            //geokeys
	            /**
	             * Contains an ID defining the crs model.
	             * @memberof GeoTiffMetadata.prototype
	             * @type {Number}
	             */
	            gtModelTypeGeoKey: {
	                get: function () {
	                    return this._gtModelTypeGeoKey;
	                },

	                set: function(value){
	                    this._gtModelTypeGeoKey = value;
	                }
	            },

	            /**
	             * Contains an ID defining the raster sample type.
	             * @memberof GeoTiffMetadata.prototype
	             * @type {Number}
	             */
	            gtRasterTypeGeoKey: {
	                get: function () {
	                    return this._gtRasterTypeGeoKey;
	                },

	                set: function(value){
	                    this._gtRasterTypeGeoKey = value;
	                }
	            },

	            /**
	             * Contains an ASCII reference to the overall configuration of the geotiff file.
	             * @memberof GeoTiffMetadata.prototype
	             * @type {String}
	             */
	            gtCitationGeoKey: {
	                get: function () {
	                    return this._gtCitationGeoKey;
	                },

	                set: function(value){
	                    this._gtCitationGeoKey = value;
	                }
	            },

	            /**
	             * Contains a value to specify the code for geographic coordinate system used to map lat-long to a specific
	             * ellipsoid over the earth
	             * @memberof GeoTiffMetadata.prototype
	             * @type {Number}
	             */
	            geographicTypeGeoKey: {
	                get: function () {
	                    return this._geographicTypeGeoKey;
	                },

	                set: function(value){
	                    this._geographicTypeGeoKey = value;
	                }
	            },

	            /**
	             * Contains a value to specify the code for geographic coordinate system used to map lat-long to a specific
	             * ellipsoid over the earth
	             * @memberof GeoTiffMetadata.prototype
	             * @type {String}
	             */
	            geogCitationGeoKey: {
	                get: function () {
	                    return this._geogCitationGeoKey;
	                },

	                set: function(value){
	                    this._geogCitationGeoKey = value;
	                }
	            },

	            /**
	             * Allows the definition of geocentric CS Linear units for used-defined GCS and for ellipsoids
	             * @memberof GeoTiffMetadata.prototype
	             * @type {Number}
	             */
	            geogAngularUnitsGeoKey: {
	                get: function () {
	                    return this._geogAngularUnitsGeoKey;
	                },

	                set: function(value){
	                    this._geogAngularUnitsGeoKey = value;
	                }
	            },

	            /**
	             * Allows the definition of user-defined angular geographic units, as measured in radians
	             * @memberof GeoTiffMetadata.prototype
	             * @type {Number}
	             */
	            geogAngularUnitSizeGeoKey: {
	                get: function () {
	                    return this._geogAngularUnitSizeGeoKey;
	                },

	                set: function(value){
	                    this._geogAngularUnitSizeGeoKey = value;
	                }
	            },

	            /**
	             * Allows the specification of user-defined Ellipsoidal Semi-Major Axis
	             * @memberof GeoTiffMetadata.prototype
	             * @type {Number}
	             */
	            geogSemiMajorAxisGeoKey: {
	                get: function () {
	                    return this._geogSemiMajorAxisGeoKey;
	                },

	                set: function(value){
	                    this._geogSemiMajorAxisGeoKey = value;
	                }
	            },

	            /**
	             * Allows the specification of the inverse of user-defined Ellipsoid's flattening parameter f.
	             * @memberof GeoTiffMetadata.prototype
	             * @type {Number}
	             */
	            geogInvFlatteningGeoKey: {
	                get: function () {
	                    return this._geogInvFlatteningGeoKey;
	                },

	                set: function(value){
	                    this._geogInvFlatteningGeoKey = value;
	                }
	            },

	            /**
	             * Contains the EPSG code of the geotiff.
	             * @memberof GeoTiffMetadata.prototype
	             * @type {Number}
	             */
	            projectedCSType: {
	                get: function () {
	                    return this._projectedCSType;
	                },

	                set: function(value){
	                    this._projectedCSType = value;
	                }
	            },

	            /**
	             * Contains the number of pixels per resolution unit in the image width direction.
	             * @memberof GeoTiffMetadata.prototype
	             * @type {Number}
	             */
	            xResolution: {
	                get: function () {
	                    return this._xResolution;
	                },

	                set: function(value){
	                    this._xResolution = value;
	                }
	            },

	            /**
	             * Contains the number of pixels per resolution unit in the image length direction.
	             * @memberof GeoTiffMetadata.prototype
	             * @type {Number}
	             */
	            yResolution: {
	                get: function () {
	                    return this._yResolution;
	                },

	                set: function(value){
	                    this._yResolution = value;
	                }
	            }
	        });

	        return GeoTiffMetadata;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports GeoTiffUtil
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(30),
	        __webpack_require__(32),
	        __webpack_require__(230)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
	              Logger,
	              TiffConstants) {
	        "use strict";

	        var GeoTiffUtil = {

	            // Get bytes from an arraybuffer depending on the size.
	            getBytes: function (geoTiffData, byteOffset, numOfBytes, isLittleEndian, isSigned) {
	                if (numOfBytes <= 0) {
	                    throw new ArgumentError(
	                        Logger.logMessage(Logger.LEVEL_SEVERE, "GeoTiffReader", "getBytes", "noBytesRequested"));
	                } else if (numOfBytes <= 1) {
	                    if (isSigned) {
	                        return geoTiffData.getInt8(byteOffset, isLittleEndian);
	                    }
	                    else {
	                        return geoTiffData.getUint8(byteOffset, isLittleEndian);
	                    }
	                } else if (numOfBytes <= 2) {
	                    if (isSigned) {
	                        return geoTiffData.getInt16(byteOffset, isLittleEndian);
	                    }
	                    else {
	                        return geoTiffData.getUint16(byteOffset, isLittleEndian);
	                    }
	                } else if (numOfBytes <= 3) {
	                    if (isSigned) {
	                        return geoTiffData.getInt32(byteOffset, isLittleEndian) >>> 8;
	                    }
	                    else {
	                        return geoTiffData.getUint32(byteOffset, isLittleEndian) >>> 8;
	                    }
	                } else if (numOfBytes <= 4) {
	                    if (isSigned) {
	                        return geoTiffData.getInt32(byteOffset, isLittleEndian);
	                    }
	                    else {
	                        return geoTiffData.getUint32(byteOffset, isLittleEndian);
	                    }
	                } else if (numOfBytes <= 8) {
	                    return geoTiffData.getFloat64(byteOffset, isLittleEndian);
	                } else {
	                    throw new ArgumentError(
	                        Logger.logMessage(Logger.LEVEL_SEVERE, "GeoTiffReader", "getBytes", "tooManyBytesRequested"));
	                }
	            },

	            // Get sample value from an arraybuffer depending on the sample format.
	            getSampleBytes: function (geoTiffData, byteOffset, numOfBytes, sampleFormat, isLittleEndian) {
	                var res;

	                switch (sampleFormat) {
	                    case TiffConstants.SampleFormat.UNSIGNED:
	                        res = this.getBytes(geoTiffData, byteOffset, numOfBytes, isLittleEndian, false);
	                        break;
	                    case TiffConstants.SampleFormat.SIGNED:
	                        res = this.getBytes(geoTiffData, byteOffset, numOfBytes, isLittleEndian, true);
	                        break;
	                    case TiffConstants.SampleFormat.IEEE_FLOAT:
	                        if (numOfBytes == 3) {
	                            res = geoTiffData.getFloat32(byteOffset, isLittleEndian) >>> 8;
	                        } else if (numOfBytes == 4) {
	                            res = geoTiffData.getFloat32(byteOffset, isLittleEndian);
	                        } else if (numOfBytes == 8) {
	                            res = geoTiffData.getFloat64(byteOffset, isLittleEndian);
	                        }
	                        else {
	                            Logger.log(Logger.LEVEL_WARNING, "Do not attempt to parse the data  not handled: " +
	                                numOfBytes);
	                        }
	                        break;
	                    case TiffConstants.SampleFormat.UNDEFINED:
	                    default:
	                        res = this.getBytes(geoTiffData, byteOffset, numOfBytes, isLittleEndian, false);
	                        break;
	                }

	                return res;
	            },

	            // Converts canvas to an image.
	            canvasToTiffImage: function (canvas) {
	                var image = new Image();
	                image.src = canvas.toDataURL();
	                return image;
	            },

	            // Get RGBA fill style for a canvas context as a string.
	            getRGBAFillValue: function (r, g, b, a) {
	                if (typeof a === 'undefined') {
	                    a = 1.0;
	                }
	                return "rgba(" + r + ", " + g + ", " + b + ", " + a + ")";
	            },

	            // Get the tag value as a string.
	            getTagValueAsString: function (tagName, tagValue) {
	                for (var property in tagName) {
	                    if (tagName[property] === tagValue) {
	                        return property;
	                    }
	                }
	                return undefined;
	            },

	            // Clamp color sample from color sample value and number of bits per sample.
	            clampColorSample: function (colorSample, bitsPerSample) {
	                var multiplier = Math.pow(2, 8 - bitsPerSample);
	                return Math.floor((colorSample * multiplier) + (multiplier - 1));
	            },

	            // Clamp color sample for elevation data from elevation sample values.
	            clampColorSampleForElevation: function (elevationSample, minElevation, maxElevation) {
	                var slope = 255 / (maxElevation - minElevation);
	                return Math.round(slope * (elevationSample - minElevation))
	            },

	            // Get min and max geotiff sample values.
	            getMinMaxGeotiffSamples: function (geotiffSampleArray, noDataValue) {
	                var min = Infinity;
	                var max = -Infinity;
	                for (var i = 0; i < geotiffSampleArray.length; i++) {
	                    for (var j = 0; j < geotiffSampleArray[i].length; j++) {
	                        for (var k = 0; k < geotiffSampleArray[i][j].length; k++) {
	                            if (geotiffSampleArray[i][j][k] == noDataValue)
	                                continue;

	                            if (geotiffSampleArray[i][j][k] > max) {
	                                max = geotiffSampleArray[i][j][k];
	                            }
	                            if (geotiffSampleArray[i][j][k] < min) {
	                                min = geotiffSampleArray[i][j][k];
	                            }
	                        }
	                    }
	                }

	                return {max: max, min: min};
	            }
	        };

	        return GeoTiffUtil;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports Tiff
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	        "use strict";

	        /**
	         * Provides all of the TIFF tag and subtag constants.
	         * @alias TiffConstants
	         * @constructor
	         * @classdesc Contains all of the TIFF tags that are used to store TIFF information of any type.
	         */
	        var TiffConstants = {
	            /**
	             * An object containing all TIFF specific tags.
	             * @memberof Tiff
	             * @type {Object}
	             */
	            Tag: {
	                'NEW_SUBFILE_TYPE': 254,
	                'SUBFILE_TYPE': 255,
	                'IMAGE_WIDTH': 256,
	                'IMAGE_LENGTH': 257,
	                'BITS_PER_SAMPLE': 258,
	                'COMPRESSION': 259,
	                'PHOTOMETRIC_INTERPRETATION': 262,
	                'THRESHHOLDING': 263,
	                'CELL_WIDTH': 264,
	                'CELL_LENGTH': 265,
	                'FILL_ORDER': 266,
	                'DOCUMENT_NAME': 269,
	                'IMAGE_DESCRIPTION': 270,
	                'MAKE': 271,
	                'MODEL': 272,
	                'STRIP_OFFSETS': 273,
	                'ORIENTATION': 274,
	                'SAMPLES_PER_PIXEL': 277,
	                'ROWS_PER_STRIP': 278,
	                'STRIP_BYTE_COUNTS': 279,
	                'MIN_SAMPLE_VALUE': 280,
	                'MAX_SAMPLE_VALUE': 281,
	                'X_RESOLUTION': 282,
	                'Y_RESOLUTION': 283,
	                'PLANAR_CONFIGURATION': 284,
	                'PAGE_NAME': 285,
	                'X_POSITION': 286,
	                'Y_POSITION': 287,
	                'FREE_OFFSETS': 288,
	                'FREE_BYTE_COUNTS': 289,
	                'GRAY_RESPONSE_UNIT': 290,
	                'GRAY_RESPONSE_CURVE': 291,
	                'T4_OPTIONS': 292,
	                'T6_PTIONS': 293,
	                'RESOLUTION_UNIT': 296,
	                'PAGE_NUMBER': 297,
	                'TRANSFER_FUNCTION': 301,
	                'SOFTWARE': 305,
	                'DATE_TIME': 306,
	                'ARTIST': 315,
	                'HOST_COMPUTER': 316,
	                'PREDICTOR': 317,
	                'WHITE_POINT': 318,
	                'PRIMARY_CHROMATICITIES': 319,
	                'COLOR_MAP': 320,
	                'HALFTONE_HINTS': 321,
	                'TILE_WIDTH': 322,
	                'TILE_LENGTH': 323,
	                'TILE_OFFSETS': 324,
	                'TILE_BYTE_COUNTS': 325,
	                'INK_SET': 332,
	                'INK_NAMES': 333,
	                'NUMBER_OF_INKS': 334,
	                'DOT_RANGE': 336,
	                'TARGET_PRINTER': 337,
	                'EXTRA_SAMPLES': 338,
	                'SAMPLE_FORMAT': 339,
	                'S_MIN_SAMPLE_VALUE': 340,
	                'S_MAX_SAMPLE_VALUE': 341,
	                'TRANSFER_RANGE': 342,
	                'JPEG_PROC': 512,
	                'JPEG_INTERCHANGE_FORMAT': 513,
	                'JPEG_INTERCHANGE_FORMAT_LENGTH': 514,
	                'JPEG_RESTART_INTERVAL': 515,
	                'JPEG_LOSSLESS_PREDICTORS': 517,
	                'JPEG_POINT_TRANSFORMS': 518,
	                'JPEG_Q_TABLES': 519,
	                'JPEG_DC_TABLES': 520,
	                'JPEG_AC_TABLES': 521,
	                'Y_Cb_Cr_COEFFICIENTS': 529,
	                'Y_Cb_Cr_SUB_SAMPLING': 530,
	                'Y_Cb_Cr_POSITIONING': 531,
	                'REFERENCE_BLACK_WHITE': 532,
	                'COPYRIGHT': 33432
	            },

	            /**
	             * An object containing all TIFF compression types.
	             * @memberof Tiff
	             * @type {Object}
	             */
	            Compression: {
	                'UNCOMPRESSED': 1,
	                'CCITT_1D': 2,
	                'GROUP_3_FAX': 3,
	                'GROUP_4_FAX': 4,
	                'LZW': 5,
	                'JPEG': 6,
	                'PACK_BITS': 32773
	            },

	            /**
	             * An object containing all TIFF orientation types.
	             * @memberof Tiff
	             * @type {Object}
	             */
	            Orientation: {
	                'Row0_IS_TOP__Col0_IS_LHS': 1,
	                'Row0_IS_TOP__Col0_IS_RHS': 2,
	                'Row0_IS_BOTTOM__Col0_IS_RHS': 3,
	                'Row0_IS_BOTTOM__Col0_IS_LHS': 4,
	                'Row0_IS_LHS__Col0_IS_TOP': 5,
	                'Row0_IS_RHS__Col0_IS_TOP': 6,
	                'Row0_IS_RHS__Col0_IS_BOTTOM': 7,
	                'Row0_IS_LHS__Col0_IS_BOTTOM': 8
	            },

	            /**
	             * An object containing all TIFF photometric interpretation types.
	             * @memberof Tiff
	             * @type {Object}
	             */
	            PhotometricInterpretation: {
	                'WHITE_IS_ZERO': 0,
	                'BLACK_IS_ZERO': 1,
	                'RGB': 2,
	                'RGB_PALETTE': 3,
	                'TRANSPARENCY_MASK': 4,
	                'CMYK': 5,
	                'Y_Cb_Cr': 6,
	                'CIE_LAB': 7
	            },

	            /**
	             * An object containing all TIFF planar configuration types.
	             * @memberof Tiff
	             * @type {Object}
	             */
	            PlanarConfiguration: {
	                'CHUNKY': 1,
	                'PLANAR': 2
	            },

	            /**
	             * An object containing all TIFF resolution unit types.
	             * @memberof Tiff
	             * @type {Object}
	             */
	            ResolutionUnit: {
	                'NONE': 1,
	                'INCH': 2,
	                'CENTIMETER': 3
	            },

	            /**
	             * An object containing all TIFF sample format types.
	             * @memberof Tiff
	             * @type {Object}
	             */
	            SampleFormat: {
	                'UNSIGNED': 1,
	                'SIGNED': 2,
	                'IEEE_FLOAT': 3,
	                'UNDEFINED': 4,
	                'DEFAULT': 1
	            },

	            /**
	             * An object containing all TIFF field types.
	             * @memberof Tiff
	             * @type {Object}
	             */
	            Type: {
	                'BYTE': 1,
	                'ASCII': 2,
	                'SHORT': 3,
	                'LONG': 4,
	                'RATIONAL': 5,
	                'SBYTE': 6,
	                'UNDEFINED': 7,
	                'SSHORT': 8,
	                'SLONG': 9,
	                'SRATIONAL': 10,
	                'FLOAT': 11,
	                'DOUBLE': 12
	            }
	        };

	        return TiffConstants;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

	var require;var require;!function(e){if(true)module.exports=e();else if("function"==typeof define&&define.amd)define(e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.proj4=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return require(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
	var mgrs = _dereq_('mgrs');

	function Point(x, y, z) {
	  if (!(this instanceof Point)) {
	    return new Point(x, y, z);
	  }
	  if (Array.isArray(x)) {
	    this.x = x[0];
	    this.y = x[1];
	    this.z = x[2] || 0.0;
	  }else if(typeof x === 'object'){
	    this.x = x.x;
	    this.y = x.y;
	    this.z = x.z || 0.0;
	  } else if (typeof x === 'string' && typeof y === 'undefined') {
	    var coords = x.split(',');
	    this.x = parseFloat(coords[0], 10);
	    this.y = parseFloat(coords[1], 10);
	    this.z = parseFloat(coords[2], 10) || 0.0;
	  }
	  else {
	    this.x = x;
	    this.y = y;
	    this.z = z || 0.0;
	  }
	  console.warn('proj4.Point will be removed in version 3, use proj4.toPoint');
	}

	Point.fromMGRS = function(mgrsStr) {
	  return new Point(mgrs.toPoint(mgrsStr));
	};
	Point.prototype.toMGRS = function(accuracy) {
	  return mgrs.forward([this.x, this.y], accuracy);
	};
	module.exports = Point;
	},{"mgrs":66}],2:[function(_dereq_,module,exports){
	var parseCode = _dereq_("./parseCode");
	var extend = _dereq_('./extend');
	var projections = _dereq_('./projections');
	var deriveConstants = _dereq_('./deriveConstants');

	function Projection(srsCode,callback) {
	  if (!(this instanceof Projection)) {
	    return new Projection(srsCode);
	  }
	  callback = callback || function(error){
	    if(error){
	      throw error;
	    }
	  };
	  var json = parseCode(srsCode);
	  if(typeof json !== 'object'){
	    callback(srsCode);
	    return;
	  }
	  var modifiedJSON = deriveConstants(json);
	  var ourProj = Projection.projections.get(modifiedJSON.projName);
	  if(ourProj){
	    extend(this, modifiedJSON);
	    extend(this, ourProj);
	    this.init();
	    callback(null, this);
	  }else{
	    callback(srsCode);
	  }
	}
	Projection.projections = projections;
	Projection.projections.start();
	module.exports = Projection;

	},{"./deriveConstants":32,"./extend":33,"./parseCode":36,"./projections":38}],3:[function(_dereq_,module,exports){
	module.exports = function(crs, denorm, point) {
	  var xin = point.x,
	    yin = point.y,
	    zin = point.z || 0.0;
	  var v, t, i;
	  for (i = 0; i < 3; i++) {
	    if (denorm && i === 2 && point.z === undefined) {
	      continue;
	    }
	    if (i === 0) {
	      v = xin;
	      t = 'x';
	    }
	    else if (i === 1) {
	      v = yin;
	      t = 'y';
	    }
	    else {
	      v = zin;
	      t = 'z';
	    }
	    switch (crs.axis[i]) {
	    case 'e':
	      point[t] = v;
	      break;
	    case 'w':
	      point[t] = -v;
	      break;
	    case 'n':
	      point[t] = v;
	      break;
	    case 's':
	      point[t] = -v;
	      break;
	    case 'u':
	      if (point[t] !== undefined) {
	        point.z = v;
	      }
	      break;
	    case 'd':
	      if (point[t] !== undefined) {
	        point.z = -v;
	      }
	      break;
	    default:
	      //console.log("ERROR: unknow axis ("+crs.axis[i]+") - check definition of "+crs.projName);
	      return null;
	    }
	  }
	  return point;
	};

	},{}],4:[function(_dereq_,module,exports){
	var HALF_PI = Math.PI/2;
	var sign = _dereq_('./sign');

	module.exports = function(x) {
	  return (Math.abs(x) < HALF_PI) ? x : (x - (sign(x) * Math.PI));
	};
	},{"./sign":21}],5:[function(_dereq_,module,exports){
	var TWO_PI = Math.PI * 2;
	// SPI is slightly greater than Math.PI, so values that exceed the -180..180
	// degree range by a tiny amount don't get wrapped. This prevents points that
	// have drifted from their original location along the 180th meridian (due to
	// floating point error) from changing their sign.
	var SPI = 3.14159265359;
	var sign = _dereq_('./sign');

	module.exports = function(x) {
	  return (Math.abs(x) <= SPI) ? x : (x - (sign(x) * TWO_PI));
	};
	},{"./sign":21}],6:[function(_dereq_,module,exports){
	module.exports = function(x) {
	  if (Math.abs(x) > 1) {
	    x = (x > 1) ? 1 : -1;
	  }
	  return Math.asin(x);
	};
	},{}],7:[function(_dereq_,module,exports){
	module.exports = function(x) {
	  return (1 - 0.25 * x * (1 + x / 16 * (3 + 1.25 * x)));
	};
	},{}],8:[function(_dereq_,module,exports){
	module.exports = function(x) {
	  return (0.375 * x * (1 + 0.25 * x * (1 + 0.46875 * x)));
	};
	},{}],9:[function(_dereq_,module,exports){
	module.exports = function(x) {
	  return (0.05859375 * x * x * (1 + 0.75 * x));
	};
	},{}],10:[function(_dereq_,module,exports){
	module.exports = function(x) {
	  return (x * x * x * (35 / 3072));
	};
	},{}],11:[function(_dereq_,module,exports){
	module.exports = function(a, e, sinphi) {
	  var temp = e * sinphi;
	  return a / Math.sqrt(1 - temp * temp);
	};
	},{}],12:[function(_dereq_,module,exports){
	module.exports = function(ml, e0, e1, e2, e3) {
	  var phi;
	  var dphi;

	  phi = ml / e0;
	  for (var i = 0; i < 15; i++) {
	    dphi = (ml - (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi))) / (e0 - 2 * e1 * Math.cos(2 * phi) + 4 * e2 * Math.cos(4 * phi) - 6 * e3 * Math.cos(6 * phi));
	    phi += dphi;
	    if (Math.abs(dphi) <= 0.0000000001) {
	      return phi;
	    }
	  }

	  //..reportError("IMLFN-CONV:Latitude failed to converge after 15 iterations");
	  return NaN;
	};
	},{}],13:[function(_dereq_,module,exports){
	var HALF_PI = Math.PI/2;

	module.exports = function(eccent, q) {
	  var temp = 1 - (1 - eccent * eccent) / (2 * eccent) * Math.log((1 - eccent) / (1 + eccent));
	  if (Math.abs(Math.abs(q) - temp) < 1.0E-6) {
	    if (q < 0) {
	      return (-1 * HALF_PI);
	    }
	    else {
	      return HALF_PI;
	    }
	  }
	  //var phi = 0.5* q/(1-eccent*eccent);
	  var phi = Math.asin(0.5 * q);
	  var dphi;
	  var sin_phi;
	  var cos_phi;
	  var con;
	  for (var i = 0; i < 30; i++) {
	    sin_phi = Math.sin(phi);
	    cos_phi = Math.cos(phi);
	    con = eccent * sin_phi;
	    dphi = Math.pow(1 - con * con, 2) / (2 * cos_phi) * (q / (1 - eccent * eccent) - sin_phi / (1 - con * con) + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
	    phi += dphi;
	    if (Math.abs(dphi) <= 0.0000000001) {
	      return phi;
	    }
	  }

	  //console.log("IQSFN-CONV:Latitude failed to converge after 30 iterations");
	  return NaN;
	};
	},{}],14:[function(_dereq_,module,exports){
	module.exports = function(e0, e1, e2, e3, phi) {
	  return (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi));
	};
	},{}],15:[function(_dereq_,module,exports){
	module.exports = function(eccent, sinphi, cosphi) {
	  var con = eccent * sinphi;
	  return cosphi / (Math.sqrt(1 - con * con));
	};
	},{}],16:[function(_dereq_,module,exports){
	var HALF_PI = Math.PI/2;
	module.exports = function(eccent, ts) {
	  var eccnth = 0.5 * eccent;
	  var con, dphi;
	  var phi = HALF_PI - 2 * Math.atan(ts);
	  for (var i = 0; i <= 15; i++) {
	    con = eccent * Math.sin(phi);
	    dphi = HALF_PI - 2 * Math.atan(ts * (Math.pow(((1 - con) / (1 + con)), eccnth))) - phi;
	    phi += dphi;
	    if (Math.abs(dphi) <= 0.0000000001) {
	      return phi;
	    }
	  }
	  //console.log("phi2z has NoConvergence");
	  return -9999;
	};
	},{}],17:[function(_dereq_,module,exports){
	var C00 = 1;
	var C02 = 0.25;
	var C04 = 0.046875;
	var C06 = 0.01953125;
	var C08 = 0.01068115234375;
	var C22 = 0.75;
	var C44 = 0.46875;
	var C46 = 0.01302083333333333333;
	var C48 = 0.00712076822916666666;
	var C66 = 0.36458333333333333333;
	var C68 = 0.00569661458333333333;
	var C88 = 0.3076171875;

	module.exports = function(es) {
	  var en = [];
	  en[0] = C00 - es * (C02 + es * (C04 + es * (C06 + es * C08)));
	  en[1] = es * (C22 - es * (C04 + es * (C06 + es * C08)));
	  var t = es * es;
	  en[2] = t * (C44 - es * (C46 + es * C48));
	  t *= es;
	  en[3] = t * (C66 - es * C68);
	  en[4] = t * es * C88;
	  return en;
	};
	},{}],18:[function(_dereq_,module,exports){
	var pj_mlfn = _dereq_("./pj_mlfn");
	var EPSLN = 1.0e-10;
	var MAX_ITER = 20;
	module.exports = function(arg, es, en) {
	  var k = 1 / (1 - es);
	  var phi = arg;
	  for (var i = MAX_ITER; i; --i) { /* rarely goes over 2 iterations */
	    var s = Math.sin(phi);
	    var t = 1 - es * s * s;
	    //t = this.pj_mlfn(phi, s, Math.cos(phi), en) - arg;
	    //phi -= t * (t * Math.sqrt(t)) * k;
	    t = (pj_mlfn(phi, s, Math.cos(phi), en) - arg) * (t * Math.sqrt(t)) * k;
	    phi -= t;
	    if (Math.abs(t) < EPSLN) {
	      return phi;
	    }
	  }
	  //..reportError("cass:pj_inv_mlfn: Convergence error");
	  return phi;
	};
	},{"./pj_mlfn":19}],19:[function(_dereq_,module,exports){
	module.exports = function(phi, sphi, cphi, en) {
	  cphi *= sphi;
	  sphi *= sphi;
	  return (en[0] * phi - cphi * (en[1] + sphi * (en[2] + sphi * (en[3] + sphi * en[4]))));
	};
	},{}],20:[function(_dereq_,module,exports){
	module.exports = function(eccent, sinphi) {
	  var con;
	  if (eccent > 1.0e-7) {
	    con = eccent * sinphi;
	    return ((1 - eccent * eccent) * (sinphi / (1 - con * con) - (0.5 / eccent) * Math.log((1 - con) / (1 + con))));
	  }
	  else {
	    return (2 * sinphi);
	  }
	};
	},{}],21:[function(_dereq_,module,exports){
	module.exports = function(x) {
	  return x<0 ? -1 : 1;
	};
	},{}],22:[function(_dereq_,module,exports){
	module.exports = function(esinp, exp) {
	  return (Math.pow((1 - esinp) / (1 + esinp), exp));
	};
	},{}],23:[function(_dereq_,module,exports){
	module.exports = function (array){
	  var out = {
	    x: array[0],
	    y: array[1]
	  };
	  if (array.length>2) {
	    out.z = array[2];
	  }
	  if (array.length>3) {
	    out.m = array[3];
	  }
	  return out;
	};
	},{}],24:[function(_dereq_,module,exports){
	var HALF_PI = Math.PI/2;

	module.exports = function(eccent, phi, sinphi) {
	  var con = eccent * sinphi;
	  var com = 0.5 * eccent;
	  con = Math.pow(((1 - con) / (1 + con)), com);
	  return (Math.tan(0.5 * (HALF_PI - phi)) / con);
	};
	},{}],25:[function(_dereq_,module,exports){
	exports.wgs84 = {
	  towgs84: "0,0,0",
	  ellipse: "WGS84",
	  datumName: "WGS84"
	};
	exports.ch1903 = {
	  towgs84: "674.374,15.056,405.346",
	  ellipse: "bessel",
	  datumName: "swiss"
	};
	exports.ggrs87 = {
	  towgs84: "-199.87,74.79,246.62",
	  ellipse: "GRS80",
	  datumName: "Greek_Geodetic_Reference_System_1987"
	};
	exports.nad83 = {
	  towgs84: "0,0,0",
	  ellipse: "GRS80",
	  datumName: "North_American_Datum_1983"
	};
	exports.nad27 = {
	  nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",
	  ellipse: "clrk66",
	  datumName: "North_American_Datum_1927"
	};
	exports.potsdam = {
	  towgs84: "606.0,23.0,413.0",
	  ellipse: "bessel",
	  datumName: "Potsdam Rauenberg 1950 DHDN"
	};
	exports.carthage = {
	  towgs84: "-263.0,6.0,431.0",
	  ellipse: "clark80",
	  datumName: "Carthage 1934 Tunisia"
	};
	exports.hermannskogel = {
	  towgs84: "653.0,-212.0,449.0",
	  ellipse: "bessel",
	  datumName: "Hermannskogel"
	};
	exports.ire65 = {
	  towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
	  ellipse: "mod_airy",
	  datumName: "Ireland 1965"
	};
	exports.rassadiran = {
	  towgs84: "-133.63,-157.5,-158.62",
	  ellipse: "intl",
	  datumName: "Rassadiran"
	};
	exports.nzgd49 = {
	  towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",
	  ellipse: "intl",
	  datumName: "New Zealand Geodetic Datum 1949"
	};
	exports.osgb36 = {
	  towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",
	  ellipse: "airy",
	  datumName: "Airy 1830"
	};
	exports.s_jtsk = {
	  towgs84: "589,76,480",
	  ellipse: 'bessel',
	  datumName: 'S-JTSK (Ferro)'
	};
	exports.beduaram = {
	  towgs84: '-106,-87,188',
	  ellipse: 'clrk80',
	  datumName: 'Beduaram'
	};
	exports.gunung_segara = {
	  towgs84: '-403,684,41',
	  ellipse: 'bessel',
	  datumName: 'Gunung Segara Jakarta'
	};
	exports.rnb72 = {
	  towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",
	  ellipse: "intl",
	  datumName: "Reseau National Belge 1972"
	};
	},{}],26:[function(_dereq_,module,exports){
	exports.MERIT = {
	  a: 6378137.0,
	  rf: 298.257,
	  ellipseName: "MERIT 1983"
	};
	exports.SGS85 = {
	  a: 6378136.0,
	  rf: 298.257,
	  ellipseName: "Soviet Geodetic System 85"
	};
	exports.GRS80 = {
	  a: 6378137.0,
	  rf: 298.257222101,
	  ellipseName: "GRS 1980(IUGG, 1980)"
	};
	exports.IAU76 = {
	  a: 6378140.0,
	  rf: 298.257,
	  ellipseName: "IAU 1976"
	};
	exports.airy = {
	  a: 6377563.396,
	  b: 6356256.910,
	  ellipseName: "Airy 1830"
	};
	exports.APL4 = {
	  a: 6378137,
	  rf: 298.25,
	  ellipseName: "Appl. Physics. 1965"
	};
	exports.NWL9D = {
	  a: 6378145.0,
	  rf: 298.25,
	  ellipseName: "Naval Weapons Lab., 1965"
	};
	exports.mod_airy = {
	  a: 6377340.189,
	  b: 6356034.446,
	  ellipseName: "Modified Airy"
	};
	exports.andrae = {
	  a: 6377104.43,
	  rf: 300.0,
	  ellipseName: "Andrae 1876 (Den., Iclnd.)"
	};
	exports.aust_SA = {
	  a: 6378160.0,
	  rf: 298.25,
	  ellipseName: "Australian Natl & S. Amer. 1969"
	};
	exports.GRS67 = {
	  a: 6378160.0,
	  rf: 298.2471674270,
	  ellipseName: "GRS 67(IUGG 1967)"
	};
	exports.bessel = {
	  a: 6377397.155,
	  rf: 299.1528128,
	  ellipseName: "Bessel 1841"
	};
	exports.bess_nam = {
	  a: 6377483.865,
	  rf: 299.1528128,
	  ellipseName: "Bessel 1841 (Namibia)"
	};
	exports.clrk66 = {
	  a: 6378206.4,
	  b: 6356583.8,
	  ellipseName: "Clarke 1866"
	};
	exports.clrk80 = {
	  a: 6378249.145,
	  rf: 293.4663,
	  ellipseName: "Clarke 1880 mod."
	};
	exports.clrk58 = {
	  a: 6378293.645208759,
	  rf: 294.2606763692654,
	  ellipseName: "Clarke 1858"
	};
	exports.CPM = {
	  a: 6375738.7,
	  rf: 334.29,
	  ellipseName: "Comm. des Poids et Mesures 1799"
	};
	exports.delmbr = {
	  a: 6376428.0,
	  rf: 311.5,
	  ellipseName: "Delambre 1810 (Belgium)"
	};
	exports.engelis = {
	  a: 6378136.05,
	  rf: 298.2566,
	  ellipseName: "Engelis 1985"
	};
	exports.evrst30 = {
	  a: 6377276.345,
	  rf: 300.8017,
	  ellipseName: "Everest 1830"
	};
	exports.evrst48 = {
	  a: 6377304.063,
	  rf: 300.8017,
	  ellipseName: "Everest 1948"
	};
	exports.evrst56 = {
	  a: 6377301.243,
	  rf: 300.8017,
	  ellipseName: "Everest 1956"
	};
	exports.evrst69 = {
	  a: 6377295.664,
	  rf: 300.8017,
	  ellipseName: "Everest 1969"
	};
	exports.evrstSS = {
	  a: 6377298.556,
	  rf: 300.8017,
	  ellipseName: "Everest (Sabah & Sarawak)"
	};
	exports.fschr60 = {
	  a: 6378166.0,
	  rf: 298.3,
	  ellipseName: "Fischer (Mercury Datum) 1960"
	};
	exports.fschr60m = {
	  a: 6378155.0,
	  rf: 298.3,
	  ellipseName: "Fischer 1960"
	};
	exports.fschr68 = {
	  a: 6378150.0,
	  rf: 298.3,
	  ellipseName: "Fischer 1968"
	};
	exports.helmert = {
	  a: 6378200.0,
	  rf: 298.3,
	  ellipseName: "Helmert 1906"
	};
	exports.hough = {
	  a: 6378270.0,
	  rf: 297.0,
	  ellipseName: "Hough"
	};
	exports.intl = {
	  a: 6378388.0,
	  rf: 297.0,
	  ellipseName: "International 1909 (Hayford)"
	};
	exports.kaula = {
	  a: 6378163.0,
	  rf: 298.24,
	  ellipseName: "Kaula 1961"
	};
	exports.lerch = {
	  a: 6378139.0,
	  rf: 298.257,
	  ellipseName: "Lerch 1979"
	};
	exports.mprts = {
	  a: 6397300.0,
	  rf: 191.0,
	  ellipseName: "Maupertius 1738"
	};
	exports.new_intl = {
	  a: 6378157.5,
	  b: 6356772.2,
	  ellipseName: "New International 1967"
	};
	exports.plessis = {
	  a: 6376523.0,
	  rf: 6355863.0,
	  ellipseName: "Plessis 1817 (France)"
	};
	exports.krass = {
	  a: 6378245.0,
	  rf: 298.3,
	  ellipseName: "Krassovsky, 1942"
	};
	exports.SEasia = {
	  a: 6378155.0,
	  b: 6356773.3205,
	  ellipseName: "Southeast Asia"
	};
	exports.walbeck = {
	  a: 6376896.0,
	  b: 6355834.8467,
	  ellipseName: "Walbeck"
	};
	exports.WGS60 = {
	  a: 6378165.0,
	  rf: 298.3,
	  ellipseName: "WGS 60"
	};
	exports.WGS66 = {
	  a: 6378145.0,
	  rf: 298.25,
	  ellipseName: "WGS 66"
	};
	exports.WGS7 = {
	  a: 6378135.0,
	  rf: 298.26,
	  ellipseName: "WGS 72"
	};
	exports.WGS84 = {
	  a: 6378137.0,
	  rf: 298.257223563,
	  ellipseName: "WGS 84"
	};
	exports.sphere = {
	  a: 6370997.0,
	  b: 6370997.0,
	  ellipseName: "Normal Sphere (r=6370997)"
	};
	},{}],27:[function(_dereq_,module,exports){
	exports.greenwich = 0.0; //"0dE",
	exports.lisbon = -9.131906111111; //"9d07'54.862\"W",
	exports.paris = 2.337229166667; //"2d20'14.025\"E",
	exports.bogota = -74.080916666667; //"74d04'51.3\"W",
	exports.madrid = -3.687938888889; //"3d41'16.58\"W",
	exports.rome = 12.452333333333; //"12d27'8.4\"E",
	exports.bern = 7.439583333333; //"7d26'22.5\"E",
	exports.jakarta = 106.807719444444; //"106d48'27.79\"E",
	exports.ferro = -17.666666666667; //"17d40'W",
	exports.brussels = 4.367975; //"4d22'4.71\"E",
	exports.stockholm = 18.058277777778; //"18d3'29.8\"E",
	exports.athens = 23.7163375; //"23d42'58.815\"E",
	exports.oslo = 10.722916666667; //"10d43'22.5\"E"
	},{}],28:[function(_dereq_,module,exports){
	var proj = _dereq_('./Proj');
	var transform = _dereq_('./transform');
	var wgs84 = proj('WGS84');

	function transformer(from, to, coords) {
	  var transformedArray;
	  if (Array.isArray(coords)) {
	    transformedArray = transform(from, to, coords);
	    if (coords.length === 3) {
	      return [transformedArray.x, transformedArray.y, transformedArray.z];
	    }
	    else {
	      return [transformedArray.x, transformedArray.y];
	    }
	  }
	  else {
	    return transform(from, to, coords);
	  }
	}

	function checkProj(item) {
	  if (item instanceof proj) {
	    return item;
	  }
	  if (item.oProj) {
	    return item.oProj;
	  }
	  return proj(item);
	}
	function proj4(fromProj, toProj, coord) {
	  fromProj = checkProj(fromProj);
	  var single = false;
	  var obj;
	  if (typeof toProj === 'undefined') {
	    toProj = fromProj;
	    fromProj = wgs84;
	    single = true;
	  }
	  else if (typeof toProj.x !== 'undefined' || Array.isArray(toProj)) {
	    coord = toProj;
	    toProj = fromProj;
	    fromProj = wgs84;
	    single = true;
	  }
	  toProj = checkProj(toProj);
	  if (coord) {
	    return transformer(fromProj, toProj, coord);
	  }
	  else {
	    obj = {
	      forward: function(coords) {
	        return transformer(fromProj, toProj, coords);
	      },
	      inverse: function(coords) {
	        return transformer(toProj, fromProj, coords);
	      }
	    };
	    if (single) {
	      obj.oProj = toProj;
	    }
	    return obj;
	  }
	}
	module.exports = proj4;
	},{"./Proj":2,"./transform":64}],29:[function(_dereq_,module,exports){
	var HALF_PI = Math.PI/2;
	var PJD_3PARAM = 1;
	var PJD_7PARAM = 2;
	var PJD_GRIDSHIFT = 3;
	var PJD_WGS84 = 4; // WGS84 or equivalent
	var PJD_NODATUM = 5; // WGS84 or equivalent
	var SEC_TO_RAD = 4.84813681109535993589914102357e-6;
	var AD_C = 1.0026000;
	var COS_67P5 = 0.38268343236508977;
	var datum = function(proj) {
	  if (!(this instanceof datum)) {
	    return new datum(proj);
	  }
	  this.datum_type = PJD_WGS84; //default setting
	  if (!proj) {
	    return;
	  }
	  if (proj.datumCode && proj.datumCode === 'none') {
	    this.datum_type = PJD_NODATUM;
	  }
	  if (proj.datum_params) {
	    for (var i = 0; i < proj.datum_params.length; i++) {
	      proj.datum_params[i] = parseFloat(proj.datum_params[i]);
	    }
	    if (proj.datum_params[0] !== 0 || proj.datum_params[1] !== 0 || proj.datum_params[2] !== 0) {
	      this.datum_type = PJD_3PARAM;
	    }
	    if (proj.datum_params.length > 3) {
	      if (proj.datum_params[3] !== 0 || proj.datum_params[4] !== 0 || proj.datum_params[5] !== 0 || proj.datum_params[6] !== 0) {
	        this.datum_type = PJD_7PARAM;
	        proj.datum_params[3] *= SEC_TO_RAD;
	        proj.datum_params[4] *= SEC_TO_RAD;
	        proj.datum_params[5] *= SEC_TO_RAD;
	        proj.datum_params[6] = (proj.datum_params[6] / 1000000.0) + 1.0;
	      }
	    }
	  }
	  // DGR 2011-03-21 : nadgrids support
	  this.datum_type = proj.grids ? PJD_GRIDSHIFT : this.datum_type;

	  this.a = proj.a; //datum object also uses these values
	  this.b = proj.b;
	  this.es = proj.es;
	  this.ep2 = proj.ep2;
	  this.datum_params = proj.datum_params;
	  if (this.datum_type === PJD_GRIDSHIFT) {
	    this.grids = proj.grids;
	  }
	};
	datum.prototype = {


	  /****************************************************************/
	  // cs_compare_datums()
	  //   Returns TRUE if the two datums match, otherwise FALSE.
	  compare_datums: function(dest) {
	    if (this.datum_type !== dest.datum_type) {
	      return false; // false, datums are not equal
	    }
	    else if (this.a !== dest.a || Math.abs(this.es - dest.es) > 0.000000000050) {
	      // the tolerence for es is to ensure that GRS80 and WGS84
	      // are considered identical
	      return false;
	    }
	    else if (this.datum_type === PJD_3PARAM) {
	      return (this.datum_params[0] === dest.datum_params[0] && this.datum_params[1] === dest.datum_params[1] && this.datum_params[2] === dest.datum_params[2]);
	    }
	    else if (this.datum_type === PJD_7PARAM) {
	      return (this.datum_params[0] === dest.datum_params[0] && this.datum_params[1] === dest.datum_params[1] && this.datum_params[2] === dest.datum_params[2] && this.datum_params[3] === dest.datum_params[3] && this.datum_params[4] === dest.datum_params[4] && this.datum_params[5] === dest.datum_params[5] && this.datum_params[6] === dest.datum_params[6]);
	    }
	    else if (this.datum_type === PJD_GRIDSHIFT || dest.datum_type === PJD_GRIDSHIFT) {
	      //alert("ERROR: Grid shift transformations are not implemented.");
	      //return false
	      //DGR 2012-07-29 lazy ...
	      return this.nadgrids === dest.nadgrids;
	    }
	    else {
	      return true; // datums are equal
	    }
	  }, // cs_compare_datums()

	  /*
	   * The function Convert_Geodetic_To_Geocentric converts geodetic coordinates
	   * (latitude, longitude, and height) to geocentric coordinates (X, Y, Z),
	   * according to the current ellipsoid parameters.
	   *
	   *    Latitude  : Geodetic latitude in radians                     (input)
	   *    Longitude : Geodetic longitude in radians                    (input)
	   *    Height    : Geodetic height, in meters                       (input)
	   *    X         : Calculated Geocentric X coordinate, in meters    (output)
	   *    Y         : Calculated Geocentric Y coordinate, in meters    (output)
	   *    Z         : Calculated Geocentric Z coordinate, in meters    (output)
	   *
	   */
	  geodetic_to_geocentric: function(p) {
	    var Longitude = p.x;
	    var Latitude = p.y;
	    var Height = p.z ? p.z : 0; //Z value not always supplied
	    var X; // output
	    var Y;
	    var Z;

	    var Error_Code = 0; //  GEOCENT_NO_ERROR;
	    var Rn; /*  Earth radius at location  */
	    var Sin_Lat; /*  Math.sin(Latitude)  */
	    var Sin2_Lat; /*  Square of Math.sin(Latitude)  */
	    var Cos_Lat; /*  Math.cos(Latitude)  */

	    /*
	     ** Don't blow up if Latitude is just a little out of the value
	     ** range as it may just be a rounding issue.  Also removed longitude
	     ** test, it should be wrapped by Math.cos() and Math.sin().  NFW for PROJ.4, Sep/2001.
	     */
	    if (Latitude < -HALF_PI && Latitude > -1.001 * HALF_PI) {
	      Latitude = -HALF_PI;
	    }
	    else if (Latitude > HALF_PI && Latitude < 1.001 * HALF_PI) {
	      Latitude = HALF_PI;
	    }
	    else if ((Latitude < -HALF_PI) || (Latitude > HALF_PI)) {
	      /* Latitude out of range */
	      //..reportError('geocent:lat out of range:' + Latitude);
	      return null;
	    }

	    if (Longitude > Math.PI) {
	      Longitude -= (2 * Math.PI);
	    }
	    Sin_Lat = Math.sin(Latitude);
	    Cos_Lat = Math.cos(Latitude);
	    Sin2_Lat = Sin_Lat * Sin_Lat;
	    Rn = this.a / (Math.sqrt(1.0e0 - this.es * Sin2_Lat));
	    X = (Rn + Height) * Cos_Lat * Math.cos(Longitude);
	    Y = (Rn + Height) * Cos_Lat * Math.sin(Longitude);
	    Z = ((Rn * (1 - this.es)) + Height) * Sin_Lat;

	    p.x = X;
	    p.y = Y;
	    p.z = Z;
	    return Error_Code;
	  }, // cs_geodetic_to_geocentric()


	  geocentric_to_geodetic: function(p) {
	    /* local defintions and variables */
	    /* end-criterium of loop, accuracy of sin(Latitude) */
	    var genau = 1e-12;
	    var genau2 = (genau * genau);
	    var maxiter = 30;

	    var P; /* distance between semi-minor axis and location */
	    var RR; /* distance between center and location */
	    var CT; /* sin of geocentric latitude */
	    var ST; /* cos of geocentric latitude */
	    var RX;
	    var RK;
	    var RN; /* Earth radius at location */
	    var CPHI0; /* cos of start or old geodetic latitude in iterations */
	    var SPHI0; /* sin of start or old geodetic latitude in iterations */
	    var CPHI; /* cos of searched geodetic latitude */
	    var SPHI; /* sin of searched geodetic latitude */
	    var SDPHI; /* end-criterium: addition-theorem of sin(Latitude(iter)-Latitude(iter-1)) */
	    var At_Pole; /* indicates location is in polar region */
	    var iter; /* # of continous iteration, max. 30 is always enough (s.a.) */

	    var X = p.x;
	    var Y = p.y;
	    var Z = p.z ? p.z : 0.0; //Z value not always supplied
	    var Longitude;
	    var Latitude;
	    var Height;

	    At_Pole = false;
	    P = Math.sqrt(X * X + Y * Y);
	    RR = Math.sqrt(X * X + Y * Y + Z * Z);

	    /*      special cases for latitude and longitude */
	    if (P / this.a < genau) {

	      /*  special case, if P=0. (X=0., Y=0.) */
	      At_Pole = true;
	      Longitude = 0.0;

	      /*  if (X,Y,Z)=(0.,0.,0.) then Height becomes semi-minor axis
	       *  of ellipsoid (=center of mass), Latitude becomes PI/2 */
	      if (RR / this.a < genau) {
	        Latitude = HALF_PI;
	        Height = -this.b;
	        return;
	      }
	    }
	    else {
	      /*  ellipsoidal (geodetic) longitude
	       *  interval: -PI < Longitude <= +PI */
	      Longitude = Math.atan2(Y, X);
	    }

	    /* --------------------------------------------------------------
	     * Following iterative algorithm was developped by
	     * "Institut for Erdmessung", University of Hannover, July 1988.
	     * Internet: www.ife.uni-hannover.de
	     * Iterative computation of CPHI,SPHI and Height.
	     * Iteration of CPHI and SPHI to 10**-12 radian resp.
	     * 2*10**-7 arcsec.
	     * --------------------------------------------------------------
	     */
	    CT = Z / RR;
	    ST = P / RR;
	    RX = 1.0 / Math.sqrt(1.0 - this.es * (2.0 - this.es) * ST * ST);
	    CPHI0 = ST * (1.0 - this.es) * RX;
	    SPHI0 = CT * RX;
	    iter = 0;

	    /* loop to find sin(Latitude) resp. Latitude
	     * until |sin(Latitude(iter)-Latitude(iter-1))| < genau */
	    do {
	      iter++;
	      RN = this.a / Math.sqrt(1.0 - this.es * SPHI0 * SPHI0);

	      /*  ellipsoidal (geodetic) height */
	      Height = P * CPHI0 + Z * SPHI0 - RN * (1.0 - this.es * SPHI0 * SPHI0);

	      RK = this.es * RN / (RN + Height);
	      RX = 1.0 / Math.sqrt(1.0 - RK * (2.0 - RK) * ST * ST);
	      CPHI = ST * (1.0 - RK) * RX;
	      SPHI = CT * RX;
	      SDPHI = SPHI * CPHI0 - CPHI * SPHI0;
	      CPHI0 = CPHI;
	      SPHI0 = SPHI;
	    }
	    while (SDPHI * SDPHI > genau2 && iter < maxiter);

	    /*      ellipsoidal (geodetic) latitude */
	    Latitude = Math.atan(SPHI / Math.abs(CPHI));

	    p.x = Longitude;
	    p.y = Latitude;
	    p.z = Height;
	    return p;
	  }, // cs_geocentric_to_geodetic()

	  /** Convert_Geocentric_To_Geodetic
	   * The method used here is derived from 'An Improved Algorithm for
	   * Geocentric to Geodetic Coordinate Conversion', by Ralph Toms, Feb 1996
	   */
	  geocentric_to_geodetic_noniter: function(p) {
	    var X = p.x;
	    var Y = p.y;
	    var Z = p.z ? p.z : 0; //Z value not always supplied
	    var Longitude;
	    var Latitude;
	    var Height;

	    var W; /* distance from Z axis */
	    var W2; /* square of distance from Z axis */
	    var T0; /* initial estimate of vertical component */
	    var T1; /* corrected estimate of vertical component */
	    var S0; /* initial estimate of horizontal component */
	    var S1; /* corrected estimate of horizontal component */
	    var Sin_B0; /* Math.sin(B0), B0 is estimate of Bowring aux variable */
	    var Sin3_B0; /* cube of Math.sin(B0) */
	    var Cos_B0; /* Math.cos(B0) */
	    var Sin_p1; /* Math.sin(phi1), phi1 is estimated latitude */
	    var Cos_p1; /* Math.cos(phi1) */
	    var Rn; /* Earth radius at location */
	    var Sum; /* numerator of Math.cos(phi1) */
	    var At_Pole; /* indicates location is in polar region */

	    X = parseFloat(X); // cast from string to float
	    Y = parseFloat(Y);
	    Z = parseFloat(Z);

	    At_Pole = false;
	    if (X !== 0.0) {
	      Longitude = Math.atan2(Y, X);
	    }
	    else {
	      if (Y > 0) {
	        Longitude = HALF_PI;
	      }
	      else if (Y < 0) {
	        Longitude = -HALF_PI;
	      }
	      else {
	        At_Pole = true;
	        Longitude = 0.0;
	        if (Z > 0.0) { /* north pole */
	          Latitude = HALF_PI;
	        }
	        else if (Z < 0.0) { /* south pole */
	          Latitude = -HALF_PI;
	        }
	        else { /* center of earth */
	          Latitude = HALF_PI;
	          Height = -this.b;
	          return;
	        }
	      }
	    }
	    W2 = X * X + Y * Y;
	    W = Math.sqrt(W2);
	    T0 = Z * AD_C;
	    S0 = Math.sqrt(T0 * T0 + W2);
	    Sin_B0 = T0 / S0;
	    Cos_B0 = W / S0;
	    Sin3_B0 = Sin_B0 * Sin_B0 * Sin_B0;
	    T1 = Z + this.b * this.ep2 * Sin3_B0;
	    Sum = W - this.a * this.es * Cos_B0 * Cos_B0 * Cos_B0;
	    S1 = Math.sqrt(T1 * T1 + Sum * Sum);
	    Sin_p1 = T1 / S1;
	    Cos_p1 = Sum / S1;
	    Rn = this.a / Math.sqrt(1.0 - this.es * Sin_p1 * Sin_p1);
	    if (Cos_p1 >= COS_67P5) {
	      Height = W / Cos_p1 - Rn;
	    }
	    else if (Cos_p1 <= -COS_67P5) {
	      Height = W / -Cos_p1 - Rn;
	    }
	    else {
	      Height = Z / Sin_p1 + Rn * (this.es - 1.0);
	    }
	    if (At_Pole === false) {
	      Latitude = Math.atan(Sin_p1 / Cos_p1);
	    }

	    p.x = Longitude;
	    p.y = Latitude;
	    p.z = Height;
	    return p;
	  }, // geocentric_to_geodetic_noniter()

	  /****************************************************************/
	  // pj_geocentic_to_wgs84( p )
	  //  p = point to transform in geocentric coordinates (x,y,z)
	  geocentric_to_wgs84: function(p) {

	    if (this.datum_type === PJD_3PARAM) {
	      // if( x[io] === HUGE_VAL )
	      //    continue;
	      p.x += this.datum_params[0];
	      p.y += this.datum_params[1];
	      p.z += this.datum_params[2];

	    }
	    else if (this.datum_type === PJD_7PARAM) {
	      var Dx_BF = this.datum_params[0];
	      var Dy_BF = this.datum_params[1];
	      var Dz_BF = this.datum_params[2];
	      var Rx_BF = this.datum_params[3];
	      var Ry_BF = this.datum_params[4];
	      var Rz_BF = this.datum_params[5];
	      var M_BF = this.datum_params[6];
	      // if( x[io] === HUGE_VAL )
	      //    continue;
	      var x_out = M_BF * (p.x - Rz_BF * p.y + Ry_BF * p.z) + Dx_BF;
	      var y_out = M_BF * (Rz_BF * p.x + p.y - Rx_BF * p.z) + Dy_BF;
	      var z_out = M_BF * (-Ry_BF * p.x + Rx_BF * p.y + p.z) + Dz_BF;
	      p.x = x_out;
	      p.y = y_out;
	      p.z = z_out;
	    }
	  }, // cs_geocentric_to_wgs84

	  /****************************************************************/
	  // pj_geocentic_from_wgs84()
	  //  coordinate system definition,
	  //  point to transform in geocentric coordinates (x,y,z)
	  geocentric_from_wgs84: function(p) {

	    if (this.datum_type === PJD_3PARAM) {
	      //if( x[io] === HUGE_VAL )
	      //    continue;
	      p.x -= this.datum_params[0];
	      p.y -= this.datum_params[1];
	      p.z -= this.datum_params[2];

	    }
	    else if (this.datum_type === PJD_7PARAM) {
	      var Dx_BF = this.datum_params[0];
	      var Dy_BF = this.datum_params[1];
	      var Dz_BF = this.datum_params[2];
	      var Rx_BF = this.datum_params[3];
	      var Ry_BF = this.datum_params[4];
	      var Rz_BF = this.datum_params[5];
	      var M_BF = this.datum_params[6];
	      var x_tmp = (p.x - Dx_BF) / M_BF;
	      var y_tmp = (p.y - Dy_BF) / M_BF;
	      var z_tmp = (p.z - Dz_BF) / M_BF;
	      //if( x[io] === HUGE_VAL )
	      //    continue;

	      p.x = x_tmp + Rz_BF * y_tmp - Ry_BF * z_tmp;
	      p.y = -Rz_BF * x_tmp + y_tmp + Rx_BF * z_tmp;
	      p.z = Ry_BF * x_tmp - Rx_BF * y_tmp + z_tmp;
	    } //cs_geocentric_from_wgs84()
	  }
	};

	/** point object, nothing fancy, just allows values to be
	    passed back and forth by reference rather than by value.
	    Other point classes may be used as long as they have
	    x and y properties, which will get modified in the transform method.
	*/
	module.exports = datum;

	},{}],30:[function(_dereq_,module,exports){
	var PJD_3PARAM = 1;
	var PJD_7PARAM = 2;
	var PJD_GRIDSHIFT = 3;
	var PJD_NODATUM = 5; // WGS84 or equivalent
	var SRS_WGS84_SEMIMAJOR = 6378137; // only used in grid shift transforms
	var SRS_WGS84_ESQUARED = 0.006694379990141316; //DGR: 2012-07-29
	module.exports = function(source, dest, point) {
	  var wp, i, l;

	  function checkParams(fallback) {
	    return (fallback === PJD_3PARAM || fallback === PJD_7PARAM);
	  }
	  // Short cut if the datums are identical.
	  if (source.compare_datums(dest)) {
	    return point; // in this case, zero is sucess,
	    // whereas cs_compare_datums returns 1 to indicate TRUE
	    // confusing, should fix this
	  }

	  // Explicitly skip datum transform by setting 'datum=none' as parameter for either source or dest
	  if (source.datum_type === PJD_NODATUM || dest.datum_type === PJD_NODATUM) {
	    return point;
	  }

	  //DGR: 2012-07-29 : add nadgrids support (begin)
	  var src_a = source.a;
	  var src_es = source.es;

	  var dst_a = dest.a;
	  var dst_es = dest.es;

	  var fallback = source.datum_type;
	  // If this datum requires grid shifts, then apply it to geodetic coordinates.
	  if (fallback === PJD_GRIDSHIFT) {
	    if (this.apply_gridshift(source, 0, point) === 0) {
	      source.a = SRS_WGS84_SEMIMAJOR;
	      source.es = SRS_WGS84_ESQUARED;
	    }
	    else {
	      // try 3 or 7 params transformation or nothing ?
	      if (!source.datum_params) {
	        source.a = src_a;
	        source.es = source.es;
	        return point;
	      }
	      wp = 1;
	      for (i = 0, l = source.datum_params.length; i < l; i++) {
	        wp *= source.datum_params[i];
	      }
	      if (wp === 0) {
	        source.a = src_a;
	        source.es = source.es;
	        return point;
	      }
	      if (source.datum_params.length > 3) {
	        fallback = PJD_7PARAM;
	      }
	      else {
	        fallback = PJD_3PARAM;
	      }
	    }
	  }
	  if (dest.datum_type === PJD_GRIDSHIFT) {
	    dest.a = SRS_WGS84_SEMIMAJOR;
	    dest.es = SRS_WGS84_ESQUARED;
	  }
	  // Do we need to go through geocentric coordinates?
	  if (source.es !== dest.es || source.a !== dest.a || checkParams(fallback) || checkParams(dest.datum_type)) {
	    //DGR: 2012-07-29 : add nadgrids support (end)
	    // Convert to geocentric coordinates.
	    source.geodetic_to_geocentric(point);
	    // CHECK_RETURN;
	    // Convert between datums
	    if (checkParams(source.datum_type)) {
	      source.geocentric_to_wgs84(point);
	      // CHECK_RETURN;
	    }
	    if (checkParams(dest.datum_type)) {
	      dest.geocentric_from_wgs84(point);
	      // CHECK_RETURN;
	    }
	    // Convert back to geodetic coordinates
	    dest.geocentric_to_geodetic(point);
	    // CHECK_RETURN;
	  }
	  // Apply grid shift to destination if required
	  if (dest.datum_type === PJD_GRIDSHIFT) {
	    this.apply_gridshift(dest, 1, point);
	    // CHECK_RETURN;
	  }

	  source.a = src_a;
	  source.es = src_es;
	  dest.a = dst_a;
	  dest.es = dst_es;

	  return point;
	};


	},{}],31:[function(_dereq_,module,exports){
	var globals = _dereq_('./global');
	var parseProj = _dereq_('./projString');
	var wkt = _dereq_('./wkt');

	function defs(name) {
	  /*global console*/
	  var that = this;
	  if (arguments.length === 2) {
	    var def = arguments[1];
	    if (typeof def === 'string') {
	      if (def.charAt(0) === '+') {
	        defs[name] = parseProj(arguments[1]);
	      }
	      else {
	        defs[name] = wkt(arguments[1]);
	      }
	    } else {
	      defs[name] = def;
	    }
	  }
	  else if (arguments.length === 1) {
	    if (Array.isArray(name)) {
	      return name.map(function(v) {
	        if (Array.isArray(v)) {
	          defs.apply(that, v);
	        }
	        else {
	          defs(v);
	        }
	      });
	    }
	    else if (typeof name === 'string') {
	      if (name in defs) {
	        return defs[name];
	      }
	    }
	    else if ('EPSG' in name) {
	      defs['EPSG:' + name.EPSG] = name;
	    }
	    else if ('ESRI' in name) {
	      defs['ESRI:' + name.ESRI] = name;
	    }
	    else if ('IAU2000' in name) {
	      defs['IAU2000:' + name.IAU2000] = name;
	    }
	    else {
	      console.log(name);
	    }
	    return;
	  }


	}
	globals(defs);
	module.exports = defs;

	},{"./global":34,"./projString":37,"./wkt":65}],32:[function(_dereq_,module,exports){
	var Datum = _dereq_('./constants/Datum');
	var Ellipsoid = _dereq_('./constants/Ellipsoid');
	var extend = _dereq_('./extend');
	var datum = _dereq_('./datum');
	var EPSLN = 1.0e-10;
	// ellipoid pj_set_ell.c
	var SIXTH = 0.1666666666666666667;
	/* 1/6 */
	var RA4 = 0.04722222222222222222;
	/* 17/360 */
	var RA6 = 0.02215608465608465608;
	module.exports = function(json) {
	  // DGR 2011-03-20 : nagrids -> nadgrids
	  if (json.datumCode && json.datumCode !== 'none') {
	    var datumDef = Datum[json.datumCode];
	    if (datumDef) {
	      json.datum_params = datumDef.towgs84 ? datumDef.towgs84.split(',') : null;
	      json.ellps = datumDef.ellipse;
	      json.datumName = datumDef.datumName ? datumDef.datumName : json.datumCode;
	    }
	  }
	  if (!json.a) { // do we have an ellipsoid?
	    var ellipse = Ellipsoid[json.ellps] ? Ellipsoid[json.ellps] : Ellipsoid.WGS84;
	    extend(json, ellipse);
	  }
	  if (json.rf && !json.b) {
	    json.b = (1.0 - 1.0 / json.rf) * json.a;
	  }
	  if (json.rf === 0 || Math.abs(json.a - json.b) < EPSLN) {
	    json.sphere = true;
	    json.b = json.a;
	  }
	  json.a2 = json.a * json.a; // used in geocentric
	  json.b2 = json.b * json.b; // used in geocentric
	  json.es = (json.a2 - json.b2) / json.a2; // e ^ 2
	  json.e = Math.sqrt(json.es); // eccentricity
	  if (json.R_A) {
	    json.a *= 1 - json.es * (SIXTH + json.es * (RA4 + json.es * RA6));
	    json.a2 = json.a * json.a;
	    json.b2 = json.b * json.b;
	    json.es = 0;
	  }
	  json.ep2 = (json.a2 - json.b2) / json.b2; // used in geocentric
	  if (!json.k0) {
	    json.k0 = 1.0; //default value
	  }
	  //DGR 2010-11-12: axis
	  if (!json.axis) {
	    json.axis = "enu";
	  }

	  if (!json.datum) {
	    json.datum = datum(json);
	  }
	  return json;
	};

	},{"./constants/Datum":25,"./constants/Ellipsoid":26,"./datum":29,"./extend":33}],33:[function(_dereq_,module,exports){
	module.exports = function(destination, source) {
	  destination = destination || {};
	  var value, property;
	  if (!source) {
	    return destination;
	  }
	  for (property in source) {
	    value = source[property];
	    if (value !== undefined) {
	      destination[property] = value;
	    }
	  }
	  return destination;
	};

	},{}],34:[function(_dereq_,module,exports){
	module.exports = function(defs) {
	  defs('EPSG:4326', "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees");
	  defs('EPSG:4269', "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees");
	  defs('EPSG:3857', "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs");

	  defs.WGS84 = defs['EPSG:4326'];
	  defs['EPSG:3785'] = defs['EPSG:3857']; // maintain backward compat, official code is 3857
	  defs.GOOGLE = defs['EPSG:3857'];
	  defs['EPSG:900913'] = defs['EPSG:3857'];
	  defs['EPSG:102113'] = defs['EPSG:3857'];
	};

	},{}],35:[function(_dereq_,module,exports){
	var proj4 = _dereq_('./core');
	proj4.defaultDatum = 'WGS84'; //default datum
	proj4.Proj = _dereq_('./Proj');
	proj4.WGS84 = new proj4.Proj('WGS84');
	proj4.Point = _dereq_('./Point');
	proj4.toPoint = _dereq_("./common/toPoint");
	proj4.defs = _dereq_('./defs');
	proj4.transform = _dereq_('./transform');
	proj4.mgrs = _dereq_('mgrs');
	proj4.version = _dereq_('../package.json').version;
	_dereq_('./includedProjections')(proj4);
	module.exports = proj4;
	},{"../package.json":67,"./Point":1,"./Proj":2,"./common/toPoint":23,"./core":28,"./defs":31,"./includedProjections":"gWUPNW","./transform":64,"mgrs":66}],36:[function(_dereq_,module,exports){
	var defs = _dereq_('./defs');
	var wkt = _dereq_('./wkt');
	var projStr = _dereq_('./projString');
	function testObj(code){
	  return typeof code === 'string';
	}
	function testDef(code){
	  return code in defs;
	}
	function testWKT(code){
	  var codeWords = ['GEOGCS','GEOCCS','PROJCS','LOCAL_CS'];
	  return codeWords.reduce(function(a,b){
	    return a+1+code.indexOf(b);
	  },0);
	}
	function testProj(code){
	  return code[0] === '+';
	}
	function parse(code){
	  if (testObj(code)) {
	    //check to see if this is a WKT string
	    if (testDef(code)) {
	      return defs[code];
	    }
	    else if (testWKT(code)) {
	      return wkt(code);
	    }
	    else if (testProj(code)) {
	      return projStr(code);
	    }
	  }else{
	    return code;
	  }
	}

	module.exports = parse;
	},{"./defs":31,"./projString":37,"./wkt":65}],37:[function(_dereq_,module,exports){
	var D2R = 0.01745329251994329577;
	var PrimeMeridian = _dereq_('./constants/PrimeMeridian');

	module.exports = function(defData) {
	  var self = {};
	  var paramObj = {};
	  defData.split("+").map(function(v) {
	    return v.trim();
	  }).filter(function(a) {
	    return a;
	  }).forEach(function(a) {
	    var split = a.split("=");
	    split.push(true);
	    paramObj[split[0].toLowerCase()] = split[1];
	  });
	  var paramName, paramVal, paramOutname;
	  var params = {
	    proj: 'projName',
	    datum: 'datumCode',
	    rf: function(v) {
	      self.rf = parseFloat(v);
	    },
	    lat_0: function(v) {
	      self.lat0 = v * D2R;
	    },
	    lat_1: function(v) {
	      self.lat1 = v * D2R;
	    },
	    lat_2: function(v) {
	      self.lat2 = v * D2R;
	    },
	    lat_ts: function(v) {
	      self.lat_ts = v * D2R;
	    },
	    lon_0: function(v) {
	      self.long0 = v * D2R;
	    },
	    lon_1: function(v) {
	      self.long1 = v * D2R;
	    },
	    lon_2: function(v) {
	      self.long2 = v * D2R;
	    },
	    alpha: function(v) {
	      self.alpha = parseFloat(v) * D2R;
	    },
	    lonc: function(v) {
	      self.longc = v * D2R;
	    },
	    x_0: function(v) {
	      self.x0 = parseFloat(v);
	    },
	    y_0: function(v) {
	      self.y0 = parseFloat(v);
	    },
	    k_0: function(v) {
	      self.k0 = parseFloat(v);
	    },
	    k: function(v) {
	      self.k0 = parseFloat(v);
	    },
	    a: function(v) {
	      self.a = parseFloat(v);
	    },
	    b: function(v) {
	      self.b = parseFloat(v);
	    },
	    r_a: function() {
	      self.R_A = true;
	    },
	    zone: function(v) {
	      self.zone = parseInt(v, 10);
	    },
	    south: function() {
	      self.utmSouth = true;
	    },
	    towgs84: function(v) {
	      self.datum_params = v.split(",").map(function(a) {
	        return parseFloat(a);
	      });
	    },
	    to_meter: function(v) {
	      self.to_meter = parseFloat(v);
	    },
	    from_greenwich: function(v) {
	      self.from_greenwich = v * D2R;
	    },
	    pm: function(v) {
	      self.from_greenwich = (PrimeMeridian[v] ? PrimeMeridian[v] : parseFloat(v)) * D2R;
	    },
	    nadgrids: function(v) {
	      if (v === '@null') {
	        self.datumCode = 'none';
	      }
	      else {
	        self.nadgrids = v;
	      }
	    },
	    axis: function(v) {
	      var legalAxis = "ewnsud";
	      if (v.length === 3 && legalAxis.indexOf(v.substr(0, 1)) !== -1 && legalAxis.indexOf(v.substr(1, 1)) !== -1 && legalAxis.indexOf(v.substr(2, 1)) !== -1) {
	        self.axis = v;
	      }
	    }
	  };
	  for (paramName in paramObj) {
	    paramVal = paramObj[paramName];
	    if (paramName in params) {
	      paramOutname = params[paramName];
	      if (typeof paramOutname === 'function') {
	        paramOutname(paramVal);
	      }
	      else {
	        self[paramOutname] = paramVal;
	      }
	    }
	    else {
	      self[paramName] = paramVal;
	    }
	  }
	  if(typeof self.datumCode === 'string' && self.datumCode !== "WGS84"){
	    self.datumCode = self.datumCode.toLowerCase();
	  }
	  return self;
	};

	},{"./constants/PrimeMeridian":27}],38:[function(_dereq_,module,exports){
	var projs = [
	  _dereq_('./projections/merc'),
	  _dereq_('./projections/longlat')
	];
	var names = {};
	var projStore = [];

	function add(proj, i) {
	  var len = projStore.length;
	  if (!proj.names) {
	    console.log(i);
	    return true;
	  }
	  projStore[len] = proj;
	  proj.names.forEach(function(n) {
	    names[n.toLowerCase()] = len;
	  });
	  return this;
	}

	exports.add = add;

	exports.get = function(name) {
	  if (!name) {
	    return false;
	  }
	  var n = name.toLowerCase();
	  if (typeof names[n] !== 'undefined' && projStore[names[n]]) {
	    return projStore[names[n]];
	  }
	};
	exports.start = function() {
	  projs.forEach(add);
	};

	},{"./projections/longlat":50,"./projections/merc":51}],39:[function(_dereq_,module,exports){
	var EPSLN = 1.0e-10;
	var msfnz = _dereq_('../common/msfnz');
	var qsfnz = _dereq_('../common/qsfnz');
	var adjust_lon = _dereq_('../common/adjust_lon');
	var asinz = _dereq_('../common/asinz');
	exports.init = function() {

	  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
	    return;
	  }
	  this.temp = this.b / this.a;
	  this.es = 1 - Math.pow(this.temp, 2);
	  this.e3 = Math.sqrt(this.es);

	  this.sin_po = Math.sin(this.lat1);
	  this.cos_po = Math.cos(this.lat1);
	  this.t1 = this.sin_po;
	  this.con = this.sin_po;
	  this.ms1 = msfnz(this.e3, this.sin_po, this.cos_po);
	  this.qs1 = qsfnz(this.e3, this.sin_po, this.cos_po);

	  this.sin_po = Math.sin(this.lat2);
	  this.cos_po = Math.cos(this.lat2);
	  this.t2 = this.sin_po;
	  this.ms2 = msfnz(this.e3, this.sin_po, this.cos_po);
	  this.qs2 = qsfnz(this.e3, this.sin_po, this.cos_po);

	  this.sin_po = Math.sin(this.lat0);
	  this.cos_po = Math.cos(this.lat0);
	  this.t3 = this.sin_po;
	  this.qs0 = qsfnz(this.e3, this.sin_po, this.cos_po);

	  if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
	    this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1);
	  }
	  else {
	    this.ns0 = this.con;
	  }
	  this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1;
	  this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0;
	};

	/* Albers Conical Equal Area forward equations--mapping lat,long to x,y
	  -------------------------------------------------------------------*/
	exports.forward = function(p) {

	  var lon = p.x;
	  var lat = p.y;

	  this.sin_phi = Math.sin(lat);
	  this.cos_phi = Math.cos(lat);

	  var qs = qsfnz(this.e3, this.sin_phi, this.cos_phi);
	  var rh1 = this.a * Math.sqrt(this.c - this.ns0 * qs) / this.ns0;
	  var theta = this.ns0 * adjust_lon(lon - this.long0);
	  var x = rh1 * Math.sin(theta) + this.x0;
	  var y = this.rh - rh1 * Math.cos(theta) + this.y0;

	  p.x = x;
	  p.y = y;
	  return p;
	};


	exports.inverse = function(p) {
	  var rh1, qs, con, theta, lon, lat;

	  p.x -= this.x0;
	  p.y = this.rh - p.y + this.y0;
	  if (this.ns0 >= 0) {
	    rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
	    con = 1;
	  }
	  else {
	    rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
	    con = -1;
	  }
	  theta = 0;
	  if (rh1 !== 0) {
	    theta = Math.atan2(con * p.x, con * p.y);
	  }
	  con = rh1 * this.ns0 / this.a;
	  if (this.sphere) {
	    lat = Math.asin((this.c - con * con) / (2 * this.ns0));
	  }
	  else {
	    qs = (this.c - con * con) / this.ns0;
	    lat = this.phi1z(this.e3, qs);
	  }

	  lon = adjust_lon(theta / this.ns0 + this.long0);
	  p.x = lon;
	  p.y = lat;
	  return p;
	};

	/* Function to compute phi1, the latitude for the inverse of the
	   Albers Conical Equal-Area projection.
	-------------------------------------------*/
	exports.phi1z = function(eccent, qs) {
	  var sinphi, cosphi, con, com, dphi;
	  var phi = asinz(0.5 * qs);
	  if (eccent < EPSLN) {
	    return phi;
	  }

	  var eccnts = eccent * eccent;
	  for (var i = 1; i <= 25; i++) {
	    sinphi = Math.sin(phi);
	    cosphi = Math.cos(phi);
	    con = eccent * sinphi;
	    com = 1 - con * con;
	    dphi = 0.5 * com * com / cosphi * (qs / (1 - eccnts) - sinphi / com + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
	    phi = phi + dphi;
	    if (Math.abs(dphi) <= 1e-7) {
	      return phi;
	    }
	  }
	  return null;
	};
	exports.names = ["Albers_Conic_Equal_Area", "Albers", "aea"];

	},{"../common/adjust_lon":5,"../common/asinz":6,"../common/msfnz":15,"../common/qsfnz":20}],40:[function(_dereq_,module,exports){
	var adjust_lon = _dereq_('../common/adjust_lon');
	var HALF_PI = Math.PI/2;
	var EPSLN = 1.0e-10;
	var mlfn = _dereq_('../common/mlfn');
	var e0fn = _dereq_('../common/e0fn');
	var e1fn = _dereq_('../common/e1fn');
	var e2fn = _dereq_('../common/e2fn');
	var e3fn = _dereq_('../common/e3fn');
	var gN = _dereq_('../common/gN');
	var asinz = _dereq_('../common/asinz');
	var imlfn = _dereq_('../common/imlfn');
	exports.init = function() {
	  this.sin_p12 = Math.sin(this.lat0);
	  this.cos_p12 = Math.cos(this.lat0);
	};

	exports.forward = function(p) {
	  var lon = p.x;
	  var lat = p.y;
	  var sinphi = Math.sin(p.y);
	  var cosphi = Math.cos(p.y);
	  var dlon = adjust_lon(lon - this.long0);
	  var e0, e1, e2, e3, Mlp, Ml, tanphi, Nl1, Nl, psi, Az, G, H, GH, Hs, c, kp, cos_c, s, s2, s3, s4, s5;
	  if (this.sphere) {
	    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
	      //North Pole case
	      p.x = this.x0 + this.a * (HALF_PI - lat) * Math.sin(dlon);
	      p.y = this.y0 - this.a * (HALF_PI - lat) * Math.cos(dlon);
	      return p;
	    }
	    else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
	      //South Pole case
	      p.x = this.x0 + this.a * (HALF_PI + lat) * Math.sin(dlon);
	      p.y = this.y0 + this.a * (HALF_PI + lat) * Math.cos(dlon);
	      return p;
	    }
	    else {
	      //default case
	      cos_c = this.sin_p12 * sinphi + this.cos_p12 * cosphi * Math.cos(dlon);
	      c = Math.acos(cos_c);
	      kp = c / Math.sin(c);
	      p.x = this.x0 + this.a * kp * cosphi * Math.sin(dlon);
	      p.y = this.y0 + this.a * kp * (this.cos_p12 * sinphi - this.sin_p12 * cosphi * Math.cos(dlon));
	      return p;
	    }
	  }
	  else {
	    e0 = e0fn(this.es);
	    e1 = e1fn(this.es);
	    e2 = e2fn(this.es);
	    e3 = e3fn(this.es);
	    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
	      //North Pole case
	      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
	      Ml = this.a * mlfn(e0, e1, e2, e3, lat);
	      p.x = this.x0 + (Mlp - Ml) * Math.sin(dlon);
	      p.y = this.y0 - (Mlp - Ml) * Math.cos(dlon);
	      return p;
	    }
	    else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
	      //South Pole case
	      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
	      Ml = this.a * mlfn(e0, e1, e2, e3, lat);
	      p.x = this.x0 + (Mlp + Ml) * Math.sin(dlon);
	      p.y = this.y0 + (Mlp + Ml) * Math.cos(dlon);
	      return p;
	    }
	    else {
	      //Default case
	      tanphi = sinphi / cosphi;
	      Nl1 = gN(this.a, this.e, this.sin_p12);
	      Nl = gN(this.a, this.e, sinphi);
	      psi = Math.atan((1 - this.es) * tanphi + this.es * Nl1 * this.sin_p12 / (Nl * cosphi));
	      Az = Math.atan2(Math.sin(dlon), this.cos_p12 * Math.tan(psi) - this.sin_p12 * Math.cos(dlon));
	      if (Az === 0) {
	        s = Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
	      }
	      else if (Math.abs(Math.abs(Az) - Math.PI) <= EPSLN) {
	        s = -Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
	      }
	      else {
	        s = Math.asin(Math.sin(dlon) * Math.cos(psi) / Math.sin(Az));
	      }
	      G = this.e * this.sin_p12 / Math.sqrt(1 - this.es);
	      H = this.e * this.cos_p12 * Math.cos(Az) / Math.sqrt(1 - this.es);
	      GH = G * H;
	      Hs = H * H;
	      s2 = s * s;
	      s3 = s2 * s;
	      s4 = s3 * s;
	      s5 = s4 * s;
	      c = Nl1 * s * (1 - s2 * Hs * (1 - Hs) / 6 + s3 / 8 * GH * (1 - 2 * Hs) + s4 / 120 * (Hs * (4 - 7 * Hs) - 3 * G * G * (1 - 7 * Hs)) - s5 / 48 * GH);
	      p.x = this.x0 + c * Math.sin(Az);
	      p.y = this.y0 + c * Math.cos(Az);
	      return p;
	    }
	  }


	};

	exports.inverse = function(p) {
	  p.x -= this.x0;
	  p.y -= this.y0;
	  var rh, z, sinz, cosz, lon, lat, con, e0, e1, e2, e3, Mlp, M, N1, psi, Az, cosAz, tmp, A, B, D, Ee, F;
	  if (this.sphere) {
	    rh = Math.sqrt(p.x * p.x + p.y * p.y);
	    if (rh > (2 * HALF_PI * this.a)) {
	      return;
	    }
	    z = rh / this.a;

	    sinz = Math.sin(z);
	    cosz = Math.cos(z);

	    lon = this.long0;
	    if (Math.abs(rh) <= EPSLN) {
	      lat = this.lat0;
	    }
	    else {
	      lat = asinz(cosz * this.sin_p12 + (p.y * sinz * this.cos_p12) / rh);
	      con = Math.abs(this.lat0) - HALF_PI;
	      if (Math.abs(con) <= EPSLN) {
	        if (this.lat0 >= 0) {
	          lon = adjust_lon(this.long0 + Math.atan2(p.x, - p.y));
	        }
	        else {
	          lon = adjust_lon(this.long0 - Math.atan2(-p.x, p.y));
	        }
	      }
	      else {
	        /*con = cosz - this.sin_p12 * Math.sin(lat);
	        if ((Math.abs(con) < EPSLN) && (Math.abs(p.x) < EPSLN)) {
	          //no-op, just keep the lon value as is
	        } else {
	          var temp = Math.atan2((p.x * sinz * this.cos_p12), (con * rh));
	          lon = adjust_lon(this.long0 + Math.atan2((p.x * sinz * this.cos_p12), (con * rh)));
	        }*/
	        lon = adjust_lon(this.long0 + Math.atan2(p.x * sinz, rh * this.cos_p12 * cosz - p.y * this.sin_p12 * sinz));
	      }
	    }

	    p.x = lon;
	    p.y = lat;
	    return p;
	  }
	  else {
	    e0 = e0fn(this.es);
	    e1 = e1fn(this.es);
	    e2 = e2fn(this.es);
	    e3 = e3fn(this.es);
	    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
	      //North pole case
	      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
	      rh = Math.sqrt(p.x * p.x + p.y * p.y);
	      M = Mlp - rh;
	      lat = imlfn(M / this.a, e0, e1, e2, e3);
	      lon = adjust_lon(this.long0 + Math.atan2(p.x, - 1 * p.y));
	      p.x = lon;
	      p.y = lat;
	      return p;
	    }
	    else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
	      //South pole case
	      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
	      rh = Math.sqrt(p.x * p.x + p.y * p.y);
	      M = rh - Mlp;

	      lat = imlfn(M / this.a, e0, e1, e2, e3);
	      lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));
	      p.x = lon;
	      p.y = lat;
	      return p;
	    }
	    else {
	      //default case
	      rh = Math.sqrt(p.x * p.x + p.y * p.y);
	      Az = Math.atan2(p.x, p.y);
	      N1 = gN(this.a, this.e, this.sin_p12);
	      cosAz = Math.cos(Az);
	      tmp = this.e * this.cos_p12 * cosAz;
	      A = -tmp * tmp / (1 - this.es);
	      B = 3 * this.es * (1 - A) * this.sin_p12 * this.cos_p12 * cosAz / (1 - this.es);
	      D = rh / N1;
	      Ee = D - A * (1 + A) * Math.pow(D, 3) / 6 - B * (1 + 3 * A) * Math.pow(D, 4) / 24;
	      F = 1 - A * Ee * Ee / 2 - D * Ee * Ee * Ee / 6;
	      psi = Math.asin(this.sin_p12 * Math.cos(Ee) + this.cos_p12 * Math.sin(Ee) * cosAz);
	      lon = adjust_lon(this.long0 + Math.asin(Math.sin(Az) * Math.sin(Ee) / Math.cos(psi)));
	      lat = Math.atan((1 - this.es * F * this.sin_p12 / Math.sin(psi)) * Math.tan(psi) / (1 - this.es));
	      p.x = lon;
	      p.y = lat;
	      return p;
	    }
	  }

	};
	exports.names = ["Azimuthal_Equidistant", "aeqd"];

	},{"../common/adjust_lon":5,"../common/asinz":6,"../common/e0fn":7,"../common/e1fn":8,"../common/e2fn":9,"../common/e3fn":10,"../common/gN":11,"../common/imlfn":12,"../common/mlfn":14}],41:[function(_dereq_,module,exports){
	var mlfn = _dereq_('../common/mlfn');
	var e0fn = _dereq_('../common/e0fn');
	var e1fn = _dereq_('../common/e1fn');
	var e2fn = _dereq_('../common/e2fn');
	var e3fn = _dereq_('../common/e3fn');
	var gN = _dereq_('../common/gN');
	var adjust_lon = _dereq_('../common/adjust_lon');
	var adjust_lat = _dereq_('../common/adjust_lat');
	var imlfn = _dereq_('../common/imlfn');
	var HALF_PI = Math.PI/2;
	var EPSLN = 1.0e-10;
	exports.init = function() {
	  if (!this.sphere) {
	    this.e0 = e0fn(this.es);
	    this.e1 = e1fn(this.es);
	    this.e2 = e2fn(this.es);
	    this.e3 = e3fn(this.es);
	    this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
	  }
	};



	/* Cassini forward equations--mapping lat,long to x,y
	  -----------------------------------------------------------------------*/
	exports.forward = function(p) {

	  /* Forward equations
	      -----------------*/
	  var x, y;
	  var lam = p.x;
	  var phi = p.y;
	  lam = adjust_lon(lam - this.long0);

	  if (this.sphere) {
	    x = this.a * Math.asin(Math.cos(phi) * Math.sin(lam));
	    y = this.a * (Math.atan2(Math.tan(phi), Math.cos(lam)) - this.lat0);
	  }
	  else {
	    //ellipsoid
	    var sinphi = Math.sin(phi);
	    var cosphi = Math.cos(phi);
	    var nl = gN(this.a, this.e, sinphi);
	    var tl = Math.tan(phi) * Math.tan(phi);
	    var al = lam * Math.cos(phi);
	    var asq = al * al;
	    var cl = this.es * cosphi * cosphi / (1 - this.es);
	    var ml = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);

	    x = nl * al * (1 - asq * tl * (1 / 6 - (8 - tl + 8 * cl) * asq / 120));
	    y = ml - this.ml0 + nl * sinphi / cosphi * asq * (0.5 + (5 - tl + 6 * cl) * asq / 24);


	  }

	  p.x = x + this.x0;
	  p.y = y + this.y0;
	  return p;
	};

	/* Inverse equations
	  -----------------*/
	exports.inverse = function(p) {
	  p.x -= this.x0;
	  p.y -= this.y0;
	  var x = p.x / this.a;
	  var y = p.y / this.a;
	  var phi, lam;

	  if (this.sphere) {
	    var dd = y + this.lat0;
	    phi = Math.asin(Math.sin(dd) * Math.cos(x));
	    lam = Math.atan2(Math.tan(x), Math.cos(dd));
	  }
	  else {
	    /* ellipsoid */
	    var ml1 = this.ml0 / this.a + y;
	    var phi1 = imlfn(ml1, this.e0, this.e1, this.e2, this.e3);
	    if (Math.abs(Math.abs(phi1) - HALF_PI) <= EPSLN) {
	      p.x = this.long0;
	      p.y = HALF_PI;
	      if (y < 0) {
	        p.y *= -1;
	      }
	      return p;
	    }
	    var nl1 = gN(this.a, this.e, Math.sin(phi1));

	    var rl1 = nl1 * nl1 * nl1 / this.a / this.a * (1 - this.es);
	    var tl1 = Math.pow(Math.tan(phi1), 2);
	    var dl = x * this.a / nl1;
	    var dsq = dl * dl;
	    phi = phi1 - nl1 * Math.tan(phi1) / rl1 * dl * dl * (0.5 - (1 + 3 * tl1) * dl * dl / 24);
	    lam = dl * (1 - dsq * (tl1 / 3 + (1 + 3 * tl1) * tl1 * dsq / 15)) / Math.cos(phi1);

	  }

	  p.x = adjust_lon(lam + this.long0);
	  p.y = adjust_lat(phi);
	  return p;

	};
	exports.names = ["Cassini", "Cassini_Soldner", "cass"];
	},{"../common/adjust_lat":4,"../common/adjust_lon":5,"../common/e0fn":7,"../common/e1fn":8,"../common/e2fn":9,"../common/e3fn":10,"../common/gN":11,"../common/imlfn":12,"../common/mlfn":14}],42:[function(_dereq_,module,exports){
	var adjust_lon = _dereq_('../common/adjust_lon');
	var qsfnz = _dereq_('../common/qsfnz');
	var msfnz = _dereq_('../common/msfnz');
	var iqsfnz = _dereq_('../common/iqsfnz');
	/*
	  reference:  
	    "Cartographic Projection Procedures for the UNIX Environment-
	    A User's Manual" by Gerald I. Evenden,
	    USGS Open File Report 90-284and Release 4 Interim Reports (2003)
	*/
	exports.init = function() {
	  //no-op
	  if (!this.sphere) {
	    this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
	  }
	};


	/* Cylindrical Equal Area forward equations--mapping lat,long to x,y
	    ------------------------------------------------------------*/
	exports.forward = function(p) {
	  var lon = p.x;
	  var lat = p.y;
	  var x, y;
	  /* Forward equations
	      -----------------*/
	  var dlon = adjust_lon(lon - this.long0);
	  if (this.sphere) {
	    x = this.x0 + this.a * dlon * Math.cos(this.lat_ts);
	    y = this.y0 + this.a * Math.sin(lat) / Math.cos(this.lat_ts);
	  }
	  else {
	    var qs = qsfnz(this.e, Math.sin(lat));
	    x = this.x0 + this.a * this.k0 * dlon;
	    y = this.y0 + this.a * qs * 0.5 / this.k0;
	  }

	  p.x = x;
	  p.y = y;
	  return p;
	};

	/* Cylindrical Equal Area inverse equations--mapping x,y to lat/long
	    ------------------------------------------------------------*/
	exports.inverse = function(p) {
	  p.x -= this.x0;
	  p.y -= this.y0;
	  var lon, lat;

	  if (this.sphere) {
	    lon = adjust_lon(this.long0 + (p.x / this.a) / Math.cos(this.lat_ts));
	    lat = Math.asin((p.y / this.a) * Math.cos(this.lat_ts));
	  }
	  else {
	    lat = iqsfnz(this.e, 2 * p.y * this.k0 / this.a);
	    lon = adjust_lon(this.long0 + p.x / (this.a * this.k0));
	  }

	  p.x = lon;
	  p.y = lat;
	  return p;
	};
	exports.names = ["cea"];

	},{"../common/adjust_lon":5,"../common/iqsfnz":13,"../common/msfnz":15,"../common/qsfnz":20}],43:[function(_dereq_,module,exports){
	var adjust_lon = _dereq_('../common/adjust_lon');
	var adjust_lat = _dereq_('../common/adjust_lat');
	exports.init = function() {

	  this.x0 = this.x0 || 0;
	  this.y0 = this.y0 || 0;
	  this.lat0 = this.lat0 || 0;
	  this.long0 = this.long0 || 0;
	  this.lat_ts = this.lat_ts || 0;
	  this.title = this.title || "Equidistant Cylindrical (Plate Carre)";

	  this.rc = Math.cos(this.lat_ts);
	};


	// forward equations--mapping lat,long to x,y
	// -----------------------------------------------------------------
	exports.forward = function(p) {

	  var lon = p.x;
	  var lat = p.y;

	  var dlon = adjust_lon(lon - this.long0);
	  var dlat = adjust_lat(lat - this.lat0);
	  p.x = this.x0 + (this.a * dlon * this.rc);
	  p.y = this.y0 + (this.a * dlat);
	  return p;
	};

	// inverse equations--mapping x,y to lat/long
	// -----------------------------------------------------------------
	exports.inverse = function(p) {

	  var x = p.x;
	  var y = p.y;

	  p.x = adjust_lon(this.long0 + ((x - this.x0) / (this.a * this.rc)));
	  p.y = adjust_lat(this.lat0 + ((y - this.y0) / (this.a)));
	  return p;
	};
	exports.names = ["Equirectangular", "Equidistant_Cylindrical", "eqc"];

	},{"../common/adjust_lat":4,"../common/adjust_lon":5}],44:[function(_dereq_,module,exports){
	var e0fn = _dereq_('../common/e0fn');
	var e1fn = _dereq_('../common/e1fn');
	var e2fn = _dereq_('../common/e2fn');
	var e3fn = _dereq_('../common/e3fn');
	var msfnz = _dereq_('../common/msfnz');
	var mlfn = _dereq_('../common/mlfn');
	var adjust_lon = _dereq_('../common/adjust_lon');
	var adjust_lat = _dereq_('../common/adjust_lat');
	var imlfn = _dereq_('../common/imlfn');
	var EPSLN = 1.0e-10;
	exports.init = function() {

	  /* Place parameters in static storage for common use
	      -------------------------------------------------*/
	  // Standard Parallels cannot be equal and on opposite sides of the equator
	  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
	    return;
	  }
	  this.lat2 = this.lat2 || this.lat1;
	  this.temp = this.b / this.a;
	  this.es = 1 - Math.pow(this.temp, 2);
	  this.e = Math.sqrt(this.es);
	  this.e0 = e0fn(this.es);
	  this.e1 = e1fn(this.es);
	  this.e2 = e2fn(this.es);
	  this.e3 = e3fn(this.es);

	  this.sinphi = Math.sin(this.lat1);
	  this.cosphi = Math.cos(this.lat1);

	  this.ms1 = msfnz(this.e, this.sinphi, this.cosphi);
	  this.ml1 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat1);

	  if (Math.abs(this.lat1 - this.lat2) < EPSLN) {
	    this.ns = this.sinphi;
	  }
	  else {
	    this.sinphi = Math.sin(this.lat2);
	    this.cosphi = Math.cos(this.lat2);
	    this.ms2 = msfnz(this.e, this.sinphi, this.cosphi);
	    this.ml2 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat2);
	    this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1);
	  }
	  this.g = this.ml1 + this.ms1 / this.ns;
	  this.ml0 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
	  this.rh = this.a * (this.g - this.ml0);
	};


	/* Equidistant Conic forward equations--mapping lat,long to x,y
	  -----------------------------------------------------------*/
	exports.forward = function(p) {
	  var lon = p.x;
	  var lat = p.y;
	  var rh1;

	  /* Forward equations
	      -----------------*/
	  if (this.sphere) {
	    rh1 = this.a * (this.g - lat);
	  }
	  else {
	    var ml = mlfn(this.e0, this.e1, this.e2, this.e3, lat);
	    rh1 = this.a * (this.g - ml);
	  }
	  var theta = this.ns * adjust_lon(lon - this.long0);
	  var x = this.x0 + rh1 * Math.sin(theta);
	  var y = this.y0 + this.rh - rh1 * Math.cos(theta);
	  p.x = x;
	  p.y = y;
	  return p;
	};

	/* Inverse equations
	  -----------------*/
	exports.inverse = function(p) {
	  p.x -= this.x0;
	  p.y = this.rh - p.y + this.y0;
	  var con, rh1, lat, lon;
	  if (this.ns >= 0) {
	    rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
	    con = 1;
	  }
	  else {
	    rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
	    con = -1;
	  }
	  var theta = 0;
	  if (rh1 !== 0) {
	    theta = Math.atan2(con * p.x, con * p.y);
	  }

	  if (this.sphere) {
	    lon = adjust_lon(this.long0 + theta / this.ns);
	    lat = adjust_lat(this.g - rh1 / this.a);
	    p.x = lon;
	    p.y = lat;
	    return p;
	  }
	  else {
	    var ml = this.g - rh1 / this.a;
	    lat = imlfn(ml, this.e0, this.e1, this.e2, this.e3);
	    lon = adjust_lon(this.long0 + theta / this.ns);
	    p.x = lon;
	    p.y = lat;
	    return p;
	  }

	};
	exports.names = ["Equidistant_Conic", "eqdc"];

	},{"../common/adjust_lat":4,"../common/adjust_lon":5,"../common/e0fn":7,"../common/e1fn":8,"../common/e2fn":9,"../common/e3fn":10,"../common/imlfn":12,"../common/mlfn":14,"../common/msfnz":15}],45:[function(_dereq_,module,exports){
	var FORTPI = Math.PI/4;
	var srat = _dereq_('../common/srat');
	var HALF_PI = Math.PI/2;
	var MAX_ITER = 20;
	exports.init = function() {
	  var sphi = Math.sin(this.lat0);
	  var cphi = Math.cos(this.lat0);
	  cphi *= cphi;
	  this.rc = Math.sqrt(1 - this.es) / (1 - this.es * sphi * sphi);
	  this.C = Math.sqrt(1 + this.es * cphi * cphi / (1 - this.es));
	  this.phic0 = Math.asin(sphi / this.C);
	  this.ratexp = 0.5 * this.C * this.e;
	  this.K = Math.tan(0.5 * this.phic0 + FORTPI) / (Math.pow(Math.tan(0.5 * this.lat0 + FORTPI), this.C) * srat(this.e * sphi, this.ratexp));
	};

	exports.forward = function(p) {
	  var lon = p.x;
	  var lat = p.y;

	  p.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * lat + FORTPI), this.C) * srat(this.e * Math.sin(lat), this.ratexp)) - HALF_PI;
	  p.x = this.C * lon;
	  return p;
	};

	exports.inverse = function(p) {
	  var DEL_TOL = 1e-14;
	  var lon = p.x / this.C;
	  var lat = p.y;
	  var num = Math.pow(Math.tan(0.5 * lat + FORTPI) / this.K, 1 / this.C);
	  for (var i = MAX_ITER; i > 0; --i) {
	    lat = 2 * Math.atan(num * srat(this.e * Math.sin(p.y), - 0.5 * this.e)) - HALF_PI;
	    if (Math.abs(lat - p.y) < DEL_TOL) {
	      break;
	    }
	    p.y = lat;
	  }
	  /* convergence failed */
	  if (!i) {
	    return null;
	  }
	  p.x = lon;
	  p.y = lat;
	  return p;
	};
	exports.names = ["gauss"];

	},{"../common/srat":22}],46:[function(_dereq_,module,exports){
	var adjust_lon = _dereq_('../common/adjust_lon');
	var EPSLN = 1.0e-10;
	var asinz = _dereq_('../common/asinz');

	/*
	  reference:
	    Wolfram Mathworld "Gnomonic Projection"
	    http://mathworld.wolfram.com/GnomonicProjection.html
	    Accessed: 12th November 2009
	  */
	exports.init = function() {

	  /* Place parameters in static storage for common use
	      -------------------------------------------------*/
	  this.sin_p14 = Math.sin(this.lat0);
	  this.cos_p14 = Math.cos(this.lat0);
	  // Approximation for projecting points to the horizon (infinity)
	  this.infinity_dist = 1000 * this.a;
	  this.rc = 1;
	};


	/* Gnomonic forward equations--mapping lat,long to x,y
	    ---------------------------------------------------*/
	exports.forward = function(p) {
	  var sinphi, cosphi; /* sin and cos value        */
	  var dlon; /* delta longitude value      */
	  var coslon; /* cos of longitude        */
	  var ksp; /* scale factor          */
	  var g;
	  var x, y;
	  var lon = p.x;
	  var lat = p.y;
	  /* Forward equations
	      -----------------*/
	  dlon = adjust_lon(lon - this.long0);

	  sinphi = Math.sin(lat);
	  cosphi = Math.cos(lat);

	  coslon = Math.cos(dlon);
	  g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
	  ksp = 1;
	  if ((g > 0) || (Math.abs(g) <= EPSLN)) {
	    x = this.x0 + this.a * ksp * cosphi * Math.sin(dlon) / g;
	    y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon) / g;
	  }
	  else {

	    // Point is in the opposing hemisphere and is unprojectable
	    // We still need to return a reasonable point, so we project 
	    // to infinity, on a bearing 
	    // equivalent to the northern hemisphere equivalent
	    // This is a reasonable approximation for short shapes and lines that 
	    // straddle the horizon.

	    x = this.x0 + this.infinity_dist * cosphi * Math.sin(dlon);
	    y = this.y0 + this.infinity_dist * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);

	  }
	  p.x = x;
	  p.y = y;
	  return p;
	};


	exports.inverse = function(p) {
	  var rh; /* Rho */
	  var sinc, cosc;
	  var c;
	  var lon, lat;

	  /* Inverse equations
	      -----------------*/
	  p.x = (p.x - this.x0) / this.a;
	  p.y = (p.y - this.y0) / this.a;

	  p.x /= this.k0;
	  p.y /= this.k0;

	  if ((rh = Math.sqrt(p.x * p.x + p.y * p.y))) {
	    c = Math.atan2(rh, this.rc);
	    sinc = Math.sin(c);
	    cosc = Math.cos(c);

	    lat = asinz(cosc * this.sin_p14 + (p.y * sinc * this.cos_p14) / rh);
	    lon = Math.atan2(p.x * sinc, rh * this.cos_p14 * cosc - p.y * this.sin_p14 * sinc);
	    lon = adjust_lon(this.long0 + lon);
	  }
	  else {
	    lat = this.phic0;
	    lon = 0;
	  }

	  p.x = lon;
	  p.y = lat;
	  return p;
	};
	exports.names = ["gnom"];

	},{"../common/adjust_lon":5,"../common/asinz":6}],47:[function(_dereq_,module,exports){
	var adjust_lon = _dereq_('../common/adjust_lon');
	exports.init = function() {
	  this.a = 6377397.155;
	  this.es = 0.006674372230614;
	  this.e = Math.sqrt(this.es);
	  if (!this.lat0) {
	    this.lat0 = 0.863937979737193;
	  }
	  if (!this.long0) {
	    this.long0 = 0.7417649320975901 - 0.308341501185665;
	  }
	  /* if scale not set default to 0.9999 */
	  if (!this.k0) {
	    this.k0 = 0.9999;
	  }
	  this.s45 = 0.785398163397448; /* 45 */
	  this.s90 = 2 * this.s45;
	  this.fi0 = this.lat0;
	  this.e2 = this.es;
	  this.e = Math.sqrt(this.e2);
	  this.alfa = Math.sqrt(1 + (this.e2 * Math.pow(Math.cos(this.fi0), 4)) / (1 - this.e2));
	  this.uq = 1.04216856380474;
	  this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa);
	  this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2);
	  this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g;
	  this.k1 = this.k0;
	  this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2));
	  this.s0 = 1.37008346281555;
	  this.n = Math.sin(this.s0);
	  this.ro0 = this.k1 * this.n0 / Math.tan(this.s0);
	  this.ad = this.s90 - this.uq;
	};

	/* ellipsoid */
	/* calculate xy from lat/lon */
	/* Constants, identical to inverse transform function */
	exports.forward = function(p) {
	  var gfi, u, deltav, s, d, eps, ro;
	  var lon = p.x;
	  var lat = p.y;
	  var delta_lon = adjust_lon(lon - this.long0);
	  /* Transformation */
	  gfi = Math.pow(((1 + this.e * Math.sin(lat)) / (1 - this.e * Math.sin(lat))), (this.alfa * this.e / 2));
	  u = 2 * (Math.atan(this.k * Math.pow(Math.tan(lat / 2 + this.s45), this.alfa) / gfi) - this.s45);
	  deltav = -delta_lon * this.alfa;
	  s = Math.asin(Math.cos(this.ad) * Math.sin(u) + Math.sin(this.ad) * Math.cos(u) * Math.cos(deltav));
	  d = Math.asin(Math.cos(u) * Math.sin(deltav) / Math.cos(s));
	  eps = this.n * d;
	  ro = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(s / 2 + this.s45), this.n);
	  p.y = ro * Math.cos(eps) / 1;
	  p.x = ro * Math.sin(eps) / 1;

	  if (!this.czech) {
	    p.y *= -1;
	    p.x *= -1;
	  }
	  return (p);
	};

	/* calculate lat/lon from xy */
	exports.inverse = function(p) {
	  var u, deltav, s, d, eps, ro, fi1;
	  var ok;

	  /* Transformation */
	  /* revert y, x*/
	  var tmp = p.x;
	  p.x = p.y;
	  p.y = tmp;
	  if (!this.czech) {
	    p.y *= -1;
	    p.x *= -1;
	  }
	  ro = Math.sqrt(p.x * p.x + p.y * p.y);
	  eps = Math.atan2(p.y, p.x);
	  d = eps / Math.sin(this.s0);
	  s = 2 * (Math.atan(Math.pow(this.ro0 / ro, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45);
	  u = Math.asin(Math.cos(this.ad) * Math.sin(s) - Math.sin(this.ad) * Math.cos(s) * Math.cos(d));
	  deltav = Math.asin(Math.cos(s) * Math.sin(d) / Math.cos(u));
	  p.x = this.long0 - deltav / this.alfa;
	  fi1 = u;
	  ok = 0;
	  var iter = 0;
	  do {
	    p.y = 2 * (Math.atan(Math.pow(this.k, - 1 / this.alfa) * Math.pow(Math.tan(u / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(fi1)) / (1 - this.e * Math.sin(fi1)), this.e / 2)) - this.s45);
	    if (Math.abs(fi1 - p.y) < 0.0000000001) {
	      ok = 1;
	    }
	    fi1 = p.y;
	    iter += 1;
	  } while (ok === 0 && iter < 15);
	  if (iter >= 15) {
	    return null;
	  }

	  return (p);
	};
	exports.names = ["Krovak", "krovak"];

	},{"../common/adjust_lon":5}],48:[function(_dereq_,module,exports){
	var HALF_PI = Math.PI/2;
	var FORTPI = Math.PI/4;
	var EPSLN = 1.0e-10;
	var qsfnz = _dereq_('../common/qsfnz');
	var adjust_lon = _dereq_('../common/adjust_lon');
	/*
	  reference
	    "New Equal-Area Map Projections for Noncircular Regions", John P. Snyder,
	    The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.
	  */

	exports.S_POLE = 1;
	exports.N_POLE = 2;
	exports.EQUIT = 3;
	exports.OBLIQ = 4;


	/* Initialize the Lambert Azimuthal Equal Area projection
	  ------------------------------------------------------*/
	exports.init = function() {
	  var t = Math.abs(this.lat0);
	  if (Math.abs(t - HALF_PI) < EPSLN) {
	    this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE;
	  }
	  else if (Math.abs(t) < EPSLN) {
	    this.mode = this.EQUIT;
	  }
	  else {
	    this.mode = this.OBLIQ;
	  }
	  if (this.es > 0) {
	    var sinphi;

	    this.qp = qsfnz(this.e, 1);
	    this.mmf = 0.5 / (1 - this.es);
	    this.apa = this.authset(this.es);
	    switch (this.mode) {
	    case this.N_POLE:
	      this.dd = 1;
	      break;
	    case this.S_POLE:
	      this.dd = 1;
	      break;
	    case this.EQUIT:
	      this.rq = Math.sqrt(0.5 * this.qp);
	      this.dd = 1 / this.rq;
	      this.xmf = 1;
	      this.ymf = 0.5 * this.qp;
	      break;
	    case this.OBLIQ:
	      this.rq = Math.sqrt(0.5 * this.qp);
	      sinphi = Math.sin(this.lat0);
	      this.sinb1 = qsfnz(this.e, sinphi) / this.qp;
	      this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1);
	      this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * sinphi * sinphi) * this.rq * this.cosb1);
	      this.ymf = (this.xmf = this.rq) / this.dd;
	      this.xmf *= this.dd;
	      break;
	    }
	  }
	  else {
	    if (this.mode === this.OBLIQ) {
	      this.sinph0 = Math.sin(this.lat0);
	      this.cosph0 = Math.cos(this.lat0);
	    }
	  }
	};

	/* Lambert Azimuthal Equal Area forward equations--mapping lat,long to x,y
	  -----------------------------------------------------------------------*/
	exports.forward = function(p) {

	  /* Forward equations
	      -----------------*/
	  var x, y, coslam, sinlam, sinphi, q, sinb, cosb, b, cosphi;
	  var lam = p.x;
	  var phi = p.y;

	  lam = adjust_lon(lam - this.long0);

	  if (this.sphere) {
	    sinphi = Math.sin(phi);
	    cosphi = Math.cos(phi);
	    coslam = Math.cos(lam);
	    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
	      y = (this.mode === this.EQUIT) ? 1 + cosphi * coslam : 1 + this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
	      if (y <= EPSLN) {
	        return null;
	      }
	      y = Math.sqrt(2 / y);
	      x = y * cosphi * Math.sin(lam);
	      y *= (this.mode === this.EQUIT) ? sinphi : this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
	    }
	    else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
	      if (this.mode === this.N_POLE) {
	        coslam = -coslam;
	      }
	      if (Math.abs(phi + this.phi0) < EPSLN) {
	        return null;
	      }
	      y = FORTPI - phi * 0.5;
	      y = 2 * ((this.mode === this.S_POLE) ? Math.cos(y) : Math.sin(y));
	      x = y * Math.sin(lam);
	      y *= coslam;
	    }
	  }
	  else {
	    sinb = 0;
	    cosb = 0;
	    b = 0;
	    coslam = Math.cos(lam);
	    sinlam = Math.sin(lam);
	    sinphi = Math.sin(phi);
	    q = qsfnz(this.e, sinphi);
	    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
	      sinb = q / this.qp;
	      cosb = Math.sqrt(1 - sinb * sinb);
	    }
	    switch (this.mode) {
	    case this.OBLIQ:
	      b = 1 + this.sinb1 * sinb + this.cosb1 * cosb * coslam;
	      break;
	    case this.EQUIT:
	      b = 1 + cosb * coslam;
	      break;
	    case this.N_POLE:
	      b = HALF_PI + phi;
	      q = this.qp - q;
	      break;
	    case this.S_POLE:
	      b = phi - HALF_PI;
	      q = this.qp + q;
	      break;
	    }
	    if (Math.abs(b) < EPSLN) {
	      return null;
	    }
	    switch (this.mode) {
	    case this.OBLIQ:
	    case this.EQUIT:
	      b = Math.sqrt(2 / b);
	      if (this.mode === this.OBLIQ) {
	        y = this.ymf * b * (this.cosb1 * sinb - this.sinb1 * cosb * coslam);
	      }
	      else {
	        y = (b = Math.sqrt(2 / (1 + cosb * coslam))) * sinb * this.ymf;
	      }
	      x = this.xmf * b * cosb * sinlam;
	      break;
	    case this.N_POLE:
	    case this.S_POLE:
	      if (q >= 0) {
	        x = (b = Math.sqrt(q)) * sinlam;
	        y = coslam * ((this.mode === this.S_POLE) ? b : -b);
	      }
	      else {
	        x = y = 0;
	      }
	      break;
	    }
	  }

	  p.x = this.a * x + this.x0;
	  p.y = this.a * y + this.y0;
	  return p;
	};

	/* Inverse equations
	  -----------------*/
	exports.inverse = function(p) {
	  p.x -= this.x0;
	  p.y -= this.y0;
	  var x = p.x / this.a;
	  var y = p.y / this.a;
	  var lam, phi, cCe, sCe, q, rho, ab;

	  if (this.sphere) {
	    var cosz = 0,
	      rh, sinz = 0;

	    rh = Math.sqrt(x * x + y * y);
	    phi = rh * 0.5;
	    if (phi > 1) {
	      return null;
	    }
	    phi = 2 * Math.asin(phi);
	    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
	      sinz = Math.sin(phi);
	      cosz = Math.cos(phi);
	    }
	    switch (this.mode) {
	    case this.EQUIT:
	      phi = (Math.abs(rh) <= EPSLN) ? 0 : Math.asin(y * sinz / rh);
	      x *= sinz;
	      y = cosz * rh;
	      break;
	    case this.OBLIQ:
	      phi = (Math.abs(rh) <= EPSLN) ? this.phi0 : Math.asin(cosz * this.sinph0 + y * sinz * this.cosph0 / rh);
	      x *= sinz * this.cosph0;
	      y = (cosz - Math.sin(phi) * this.sinph0) * rh;
	      break;
	    case this.N_POLE:
	      y = -y;
	      phi = HALF_PI - phi;
	      break;
	    case this.S_POLE:
	      phi -= HALF_PI;
	      break;
	    }
	    lam = (y === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ)) ? 0 : Math.atan2(x, y);
	  }
	  else {
	    ab = 0;
	    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
	      x /= this.dd;
	      y *= this.dd;
	      rho = Math.sqrt(x * x + y * y);
	      if (rho < EPSLN) {
	        p.x = 0;
	        p.y = this.phi0;
	        return p;
	      }
	      sCe = 2 * Math.asin(0.5 * rho / this.rq);
	      cCe = Math.cos(sCe);
	      x *= (sCe = Math.sin(sCe));
	      if (this.mode === this.OBLIQ) {
	        ab = cCe * this.sinb1 + y * sCe * this.cosb1 / rho;
	        q = this.qp * ab;
	        y = rho * this.cosb1 * cCe - y * this.sinb1 * sCe;
	      }
	      else {
	        ab = y * sCe / rho;
	        q = this.qp * ab;
	        y = rho * cCe;
	      }
	    }
	    else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
	      if (this.mode === this.N_POLE) {
	        y = -y;
	      }
	      q = (x * x + y * y);
	      if (!q) {
	        p.x = 0;
	        p.y = this.phi0;
	        return p;
	      }
	      ab = 1 - q / this.qp;
	      if (this.mode === this.S_POLE) {
	        ab = -ab;
	      }
	    }
	    lam = Math.atan2(x, y);
	    phi = this.authlat(Math.asin(ab), this.apa);
	  }


	  p.x = adjust_lon(this.long0 + lam);
	  p.y = phi;
	  return p;
	};

	/* determine latitude from authalic latitude */
	exports.P00 = 0.33333333333333333333;
	exports.P01 = 0.17222222222222222222;
	exports.P02 = 0.10257936507936507936;
	exports.P10 = 0.06388888888888888888;
	exports.P11 = 0.06640211640211640211;
	exports.P20 = 0.01641501294219154443;

	exports.authset = function(es) {
	  var t;
	  var APA = [];
	  APA[0] = es * this.P00;
	  t = es * es;
	  APA[0] += t * this.P01;
	  APA[1] = t * this.P10;
	  t *= es;
	  APA[0] += t * this.P02;
	  APA[1] += t * this.P11;
	  APA[2] = t * this.P20;
	  return APA;
	};

	exports.authlat = function(beta, APA) {
	  var t = beta + beta;
	  return (beta + APA[0] * Math.sin(t) + APA[1] * Math.sin(t + t) + APA[2] * Math.sin(t + t + t));
	};
	exports.names = ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"];

	},{"../common/adjust_lon":5,"../common/qsfnz":20}],49:[function(_dereq_,module,exports){
	var EPSLN = 1.0e-10;
	var msfnz = _dereq_('../common/msfnz');
	var tsfnz = _dereq_('../common/tsfnz');
	var HALF_PI = Math.PI/2;
	var sign = _dereq_('../common/sign');
	var adjust_lon = _dereq_('../common/adjust_lon');
	var phi2z = _dereq_('../common/phi2z');
	exports.init = function() {

	  // array of:  r_maj,r_min,lat1,lat2,c_lon,c_lat,false_east,false_north
	  //double c_lat;                   /* center latitude                      */
	  //double c_lon;                   /* center longitude                     */
	  //double lat1;                    /* first standard parallel              */
	  //double lat2;                    /* second standard parallel             */
	  //double r_maj;                   /* major axis                           */
	  //double r_min;                   /* minor axis                           */
	  //double false_east;              /* x offset in meters                   */
	  //double false_north;             /* y offset in meters                   */

	  if (!this.lat2) {
	    this.lat2 = this.lat1;
	  } //if lat2 is not defined
	  if (!this.k0) {
	    this.k0 = 1;
	  }
	  this.x0 = this.x0 || 0;
	  this.y0 = this.y0 || 0;
	  // Standard Parallels cannot be equal and on opposite sides of the equator
	  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
	    return;
	  }

	  var temp = this.b / this.a;
	  this.e = Math.sqrt(1 - temp * temp);

	  var sin1 = Math.sin(this.lat1);
	  var cos1 = Math.cos(this.lat1);
	  var ms1 = msfnz(this.e, sin1, cos1);
	  var ts1 = tsfnz(this.e, this.lat1, sin1);

	  var sin2 = Math.sin(this.lat2);
	  var cos2 = Math.cos(this.lat2);
	  var ms2 = msfnz(this.e, sin2, cos2);
	  var ts2 = tsfnz(this.e, this.lat2, sin2);

	  var ts0 = tsfnz(this.e, this.lat0, Math.sin(this.lat0));

	  if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
	    this.ns = Math.log(ms1 / ms2) / Math.log(ts1 / ts2);
	  }
	  else {
	    this.ns = sin1;
	  }
	  if (isNaN(this.ns)) {
	    this.ns = sin1;
	  }
	  this.f0 = ms1 / (this.ns * Math.pow(ts1, this.ns));
	  this.rh = this.a * this.f0 * Math.pow(ts0, this.ns);
	  if (!this.title) {
	    this.title = "Lambert Conformal Conic";
	  }
	};


	// Lambert Conformal conic forward equations--mapping lat,long to x,y
	// -----------------------------------------------------------------
	exports.forward = function(p) {

	  var lon = p.x;
	  var lat = p.y;

	  // singular cases :
	  if (Math.abs(2 * Math.abs(lat) - Math.PI) <= EPSLN) {
	    lat = sign(lat) * (HALF_PI - 2 * EPSLN);
	  }

	  var con = Math.abs(Math.abs(lat) - HALF_PI);
	  var ts, rh1;
	  if (con > EPSLN) {
	    ts = tsfnz(this.e, lat, Math.sin(lat));
	    rh1 = this.a * this.f0 * Math.pow(ts, this.ns);
	  }
	  else {
	    con = lat * this.ns;
	    if (con <= 0) {
	      return null;
	    }
	    rh1 = 0;
	  }
	  var theta = this.ns * adjust_lon(lon - this.long0);
	  p.x = this.k0 * (rh1 * Math.sin(theta)) + this.x0;
	  p.y = this.k0 * (this.rh - rh1 * Math.cos(theta)) + this.y0;

	  return p;
	};

	// Lambert Conformal Conic inverse equations--mapping x,y to lat/long
	// -----------------------------------------------------------------
	exports.inverse = function(p) {

	  var rh1, con, ts;
	  var lat, lon;
	  var x = (p.x - this.x0) / this.k0;
	  var y = (this.rh - (p.y - this.y0) / this.k0);
	  if (this.ns > 0) {
	    rh1 = Math.sqrt(x * x + y * y);
	    con = 1;
	  }
	  else {
	    rh1 = -Math.sqrt(x * x + y * y);
	    con = -1;
	  }
	  var theta = 0;
	  if (rh1 !== 0) {
	    theta = Math.atan2((con * x), (con * y));
	  }
	  if ((rh1 !== 0) || (this.ns > 0)) {
	    con = 1 / this.ns;
	    ts = Math.pow((rh1 / (this.a * this.f0)), con);
	    lat = phi2z(this.e, ts);
	    if (lat === -9999) {
	      return null;
	    }
	  }
	  else {
	    lat = -HALF_PI;
	  }
	  lon = adjust_lon(theta / this.ns + this.long0);

	  p.x = lon;
	  p.y = lat;
	  return p;
	};

	exports.names = ["Lambert Tangential Conformal Conic Projection", "Lambert_Conformal_Conic", "Lambert_Conformal_Conic_2SP", "lcc"];

	},{"../common/adjust_lon":5,"../common/msfnz":15,"../common/phi2z":16,"../common/sign":21,"../common/tsfnz":24}],50:[function(_dereq_,module,exports){
	exports.init = function() {
	  //no-op for longlat
	};

	function identity(pt) {
	  return pt;
	}
	exports.forward = identity;
	exports.inverse = identity;
	exports.names = ["longlat", "identity"];

	},{}],51:[function(_dereq_,module,exports){
	var msfnz = _dereq_('../common/msfnz');
	var HALF_PI = Math.PI/2;
	var EPSLN = 1.0e-10;
	var R2D = 57.29577951308232088;
	var adjust_lon = _dereq_('../common/adjust_lon');
	var FORTPI = Math.PI/4;
	var tsfnz = _dereq_('../common/tsfnz');
	var phi2z = _dereq_('../common/phi2z');
	exports.init = function() {
	  var con = this.b / this.a;
	  this.es = 1 - con * con;
	  if(!('x0' in this)){
	    this.x0 = 0;
	  }
	  if(!('y0' in this)){
	    this.y0 = 0;
	  }
	  this.e = Math.sqrt(this.es);
	  if (this.lat_ts) {
	    if (this.sphere) {
	      this.k0 = Math.cos(this.lat_ts);
	    }
	    else {
	      this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
	    }
	  }
	  else {
	    if (!this.k0) {
	      if (this.k) {
	        this.k0 = this.k;
	      }
	      else {
	        this.k0 = 1;
	      }
	    }
	  }
	};

	/* Mercator forward equations--mapping lat,long to x,y
	  --------------------------------------------------*/

	exports.forward = function(p) {
	  var lon = p.x;
	  var lat = p.y;
	  // convert to radians
	  if (lat * R2D > 90 && lat * R2D < -90 && lon * R2D > 180 && lon * R2D < -180) {
	    return null;
	  }

	  var x, y;
	  if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
	    return null;
	  }
	  else {
	    if (this.sphere) {
	      x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);
	      y = this.y0 + this.a * this.k0 * Math.log(Math.tan(FORTPI + 0.5 * lat));
	    }
	    else {
	      var sinphi = Math.sin(lat);
	      var ts = tsfnz(this.e, lat, sinphi);
	      x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);
	      y = this.y0 - this.a * this.k0 * Math.log(ts);
	    }
	    p.x = x;
	    p.y = y;
	    return p;
	  }
	};


	/* Mercator inverse equations--mapping x,y to lat/long
	  --------------------------------------------------*/
	exports.inverse = function(p) {

	  var x = p.x - this.x0;
	  var y = p.y - this.y0;
	  var lon, lat;

	  if (this.sphere) {
	    lat = HALF_PI - 2 * Math.atan(Math.exp(-y / (this.a * this.k0)));
	  }
	  else {
	    var ts = Math.exp(-y / (this.a * this.k0));
	    lat = phi2z(this.e, ts);
	    if (lat === -9999) {
	      return null;
	    }
	  }
	  lon = adjust_lon(this.long0 + x / (this.a * this.k0));

	  p.x = lon;
	  p.y = lat;
	  return p;
	};

	exports.names = ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "merc"];

	},{"../common/adjust_lon":5,"../common/msfnz":15,"../common/phi2z":16,"../common/tsfnz":24}],52:[function(_dereq_,module,exports){
	var adjust_lon = _dereq_('../common/adjust_lon');
	/*
	  reference
	    "New Equal-Area Map Projections for Noncircular Regions", John P. Snyder,
	    The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.
	  */


	/* Initialize the Miller Cylindrical projection
	  -------------------------------------------*/
	exports.init = function() {
	  //no-op
	};


	/* Miller Cylindrical forward equations--mapping lat,long to x,y
	    ------------------------------------------------------------*/
	exports.forward = function(p) {
	  var lon = p.x;
	  var lat = p.y;
	  /* Forward equations
	      -----------------*/
	  var dlon = adjust_lon(lon - this.long0);
	  var x = this.x0 + this.a * dlon;
	  var y = this.y0 + this.a * Math.log(Math.tan((Math.PI / 4) + (lat / 2.5))) * 1.25;

	  p.x = x;
	  p.y = y;
	  return p;
	};

	/* Miller Cylindrical inverse equations--mapping x,y to lat/long
	    ------------------------------------------------------------*/
	exports.inverse = function(p) {
	  p.x -= this.x0;
	  p.y -= this.y0;

	  var lon = adjust_lon(this.long0 + p.x / this.a);
	  var lat = 2.5 * (Math.atan(Math.exp(0.8 * p.y / this.a)) - Math.PI / 4);

	  p.x = lon;
	  p.y = lat;
	  return p;
	};
	exports.names = ["Miller_Cylindrical", "mill"];

	},{"../common/adjust_lon":5}],53:[function(_dereq_,module,exports){
	var adjust_lon = _dereq_('../common/adjust_lon');
	var EPSLN = 1.0e-10;
	exports.init = function() {};

	/* Mollweide forward equations--mapping lat,long to x,y
	    ----------------------------------------------------*/
	exports.forward = function(p) {

	  /* Forward equations
	      -----------------*/
	  var lon = p.x;
	  var lat = p.y;

	  var delta_lon = adjust_lon(lon - this.long0);
	  var theta = lat;
	  var con = Math.PI * Math.sin(lat);

	  /* Iterate using the Newton-Raphson method to find theta
	      -----------------------------------------------------*/
	  for (var i = 0; true; i++) {
	    var delta_theta = -(theta + Math.sin(theta) - con) / (1 + Math.cos(theta));
	    theta += delta_theta;
	    if (Math.abs(delta_theta) < EPSLN) {
	      break;
	    }
	  }
	  theta /= 2;

	  /* If the latitude is 90 deg, force the x coordinate to be "0 + false easting"
	       this is done here because of precision problems with "cos(theta)"
	       --------------------------------------------------------------------------*/
	  if (Math.PI / 2 - Math.abs(lat) < EPSLN) {
	    delta_lon = 0;
	  }
	  var x = 0.900316316158 * this.a * delta_lon * Math.cos(theta) + this.x0;
	  var y = 1.4142135623731 * this.a * Math.sin(theta) + this.y0;

	  p.x = x;
	  p.y = y;
	  return p;
	};

	exports.inverse = function(p) {
	  var theta;
	  var arg;

	  /* Inverse equations
	      -----------------*/
	  p.x -= this.x0;
	  p.y -= this.y0;
	  arg = p.y / (1.4142135623731 * this.a);

	  /* Because of division by zero problems, 'arg' can not be 1.  Therefore
	       a number very close to one is used instead.
	       -------------------------------------------------------------------*/
	  if (Math.abs(arg) > 0.999999999999) {
	    arg = 0.999999999999;
	  }
	  theta = Math.asin(arg);
	  var lon = adjust_lon(this.long0 + (p.x / (0.900316316158 * this.a * Math.cos(theta))));
	  if (lon < (-Math.PI)) {
	    lon = -Math.PI;
	  }
	  if (lon > Math.PI) {
	    lon = Math.PI;
	  }
	  arg = (2 * theta + Math.sin(2 * theta)) / Math.PI;
	  if (Math.abs(arg) > 1) {
	    arg = 1;
	  }
	  var lat = Math.asin(arg);

	  p.x = lon;
	  p.y = lat;
	  return p;
	};
	exports.names = ["Mollweide", "moll"];

	},{"../common/adjust_lon":5}],54:[function(_dereq_,module,exports){
	var SEC_TO_RAD = 4.84813681109535993589914102357e-6;
	/*
	  reference
	    Department of Land and Survey Technical Circular 1973/32
	      http://www.linz.govt.nz/docs/miscellaneous/nz-map-definition.pdf
	    OSG Technical Report 4.1
	      http://www.linz.govt.nz/docs/miscellaneous/nzmg.pdf
	  */

	/**
	 * iterations: Number of iterations to refine inverse transform.
	 *     0 -> km accuracy
	 *     1 -> m accuracy -- suitable for most mapping applications
	 *     2 -> mm accuracy
	 */
	exports.iterations = 1;

	exports.init = function() {
	  this.A = [];
	  this.A[1] = 0.6399175073;
	  this.A[2] = -0.1358797613;
	  this.A[3] = 0.063294409;
	  this.A[4] = -0.02526853;
	  this.A[5] = 0.0117879;
	  this.A[6] = -0.0055161;
	  this.A[7] = 0.0026906;
	  this.A[8] = -0.001333;
	  this.A[9] = 0.00067;
	  this.A[10] = -0.00034;

	  this.B_re = [];
	  this.B_im = [];
	  this.B_re[1] = 0.7557853228;
	  this.B_im[1] = 0;
	  this.B_re[2] = 0.249204646;
	  this.B_im[2] = 0.003371507;
	  this.B_re[3] = -0.001541739;
	  this.B_im[3] = 0.041058560;
	  this.B_re[4] = -0.10162907;
	  this.B_im[4] = 0.01727609;
	  this.B_re[5] = -0.26623489;
	  this.B_im[5] = -0.36249218;
	  this.B_re[6] = -0.6870983;
	  this.B_im[6] = -1.1651967;

	  this.C_re = [];
	  this.C_im = [];
	  this.C_re[1] = 1.3231270439;
	  this.C_im[1] = 0;
	  this.C_re[2] = -0.577245789;
	  this.C_im[2] = -0.007809598;
	  this.C_re[3] = 0.508307513;
	  this.C_im[3] = -0.112208952;
	  this.C_re[4] = -0.15094762;
	  this.C_im[4] = 0.18200602;
	  this.C_re[5] = 1.01418179;
	  this.C_im[5] = 1.64497696;
	  this.C_re[6] = 1.9660549;
	  this.C_im[6] = 2.5127645;

	  this.D = [];
	  this.D[1] = 1.5627014243;
	  this.D[2] = 0.5185406398;
	  this.D[3] = -0.03333098;
	  this.D[4] = -0.1052906;
	  this.D[5] = -0.0368594;
	  this.D[6] = 0.007317;
	  this.D[7] = 0.01220;
	  this.D[8] = 0.00394;
	  this.D[9] = -0.0013;
	};

	/**
	    New Zealand Map Grid Forward  - long/lat to x/y
	    long/lat in radians
	  */
	exports.forward = function(p) {
	  var n;
	  var lon = p.x;
	  var lat = p.y;

	  var delta_lat = lat - this.lat0;
	  var delta_lon = lon - this.long0;

	  // 1. Calculate d_phi and d_psi    ...                          // and d_lambda
	  // For this algorithm, delta_latitude is in seconds of arc x 10-5, so we need to scale to those units. Longitude is radians.
	  var d_phi = delta_lat / SEC_TO_RAD * 1E-5;
	  var d_lambda = delta_lon;
	  var d_phi_n = 1; // d_phi^0

	  var d_psi = 0;
	  for (n = 1; n <= 10; n++) {
	    d_phi_n = d_phi_n * d_phi;
	    d_psi = d_psi + this.A[n] * d_phi_n;
	  }

	  // 2. Calculate theta
	  var th_re = d_psi;
	  var th_im = d_lambda;

	  // 3. Calculate z
	  var th_n_re = 1;
	  var th_n_im = 0; // theta^0
	  var th_n_re1;
	  var th_n_im1;

	  var z_re = 0;
	  var z_im = 0;
	  for (n = 1; n <= 6; n++) {
	    th_n_re1 = th_n_re * th_re - th_n_im * th_im;
	    th_n_im1 = th_n_im * th_re + th_n_re * th_im;
	    th_n_re = th_n_re1;
	    th_n_im = th_n_im1;
	    z_re = z_re + this.B_re[n] * th_n_re - this.B_im[n] * th_n_im;
	    z_im = z_im + this.B_im[n] * th_n_re + this.B_re[n] * th_n_im;
	  }

	  // 4. Calculate easting and northing
	  p.x = (z_im * this.a) + this.x0;
	  p.y = (z_re * this.a) + this.y0;

	  return p;
	};


	/**
	    New Zealand Map Grid Inverse  -  x/y to long/lat
	  */
	exports.inverse = function(p) {
	  var n;
	  var x = p.x;
	  var y = p.y;

	  var delta_x = x - this.x0;
	  var delta_y = y - this.y0;

	  // 1. Calculate z
	  var z_re = delta_y / this.a;
	  var z_im = delta_x / this.a;

	  // 2a. Calculate theta - first approximation gives km accuracy
	  var z_n_re = 1;
	  var z_n_im = 0; // z^0
	  var z_n_re1;
	  var z_n_im1;

	  var th_re = 0;
	  var th_im = 0;
	  for (n = 1; n <= 6; n++) {
	    z_n_re1 = z_n_re * z_re - z_n_im * z_im;
	    z_n_im1 = z_n_im * z_re + z_n_re * z_im;
	    z_n_re = z_n_re1;
	    z_n_im = z_n_im1;
	    th_re = th_re + this.C_re[n] * z_n_re - this.C_im[n] * z_n_im;
	    th_im = th_im + this.C_im[n] * z_n_re + this.C_re[n] * z_n_im;
	  }

	  // 2b. Iterate to refine the accuracy of the calculation
	  //        0 iterations gives km accuracy
	  //        1 iteration gives m accuracy -- good enough for most mapping applications
	  //        2 iterations bives mm accuracy
	  for (var i = 0; i < this.iterations; i++) {
	    var th_n_re = th_re;
	    var th_n_im = th_im;
	    var th_n_re1;
	    var th_n_im1;

	    var num_re = z_re;
	    var num_im = z_im;
	    for (n = 2; n <= 6; n++) {
	      th_n_re1 = th_n_re * th_re - th_n_im * th_im;
	      th_n_im1 = th_n_im * th_re + th_n_re * th_im;
	      th_n_re = th_n_re1;
	      th_n_im = th_n_im1;
	      num_re = num_re + (n - 1) * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
	      num_im = num_im + (n - 1) * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
	    }

	    th_n_re = 1;
	    th_n_im = 0;
	    var den_re = this.B_re[1];
	    var den_im = this.B_im[1];
	    for (n = 2; n <= 6; n++) {
	      th_n_re1 = th_n_re * th_re - th_n_im * th_im;
	      th_n_im1 = th_n_im * th_re + th_n_re * th_im;
	      th_n_re = th_n_re1;
	      th_n_im = th_n_im1;
	      den_re = den_re + n * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
	      den_im = den_im + n * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
	    }

	    // Complex division
	    var den2 = den_re * den_re + den_im * den_im;
	    th_re = (num_re * den_re + num_im * den_im) / den2;
	    th_im = (num_im * den_re - num_re * den_im) / den2;
	  }

	  // 3. Calculate d_phi              ...                                    // and d_lambda
	  var d_psi = th_re;
	  var d_lambda = th_im;
	  var d_psi_n = 1; // d_psi^0

	  var d_phi = 0;
	  for (n = 1; n <= 9; n++) {
	    d_psi_n = d_psi_n * d_psi;
	    d_phi = d_phi + this.D[n] * d_psi_n;
	  }

	  // 4. Calculate latitude and longitude
	  // d_phi is calcuated in second of arc * 10^-5, so we need to scale back to radians. d_lambda is in radians.
	  var lat = this.lat0 + (d_phi * SEC_TO_RAD * 1E5);
	  var lon = this.long0 + d_lambda;

	  p.x = lon;
	  p.y = lat;

	  return p;
	};
	exports.names = ["New_Zealand_Map_Grid", "nzmg"];
	},{}],55:[function(_dereq_,module,exports){
	var tsfnz = _dereq_('../common/tsfnz');
	var adjust_lon = _dereq_('../common/adjust_lon');
	var phi2z = _dereq_('../common/phi2z');
	var HALF_PI = Math.PI/2;
	var FORTPI = Math.PI/4;
	var EPSLN = 1.0e-10;

	/* Initialize the Oblique Mercator  projection
	    ------------------------------------------*/
	exports.init = function() {
	  this.no_off = this.no_off || false;
	  this.no_rot = this.no_rot || false;

	  if (isNaN(this.k0)) {
	    this.k0 = 1;
	  }
	  var sinlat = Math.sin(this.lat0);
	  var coslat = Math.cos(this.lat0);
	  var con = this.e * sinlat;

	  this.bl = Math.sqrt(1 + this.es / (1 - this.es) * Math.pow(coslat, 4));
	  this.al = this.a * this.bl * this.k0 * Math.sqrt(1 - this.es) / (1 - con * con);
	  var t0 = tsfnz(this.e, this.lat0, sinlat);
	  var dl = this.bl / coslat * Math.sqrt((1 - this.es) / (1 - con * con));
	  if (dl * dl < 1) {
	    dl = 1;
	  }
	  var fl;
	  var gl;
	  if (!isNaN(this.longc)) {
	    //Central point and azimuth method

	    if (this.lat0 >= 0) {
	      fl = dl + Math.sqrt(dl * dl - 1);
	    }
	    else {
	      fl = dl - Math.sqrt(dl * dl - 1);
	    }
	    this.el = fl * Math.pow(t0, this.bl);
	    gl = 0.5 * (fl - 1 / fl);
	    this.gamma0 = Math.asin(Math.sin(this.alpha) / dl);
	    this.long0 = this.longc - Math.asin(gl * Math.tan(this.gamma0)) / this.bl;

	  }
	  else {
	    //2 points method
	    var t1 = tsfnz(this.e, this.lat1, Math.sin(this.lat1));
	    var t2 = tsfnz(this.e, this.lat2, Math.sin(this.lat2));
	    if (this.lat0 >= 0) {
	      this.el = (dl + Math.sqrt(dl * dl - 1)) * Math.pow(t0, this.bl);
	    }
	    else {
	      this.el = (dl - Math.sqrt(dl * dl - 1)) * Math.pow(t0, this.bl);
	    }
	    var hl = Math.pow(t1, this.bl);
	    var ll = Math.pow(t2, this.bl);
	    fl = this.el / hl;
	    gl = 0.5 * (fl - 1 / fl);
	    var jl = (this.el * this.el - ll * hl) / (this.el * this.el + ll * hl);
	    var pl = (ll - hl) / (ll + hl);
	    var dlon12 = adjust_lon(this.long1 - this.long2);
	    this.long0 = 0.5 * (this.long1 + this.long2) - Math.atan(jl * Math.tan(0.5 * this.bl * (dlon12)) / pl) / this.bl;
	    this.long0 = adjust_lon(this.long0);
	    var dlon10 = adjust_lon(this.long1 - this.long0);
	    this.gamma0 = Math.atan(Math.sin(this.bl * (dlon10)) / gl);
	    this.alpha = Math.asin(dl * Math.sin(this.gamma0));
	  }

	  if (this.no_off) {
	    this.uc = 0;
	  }
	  else {
	    if (this.lat0 >= 0) {
	      this.uc = this.al / this.bl * Math.atan2(Math.sqrt(dl * dl - 1), Math.cos(this.alpha));
	    }
	    else {
	      this.uc = -1 * this.al / this.bl * Math.atan2(Math.sqrt(dl * dl - 1), Math.cos(this.alpha));
	    }
	  }

	};


	/* Oblique Mercator forward equations--mapping lat,long to x,y
	    ----------------------------------------------------------*/
	exports.forward = function(p) {
	  var lon = p.x;
	  var lat = p.y;
	  var dlon = adjust_lon(lon - this.long0);
	  var us, vs;
	  var con;
	  if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
	    if (lat > 0) {
	      con = -1;
	    }
	    else {
	      con = 1;
	    }
	    vs = this.al / this.bl * Math.log(Math.tan(FORTPI + con * this.gamma0 * 0.5));
	    us = -1 * con * HALF_PI * this.al / this.bl;
	  }
	  else {
	    var t = tsfnz(this.e, lat, Math.sin(lat));
	    var ql = this.el / Math.pow(t, this.bl);
	    var sl = 0.5 * (ql - 1 / ql);
	    var tl = 0.5 * (ql + 1 / ql);
	    var vl = Math.sin(this.bl * (dlon));
	    var ul = (sl * Math.sin(this.gamma0) - vl * Math.cos(this.gamma0)) / tl;
	    if (Math.abs(Math.abs(ul) - 1) <= EPSLN) {
	      vs = Number.POSITIVE_INFINITY;
	    }
	    else {
	      vs = 0.5 * this.al * Math.log((1 - ul) / (1 + ul)) / this.bl;
	    }
	    if (Math.abs(Math.cos(this.bl * (dlon))) <= EPSLN) {
	      us = this.al * this.bl * (dlon);
	    }
	    else {
	      us = this.al * Math.atan2(sl * Math.cos(this.gamma0) + vl * Math.sin(this.gamma0), Math.cos(this.bl * dlon)) / this.bl;
	    }
	  }

	  if (this.no_rot) {
	    p.x = this.x0 + us;
	    p.y = this.y0 + vs;
	  }
	  else {

	    us -= this.uc;
	    p.x = this.x0 + vs * Math.cos(this.alpha) + us * Math.sin(this.alpha);
	    p.y = this.y0 + us * Math.cos(this.alpha) - vs * Math.sin(this.alpha);
	  }
	  return p;
	};

	exports.inverse = function(p) {
	  var us, vs;
	  if (this.no_rot) {
	    vs = p.y - this.y0;
	    us = p.x - this.x0;
	  }
	  else {
	    vs = (p.x - this.x0) * Math.cos(this.alpha) - (p.y - this.y0) * Math.sin(this.alpha);
	    us = (p.y - this.y0) * Math.cos(this.alpha) + (p.x - this.x0) * Math.sin(this.alpha);
	    us += this.uc;
	  }
	  var qp = Math.exp(-1 * this.bl * vs / this.al);
	  var sp = 0.5 * (qp - 1 / qp);
	  var tp = 0.5 * (qp + 1 / qp);
	  var vp = Math.sin(this.bl * us / this.al);
	  var up = (vp * Math.cos(this.gamma0) + sp * Math.sin(this.gamma0)) / tp;
	  var ts = Math.pow(this.el / Math.sqrt((1 + up) / (1 - up)), 1 / this.bl);
	  if (Math.abs(up - 1) < EPSLN) {
	    p.x = this.long0;
	    p.y = HALF_PI;
	  }
	  else if (Math.abs(up + 1) < EPSLN) {
	    p.x = this.long0;
	    p.y = -1 * HALF_PI;
	  }
	  else {
	    p.y = phi2z(this.e, ts);
	    p.x = adjust_lon(this.long0 - Math.atan2(sp * Math.cos(this.gamma0) - vp * Math.sin(this.gamma0), Math.cos(this.bl * us / this.al)) / this.bl);
	  }
	  return p;
	};

	exports.names = ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "omerc"];
	},{"../common/adjust_lon":5,"../common/phi2z":16,"../common/tsfnz":24}],56:[function(_dereq_,module,exports){
	var e0fn = _dereq_('../common/e0fn');
	var e1fn = _dereq_('../common/e1fn');
	var e2fn = _dereq_('../common/e2fn');
	var e3fn = _dereq_('../common/e3fn');
	var adjust_lon = _dereq_('../common/adjust_lon');
	var adjust_lat = _dereq_('../common/adjust_lat');
	var mlfn = _dereq_('../common/mlfn');
	var EPSLN = 1.0e-10;
	var gN = _dereq_('../common/gN');
	var MAX_ITER = 20;
	exports.init = function() {
	  /* Place parameters in static storage for common use
	      -------------------------------------------------*/
	  this.temp = this.b / this.a;
	  this.es = 1 - Math.pow(this.temp, 2); // devait etre dans tmerc.js mais n y est pas donc je commente sinon retour de valeurs nulles
	  this.e = Math.sqrt(this.es);
	  this.e0 = e0fn(this.es);
	  this.e1 = e1fn(this.es);
	  this.e2 = e2fn(this.es);
	  this.e3 = e3fn(this.es);
	  this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0); //si que des zeros le calcul ne se fait pas
	};


	/* Polyconic forward equations--mapping lat,long to x,y
	    ---------------------------------------------------*/
	exports.forward = function(p) {
	  var lon = p.x;
	  var lat = p.y;
	  var x, y, el;
	  var dlon = adjust_lon(lon - this.long0);
	  el = dlon * Math.sin(lat);
	  if (this.sphere) {
	    if (Math.abs(lat) <= EPSLN) {
	      x = this.a * dlon;
	      y = -1 * this.a * this.lat0;
	    }
	    else {
	      x = this.a * Math.sin(el) / Math.tan(lat);
	      y = this.a * (adjust_lat(lat - this.lat0) + (1 - Math.cos(el)) / Math.tan(lat));
	    }
	  }
	  else {
	    if (Math.abs(lat) <= EPSLN) {
	      x = this.a * dlon;
	      y = -1 * this.ml0;
	    }
	    else {
	      var nl = gN(this.a, this.e, Math.sin(lat)) / Math.tan(lat);
	      x = nl * Math.sin(el);
	      y = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, lat) - this.ml0 + nl * (1 - Math.cos(el));
	    }

	  }
	  p.x = x + this.x0;
	  p.y = y + this.y0;
	  return p;
	};


	/* Inverse equations
	  -----------------*/
	exports.inverse = function(p) {
	  var lon, lat, x, y, i;
	  var al, bl;
	  var phi, dphi;
	  x = p.x - this.x0;
	  y = p.y - this.y0;

	  if (this.sphere) {
	    if (Math.abs(y + this.a * this.lat0) <= EPSLN) {
	      lon = adjust_lon(x / this.a + this.long0);
	      lat = 0;
	    }
	    else {
	      al = this.lat0 + y / this.a;
	      bl = x * x / this.a / this.a + al * al;
	      phi = al;
	      var tanphi;
	      for (i = MAX_ITER; i; --i) {
	        tanphi = Math.tan(phi);
	        dphi = -1 * (al * (phi * tanphi + 1) - phi - 0.5 * (phi * phi + bl) * tanphi) / ((phi - al) / tanphi - 1);
	        phi += dphi;
	        if (Math.abs(dphi) <= EPSLN) {
	          lat = phi;
	          break;
	        }
	      }
	      lon = adjust_lon(this.long0 + (Math.asin(x * Math.tan(phi) / this.a)) / Math.sin(lat));
	    }
	  }
	  else {
	    if (Math.abs(y + this.ml0) <= EPSLN) {
	      lat = 0;
	      lon = adjust_lon(this.long0 + x / this.a);
	    }
	    else {

	      al = (this.ml0 + y) / this.a;
	      bl = x * x / this.a / this.a + al * al;
	      phi = al;
	      var cl, mln, mlnp, ma;
	      var con;
	      for (i = MAX_ITER; i; --i) {
	        con = this.e * Math.sin(phi);
	        cl = Math.sqrt(1 - con * con) * Math.tan(phi);
	        mln = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);
	        mlnp = this.e0 - 2 * this.e1 * Math.cos(2 * phi) + 4 * this.e2 * Math.cos(4 * phi) - 6 * this.e3 * Math.cos(6 * phi);
	        ma = mln / this.a;
	        dphi = (al * (cl * ma + 1) - ma - 0.5 * cl * (ma * ma + bl)) / (this.es * Math.sin(2 * phi) * (ma * ma + bl - 2 * al * ma) / (4 * cl) + (al - ma) * (cl * mlnp - 2 / Math.sin(2 * phi)) - mlnp);
	        phi -= dphi;
	        if (Math.abs(dphi) <= EPSLN) {
	          lat = phi;
	          break;
	        }
	      }

	      //lat=phi4z(this.e,this.e0,this.e1,this.e2,this.e3,al,bl,0,0);
	      cl = Math.sqrt(1 - this.es * Math.pow(Math.sin(lat), 2)) * Math.tan(lat);
	      lon = adjust_lon(this.long0 + Math.asin(x * cl / this.a) / Math.sin(lat));
	    }
	  }

	  p.x = lon;
	  p.y = lat;
	  return p;
	};
	exports.names = ["Polyconic", "poly"];
	},{"../common/adjust_lat":4,"../common/adjust_lon":5,"../common/e0fn":7,"../common/e1fn":8,"../common/e2fn":9,"../common/e3fn":10,"../common/gN":11,"../common/mlfn":14}],57:[function(_dereq_,module,exports){
	var adjust_lon = _dereq_('../common/adjust_lon');
	var adjust_lat = _dereq_('../common/adjust_lat');
	var pj_enfn = _dereq_('../common/pj_enfn');
	var MAX_ITER = 20;
	var pj_mlfn = _dereq_('../common/pj_mlfn');
	var pj_inv_mlfn = _dereq_('../common/pj_inv_mlfn');
	var HALF_PI = Math.PI/2;
	var EPSLN = 1.0e-10;
	var asinz = _dereq_('../common/asinz');
	exports.init = function() {
	  /* Place parameters in static storage for common use
	    -------------------------------------------------*/


	  if (!this.sphere) {
	    this.en = pj_enfn(this.es);
	  }
	  else {
	    this.n = 1;
	    this.m = 0;
	    this.es = 0;
	    this.C_y = Math.sqrt((this.m + 1) / this.n);
	    this.C_x = this.C_y / (this.m + 1);
	  }

	};

	/* Sinusoidal forward equations--mapping lat,long to x,y
	  -----------------------------------------------------*/
	exports.forward = function(p) {
	  var x, y;
	  var lon = p.x;
	  var lat = p.y;
	  /* Forward equations
	    -----------------*/
	  lon = adjust_lon(lon - this.long0);

	  if (this.sphere) {
	    if (!this.m) {
	      lat = this.n !== 1 ? Math.asin(this.n * Math.sin(lat)) : lat;
	    }
	    else {
	      var k = this.n * Math.sin(lat);
	      for (var i = MAX_ITER; i; --i) {
	        var V = (this.m * lat + Math.sin(lat) - k) / (this.m + Math.cos(lat));
	        lat -= V;
	        if (Math.abs(V) < EPSLN) {
	          break;
	        }
	      }
	    }
	    x = this.a * this.C_x * lon * (this.m + Math.cos(lat));
	    y = this.a * this.C_y * lat;

	  }
	  else {

	    var s = Math.sin(lat);
	    var c = Math.cos(lat);
	    y = this.a * pj_mlfn(lat, s, c, this.en);
	    x = this.a * lon * c / Math.sqrt(1 - this.es * s * s);
	  }

	  p.x = x;
	  p.y = y;
	  return p;
	};

	exports.inverse = function(p) {
	  var lat, temp, lon, s;

	  p.x -= this.x0;
	  lon = p.x / this.a;
	  p.y -= this.y0;
	  lat = p.y / this.a;

	  if (this.sphere) {
	    lat /= this.C_y;
	    lon = lon / (this.C_x * (this.m + Math.cos(lat)));
	    if (this.m) {
	      lat = asinz((this.m * lat + Math.sin(lat)) / this.n);
	    }
	    else if (this.n !== 1) {
	      lat = asinz(Math.sin(lat) / this.n);
	    }
	    lon = adjust_lon(lon + this.long0);
	    lat = adjust_lat(lat);
	  }
	  else {
	    lat = pj_inv_mlfn(p.y / this.a, this.es, this.en);
	    s = Math.abs(lat);
	    if (s < HALF_PI) {
	      s = Math.sin(lat);
	      temp = this.long0 + p.x * Math.sqrt(1 - this.es * s * s) / (this.a * Math.cos(lat));
	      //temp = this.long0 + p.x / (this.a * Math.cos(lat));
	      lon = adjust_lon(temp);
	    }
	    else if ((s - EPSLN) < HALF_PI) {
	      lon = this.long0;
	    }
	  }
	  p.x = lon;
	  p.y = lat;
	  return p;
	};
	exports.names = ["Sinusoidal", "sinu"];
	},{"../common/adjust_lat":4,"../common/adjust_lon":5,"../common/asinz":6,"../common/pj_enfn":17,"../common/pj_inv_mlfn":18,"../common/pj_mlfn":19}],58:[function(_dereq_,module,exports){
	/*
	  references:
	    Formules et constantes pour le Calcul pour la
	    projection cylindrique conforme à axe oblique et pour la transformation entre
	    des systèmes de référence.
	    http://www.swisstopo.admin.ch/internet/swisstopo/fr/home/topics/survey/sys/refsys/switzerland.parsysrelated1.31216.downloadList.77004.DownloadFile.tmp/swissprojectionfr.pdf
	  */
	exports.init = function() {
	  var phy0 = this.lat0;
	  this.lambda0 = this.long0;
	  var sinPhy0 = Math.sin(phy0);
	  var semiMajorAxis = this.a;
	  var invF = this.rf;
	  var flattening = 1 / invF;
	  var e2 = 2 * flattening - Math.pow(flattening, 2);
	  var e = this.e = Math.sqrt(e2);
	  this.R = this.k0 * semiMajorAxis * Math.sqrt(1 - e2) / (1 - e2 * Math.pow(sinPhy0, 2));
	  this.alpha = Math.sqrt(1 + e2 / (1 - e2) * Math.pow(Math.cos(phy0), 4));
	  this.b0 = Math.asin(sinPhy0 / this.alpha);
	  var k1 = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2));
	  var k2 = Math.log(Math.tan(Math.PI / 4 + phy0 / 2));
	  var k3 = Math.log((1 + e * sinPhy0) / (1 - e * sinPhy0));
	  this.K = k1 - this.alpha * k2 + this.alpha * e / 2 * k3;
	};


	exports.forward = function(p) {
	  var Sa1 = Math.log(Math.tan(Math.PI / 4 - p.y / 2));
	  var Sa2 = this.e / 2 * Math.log((1 + this.e * Math.sin(p.y)) / (1 - this.e * Math.sin(p.y)));
	  var S = -this.alpha * (Sa1 + Sa2) + this.K;

	  // spheric latitude
	  var b = 2 * (Math.atan(Math.exp(S)) - Math.PI / 4);

	  // spheric longitude
	  var I = this.alpha * (p.x - this.lambda0);

	  // psoeudo equatorial rotation
	  var rotI = Math.atan(Math.sin(I) / (Math.sin(this.b0) * Math.tan(b) + Math.cos(this.b0) * Math.cos(I)));

	  var rotB = Math.asin(Math.cos(this.b0) * Math.sin(b) - Math.sin(this.b0) * Math.cos(b) * Math.cos(I));

	  p.y = this.R / 2 * Math.log((1 + Math.sin(rotB)) / (1 - Math.sin(rotB))) + this.y0;
	  p.x = this.R * rotI + this.x0;
	  return p;
	};

	exports.inverse = function(p) {
	  var Y = p.x - this.x0;
	  var X = p.y - this.y0;

	  var rotI = Y / this.R;
	  var rotB = 2 * (Math.atan(Math.exp(X / this.R)) - Math.PI / 4);

	  var b = Math.asin(Math.cos(this.b0) * Math.sin(rotB) + Math.sin(this.b0) * Math.cos(rotB) * Math.cos(rotI));
	  var I = Math.atan(Math.sin(rotI) / (Math.cos(this.b0) * Math.cos(rotI) - Math.sin(this.b0) * Math.tan(rotB)));

	  var lambda = this.lambda0 + I / this.alpha;

	  var S = 0;
	  var phy = b;
	  var prevPhy = -1000;
	  var iteration = 0;
	  while (Math.abs(phy - prevPhy) > 0.0000001) {
	    if (++iteration > 20) {
	      //...reportError("omercFwdInfinity");
	      return;
	    }
	    //S = Math.log(Math.tan(Math.PI / 4 + phy / 2));
	    S = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + b / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(phy)) / 2));
	    prevPhy = phy;
	    phy = 2 * Math.atan(Math.exp(S)) - Math.PI / 2;
	  }

	  p.x = lambda;
	  p.y = phy;
	  return p;
	};

	exports.names = ["somerc"];

	},{}],59:[function(_dereq_,module,exports){
	var HALF_PI = Math.PI/2;
	var EPSLN = 1.0e-10;
	var sign = _dereq_('../common/sign');
	var msfnz = _dereq_('../common/msfnz');
	var tsfnz = _dereq_('../common/tsfnz');
	var phi2z = _dereq_('../common/phi2z');
	var adjust_lon = _dereq_('../common/adjust_lon');
	exports.ssfn_ = function(phit, sinphi, eccen) {
	  sinphi *= eccen;
	  return (Math.tan(0.5 * (HALF_PI + phit)) * Math.pow((1 - sinphi) / (1 + sinphi), 0.5 * eccen));
	};

	exports.init = function() {
	  this.coslat0 = Math.cos(this.lat0);
	  this.sinlat0 = Math.sin(this.lat0);
	  if (this.sphere) {
	    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
	      this.k0 = 0.5 * (1 + sign(this.lat0) * Math.sin(this.lat_ts));
	    }
	  }
	  else {
	    if (Math.abs(this.coslat0) <= EPSLN) {
	      if (this.lat0 > 0) {
	        //North pole
	        //trace('stere:north pole');
	        this.con = 1;
	      }
	      else {
	        //South pole
	        //trace('stere:south pole');
	        this.con = -1;
	      }
	    }
	    this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e));
	    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
	      this.k0 = 0.5 * this.cons * msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / tsfnz(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts));
	    }
	    this.ms1 = msfnz(this.e, this.sinlat0, this.coslat0);
	    this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - HALF_PI;
	    this.cosX0 = Math.cos(this.X0);
	    this.sinX0 = Math.sin(this.X0);
	  }
	};

	// Stereographic forward equations--mapping lat,long to x,y
	exports.forward = function(p) {
	  var lon = p.x;
	  var lat = p.y;
	  var sinlat = Math.sin(lat);
	  var coslat = Math.cos(lat);
	  var A, X, sinX, cosX, ts, rh;
	  var dlon = adjust_lon(lon - this.long0);

	  if (Math.abs(Math.abs(lon - this.long0) - Math.PI) <= EPSLN && Math.abs(lat + this.lat0) <= EPSLN) {
	    //case of the origine point
	    //trace('stere:this is the origin point');
	    p.x = NaN;
	    p.y = NaN;
	    return p;
	  }
	  if (this.sphere) {
	    //trace('stere:sphere case');
	    A = 2 * this.k0 / (1 + this.sinlat0 * sinlat + this.coslat0 * coslat * Math.cos(dlon));
	    p.x = this.a * A * coslat * Math.sin(dlon) + this.x0;
	    p.y = this.a * A * (this.coslat0 * sinlat - this.sinlat0 * coslat * Math.cos(dlon)) + this.y0;
	    return p;
	  }
	  else {
	    X = 2 * Math.atan(this.ssfn_(lat, sinlat, this.e)) - HALF_PI;
	    cosX = Math.cos(X);
	    sinX = Math.sin(X);
	    if (Math.abs(this.coslat0) <= EPSLN) {
	      ts = tsfnz(this.e, lat * this.con, this.con * sinlat);
	      rh = 2 * this.a * this.k0 * ts / this.cons;
	      p.x = this.x0 + rh * Math.sin(lon - this.long0);
	      p.y = this.y0 - this.con * rh * Math.cos(lon - this.long0);
	      //trace(p.toString());
	      return p;
	    }
	    else if (Math.abs(this.sinlat0) < EPSLN) {
	      //Eq
	      //trace('stere:equateur');
	      A = 2 * this.a * this.k0 / (1 + cosX * Math.cos(dlon));
	      p.y = A * sinX;
	    }
	    else {
	      //other case
	      //trace('stere:normal case');
	      A = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * sinX + this.cosX0 * cosX * Math.cos(dlon)));
	      p.y = A * (this.cosX0 * sinX - this.sinX0 * cosX * Math.cos(dlon)) + this.y0;
	    }
	    p.x = A * cosX * Math.sin(dlon) + this.x0;
	  }
	  //trace(p.toString());
	  return p;
	};


	//* Stereographic inverse equations--mapping x,y to lat/long
	exports.inverse = function(p) {
	  p.x -= this.x0;
	  p.y -= this.y0;
	  var lon, lat, ts, ce, Chi;
	  var rh = Math.sqrt(p.x * p.x + p.y * p.y);
	  if (this.sphere) {
	    var c = 2 * Math.atan(rh / (0.5 * this.a * this.k0));
	    lon = this.long0;
	    lat = this.lat0;
	    if (rh <= EPSLN) {
	      p.x = lon;
	      p.y = lat;
	      return p;
	    }
	    lat = Math.asin(Math.cos(c) * this.sinlat0 + p.y * Math.sin(c) * this.coslat0 / rh);
	    if (Math.abs(this.coslat0) < EPSLN) {
	      if (this.lat0 > 0) {
	        lon = adjust_lon(this.long0 + Math.atan2(p.x, - 1 * p.y));
	      }
	      else {
	        lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));
	      }
	    }
	    else {
	      lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(c), rh * this.coslat0 * Math.cos(c) - p.y * this.sinlat0 * Math.sin(c)));
	    }
	    p.x = lon;
	    p.y = lat;
	    return p;
	  }
	  else {
	    if (Math.abs(this.coslat0) <= EPSLN) {
	      if (rh <= EPSLN) {
	        lat = this.lat0;
	        lon = this.long0;
	        p.x = lon;
	        p.y = lat;
	        //trace(p.toString());
	        return p;
	      }
	      p.x *= this.con;
	      p.y *= this.con;
	      ts = rh * this.cons / (2 * this.a * this.k0);
	      lat = this.con * phi2z(this.e, ts);
	      lon = this.con * adjust_lon(this.con * this.long0 + Math.atan2(p.x, - 1 * p.y));
	    }
	    else {
	      ce = 2 * Math.atan(rh * this.cosX0 / (2 * this.a * this.k0 * this.ms1));
	      lon = this.long0;
	      if (rh <= EPSLN) {
	        Chi = this.X0;
	      }
	      else {
	        Chi = Math.asin(Math.cos(ce) * this.sinX0 + p.y * Math.sin(ce) * this.cosX0 / rh);
	        lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(ce), rh * this.cosX0 * Math.cos(ce) - p.y * this.sinX0 * Math.sin(ce)));
	      }
	      lat = -1 * phi2z(this.e, Math.tan(0.5 * (HALF_PI + Chi)));
	    }
	  }
	  p.x = lon;
	  p.y = lat;

	  //trace(p.toString());
	  return p;

	};
	exports.names = ["stere"];
	},{"../common/adjust_lon":5,"../common/msfnz":15,"../common/phi2z":16,"../common/sign":21,"../common/tsfnz":24}],60:[function(_dereq_,module,exports){
	var gauss = _dereq_('./gauss');
	var adjust_lon = _dereq_('../common/adjust_lon');
	exports.init = function() {
	  gauss.init.apply(this);
	  if (!this.rc) {
	    return;
	  }
	  this.sinc0 = Math.sin(this.phic0);
	  this.cosc0 = Math.cos(this.phic0);
	  this.R2 = 2 * this.rc;
	  if (!this.title) {
	    this.title = "Oblique Stereographic Alternative";
	  }
	};

	exports.forward = function(p) {
	  var sinc, cosc, cosl, k;
	  p.x = adjust_lon(p.x - this.long0);
	  gauss.forward.apply(this, [p]);
	  sinc = Math.sin(p.y);
	  cosc = Math.cos(p.y);
	  cosl = Math.cos(p.x);
	  k = this.k0 * this.R2 / (1 + this.sinc0 * sinc + this.cosc0 * cosc * cosl);
	  p.x = k * cosc * Math.sin(p.x);
	  p.y = k * (this.cosc0 * sinc - this.sinc0 * cosc * cosl);
	  p.x = this.a * p.x + this.x0;
	  p.y = this.a * p.y + this.y0;
	  return p;
	};

	exports.inverse = function(p) {
	  var sinc, cosc, lon, lat, rho;
	  p.x = (p.x - this.x0) / this.a;
	  p.y = (p.y - this.y0) / this.a;

	  p.x /= this.k0;
	  p.y /= this.k0;
	  if ((rho = Math.sqrt(p.x * p.x + p.y * p.y))) {
	    var c = 2 * Math.atan2(rho, this.R2);
	    sinc = Math.sin(c);
	    cosc = Math.cos(c);
	    lat = Math.asin(cosc * this.sinc0 + p.y * sinc * this.cosc0 / rho);
	    lon = Math.atan2(p.x * sinc, rho * this.cosc0 * cosc - p.y * this.sinc0 * sinc);
	  }
	  else {
	    lat = this.phic0;
	    lon = 0;
	  }

	  p.x = lon;
	  p.y = lat;
	  gauss.inverse.apply(this, [p]);
	  p.x = adjust_lon(p.x + this.long0);
	  return p;
	};

	exports.names = ["Stereographic_North_Pole", "Oblique_Stereographic", "Polar_Stereographic", "sterea","Oblique Stereographic Alternative"];

	},{"../common/adjust_lon":5,"./gauss":45}],61:[function(_dereq_,module,exports){
	var e0fn = _dereq_('../common/e0fn');
	var e1fn = _dereq_('../common/e1fn');
	var e2fn = _dereq_('../common/e2fn');
	var e3fn = _dereq_('../common/e3fn');
	var mlfn = _dereq_('../common/mlfn');
	var adjust_lon = _dereq_('../common/adjust_lon');
	var HALF_PI = Math.PI/2;
	var EPSLN = 1.0e-10;
	var sign = _dereq_('../common/sign');
	var asinz = _dereq_('../common/asinz');

	exports.init = function() {
	  this.e0 = e0fn(this.es);
	  this.e1 = e1fn(this.es);
	  this.e2 = e2fn(this.es);
	  this.e3 = e3fn(this.es);
	  this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
	};

	/**
	    Transverse Mercator Forward  - long/lat to x/y
	    long/lat in radians
	  */
	exports.forward = function(p) {
	  var lon = p.x;
	  var lat = p.y;

	  var delta_lon = adjust_lon(lon - this.long0);
	  var con;
	  var x, y;
	  var sin_phi = Math.sin(lat);
	  var cos_phi = Math.cos(lat);

	  if (this.sphere) {
	    var b = cos_phi * Math.sin(delta_lon);
	    if ((Math.abs(Math.abs(b) - 1)) < 0.0000000001) {
	      return (93);
	    }
	    else {
	      x = 0.5 * this.a * this.k0 * Math.log((1 + b) / (1 - b));
	      con = Math.acos(cos_phi * Math.cos(delta_lon) / Math.sqrt(1 - b * b));
	      if (lat < 0) {
	        con = -con;
	      }
	      y = this.a * this.k0 * (con - this.lat0);
	    }
	  }
	  else {
	    var al = cos_phi * delta_lon;
	    var als = Math.pow(al, 2);
	    var c = this.ep2 * Math.pow(cos_phi, 2);
	    var tq = Math.tan(lat);
	    var t = Math.pow(tq, 2);
	    con = 1 - this.es * Math.pow(sin_phi, 2);
	    var n = this.a / Math.sqrt(con);
	    var ml = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, lat);

	    x = this.k0 * n * al * (1 + als / 6 * (1 - t + c + als / 20 * (5 - 18 * t + Math.pow(t, 2) + 72 * c - 58 * this.ep2))) + this.x0;
	    y = this.k0 * (ml - this.ml0 + n * tq * (als * (0.5 + als / 24 * (5 - t + 9 * c + 4 * Math.pow(c, 2) + als / 30 * (61 - 58 * t + Math.pow(t, 2) + 600 * c - 330 * this.ep2))))) + this.y0;

	  }
	  p.x = x;
	  p.y = y;
	  return p;
	};

	/**
	    Transverse Mercator Inverse  -  x/y to long/lat
	  */
	exports.inverse = function(p) {
	  var con, phi;
	  var delta_phi;
	  var i;
	  var max_iter = 6;
	  var lat, lon;

	  if (this.sphere) {
	    var f = Math.exp(p.x / (this.a * this.k0));
	    var g = 0.5 * (f - 1 / f);
	    var temp = this.lat0 + p.y / (this.a * this.k0);
	    var h = Math.cos(temp);
	    con = Math.sqrt((1 - h * h) / (1 + g * g));
	    lat = asinz(con);
	    if (temp < 0) {
	      lat = -lat;
	    }
	    if ((g === 0) && (h === 0)) {
	      lon = this.long0;
	    }
	    else {
	      lon = adjust_lon(Math.atan2(g, h) + this.long0);
	    }
	  }
	  else { // ellipsoidal form
	    var x = p.x - this.x0;
	    var y = p.y - this.y0;

	    con = (this.ml0 + y / this.k0) / this.a;
	    phi = con;
	    for (i = 0; true; i++) {
	      delta_phi = ((con + this.e1 * Math.sin(2 * phi) - this.e2 * Math.sin(4 * phi) + this.e3 * Math.sin(6 * phi)) / this.e0) - phi;
	      phi += delta_phi;
	      if (Math.abs(delta_phi) <= EPSLN) {
	        break;
	      }
	      if (i >= max_iter) {
	        return (95);
	      }
	    } // for()
	    if (Math.abs(phi) < HALF_PI) {
	      var sin_phi = Math.sin(phi);
	      var cos_phi = Math.cos(phi);
	      var tan_phi = Math.tan(phi);
	      var c = this.ep2 * Math.pow(cos_phi, 2);
	      var cs = Math.pow(c, 2);
	      var t = Math.pow(tan_phi, 2);
	      var ts = Math.pow(t, 2);
	      con = 1 - this.es * Math.pow(sin_phi, 2);
	      var n = this.a / Math.sqrt(con);
	      var r = n * (1 - this.es) / con;
	      var d = x / (n * this.k0);
	      var ds = Math.pow(d, 2);
	      lat = phi - (n * tan_phi * ds / r) * (0.5 - ds / 24 * (5 + 3 * t + 10 * c - 4 * cs - 9 * this.ep2 - ds / 30 * (61 + 90 * t + 298 * c + 45 * ts - 252 * this.ep2 - 3 * cs)));
	      lon = adjust_lon(this.long0 + (d * (1 - ds / 6 * (1 + 2 * t + c - ds / 20 * (5 - 2 * c + 28 * t - 3 * cs + 8 * this.ep2 + 24 * ts))) / cos_phi));
	    }
	    else {
	      lat = HALF_PI * sign(y);
	      lon = this.long0;
	    }
	  }
	  p.x = lon;
	  p.y = lat;
	  return p;
	};
	exports.names = ["Transverse_Mercator", "Transverse Mercator", "tmerc"];

	},{"../common/adjust_lon":5,"../common/asinz":6,"../common/e0fn":7,"../common/e1fn":8,"../common/e2fn":9,"../common/e3fn":10,"../common/mlfn":14,"../common/sign":21}],62:[function(_dereq_,module,exports){
	var D2R = 0.01745329251994329577;
	var tmerc = _dereq_('./tmerc');
	exports.dependsOn = 'tmerc';
	exports.init = function() {
	  if (!this.zone) {
	    return;
	  }
	  this.lat0 = 0;
	  this.long0 = ((6 * Math.abs(this.zone)) - 183) * D2R;
	  this.x0 = 500000;
	  this.y0 = this.utmSouth ? 10000000 : 0;
	  this.k0 = 0.9996;

	  tmerc.init.apply(this);
	  this.forward = tmerc.forward;
	  this.inverse = tmerc.inverse;
	};
	exports.names = ["Universal Transverse Mercator System", "utm"];

	},{"./tmerc":61}],63:[function(_dereq_,module,exports){
	var adjust_lon = _dereq_('../common/adjust_lon');
	var HALF_PI = Math.PI/2;
	var EPSLN = 1.0e-10;
	var asinz = _dereq_('../common/asinz');
	/* Initialize the Van Der Grinten projection
	  ----------------------------------------*/
	exports.init = function() {
	  //this.R = 6370997; //Radius of earth
	  this.R = this.a;
	};

	exports.forward = function(p) {

	  var lon = p.x;
	  var lat = p.y;

	  /* Forward equations
	    -----------------*/
	  var dlon = adjust_lon(lon - this.long0);
	  var x, y;

	  if (Math.abs(lat) <= EPSLN) {
	    x = this.x0 + this.R * dlon;
	    y = this.y0;
	  }
	  var theta = asinz(2 * Math.abs(lat / Math.PI));
	  if ((Math.abs(dlon) <= EPSLN) || (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN)) {
	    x = this.x0;
	    if (lat >= 0) {
	      y = this.y0 + Math.PI * this.R * Math.tan(0.5 * theta);
	    }
	    else {
	      y = this.y0 + Math.PI * this.R * -Math.tan(0.5 * theta);
	    }
	    //  return(OK);
	  }
	  var al = 0.5 * Math.abs((Math.PI / dlon) - (dlon / Math.PI));
	  var asq = al * al;
	  var sinth = Math.sin(theta);
	  var costh = Math.cos(theta);

	  var g = costh / (sinth + costh - 1);
	  var gsq = g * g;
	  var m = g * (2 / sinth - 1);
	  var msq = m * m;
	  var con = Math.PI * this.R * (al * (g - msq) + Math.sqrt(asq * (g - msq) * (g - msq) - (msq + asq) * (gsq - msq))) / (msq + asq);
	  if (dlon < 0) {
	    con = -con;
	  }
	  x = this.x0 + con;
	  //con = Math.abs(con / (Math.PI * this.R));
	  var q = asq + g;
	  con = Math.PI * this.R * (m * q - al * Math.sqrt((msq + asq) * (asq + 1) - q * q)) / (msq + asq);
	  if (lat >= 0) {
	    //y = this.y0 + Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);
	    y = this.y0 + con;
	  }
	  else {
	    //y = this.y0 - Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);
	    y = this.y0 - con;
	  }
	  p.x = x;
	  p.y = y;
	  return p;
	};

	/* Van Der Grinten inverse equations--mapping x,y to lat/long
	  ---------------------------------------------------------*/
	exports.inverse = function(p) {
	  var lon, lat;
	  var xx, yy, xys, c1, c2, c3;
	  var a1;
	  var m1;
	  var con;
	  var th1;
	  var d;

	  /* inverse equations
	    -----------------*/
	  p.x -= this.x0;
	  p.y -= this.y0;
	  con = Math.PI * this.R;
	  xx = p.x / con;
	  yy = p.y / con;
	  xys = xx * xx + yy * yy;
	  c1 = -Math.abs(yy) * (1 + xys);
	  c2 = c1 - 2 * yy * yy + xx * xx;
	  c3 = -2 * c1 + 1 + 2 * yy * yy + xys * xys;
	  d = yy * yy / c3 + (2 * c2 * c2 * c2 / c3 / c3 / c3 - 9 * c1 * c2 / c3 / c3) / 27;
	  a1 = (c1 - c2 * c2 / 3 / c3) / c3;
	  m1 = 2 * Math.sqrt(-a1 / 3);
	  con = ((3 * d) / a1) / m1;
	  if (Math.abs(con) > 1) {
	    if (con >= 0) {
	      con = 1;
	    }
	    else {
	      con = -1;
	    }
	  }
	  th1 = Math.acos(con) / 3;
	  if (p.y >= 0) {
	    lat = (-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
	  }
	  else {
	    lat = -(-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
	  }

	  if (Math.abs(xx) < EPSLN) {
	    lon = this.long0;
	  }
	  else {
	    lon = adjust_lon(this.long0 + Math.PI * (xys - 1 + Math.sqrt(1 + 2 * (xx * xx - yy * yy) + xys * xys)) / 2 / xx);
	  }

	  p.x = lon;
	  p.y = lat;
	  return p;
	};
	exports.names = ["Van_der_Grinten_I", "VanDerGrinten", "vandg"];
	},{"../common/adjust_lon":5,"../common/asinz":6}],64:[function(_dereq_,module,exports){
	var D2R = 0.01745329251994329577;
	var R2D = 57.29577951308232088;
	var PJD_3PARAM = 1;
	var PJD_7PARAM = 2;
	var datum_transform = _dereq_('./datum_transform');
	var adjust_axis = _dereq_('./adjust_axis');
	var proj = _dereq_('./Proj');
	var toPoint = _dereq_('./common/toPoint');
	module.exports = function transform(source, dest, point) {
	  var wgs84;
	  if (Array.isArray(point)) {
	    point = toPoint(point);
	  }
	  function checkNotWGS(source, dest) {
	    return ((source.datum.datum_type === PJD_3PARAM || source.datum.datum_type === PJD_7PARAM) && dest.datumCode !== "WGS84");
	  }

	  // Workaround for datum shifts towgs84, if either source or destination projection is not wgs84
	  if (source.datum && dest.datum && (checkNotWGS(source, dest) || checkNotWGS(dest, source))) {
	    wgs84 = new proj('WGS84');
	    transform(source, wgs84, point);
	    source = wgs84;
	  }
	  // DGR, 2010/11/12
	  if (source.axis !== "enu") {
	    adjust_axis(source, false, point);
	  }
	  // Transform source points to long/lat, if they aren't already.
	  if (source.projName === "longlat") {
	    point.x *= D2R; // convert degrees to radians
	    point.y *= D2R;
	  }
	  else {
	    if (source.to_meter) {
	      point.x *= source.to_meter;
	      point.y *= source.to_meter;
	    }
	    source.inverse(point); // Convert Cartesian to longlat
	  }
	  // Adjust for the prime meridian if necessary
	  if (source.from_greenwich) {
	    point.x += source.from_greenwich;
	  }

	  // Convert datums if needed, and if possible.
	  point = datum_transform(source.datum, dest.datum, point);

	  // Adjust for the prime meridian if necessary
	  if (dest.from_greenwich) {
	    point.x -= dest.from_greenwich;
	  }

	  if (dest.projName === "longlat") {
	    // convert radians to decimal degrees
	    point.x *= R2D;
	    point.y *= R2D;
	  }
	  else { // else project
	    dest.forward(point);
	    if (dest.to_meter) {
	      point.x /= dest.to_meter;
	      point.y /= dest.to_meter;
	    }
	  }

	  // DGR, 2010/11/12
	  if (dest.axis !== "enu") {
	    adjust_axis(dest, true, point);
	  }

	  return point;
	};
	},{"./Proj":2,"./adjust_axis":3,"./common/toPoint":23,"./datum_transform":30}],65:[function(_dereq_,module,exports){
	var D2R = 0.01745329251994329577;
	var extend = _dereq_('./extend');

	function mapit(obj, key, v) {
	  obj[key] = v.map(function(aa) {
	    var o = {};
	    sExpr(aa, o);
	    return o;
	  }).reduce(function(a, b) {
	    return extend(a, b);
	  }, {});
	}

	function sExpr(v, obj) {
	  var key;
	  if (!Array.isArray(v)) {
	    obj[v] = true;
	    return;
	  }
	  else {
	    key = v.shift();
	    if (key === 'PARAMETER') {
	      key = v.shift();
	    }
	    if (v.length === 1) {
	      if (Array.isArray(v[0])) {
	        obj[key] = {};
	        sExpr(v[0], obj[key]);
	      }
	      else {
	        obj[key] = v[0];
	      }
	    }
	    else if (!v.length) {
	      obj[key] = true;
	    }
	    else if (key === 'TOWGS84') {
	      obj[key] = v;
	    }
	    else {
	      obj[key] = {};
	      if (['UNIT', 'PRIMEM', 'VERT_DATUM'].indexOf(key) > -1) {
	        obj[key] = {
	          name: v[0].toLowerCase(),
	          convert: v[1]
	        };
	        if (v.length === 3) {
	          obj[key].auth = v[2];
	        }
	      }
	      else if (key === 'SPHEROID') {
	        obj[key] = {
	          name: v[0],
	          a: v[1],
	          rf: v[2]
	        };
	        if (v.length === 4) {
	          obj[key].auth = v[3];
	        }
	      }
	      else if (['GEOGCS', 'GEOCCS', 'DATUM', 'VERT_CS', 'COMPD_CS', 'LOCAL_CS', 'FITTED_CS', 'LOCAL_DATUM'].indexOf(key) > -1) {
	        v[0] = ['name', v[0]];
	        mapit(obj, key, v);
	      }
	      else if (v.every(function(aa) {
	        return Array.isArray(aa);
	      })) {
	        mapit(obj, key, v);
	      }
	      else {
	        sExpr(v, obj[key]);
	      }
	    }
	  }
	}

	function rename(obj, params) {
	  var outName = params[0];
	  var inName = params[1];
	  if (!(outName in obj) && (inName in obj)) {
	    obj[outName] = obj[inName];
	    if (params.length === 3) {
	      obj[outName] = params[2](obj[outName]);
	    }
	  }
	}

	function d2r(input) {
	  return input * D2R;
	}

	function cleanWKT(wkt) {
	  if (wkt.type === 'GEOGCS') {
	    wkt.projName = 'longlat';
	  }
	  else if (wkt.type === 'LOCAL_CS') {
	    wkt.projName = 'identity';
	    wkt.local = true;
	  }
	  else {
	    if (typeof wkt.PROJECTION === "object") {
	      wkt.projName = Object.keys(wkt.PROJECTION)[0];
	    }
	    else {
	      wkt.projName = wkt.PROJECTION;
	    }
	  }
	  if (wkt.UNIT) {
	    wkt.units = wkt.UNIT.name.toLowerCase();
	    if (wkt.units === 'metre') {
	      wkt.units = 'meter';
	    }
	    if (wkt.UNIT.convert) {
	      wkt.to_meter = parseFloat(wkt.UNIT.convert, 10);
	    }
	  }

	  if (wkt.GEOGCS) {
	    //if(wkt.GEOGCS.PRIMEM&&wkt.GEOGCS.PRIMEM.convert){
	    //  wkt.from_greenwich=wkt.GEOGCS.PRIMEM.convert*D2R;
	    //}
	    if (wkt.GEOGCS.DATUM) {
	      wkt.datumCode = wkt.GEOGCS.DATUM.name.toLowerCase();
	    }
	    else {
	      wkt.datumCode = wkt.GEOGCS.name.toLowerCase();
	    }
	    if (wkt.datumCode.slice(0, 2) === 'd_') {
	      wkt.datumCode = wkt.datumCode.slice(2);
	    }
	    if (wkt.datumCode === 'new_zealand_geodetic_datum_1949' || wkt.datumCode === 'new_zealand_1949') {
	      wkt.datumCode = 'nzgd49';
	    }
	    if (wkt.datumCode === "wgs_1984") {
	      if (wkt.PROJECTION === 'Mercator_Auxiliary_Sphere') {
	        wkt.sphere = true;
	      }
	      wkt.datumCode = 'wgs84';
	    }
	    if (wkt.datumCode.slice(-6) === '_ferro') {
	      wkt.datumCode = wkt.datumCode.slice(0, - 6);
	    }
	    if (wkt.datumCode.slice(-8) === '_jakarta') {
	      wkt.datumCode = wkt.datumCode.slice(0, - 8);
	    }
	    if (~wkt.datumCode.indexOf('belge')) {
	      wkt.datumCode = "rnb72";
	    }
	    if (wkt.GEOGCS.DATUM && wkt.GEOGCS.DATUM.SPHEROID) {
	      wkt.ellps = wkt.GEOGCS.DATUM.SPHEROID.name.replace('_19', '').replace(/[Cc]larke\_18/, 'clrk');
	      if (wkt.ellps.toLowerCase().slice(0, 13) === "international") {
	        wkt.ellps = 'intl';
	      }

	      wkt.a = wkt.GEOGCS.DATUM.SPHEROID.a;
	      wkt.rf = parseFloat(wkt.GEOGCS.DATUM.SPHEROID.rf, 10);
	    }
	    if (~wkt.datumCode.indexOf('osgb_1936')) {
	      wkt.datumCode = "osgb36";
	    }
	  }
	  if (wkt.b && !isFinite(wkt.b)) {
	    wkt.b = wkt.a;
	  }

	  function toMeter(input) {
	    var ratio = wkt.to_meter || 1;
	    return parseFloat(input, 10) * ratio;
	  }
	  var renamer = function(a) {
	    return rename(wkt, a);
	  };
	  var list = [
	    ['standard_parallel_1', 'Standard_Parallel_1'],
	    ['standard_parallel_2', 'Standard_Parallel_2'],
	    ['false_easting', 'False_Easting'],
	    ['false_northing', 'False_Northing'],
	    ['central_meridian', 'Central_Meridian'],
	    ['latitude_of_origin', 'Latitude_Of_Origin'],
	    ['latitude_of_origin', 'Central_Parallel'],
	    ['scale_factor', 'Scale_Factor'],
	    ['k0', 'scale_factor'],
	    ['latitude_of_center', 'Latitude_of_center'],
	    ['lat0', 'latitude_of_center', d2r],
	    ['longitude_of_center', 'Longitude_Of_Center'],
	    ['longc', 'longitude_of_center', d2r],
	    ['x0', 'false_easting', toMeter],
	    ['y0', 'false_northing', toMeter],
	    ['long0', 'central_meridian', d2r],
	    ['lat0', 'latitude_of_origin', d2r],
	    ['lat0', 'standard_parallel_1', d2r],
	    ['lat1', 'standard_parallel_1', d2r],
	    ['lat2', 'standard_parallel_2', d2r],
	    ['alpha', 'azimuth', d2r],
	    ['srsCode', 'name']
	  ];
	  list.forEach(renamer);
	  if (!wkt.long0 && wkt.longc && (wkt.PROJECTION === 'Albers_Conic_Equal_Area' || wkt.PROJECTION === "Lambert_Azimuthal_Equal_Area")) {
	    wkt.long0 = wkt.longc;
	  }
	}
	module.exports = function(wkt, self) {
	  var lisp = JSON.parse(("," + wkt).replace(/\s*\,\s*([A-Z_0-9]+?)(\[)/g, ',["$1",').slice(1).replace(/\s*\,\s*([A-Z_0-9]+?)\]/g, ',"$1"]').replace(/,\["VERTCS".+/,''));
	  var type = lisp.shift();
	  var name = lisp.shift();
	  lisp.unshift(['name', name]);
	  lisp.unshift(['type', type]);
	  lisp.unshift('output');
	  var obj = {};
	  sExpr(lisp, obj);
	  cleanWKT(obj.output);
	  return extend(self, obj.output);
	};

	},{"./extend":33}],66:[function(_dereq_,module,exports){



	/**
	 * UTM zones are grouped, and assigned to one of a group of 6
	 * sets.
	 *
	 * {int} @private
	 */
	var NUM_100K_SETS = 6;

	/**
	 * The column letters (for easting) of the lower left value, per
	 * set.
	 *
	 * {string} @private
	 */
	var SET_ORIGIN_COLUMN_LETTERS = 'AJSAJS';

	/**
	 * The row letters (for northing) of the lower left value, per
	 * set.
	 *
	 * {string} @private
	 */
	var SET_ORIGIN_ROW_LETTERS = 'AFAFAF';

	var A = 65; // A
	var I = 73; // I
	var O = 79; // O
	var V = 86; // V
	var Z = 90; // Z

	/**
	 * Conversion of lat/lon to MGRS.
	 *
	 * @param {object} ll Object literal with lat and lon properties on a
	 *     WGS84 ellipsoid.
	 * @param {int} accuracy Accuracy in digits (5 for 1 m, 4 for 10 m, 3 for
	 *      100 m, 4 for 1000 m or 5 for 10000 m). Optional, default is 5.
	 * @return {string} the MGRS string for the given location and accuracy.
	 */
	exports.forward = function(ll, accuracy) {
	  accuracy = accuracy || 5; // default accuracy 1m
	  return encode(LLtoUTM({
	    lat: ll[1],
	    lon: ll[0]
	  }), accuracy);
	};

	/**
	 * Conversion of MGRS to lat/lon.
	 *
	 * @param {string} mgrs MGRS string.
	 * @return {array} An array with left (longitude), bottom (latitude), right
	 *     (longitude) and top (latitude) values in WGS84, representing the
	 *     bounding box for the provided MGRS reference.
	 */
	exports.inverse = function(mgrs) {
	  var bbox = UTMtoLL(decode(mgrs.toUpperCase()));
	  return [bbox.left, bbox.bottom, bbox.right, bbox.top];
	};

	exports.toPoint = function(mgrsStr) {
	  var llbbox = exports.inverse(mgrsStr);
	  return [(llbbox[2] + llbbox[0]) / 2, (llbbox[3] + llbbox[1]) / 2];
	};
	/**
	 * Conversion from degrees to radians.
	 *
	 * @private
	 * @param {number} deg the angle in degrees.
	 * @return {number} the angle in radians.
	 */
	function degToRad(deg) {
	  return (deg * (Math.PI / 180.0));
	}

	/**
	 * Conversion from radians to degrees.
	 *
	 * @private
	 * @param {number} rad the angle in radians.
	 * @return {number} the angle in degrees.
	 */
	function radToDeg(rad) {
	  return (180.0 * (rad / Math.PI));
	}

	/**
	 * Converts a set of Longitude and Latitude co-ordinates to UTM
	 * using the WGS84 ellipsoid.
	 *
	 * @private
	 * @param {object} ll Object literal with lat and lon properties
	 *     representing the WGS84 coordinate to be converted.
	 * @return {object} Object literal containing the UTM value with easting,
	 *     northing, zoneNumber and zoneLetter properties, and an optional
	 *     accuracy property in digits. Returns null if the conversion failed.
	 */
	function LLtoUTM(ll) {
	  var Lat = ll.lat;
	  var Long = ll.lon;
	  var a = 6378137.0; //ellip.radius;
	  var eccSquared = 0.00669438; //ellip.eccsq;
	  var k0 = 0.9996;
	  var LongOrigin;
	  var eccPrimeSquared;
	  var N, T, C, A, M;
	  var LatRad = degToRad(Lat);
	  var LongRad = degToRad(Long);
	  var LongOriginRad;
	  var ZoneNumber;
	  // (int)
	  ZoneNumber = Math.floor((Long + 180) / 6) + 1;

	  //Make sure the longitude 180.00 is in Zone 60
	  if (Long === 180) {
	    ZoneNumber = 60;
	  }

	  // Special zone for Norway
	  if (Lat >= 56.0 && Lat < 64.0 && Long >= 3.0 && Long < 12.0) {
	    ZoneNumber = 32;
	  }

	  // Special zones for Svalbard
	  if (Lat >= 72.0 && Lat < 84.0) {
	    if (Long >= 0.0 && Long < 9.0) {
	      ZoneNumber = 31;
	    }
	    else if (Long >= 9.0 && Long < 21.0) {
	      ZoneNumber = 33;
	    }
	    else if (Long >= 21.0 && Long < 33.0) {
	      ZoneNumber = 35;
	    }
	    else if (Long >= 33.0 && Long < 42.0) {
	      ZoneNumber = 37;
	    }
	  }

	  LongOrigin = (ZoneNumber - 1) * 6 - 180 + 3; //+3 puts origin
	  // in middle of
	  // zone
	  LongOriginRad = degToRad(LongOrigin);

	  eccPrimeSquared = (eccSquared) / (1 - eccSquared);

	  N = a / Math.sqrt(1 - eccSquared * Math.sin(LatRad) * Math.sin(LatRad));
	  T = Math.tan(LatRad) * Math.tan(LatRad);
	  C = eccPrimeSquared * Math.cos(LatRad) * Math.cos(LatRad);
	  A = Math.cos(LatRad) * (LongRad - LongOriginRad);

	  M = a * ((1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256) * LatRad - (3 * eccSquared / 8 + 3 * eccSquared * eccSquared / 32 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(2 * LatRad) + (15 * eccSquared * eccSquared / 256 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(4 * LatRad) - (35 * eccSquared * eccSquared * eccSquared / 3072) * Math.sin(6 * LatRad));

	  var UTMEasting = (k0 * N * (A + (1 - T + C) * A * A * A / 6.0 + (5 - 18 * T + T * T + 72 * C - 58 * eccPrimeSquared) * A * A * A * A * A / 120.0) + 500000.0);

	  var UTMNorthing = (k0 * (M + N * Math.tan(LatRad) * (A * A / 2 + (5 - T + 9 * C + 4 * C * C) * A * A * A * A / 24.0 + (61 - 58 * T + T * T + 600 * C - 330 * eccPrimeSquared) * A * A * A * A * A * A / 720.0)));
	  if (Lat < 0.0) {
	    UTMNorthing += 10000000.0; //10000000 meter offset for
	    // southern hemisphere
	  }

	  return {
	    northing: Math.round(UTMNorthing),
	    easting: Math.round(UTMEasting),
	    zoneNumber: ZoneNumber,
	    zoneLetter: getLetterDesignator(Lat)
	  };
	}

	/**
	 * Converts UTM coords to lat/long, using the WGS84 ellipsoid. This is a convenience
	 * class where the Zone can be specified as a single string eg."60N" which
	 * is then broken down into the ZoneNumber and ZoneLetter.
	 *
	 * @private
	 * @param {object} utm An object literal with northing, easting, zoneNumber
	 *     and zoneLetter properties. If an optional accuracy property is
	 *     provided (in meters), a bounding box will be returned instead of
	 *     latitude and longitude.
	 * @return {object} An object literal containing either lat and lon values
	 *     (if no accuracy was provided), or top, right, bottom and left values
	 *     for the bounding box calculated according to the provided accuracy.
	 *     Returns null if the conversion failed.
	 */
	function UTMtoLL(utm) {

	  var UTMNorthing = utm.northing;
	  var UTMEasting = utm.easting;
	  var zoneLetter = utm.zoneLetter;
	  var zoneNumber = utm.zoneNumber;
	  // check the ZoneNummber is valid
	  if (zoneNumber < 0 || zoneNumber > 60) {
	    return null;
	  }

	  var k0 = 0.9996;
	  var a = 6378137.0; //ellip.radius;
	  var eccSquared = 0.00669438; //ellip.eccsq;
	  var eccPrimeSquared;
	  var e1 = (1 - Math.sqrt(1 - eccSquared)) / (1 + Math.sqrt(1 - eccSquared));
	  var N1, T1, C1, R1, D, M;
	  var LongOrigin;
	  var mu, phi1Rad;

	  // remove 500,000 meter offset for longitude
	  var x = UTMEasting - 500000.0;
	  var y = UTMNorthing;

	  // We must know somehow if we are in the Northern or Southern
	  // hemisphere, this is the only time we use the letter So even
	  // if the Zone letter isn't exactly correct it should indicate
	  // the hemisphere correctly
	  if (zoneLetter < 'N') {
	    y -= 10000000.0; // remove 10,000,000 meter offset used
	    // for southern hemisphere
	  }

	  // There are 60 zones with zone 1 being at West -180 to -174
	  LongOrigin = (zoneNumber - 1) * 6 - 180 + 3; // +3 puts origin
	  // in middle of
	  // zone

	  eccPrimeSquared = (eccSquared) / (1 - eccSquared);

	  M = y / k0;
	  mu = M / (a * (1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256));

	  phi1Rad = mu + (3 * e1 / 2 - 27 * e1 * e1 * e1 / 32) * Math.sin(2 * mu) + (21 * e1 * e1 / 16 - 55 * e1 * e1 * e1 * e1 / 32) * Math.sin(4 * mu) + (151 * e1 * e1 * e1 / 96) * Math.sin(6 * mu);
	  // double phi1 = ProjMath.radToDeg(phi1Rad);

	  N1 = a / Math.sqrt(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad));
	  T1 = Math.tan(phi1Rad) * Math.tan(phi1Rad);
	  C1 = eccPrimeSquared * Math.cos(phi1Rad) * Math.cos(phi1Rad);
	  R1 = a * (1 - eccSquared) / Math.pow(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad), 1.5);
	  D = x / (N1 * k0);

	  var lat = phi1Rad - (N1 * Math.tan(phi1Rad) / R1) * (D * D / 2 - (5 + 3 * T1 + 10 * C1 - 4 * C1 * C1 - 9 * eccPrimeSquared) * D * D * D * D / 24 + (61 + 90 * T1 + 298 * C1 + 45 * T1 * T1 - 252 * eccPrimeSquared - 3 * C1 * C1) * D * D * D * D * D * D / 720);
	  lat = radToDeg(lat);

	  var lon = (D - (1 + 2 * T1 + C1) * D * D * D / 6 + (5 - 2 * C1 + 28 * T1 - 3 * C1 * C1 + 8 * eccPrimeSquared + 24 * T1 * T1) * D * D * D * D * D / 120) / Math.cos(phi1Rad);
	  lon = LongOrigin + radToDeg(lon);

	  var result;
	  if (utm.accuracy) {
	    var topRight = UTMtoLL({
	      northing: utm.northing + utm.accuracy,
	      easting: utm.easting + utm.accuracy,
	      zoneLetter: utm.zoneLetter,
	      zoneNumber: utm.zoneNumber
	    });
	    result = {
	      top: topRight.lat,
	      right: topRight.lon,
	      bottom: lat,
	      left: lon
	    };
	  }
	  else {
	    result = {
	      lat: lat,
	      lon: lon
	    };
	  }
	  return result;
	}

	/**
	 * Calculates the MGRS letter designator for the given latitude.
	 *
	 * @private
	 * @param {number} lat The latitude in WGS84 to get the letter designator
	 *     for.
	 * @return {char} The letter designator.
	 */
	function getLetterDesignator(lat) {
	  //This is here as an error flag to show that the Latitude is
	  //outside MGRS limits
	  var LetterDesignator = 'Z';

	  if ((84 >= lat) && (lat >= 72)) {
	    LetterDesignator = 'X';
	  }
	  else if ((72 > lat) && (lat >= 64)) {
	    LetterDesignator = 'W';
	  }
	  else if ((64 > lat) && (lat >= 56)) {
	    LetterDesignator = 'V';
	  }
	  else if ((56 > lat) && (lat >= 48)) {
	    LetterDesignator = 'U';
	  }
	  else if ((48 > lat) && (lat >= 40)) {
	    LetterDesignator = 'T';
	  }
	  else if ((40 > lat) && (lat >= 32)) {
	    LetterDesignator = 'S';
	  }
	  else if ((32 > lat) && (lat >= 24)) {
	    LetterDesignator = 'R';
	  }
	  else if ((24 > lat) && (lat >= 16)) {
	    LetterDesignator = 'Q';
	  }
	  else if ((16 > lat) && (lat >= 8)) {
	    LetterDesignator = 'P';
	  }
	  else if ((8 > lat) && (lat >= 0)) {
	    LetterDesignator = 'N';
	  }
	  else if ((0 > lat) && (lat >= -8)) {
	    LetterDesignator = 'M';
	  }
	  else if ((-8 > lat) && (lat >= -16)) {
	    LetterDesignator = 'L';
	  }
	  else if ((-16 > lat) && (lat >= -24)) {
	    LetterDesignator = 'K';
	  }
	  else if ((-24 > lat) && (lat >= -32)) {
	    LetterDesignator = 'J';
	  }
	  else if ((-32 > lat) && (lat >= -40)) {
	    LetterDesignator = 'H';
	  }
	  else if ((-40 > lat) && (lat >= -48)) {
	    LetterDesignator = 'G';
	  }
	  else if ((-48 > lat) && (lat >= -56)) {
	    LetterDesignator = 'F';
	  }
	  else if ((-56 > lat) && (lat >= -64)) {
	    LetterDesignator = 'E';
	  }
	  else if ((-64 > lat) && (lat >= -72)) {
	    LetterDesignator = 'D';
	  }
	  else if ((-72 > lat) && (lat >= -80)) {
	    LetterDesignator = 'C';
	  }
	  return LetterDesignator;
	}

	/**
	 * Encodes a UTM location as MGRS string.
	 *
	 * @private
	 * @param {object} utm An object literal with easting, northing,
	 *     zoneLetter, zoneNumber
	 * @param {number} accuracy Accuracy in digits (1-5).
	 * @return {string} MGRS string for the given UTM location.
	 */
	function encode(utm, accuracy) {
	  var seasting = "" + utm.easting,
	    snorthing = "" + utm.northing;

	  return utm.zoneNumber + utm.zoneLetter + get100kID(utm.easting, utm.northing, utm.zoneNumber) + seasting.substr(seasting.length - 5, accuracy) + snorthing.substr(snorthing.length - 5, accuracy);
	}

	/**
	 * Get the two letter 100k designator for a given UTM easting,
	 * northing and zone number value.
	 *
	 * @private
	 * @param {number} easting
	 * @param {number} northing
	 * @param {number} zoneNumber
	 * @return the two letter 100k designator for the given UTM location.
	 */
	function get100kID(easting, northing, zoneNumber) {
	  var setParm = get100kSetForZone(zoneNumber);
	  var setColumn = Math.floor(easting / 100000);
	  var setRow = Math.floor(northing / 100000) % 20;
	  return getLetter100kID(setColumn, setRow, setParm);
	}

	/**
	 * Given a UTM zone number, figure out the MGRS 100K set it is in.
	 *
	 * @private
	 * @param {number} i An UTM zone number.
	 * @return {number} the 100k set the UTM zone is in.
	 */
	function get100kSetForZone(i) {
	  var setParm = i % NUM_100K_SETS;
	  if (setParm === 0) {
	    setParm = NUM_100K_SETS;
	  }

	  return setParm;
	}

	/**
	 * Get the two-letter MGRS 100k designator given information
	 * translated from the UTM northing, easting and zone number.
	 *
	 * @private
	 * @param {number} column the column index as it relates to the MGRS
	 *        100k set spreadsheet, created from the UTM easting.
	 *        Values are 1-8.
	 * @param {number} row the row index as it relates to the MGRS 100k set
	 *        spreadsheet, created from the UTM northing value. Values
	 *        are from 0-19.
	 * @param {number} parm the set block, as it relates to the MGRS 100k set
	 *        spreadsheet, created from the UTM zone. Values are from
	 *        1-60.
	 * @return two letter MGRS 100k code.
	 */
	function getLetter100kID(column, row, parm) {
	  // colOrigin and rowOrigin are the letters at the origin of the set
	  var index = parm - 1;
	  var colOrigin = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(index);
	  var rowOrigin = SET_ORIGIN_ROW_LETTERS.charCodeAt(index);

	  // colInt and rowInt are the letters to build to return
	  var colInt = colOrigin + column - 1;
	  var rowInt = rowOrigin + row;
	  var rollover = false;

	  if (colInt > Z) {
	    colInt = colInt - Z + A - 1;
	    rollover = true;
	  }

	  if (colInt === I || (colOrigin < I && colInt > I) || ((colInt > I || colOrigin < I) && rollover)) {
	    colInt++;
	  }

	  if (colInt === O || (colOrigin < O && colInt > O) || ((colInt > O || colOrigin < O) && rollover)) {
	    colInt++;

	    if (colInt === I) {
	      colInt++;
	    }
	  }

	  if (colInt > Z) {
	    colInt = colInt - Z + A - 1;
	  }

	  if (rowInt > V) {
	    rowInt = rowInt - V + A - 1;
	    rollover = true;
	  }
	  else {
	    rollover = false;
	  }

	  if (((rowInt === I) || ((rowOrigin < I) && (rowInt > I))) || (((rowInt > I) || (rowOrigin < I)) && rollover)) {
	    rowInt++;
	  }

	  if (((rowInt === O) || ((rowOrigin < O) && (rowInt > O))) || (((rowInt > O) || (rowOrigin < O)) && rollover)) {
	    rowInt++;

	    if (rowInt === I) {
	      rowInt++;
	    }
	  }

	  if (rowInt > V) {
	    rowInt = rowInt - V + A - 1;
	  }

	  var twoLetter = String.fromCharCode(colInt) + String.fromCharCode(rowInt);
	  return twoLetter;
	}

	/**
	 * Decode the UTM parameters from a MGRS string.
	 *
	 * @private
	 * @param {string} mgrsString an UPPERCASE coordinate string is expected.
	 * @return {object} An object literal with easting, northing, zoneLetter,
	 *     zoneNumber and accuracy (in meters) properties.
	 */
	function decode(mgrsString) {

	  if (mgrsString && mgrsString.length === 0) {
	    throw ("MGRSPoint coverting from nothing");
	  }

	  var length = mgrsString.length;

	  var hunK = null;
	  var sb = "";
	  var testChar;
	  var i = 0;

	  // get Zone number
	  while (!(/[A-Z]/).test(testChar = mgrsString.charAt(i))) {
	    if (i >= 2) {
	      throw ("MGRSPoint bad conversion from: " + mgrsString);
	    }
	    sb += testChar;
	    i++;
	  }

	  var zoneNumber = parseInt(sb, 10);

	  if (i === 0 || i + 3 > length) {
	    // A good MGRS string has to be 4-5 digits long,
	    // ##AAA/#AAA at least.
	    throw ("MGRSPoint bad conversion from: " + mgrsString);
	  }

	  var zoneLetter = mgrsString.charAt(i++);

	  // Should we check the zone letter here? Why not.
	  if (zoneLetter <= 'A' || zoneLetter === 'B' || zoneLetter === 'Y' || zoneLetter >= 'Z' || zoneLetter === 'I' || zoneLetter === 'O') {
	    throw ("MGRSPoint zone letter " + zoneLetter + " not handled: " + mgrsString);
	  }

	  hunK = mgrsString.substring(i, i += 2);

	  var set = get100kSetForZone(zoneNumber);

	  var east100k = getEastingFromChar(hunK.charAt(0), set);
	  var north100k = getNorthingFromChar(hunK.charAt(1), set);

	  // We have a bug where the northing may be 2000000 too low.
	  // How
	  // do we know when to roll over?

	  while (north100k < getMinNorthing(zoneLetter)) {
	    north100k += 2000000;
	  }

	  // calculate the char index for easting/northing separator
	  var remainder = length - i;

	  if (remainder % 2 !== 0) {
	    throw ("MGRSPoint has to have an even number \nof digits after the zone letter and two 100km letters - front \nhalf for easting meters, second half for \nnorthing meters" + mgrsString);
	  }

	  var sep = remainder / 2;

	  var sepEasting = 0.0;
	  var sepNorthing = 0.0;
	  var accuracyBonus, sepEastingString, sepNorthingString, easting, northing;
	  if (sep > 0) {
	    accuracyBonus = 100000.0 / Math.pow(10, sep);
	    sepEastingString = mgrsString.substring(i, i + sep);
	    sepEasting = parseFloat(sepEastingString) * accuracyBonus;
	    sepNorthingString = mgrsString.substring(i + sep);
	    sepNorthing = parseFloat(sepNorthingString) * accuracyBonus;
	  }

	  easting = sepEasting + east100k;
	  northing = sepNorthing + north100k;

	  return {
	    easting: easting,
	    northing: northing,
	    zoneLetter: zoneLetter,
	    zoneNumber: zoneNumber,
	    accuracy: accuracyBonus
	  };
	}

	/**
	 * Given the first letter from a two-letter MGRS 100k zone, and given the
	 * MGRS table set for the zone number, figure out the easting value that
	 * should be added to the other, secondary easting value.
	 *
	 * @private
	 * @param {char} e The first letter from a two-letter MGRS 100´k zone.
	 * @param {number} set The MGRS table set for the zone number.
	 * @return {number} The easting value for the given letter and set.
	 */
	function getEastingFromChar(e, set) {
	  // colOrigin is the letter at the origin of the set for the
	  // column
	  var curCol = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(set - 1);
	  var eastingValue = 100000.0;
	  var rewindMarker = false;

	  while (curCol !== e.charCodeAt(0)) {
	    curCol++;
	    if (curCol === I) {
	      curCol++;
	    }
	    if (curCol === O) {
	      curCol++;
	    }
	    if (curCol > Z) {
	      if (rewindMarker) {
	        throw ("Bad character: " + e);
	      }
	      curCol = A;
	      rewindMarker = true;
	    }
	    eastingValue += 100000.0;
	  }

	  return eastingValue;
	}

	/**
	 * Given the second letter from a two-letter MGRS 100k zone, and given the
	 * MGRS table set for the zone number, figure out the northing value that
	 * should be added to the other, secondary northing value. You have to
	 * remember that Northings are determined from the equator, and the vertical
	 * cycle of letters mean a 2000000 additional northing meters. This happens
	 * approx. every 18 degrees of latitude. This method does *NOT* count any
	 * additional northings. You have to figure out how many 2000000 meters need
	 * to be added for the zone letter of the MGRS coordinate.
	 *
	 * @private
	 * @param {char} n Second letter of the MGRS 100k zone
	 * @param {number} set The MGRS table set number, which is dependent on the
	 *     UTM zone number.
	 * @return {number} The northing value for the given letter and set.
	 */
	function getNorthingFromChar(n, set) {

	  if (n > 'V') {
	    throw ("MGRSPoint given invalid Northing " + n);
	  }

	  // rowOrigin is the letter at the origin of the set for the
	  // column
	  var curRow = SET_ORIGIN_ROW_LETTERS.charCodeAt(set - 1);
	  var northingValue = 0.0;
	  var rewindMarker = false;

	  while (curRow !== n.charCodeAt(0)) {
	    curRow++;
	    if (curRow === I) {
	      curRow++;
	    }
	    if (curRow === O) {
	      curRow++;
	    }
	    // fixing a bug making whole application hang in this loop
	    // when 'n' is a wrong character
	    if (curRow > V) {
	      if (rewindMarker) { // making sure that this loop ends
	        throw ("Bad character: " + n);
	      }
	      curRow = A;
	      rewindMarker = true;
	    }
	    northingValue += 100000.0;
	  }

	  return northingValue;
	}

	/**
	 * The function getMinNorthing returns the minimum northing value of a MGRS
	 * zone.
	 *
	 * Ported from Geotrans' c Lattitude_Band_Value structure table.
	 *
	 * @private
	 * @param {char} zoneLetter The MGRS zone to get the min northing for.
	 * @return {number}
	 */
	function getMinNorthing(zoneLetter) {
	  var northing;
	  switch (zoneLetter) {
	  case 'C':
	    northing = 1100000.0;
	    break;
	  case 'D':
	    northing = 2000000.0;
	    break;
	  case 'E':
	    northing = 2800000.0;
	    break;
	  case 'F':
	    northing = 3700000.0;
	    break;
	  case 'G':
	    northing = 4600000.0;
	    break;
	  case 'H':
	    northing = 5500000.0;
	    break;
	  case 'J':
	    northing = 6400000.0;
	    break;
	  case 'K':
	    northing = 7300000.0;
	    break;
	  case 'L':
	    northing = 8200000.0;
	    break;
	  case 'M':
	    northing = 9100000.0;
	    break;
	  case 'N':
	    northing = 0.0;
	    break;
	  case 'P':
	    northing = 800000.0;
	    break;
	  case 'Q':
	    northing = 1700000.0;
	    break;
	  case 'R':
	    northing = 2600000.0;
	    break;
	  case 'S':
	    northing = 3500000.0;
	    break;
	  case 'T':
	    northing = 4400000.0;
	    break;
	  case 'U':
	    northing = 5300000.0;
	    break;
	  case 'V':
	    northing = 6200000.0;
	    break;
	  case 'W':
	    northing = 7000000.0;
	    break;
	  case 'X':
	    northing = 7900000.0;
	    break;
	  default:
	    northing = -1.0;
	  }
	  if (northing >= 0.0) {
	    return northing;
	  }
	  else {
	    throw ("Invalid zone letter: " + zoneLetter);
	  }

	}

	},{}],67:[function(_dereq_,module,exports){
	module.exports={
	  "name": "proj4",
	  "version": "2.3.3",
	  "description": "Proj4js is a JavaScript library to transform point coordinates from one coordinate system to another, including datum transformations.",
	  "main": "lib/index.js",
	  "directories": {
	    "test": "test",
	    "doc": "docs"
	  },
	  "scripts": {
	    "test": "./node_modules/istanbul/lib/cli.js test ./node_modules/mocha/bin/_mocha test/test.js"
	  },
	  "repository": {
	    "type": "git",
	    "url": "git://github.com/proj4js/proj4js.git"
	  },
	  "author": "",
	  "license": "MIT",
	  "jam": {
	    "main": "dist/proj4.js",
	    "include": [
	      "dist/proj4.js",
	      "README.md",
	      "AUTHORS",
	      "LICENSE.md"
	    ]
	  },
	  "devDependencies": {
	    "grunt-cli": "~0.1.13",
	    "grunt": "~0.4.2",
	    "grunt-contrib-connect": "~0.6.0",
	    "grunt-contrib-jshint": "~0.8.0",
	    "chai": "~1.8.1",
	    "mocha": "~1.17.1",
	    "grunt-mocha-phantomjs": "~0.4.0",
	    "browserify": "~3.24.5",
	    "grunt-browserify": "~1.3.0",
	    "grunt-contrib-uglify": "~0.3.2",
	    "curl": "git://github.com/cujojs/curl.git",
	    "istanbul": "~0.2.4",
	    "tin": "~0.4.0"
	  },
	  "dependencies": {
	    "mgrs": "0.0.0"
	  }
	}

	},{}],"./includedProjections":[function(_dereq_,module,exports){
	module.exports=_dereq_('gWUPNW');
	},{}],"gWUPNW":[function(_dereq_,module,exports){
	var projs = [
	 _dereq_('./lib/projections/tmerc'),
		_dereq_('./lib/projections/utm'),
		_dereq_('./lib/projections/sterea'),
		_dereq_('./lib/projections/stere'),
		_dereq_('./lib/projections/somerc'),
		_dereq_('./lib/projections/omerc'),
		_dereq_('./lib/projections/lcc'),
		_dereq_('./lib/projections/krovak'),
		_dereq_('./lib/projections/cass'),
		_dereq_('./lib/projections/laea'),
		_dereq_('./lib/projections/aea'),
		_dereq_('./lib/projections/gnom'),
		_dereq_('./lib/projections/cea'),
		_dereq_('./lib/projections/eqc'),
		_dereq_('./lib/projections/poly'),
		_dereq_('./lib/projections/nzmg'),
		_dereq_('./lib/projections/mill'),
		_dereq_('./lib/projections/sinu'),
		_dereq_('./lib/projections/moll'),
		_dereq_('./lib/projections/eqdc'),
		_dereq_('./lib/projections/vandg'),
		_dereq_('./lib/projections/aeqd')
	];
	module.exports = function(proj4){
	 projs.forEach(function(proj){
	   proj4.Proj.projections.add(proj);
	 });
	}
	},{"./lib/projections/aea":39,"./lib/projections/aeqd":40,"./lib/projections/cass":41,"./lib/projections/cea":42,"./lib/projections/eqc":43,"./lib/projections/eqdc":44,"./lib/projections/gnom":46,"./lib/projections/krovak":47,"./lib/projections/laea":48,"./lib/projections/lcc":49,"./lib/projections/mill":52,"./lib/projections/moll":53,"./lib/projections/nzmg":54,"./lib/projections/omerc":55,"./lib/projections/poly":56,"./lib/projections/sinu":57,"./lib/projections/somerc":58,"./lib/projections/stere":59,"./lib/projections/sterea":60,"./lib/projections/tmerc":61,"./lib/projections/utm":62,"./lib/projections/vandg":63}]},{},[35])
	(35)
	});

/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports TiffIFDEntry
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(31),
	        __webpack_require__(30),
	        __webpack_require__(229),
	        __webpack_require__(32),
	        __webpack_require__(230)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (AbstractError,
	              ArgumentError,
	              GeoTiffUtil,
	              Logger,
	              TiffConstants) {
	        "use strict";

	        /**
	         * Constructs an image file directory entry. Applications typically do not call this constructor. It is called
	         * by {@link GeoTiffReader} as GeoTIFF image file directories are read.
	         * @alias TiffIFDEntry
	         * @constructor
	         * @classdesc Contains the data associated with a GeoTIFF image file directory. An image file directory
	         * contains information about the image, as well as pointers to the actual image data.
	         * @param {Number} tag The TIFF tag that identifies the field.
	         * @param {Number} type The type of the field.
	         * @param {Number} count The number of values, count of the indicated type.
	         * @param {Number} valueOffset  The file offset (in bytes) of the Value for the field. This file offset may
	         * point anywhere in the file, even after the image data.
	         * @param {ArrayBuffer} geoTiffData The buffer descriptor of the geotiff file's content.
	         * @param {Boolean} isLittleEndian Indicates whether the geotiff byte order is little endian.
	         * @throws {ArgumentError} If either the specified tag, type, count, valueOffset, geoTiffData or isLittleEndian
	         * are null or undefined.
	         */
	        var TiffIFDEntry = function (tag, type, count, valueOffset, geoTiffData, isLittleEndian) {
	            if (!tag) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "TiffIFDEntry", "constructor", "missingTag"));
	            }

	            if (!type) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "TiffIFDEntry", "constructor", "missingType"));
	            }

	            if (!count) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "TiffIFDEntry", "constructor", "missingCount"));
	            }

	            if (valueOffset === null || valueOffset === undefined) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "TiffIFDEntry", "constructor", "missingValueOffset"));
	            }

	            if (!geoTiffData) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "TiffIFDEntry", "constructor", "missingGeoTiffData"));
	            }

	            if (isLittleEndian === null || isLittleEndian === undefined) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "TiffIFDEntry", "constructor", "missingIsLittleEndian"));
	            }

	            // Documented in defineProperties below.
	            this._tag = tag;

	            // Documented in defineProperties below.
	            this._type = type;

	            // Documented in defineProperties below.
	            this._count = count;

	            // Documented in defineProperties below.
	            this._valueOffset = valueOffset;

	            // Documented in defineProperties below.
	            this._geoTiffData = geoTiffData;

	            // Documented in defineProperties below.
	            this._isLittleEndian = isLittleEndian;
	        };

	        Object.defineProperties(TiffIFDEntry.prototype, {

	            /**
	             * The tag that identifies the field as specified to this TiffIFDEntry's constructor.
	             * @memberof TiffIFDEntry.prototype
	             * @type {Number}
	             * @readonly
	             */
	            tag: {
	                get: function () {
	                    return this._tag;
	                }
	            },

	            /**
	             * The field type as specified to this TiffIFDEntry's constructor.
	             * @memberof TiffIFDEntry.prototype
	             * @type {Number}
	             * @readonly
	             */
	            type: {
	                get: function () {
	                    return this._type;
	                }
	            },

	            /**
	             * The number of the values as specified to this TiffIFDEntry's constructor.
	             * @memberof TiffIFDEntry.prototype
	             * @type {Number}
	             * @readonly
	             */
	            count: {
	                get: function () {
	                    return this._count;
	                }
	            },

	            /**
	             * The file offset as specified to this TiffIFDEntry's constructor.
	             * @memberof TiffIFDEntry.prototype
	             * @type {Number}
	             * @readonly
	             */
	            valueOffset: {
	                get: function () {
	                    return this._valueOffset;
	                }
	            },

	            /**
	             * The geotiff buffer data as specified to this TiffIFDEntry's constructor.
	             * @memberof TiffIFDEntry.prototype
	             * @type {ArrayBuffer}
	             * @readonly
	             */
	            geoTiffData: {
	                get: function () {
	                    return this._geoTiffData;
	                }
	            },

	            /**
	             * The little endian byte order flag as specified to this TiffIFDEntry's constructor.
	             * @memberof TiffIFDEntry.prototype
	             * @type {Boolean}
	             * @readonly
	             */
	            isLittleEndian: {
	                get: function () {
	                    return this._isLittleEndian;
	                }
	            }
	        });

	        /**
	         * Get the number of bytes of an image file directory depending on its type.
	         * @returns {Number}
	         */
	        TiffIFDEntry.prototype.getIFDTypeLength = function () {
	            switch(this.type){
	                case TiffConstants.Type.BYTE:
	                case TiffConstants.Type.ASCII:
	                case TiffConstants.Type.SBYTE:
	                case TiffConstants.Type.UNDEFINED:
	                    return 1;
	                case TiffConstants.Type.SHORT:
	                case TiffConstants.Type.SSHORT:
	                    return 2;
	                case TiffConstants.Type.LONG:
	                case TiffConstants.Type.SLONG:
	                case TiffConstants.Type.FLOAT:
	                    return 4;
	                case TiffConstants.Type.RATIONAL:
	                case TiffConstants.Type.SRATIONAL:
	                case TiffConstants.Type.DOUBLE:
	                    return 8;
	                default:
	                    return -1;
	            }
	        }

	        /**
	         * Get the value of an image file directory.
	         * @returns {Number[]}
	         */
	        TiffIFDEntry.prototype.getIFDEntryValue = function () {
	            var ifdValues = [];
	            var value = null;
	            var ifdTypeLength = this.getIFDTypeLength();
	            var ifdValueSize = ifdTypeLength * this.count;

	            if (ifdValueSize <= 4) {
	                if (this.isLittleEndian === false) {
	                    value = this.valueOffset >>> ((4 - ifdTypeLength) * 8);
	                } else {
	                    value = this.valueOffset;
	                }
	                ifdValues.push(value);
	            } else {
	                for (var i = 0; i < this.count; i++) {
	                    var indexOffset = ifdTypeLength * i;

	                    if (ifdTypeLength >= 8) {
	                        if (this.type === TiffConstants.Type.RATIONAL || this.type === TiffConstants.Type.SRATIONAL) {
	                            // Numerator
	                            ifdValues.push(GeoTiffUtil.getBytes(this.geoTiffData, this.valueOffset + indexOffset, 4,
	                                this.isLittleEndian));
	                            // Denominator
	                            ifdValues.push(GeoTiffUtil.getBytes(this.geoTiffData, this.valueOffset + indexOffset + 4, 4,
	                                this.isLittleEndian));
	                        } else if (this.type === TiffConstants.Type.DOUBLE) {
	                            ifdValues.push(GeoTiffUtil.getBytes(this.geoTiffData, this.valueOffset + indexOffset, 8,
	                                this.isLittleEndian));
	                        } else {
	                            throw new AbstractError(
	                                Logger.logMessage(Logger.LEVEL_SEVERE, "TiffIFDEntry", "parse", "invalidTypeOfIFD"));
	                        }
	                    } else {
	                        ifdValues.push(GeoTiffUtil.getBytes(this.geoTiffData, this.valueOffset + indexOffset,
	                            ifdTypeLength, this.isLittleEndian));
	                    }
	                }
	            }

	            if (this.type === TiffConstants.Type.ASCII) {
	                ifdValues.forEach(function (element, index, array) {
	                    if (element === 0){
	                        array.splice(index, 1);
	                    }
	                    else{
	                        array[index] = String.fromCharCode(element);
	                    }
	                });

	                return ifdValues.join("");
	            }

	            return ifdValues;
	        };

	        return TiffIFDEntry;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

	var Events = __webpack_require__(5);
	var WmtsLayer = __webpack_require__(207);


	var WmtsImageLayer = function (layerCaps, styleIdentifier, timeString) {
	    WmtsLayer.call(this, layerCaps, styleIdentifier, timeString);

	    this.displayName = this.layerIdentifier;
	};

	WmtsImageLayer.prototype = Object.create(WmtsLayer.prototype);

	module.exports = WmtsImageLayer;

	WmtsLayer.prototype.removeFromCurrentRetrievals = function (imagePath) {
	    var index = this.currentRetrievals.indexOf(imagePath);
	    if (index > -1) {
	        this.currentRetrievals.splice(index, 1);
	    }
	    Events.post(Events.WAIT, this.currentRetrievals.length);
	};



/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

	var Events = __webpack_require__(5);
	var WmsLayer = __webpack_require__(218);
	var TiledImageLayer = __webpack_require__(204);

	var WmsImageLayer = function (layerCaps, styleIdentifier, timeString) {

	    if (layerCaps.proxy && layerCaps.service) {
	        layerCaps.service = layerCaps.proxy +layerCaps.service;
	    }

	    WmsLayer.call(this, layerCaps, styleIdentifier, timeString);
	   // this.displayName = this.layerIdentifier;
	};

	WmsImageLayer.prototype = Object.create(WmsLayer.prototype);


	WmsImageLayer.isEpsg4326Crs = function (crs) {
	    return ((crs.indexOf("EPSG") >= 0) && (crs.indexOf("4326") >= 0));
	};

	WmsImageLayer.isEpsg3857Crs = function (crs) {
	    return (crs.indexOf("EPSG") >= 0)
	        && ((crs.indexOf("3857") >= 0) || (crs.indexOf("900913") >= 0)); // 900913 is google's 3857 alias
	};

	WmsImageLayer.isOGCCrs84 = function (crs) {
	    return (crs.indexOf("OGC") >= 0) && (crs.indexOf("CRS84") >= 0);
	};


	module.exports = WmsImageLayer;

	TiledImageLayer.prototype.removeFromCurrentRetrievals = function (imagePath) {
	    var index = this.currentRetrievals.indexOf(imagePath);
	    if (index > -1) {
	        this.currentRetrievals.splice(index, 1);
	    }
	    Events.post(Events.WAIT, this.currentRetrievals.length);
	};


	TiledImageLayer.prototype.resourceUrlForTile = function (tile, imageFormat) {
	    if (this.urlBuilder) {

	        tile.sector

	        return this.urlBuilder.urlForTile(tile, imageFormat);
	    } else {
	        return null;
	    }
	};



/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

	var Events = __webpack_require__(5);
	var StarFieldLayer = __webpack_require__(236);
	var SkyboxLayer = __webpack_require__(240);
	var Atmosphere = __webpack_require__(242);
	var CompassLayer = __webpack_require__(248);

	var time = new Date('2017-04-11T20:20:30Z');

	module.exports = function (earth) {

	    var starFieldLayer, skyboxLayer;
	    var atmosphereLayer = Atmosphere(time, earth);

	    //addLayer(new SingleImageLayer('images/ground/vesat.2048x1024.jpg'));
	    addLayer(CompassLayer(null, 'images/compass.png'));

	    Events.listen(Events._ADD_LAYER, addLayer);
	    Events.listen(Events._INSERT_LAYER, insertLayer);
	    Events.listen(Events._REMOVE_LAYER, removeLayer);
	    Events.listen(Events.CHANGE_SPACE, changeSpaceLayer);

	    changeSpaceLayer({skybox: 'images/skybox/one'});

	    function changeSpaceLayer(spaceLayer) {
	        removeLayer(atmosphereLayer);
	        removeLayer(starFieldLayer);
	        removeLayer(skyboxLayer);

	        if ('stars' === spaceLayer) {
	            if (!starFieldLayer) {
	                starFieldLayer = StarFieldLayer(time);
	            }
	            addLayer(starFieldLayer);
	        } else if (spaceLayer && spaceLayer.skybox) {
	            if (!skyboxLayer || spaceLayer.skybox !== skyboxLayer.path) {
	                skyboxLayer = createSkyboxLayer(spaceLayer.skybox);
	            }
	            addLayer(skyboxLayer);
	        }
	        addLayer(atmosphereLayer);
	        earth.redraw();
	    }

	    function addLayer(layer) {
	        earth.addLayer(layer);
	    }

	    function removeLayer(layer) {
	        earth.removeLayer(layer);
	    }

	    function insertLayer(layer) {
	        earth.insertLayer(layer.index, layer.layer);
	    }

	    function createSkyboxLayer(skyboxLayerPath) {
	        var skybox = new SkyboxLayer(skyboxLayerPath, earth);
	        skybox.path = skyboxLayerPath;
	        return skybox;
	    }
	};




/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

	var StarFieldLayer = __webpack_require__(237);
	var Events = __webpack_require__(5);

	module.exports = function (time) {

	    var starfield = new StarFieldLayer();
	    starfield.starDataSource = 'stars.json';
	    starfield.sunImageSource = 'images/sunTexture.png';
	    starfield.time = time;

	    Events.listen(Events.NAVIGATOR_STATE_CHANGED, function (state) {
	        if (state.range) starfield.showSun = state.range > 1e7;
	    });

	    return starfield;
	};


/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports StarFieldLayer
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(126),
	        __webpack_require__(32),
	        __webpack_require__(63),
	        __webpack_require__(238),
	        __webpack_require__(239)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Layer,
	              Logger,
	              Matrix,
	              StarFieldProgram,
	              SunPosition) {
	        'use strict';

	        /**
	         * Constructs a layer showing stars and the Sun around the Earth.
	         * If used together with the AtmosphereLayer, the StarFieldLayer must be inserted before the AtmosphereLayer.
	         *
	         * If you want to use your own star data, the file provided must be .json
	         * and the fields 'ra', 'dec' and 'vmag' must be present in the metadata.
	         * ra and dec must be expressed in degrees.
	         *
	         * This layer uses J2000.0 as the ref epoch.
	         *
	         * If the star data .json file is too big, consider enabling gzip compression on your web server.
	         * For more info about enabling gzip compression consult the configuration for your web server.
	         *
	         * @alias StarFieldLayer
	         * @constructor
	         * @classdesc Provides a layer showing stars, and the Sun around the Earth
	         * @param {URL} starDataSource optional url for the stars data
	         * @augments Layer
	         */
	        var StarFieldLayer = function (starDataSource) {
	            Layer.call(this, 'StarField');

	            // The StarField Layer is not pickable.
	            this.pickEnabled = false;

	            /**
	             * The size of the Sun in pixels.
	             * This can not exceed the maximum allowed pointSize of the GPU.
	             * A warning will be given if the size is too big and the allowed max size will be used.
	             * @type {Number}
	             * @default 128
	             */
	            this.sunSize = 128;

	            /**
	             * Indicates weather to show or hide the Sun
	             * @type {Boolean}
	             * @default true
	             */
	            this.showSun = true;

	            //Documented in defineProperties below.
	            this._starDataSource = starDataSource || WorldWind.configuration.baseUrl + 'images/stars.json';
	            this._sunImageSource = WorldWind.configuration.baseUrl + 'images/sunTexture.png';

	            //Internal use only.
	            //The MVP matrix of this layer.
	            this._matrix = Matrix.fromIdentity();

	            //Internal use only.
	            //gpu cache key for the stars vbo.
	            this._starsPositionsVboCacheKey = null;

	            //Internal use only.
	            this._numStars = 0;

	            //Internal use only.
	            this._starData = null;

	            //Internal use only.
	            this._minMagnitude = Number.MAX_VALUE;
	            this._maxMagnitude = Number.MIN_VALUE;

	            //Internal use only.
	            //A flag to indicate the star data is currently being retrieved.
	            this._loadStarted = false;

	            //Internal use only.
	            this._minScale = 10e6;

	            //Internal use only.
	            this._sunPositionsCacheKey = '';
	            this._sunBufferView = new Float32Array(4);

	            //Internal use only.
	            this._MAX_GL_POINT_SIZE = 0;
	        };

	        StarFieldLayer.prototype = Object.create(Layer.prototype);

	        Object.defineProperties(StarFieldLayer.prototype, {
	            /**
	             * Url for the stars data.
	             * @memberof StarFieldLayer.prototype
	             * @type {URL}
	             */
	            starDataSource: {
	                get: function () {
	                    return this._starDataSource;
	                },
	                set: function (value) {
	                    this._starDataSource = value;
	                    this.invalidateStarData();
	                }
	            },

	            /**
	             * Url for the sun texture image.
	             * @memberof StarFieldLayer.prototype
	             * @type {URL}
	             */
	            sunImageSource: {
	                get: function () {
	                    return this._sunImageSource;
	                },
	                set: function (value) {
	                    this._sunImageSource = value;
	                }
	            }
	        });

	        // Documented in superclass.
	        StarFieldLayer.prototype.doRender = function (dc) {
	            if (dc.globe.is2D()) {
	                return;
	            }

	            if (!this.haveResources(dc)) {
	                this.loadResources(dc);
	                return;
	            }

	            this.beginRendering(dc);
	            try {
	                this.doDraw(dc);
	            }
	            finally {
	                this.endRendering(dc);
	            }
	        };

	        // Internal. Intentionally not documented.
	        StarFieldLayer.prototype.haveResources = function (dc) {
	            var sunTexture = dc.gpuResourceCache.resourceForKey(this._sunImageSource);
	            return (
	                this._starData != null &&
	                sunTexture != null
	            );
	        };

	        // Internal. Intentionally not documented.
	        StarFieldLayer.prototype.loadResources = function (dc) {
	            var gl = dc.currentGlContext;
	            var gpuResourceCache = dc.gpuResourceCache;

	            if (!this._starData) {
	                this.fetchStarData();
	            }

	            var sunTexture = gpuResourceCache.resourceForKey(this._sunImageSource);
	            if (!sunTexture) {
	                gpuResourceCache.retrieveTexture(gl, this._sunImageSource);
	            }
	        };

	        // Internal. Intentionally not documented.
	        StarFieldLayer.prototype.beginRendering = function (dc) {
	            var gl = dc.currentGlContext;
	            dc.findAndBindProgram(StarFieldProgram);
	            gl.enableVertexAttribArray(0);
	            gl.depthMask(false);
	        };

	        // Internal. Intentionally not documented.
	        StarFieldLayer.prototype.doDraw = function (dc) {
	            this.loadCommonUniforms(dc);
	            this.renderStars(dc);
	            if (this.showSun) {
	                this.renderSun(dc);
	            }
	        };

	        // Internal. Intentionally not documented.
	        StarFieldLayer.prototype.loadCommonUniforms = function (dc) {
	            var gl = dc.currentGlContext;
	            var program = dc.currentProgram;

	            var eyePoint = dc.navigatorState.eyePoint;
	            var eyePosition = dc.globe.computePositionFromPoint(eyePoint[0], eyePoint[1], eyePoint[2], {});
	            var scale = Math.max(eyePosition.altitude * 1.5, this._minScale);
	            this._matrix.copy(dc.navigatorState.modelviewProjection);
	            this._matrix.multiplyByScale(scale, scale, scale);
	            program.loadModelviewProjection(gl, this._matrix);

	            //this subtraction does not work properly on the GPU, it must be done on the CPU
	            //possibly due to precision loss
	            //number of days (positive or negative) since Greenwich noon, Terrestrial Time, on 1 January 2000 (J2000.0)
	            var julianDate = SunPosition.computeJulianDate(this.time || new Date());
	            program.loadNumDays(gl, julianDate - 2451545.0);
	        };

	        // Internal. Intentionally not documented.
	        StarFieldLayer.prototype.renderStars = function (dc) {
	            var gl = dc.currentGlContext;
	            var gpuResourceCache = dc.gpuResourceCache;
	            var program = dc.currentProgram;

	            if (!this._starsPositionsVboCacheKey) {
	                this._starsPositionsVboCacheKey = gpuResourceCache.generateCacheKey();
	            }
	            var vboId = gpuResourceCache.resourceForKey(this._starsPositionsVboCacheKey);
	            if (!vboId) {
	                vboId = gl.createBuffer();
	                var positions = this.createStarsGeometry();
	                gpuResourceCache.putResource(this._starsPositionsVboCacheKey, vboId, positions.length * 4);
	                gl.bindBuffer(gl.ARRAY_BUFFER, vboId);
	                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
	            }
	            else {
	                gl.bindBuffer(gl.ARRAY_BUFFER, vboId);
	            }
	            dc.frameStatistics.incrementVboLoadCount(1);

	            gl.vertexAttribPointer(0, 4, gl.FLOAT, false, 0, 0);

	            program.loadMagnitudeRange(gl, this._minMagnitude, this._maxMagnitude);
	            program.loadTextureEnabled(gl, false);

	            gl.drawArrays(gl.POINTS, 0, this._numStars);
	        };

	        // Internal. Intentionally not documented.
	        StarFieldLayer.prototype.renderSun = function (dc) {
	            var gl = dc.currentGlContext;
	            var program = dc.currentProgram;
	            var gpuResourceCache = dc.gpuResourceCache;

	            if (!this._MAX_GL_POINT_SIZE) {
	                this._MAX_GL_POINT_SIZE = gl.getParameter(gl.ALIASED_POINT_SIZE_RANGE)[1];
	            }
	            if (this.sunSize > this._MAX_GL_POINT_SIZE) {
	                Logger.log(Logger.LEVEL_WARNING, 'StarFieldLayer - sunSize is to big, max size allowed is: ' +
	                    this._MAX_GL_POINT_SIZE);
	            }

	            var sunCelestialLocation = SunPosition.getAsCelestialLocation(this.time || new Date());

	            //.x = declination
	            //.y = right ascension
	            //.z = point size
	            //.w = magnitude
	            this._sunBufferView[0] = sunCelestialLocation.declination;
	            this._sunBufferView[1] = sunCelestialLocation.rightAscension;
	            this._sunBufferView[2] = Math.min(this.sunSize, this._MAX_GL_POINT_SIZE);
	            this._sunBufferView[3] = 1;

	            if (!this._sunPositionsCacheKey) {
	                this._sunPositionsCacheKey = gpuResourceCache.generateCacheKey();
	            }
	            var vboId = gpuResourceCache.resourceForKey(this._sunPositionsCacheKey);
	            if (!vboId) {
	                vboId = gl.createBuffer();
	                gpuResourceCache.putResource(this._sunPositionsCacheKey, vboId, this._sunBufferView.length * 4);
	                gl.bindBuffer(gl.ARRAY_BUFFER, vboId);
	                gl.bufferData(gl.ARRAY_BUFFER, this._sunBufferView, gl.DYNAMIC_DRAW);
	            }
	            else {
	                gl.bindBuffer(gl.ARRAY_BUFFER, vboId);
	                gl.bufferSubData(gl.ARRAY_BUFFER, 0, this._sunBufferView);
	            }
	            dc.frameStatistics.incrementVboLoadCount(1);
	            gl.vertexAttribPointer(0, 4, gl.FLOAT, false, 0, 0);

	            program.loadTextureEnabled(gl, true);

	            var sunTexture = dc.gpuResourceCache.resourceForKey(this._sunImageSource);
	            sunTexture.bind(dc);

	            gl.drawArrays(gl.POINTS, 0, 1);
	        };

	        // Internal. Intentionally not documented.
	        StarFieldLayer.prototype.endRendering = function (dc) {
	            var gl = dc.currentGlContext;
	            gl.depthMask(true);
	            gl.disableVertexAttribArray(0);
	        };

	        // Internal. Intentionally not documented.
	        StarFieldLayer.prototype.fetchStarData = function () {
	            if (this._loadStarted) {
	                return;
	            }

	            this._loadStarted = true;
	            var self = this;
	            var xhr = new XMLHttpRequest();

	            xhr.onload = function () {
	                if (this.status >= 200 && this.status < 300) {
	                    try {
	                        self._starData = JSON.parse(this.response);
	                        self.sendRedrawRequest();
	                    }
	                    catch (e) {
	                        Logger.log(Logger.LEVEL_SEVERE, 'StarFieldLayer unable to parse JSON for star data ' +
	                            e.toString());
	                    }
	                }
	                else {
	                    Logger.log(Logger.LEVEL_SEVERE, 'StarFieldLayer unable to fetch star data. Status: ' +
	                        this.status + ' ' + this.statusText);
	                }
	                self._loadStarted = false;
	            };

	            xhr.onerror = function () {
	                Logger.log(Logger.LEVEL_SEVERE, 'StarFieldLayer unable to fetch star data');
	                self._loadStarted = false;
	            };

	            xhr.ontimeout = function () {
	                Logger.log(Logger.LEVEL_SEVERE, 'StarFieldLayer fetch star data has timeout');
	                self._loadStarted = false;
	            };

	            xhr.open('GET', this._starDataSource, true);
	            xhr.send();
	        };

	        // Internal. Intentionally not documented.
	        StarFieldLayer.prototype.createStarsGeometry = function () {
	            var indexes = this.parseStarsMetadata(this._starData.metadata);

	            if (indexes.raIndex === -1) {
	                throw new Error(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, 'StarFieldLayer', 'createStarsGeometry',
	                        'Missing ra field in star data.'));
	            }
	            if (indexes.decIndex === -1) {
	                throw new Error(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, 'StarFieldLayer', 'createStarsGeometry',
	                        'Missing dec field in star data.'));
	            }
	            if (indexes.magIndex === -1) {
	                throw new Error(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, 'StarFieldLayer', 'createStarsGeometry',
	                        'Missing vmag field in star data.'));
	            }

	            var data = this._starData.data;
	            var positions = [];

	            this._minMagnitude = Number.MAX_VALUE;
	            this._maxMagnitude = Number.MIN_VALUE;

	            for (var i = 0, len = data.length; i < len; i++) {
	                var starInfo = data[i];
	                var declination = starInfo[indexes.decIndex]; //for latitude
	                var rightAscension = starInfo[indexes.raIndex]; //for longitude
	                var magnitude = starInfo[indexes.magIndex];
	                var pointSize = magnitude < 2 ? 2 : 1;

	                positions.push(declination, rightAscension, pointSize, magnitude);

	                this._minMagnitude = Math.min(this._minMagnitude, magnitude);
	                this._maxMagnitude = Math.max(this._maxMagnitude, magnitude);
	            }
	            this._numStars = Math.floor(positions.length / 4);

	            return positions;
	        };

	        // Internal. Intentionally not documented.
	        StarFieldLayer.prototype.parseStarsMetadata = function (metadata) {
	            var raIndex = -1,
	                decIndex = -1,
	                magIndex = -1;
	            for (var i = 0, len = metadata.length; i < len; i++) {
	                var starMetaInfo = metadata[i];
	                if (starMetaInfo.name === 'ra') {
	                    raIndex = i;
	                }
	                if (starMetaInfo.name === 'dec') {
	                    decIndex = i;
	                }
	                if (starMetaInfo.name === 'vmag') {
	                    magIndex = i;
	                }
	            }
	            return {
	                raIndex: raIndex,
	                decIndex: decIndex,
	                magIndex: magIndex
	            };
	        };

	        // Internal. Intentionally not documented.
	        StarFieldLayer.prototype.invalidateStarData = function () {
	            this._starData = null;
	            this._starsPositionsVboCacheKey = null;
	        };

	        // Internal. Intentionally not documented.
	        StarFieldLayer.prototype.sendRedrawRequest = function () {
	            var e = document.createEvent('Event');
	            e.initEvent(WorldWind.REDRAW_EVENT_TYPE, true, true);
	            window.dispatchEvent(e);
	        };

	        return StarFieldLayer;

	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports StarFieldProgram
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(30),
	        __webpack_require__(81),
	        __webpack_require__(32)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
	              GpuProgram,
	              Logger) {
	        "use strict";

	        /**
	         * Constructs a new program.
	         * Initializes, compiles and links this GLSL program with the source code for its vertex and fragment shaders.
	         * <p>
	         * This method creates WebGL shaders for the program's shader sources and attaches them to a new GLSL program.
	         * This method then compiles the shaders and then links the program if compilation is successful.
	         * Use the bind method to make the program current during rendering.
	         *
	         * @alias StarFieldProgram
	         * @constructor
	         * @augments GpuProgram
	         * @classdesc StarFieldProgram is a GLSL program that draws points representing stars.
	         * @param {WebGLRenderingContext} gl The current WebGL context.
	         * @throws {ArgumentError} If the shaders cannot be compiled, or linking of the compiled shaders into a program
	         * fails.
	         */
	        var StarFieldProgram = function (gl) {
	            var vertexShaderSource =
	                    //.x = declination
	                    //.y = right ascension
	                    //.z = point size
	                    //.w = magnitude
	                    'attribute vec4 vertexPoint;\n' +

	                    'uniform mat4 mvpMatrix;\n' +
	                    //number of days (positive or negative) since Greenwich noon, Terrestrial Time,
	                    // on 1 January 2000 (J2000.0)
	                    'uniform float numDays;\n' +
	                    'uniform vec2 magnitudeRange;\n' +

	                    'varying float magnitudeWeight;\n' +

	                    //normalizes an angle between 0.0 and 359.0
	                    'float normalizeAngle(float angle) {\n' +
	                    '   float angleDivisions = angle / 360.0;\n' +
	                    '   return 360.0 * (angleDivisions - floor(angleDivisions));\n' +
	                    '}\n' +

	                    //the same as: return x > y ? 1.0 : 0.0;
	                    'float if_gt(float x, float y) {\n' +
	                    '   return max(sign(x - y), 0.0);\n' +
	                    '}\n' +

	                    //transforms declination and right ascension in cartesian coordinates
	                    'vec3 computePosition(float dec, float ra) {\n' +
	                    '   float GMST = normalizeAngle(280.46061837 + 360.98564736629 * numDays);\n' +
	                    '   float GHA = normalizeAngle(GMST - ra);\n' +
	                    '   float lon = -GHA + 360.0 * if_gt(GHA, 180.0);\n' +
	                    '   float latRad = radians(dec);\n' +
	                    '   float lonRad = radians(lon);\n' +
	                    '   float radCosLat = cos(latRad);\n' +
	                    '   return vec3(radCosLat * sin(lonRad), sin(latRad), radCosLat * cos(lonRad));\n' +
	                    '}\n' +

	                    //normalizes a value between 0.0 and 1.0
	                    'float normalizeScalar(float value, float minValue, float maxValue){\n' +
	                    '   return (value - minValue) / (maxValue - minValue);\n' +
	                    '}\n' +

	                    'void main() {\n' +
	                    '   vec3 vertexPosition = computePosition(vertexPoint.x, vertexPoint.y);\n' +
	                    '   gl_Position = mvpMatrix * vec4(vertexPosition.xyz, 1.0);\n' +
	                    '   gl_Position.z = gl_Position.w - 0.00001;\n' +
	                    '   gl_PointSize = vertexPoint.z;\n' +
	                    '   magnitudeWeight = normalizeScalar(vertexPoint.w, magnitudeRange.x, magnitudeRange.y);\n' +
	                    '}',
	                fragmentShaderSource =
	                    'precision mediump float;\n' +

	                    'uniform sampler2D textureSampler;\n' +
	                    'uniform int textureEnabled;\n' +

	                    'varying float magnitudeWeight;\n' +

	                    'const vec4 white = vec4(1.0, 1.0, 1.0, 1.0);\n' +
	                    'const vec4 grey = vec4(0.5, 0.5, 0.5, 1.0);\n' +

	                    'void main() {\n' +
	                    '   if (textureEnabled == 1) {\n' +
	                    '       gl_FragColor = texture2D(textureSampler, gl_PointCoord);\n' +
	                    '   }\n' +
	                    '   else {\n' +
	                    //paint the starts in shades of grey, where the brightest star is white and the dimmest star is grey
	                    '       gl_FragColor = mix(white, grey, magnitudeWeight);\n' +
	                    '   }\n' +
	                    '}';

	            // Call to the superclass, which performs shader program compiling and linking.
	            GpuProgram.call(this, gl, vertexShaderSource, fragmentShaderSource, ["vertexPoint"]);

	            /**
	             * The WebGL location for this program's 'vertexPoint' attribute.
	             * @type {Number}
	             * @readonly
	             */
	            this.vertexPointLocation = this.attributeLocation(gl, "vertexPoint");

	            /**
	             * The WebGL location for this program's 'mvpMatrix' uniform.
	             * @type {WebGLUniformLocation}
	             * @readonly
	             */
	            this.mvpMatrixLocation = this.uniformLocation(gl, "mvpMatrix");

	            /**
	             * The WebGL location for this program's 'numDays' uniform.
	             * @type {WebGLUniformLocation}
	             * @readonly
	             */
	            this.numDaysLocation = this.uniformLocation(gl, "numDays");

	            /**
	             * The WebGL location for this program's 'magnitudeRangeLocation' uniform.
	             * @type {WebGLUniformLocation}
	             * @readonly
	             */
	            this.magnitudeRangeLocation = this.uniformLocation(gl, "magnitudeRange");

	            /**
	             * The WebGL location for this program's 'textureSampler' uniform.
	             * @type {WebGLUniformLocation}
	             * @readonly
	             */
	            this.textureUnitLocation = this.uniformLocation(gl, "textureSampler");

	            /**
	             * The WebGL location for this program's 'textureEnabled' uniform.
	             * @type {WebGLUniformLocation}
	             * @readonly
	             */
	            this.textureEnabledLocation = this.uniformLocation(gl, "textureEnabled");
	        };

	        /**
	         * A string that uniquely identifies this program.
	         * @type {string}
	         * @readonly
	         */
	        StarFieldProgram.key = "WorldWindGpuStarFieldProgram";

	        // Inherit from GpuProgram.
	        StarFieldProgram.prototype = Object.create(GpuProgram.prototype);

	        /**
	         * Loads the specified matrix as the value of this program's 'mvpMatrix' uniform variable.
	         *
	         * @param {WebGLRenderingContext} gl The current WebGL context.
	         * @param {Matrix} matrix The matrix to load.
	         * @throws {ArgumentError} If the specified matrix is null or undefined.
	         */
	        StarFieldProgram.prototype.loadModelviewProjection = function (gl, matrix) {
	            if (!matrix) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "StarFieldProgram", "loadModelviewProjection", "missingMatrix"));
	            }

	            this.loadUniformMatrix(gl, matrix, this.mvpMatrixLocation);
	        };

	        /**
	         * Loads the specified number as the value of this program's 'numDays' uniform variable.
	         *
	         * @param {WebGLRenderingContext} gl The current WebGL context.
	         * @param {Number} numDays The number of days (positive or negative) since Greenwich noon, Terrestrial Time,
	         * on 1 January 2000 (J2000.0)
	         * @throws {ArgumentError} If the specified number is null or undefined.
	         */
	        StarFieldProgram.prototype.loadNumDays = function (gl, numDays) {
	            if (numDays == null) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "StarFieldProgram", "loadNumDays", "missingNumDays"));
	            }
	            gl.uniform1f(this.numDaysLocation, numDays);
	        };

	        /**
	         * Loads the specified numbers as the value of this program's 'magnitudeRange' uniform variable.
	         *
	         * @param {WebGLRenderingContext} gl The current WebGL context.
	         * @param {Number} minMag
	         * @param {Number} maxMag
	         * @throws {ArgumentError} If the specified numbers are null or undefined.
	         */
	        StarFieldProgram.prototype.loadMagnitudeRange = function (gl, minMag, maxMag) {
	            if (minMag == null) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "StarFieldProgram", "loadMagRange", "missingMinMag"));
	            }
	            if (maxMag == null) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "StarFieldProgram", "loadMagRange", "missingMaxMag"));
	            }
	            gl.uniform2f(this.magnitudeRangeLocation, minMag, maxMag);
	        };

	        /**
	         * Loads the specified number as the value of this program's 'textureSampler' uniform variable.
	         * @param {WebGLRenderingContext} gl The current WebGL context.
	         * @param {Number} unit The texture unit.
	         */
	        StarFieldProgram.prototype.loadTextureUnit = function (gl, unit) {
	            gl.uniform1i(this.textureUnitLocation, unit - gl.TEXTURE0);
	        };

	        /**
	         * Loads the specified boolean as the value of this program's 'textureEnabledLocation' uniform variable.
	         * @param {WebGLRenderingContext} gl The current WebGL context.
	         * @param {Boolean} value
	         */
	        StarFieldProgram.prototype.loadTextureEnabled = function (gl, value) {
	            gl.uniform1i(this.textureEnabledLocation, value ? 1 : 0);
	        };

	        return StarFieldProgram;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(29),
	        __webpack_require__(30),
	        __webpack_require__(32)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Angle,
	              ArgumentError,
	              Logger) {
	        'use strict';

	        /**
	         * Provides utilities for determining the Sun geographic and celestial location.
	         * @exports SunPosition
	         */
	        var SunPosition = {

	            /**
	             * Computes the geographic location of the sun for a given date
	             * @param {Date} date
	             * @throws {ArgumentError} if the date is missing
	             * @return {{latitude: Number, longitude: Number}} the geographic location
	             */
	            getAsGeographicLocation: function (date) {
	                if (date instanceof Date === false) {
	                    throw new ArgumentError(
	                        Logger.logMessage(Logger.LEVEL_SEVERE, "SunPosition", "getAsGeographicLocation",
	                            "missingDate"));
	                }

	                var celestialLocation = this.getAsCelestialLocation(date);
	                return this.celestialToGeographic(celestialLocation, date);
	            },

	            /**
	             * Computes the celestial location of the sun for a given julianDate
	             * @param {Date} date
	             * @throws {ArgumentError} if the date is missing
	             * @return {{declination: Number, rightAscension: Number}} the celestial location
	             */
	            getAsCelestialLocation: function (date) {
	                if (date instanceof Date === false) {
	                    throw new ArgumentError(
	                        Logger.logMessage(Logger.LEVEL_SEVERE, "SunPosition", "getAsCelestialLocation",
	                            "missingDate"));
	                }

	                var julianDate = this.computeJulianDate(date);

	                //number of days (positive or negative) since Greenwich noon, Terrestrial Time, on 1 January 2000 (J2000.0)
	                var numDays = julianDate - 2451545;

	                var meanLongitude = this.normalizeAngle(280.460 + 0.9856474 * numDays);

	                var meanAnomaly = this.normalizeAngle(357.528 + 0.9856003 * numDays) * Angle.DEGREES_TO_RADIANS;

	                var eclipticLongitude = meanLongitude + 1.915 * Math.sin(meanAnomaly) + 0.02 * Math.sin(2 * meanAnomaly);
	                var eclipticLongitudeRad = eclipticLongitude * Angle.DEGREES_TO_RADIANS;

	                var obliquityOfTheEcliptic = (23.439 - 0.0000004 * numDays) * Angle.DEGREES_TO_RADIANS;

	                var declination = Math.asin(Math.sin(obliquityOfTheEcliptic) * Math.sin(eclipticLongitudeRad)) *
	                    Angle.RADIANS_TO_DEGREES;

	                var rightAscension = Math.atan(Math.cos(obliquityOfTheEcliptic) * Math.tan(eclipticLongitudeRad)) *
	                    Angle.RADIANS_TO_DEGREES;

	                //compensate for atan result
	                if (eclipticLongitude >= 90 && eclipticLongitude < 270) {
	                    rightAscension += 180;
	                }
	                rightAscension = this.normalizeAngle(rightAscension);

	                return {
	                    declination: declination,
	                    rightAscension: rightAscension
	                };
	            },

	            /**
	             * Converts from celestial coordinates (declination and right ascension) to geographic coordinates
	             * (latitude, longitude) for a given julian date
	             * @param {{declination: Number, rightAscension: Number}} celestialLocation
	             * @param {Date} date
	             * @throws {ArgumentError} if celestialLocation or julianDate are missing
	             * @return {{latitude: Number, longitude: Number}} the geographic location
	             */
	            celestialToGeographic: function (celestialLocation, date) {
	                if (!celestialLocation) {
	                    throw new ArgumentError(
	                        Logger.logMessage(Logger.LEVEL_SEVERE, "SunPosition", "celestialToGeographic",
	                            "missingCelestialLocation"));
	                }
	                if (date instanceof Date === false) {
	                    throw new ArgumentError(
	                        Logger.logMessage(Logger.LEVEL_SEVERE, "SunPosition", "celestialToGeographic", "missingDate"));
	                }

	                var julianDate = this.computeJulianDate(date);

	                //number of days (positive or negative) since Greenwich noon, Terrestrial Time, on 1 January 2000 (J2000.0)
	                var numDays = julianDate - 2451545;

	                //Greenwich Mean Sidereal Time
	                var GMST = this.normalizeAngle(280.46061837 + 360.98564736629 * numDays);

	                //Greenwich Hour Angle
	                var GHA = this.normalizeAngle(GMST - celestialLocation.rightAscension);

	                var longitude = Angle.normalizedDegreesLongitude(-GHA);

	                return {
	                    latitude: celestialLocation.declination,
	                    longitude: longitude
	                };
	            },

	            /**
	             * Computes the julian date from a javascript date object
	             * @param {Date} date
	             * @throws {ArgumentError} if the date is missing
	             * @return {Number} the julian date
	             */
	            computeJulianDate: function (date) {
	                if (date instanceof Date === false) {
	                    throw new ArgumentError(
	                        Logger.logMessage(Logger.LEVEL_SEVERE, "SunPosition", "computeJulianDate", "missingDate"));
	                }

	                var year = date.getUTCFullYear();
	                var month = date.getUTCMonth() + 1;
	                var day = date.getUTCDate();
	                var hour = date.getUTCHours();
	                var minute = date.getUTCMinutes();
	                var second = date.getUTCSeconds();

	                var dayFraction = (hour + minute / 60 + second / 3600) / 24;

	                if (month <= 2) {
	                    year -= 1;
	                    month += 12;
	                }

	                var A = Math.floor(year / 100);
	                var B = 2 - A + Math.floor(A / 4);
	                var JD0h = Math.floor(365.25 * (year + 4716)) + Math.floor(30.6001 * (month + 1)) + day + B - 1524.5;

	                return JD0h + dayFraction;
	            },

	            /**
	             * Normalizes an angle between 0.0 inclusive and 360.0 exclusive
	             * @param {Number} angle
	             * @throws {ArgumentError} if the angle is missing
	             * @return {Number} the normalised angle
	             */
	            normalizeAngle: function (angle) {
	                if (angle == null) {
	                    throw new ArgumentError(
	                        Logger.logMessage(Logger.LEVEL_SEVERE, "SunPosition", "normalizeAngle", "missingAngle"));
	                }
	                return 360 * (angle / 360 - Math.floor(angle / 360));
	            }

	        };

	        return SunPosition;

	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

	var Layer = __webpack_require__(126);
	var Matrix = __webpack_require__(63);
	var SkyboxProgram = __webpack_require__(241);

	var SkyboxLayer = function (path, wwd) {

	    Layer.call(this, "Skybox");

	    //Documented in defineProperties below.
	    this._imageUrls = this.getImageUrls(path + '/');

	    //Documented in defineProperties below.
	    this._wwd = wwd;

	    //Disable picking for the skybox.
	    this.pickEnabled = false;

	    //Internal use. The number of triangles to draw.
	    this._numTriangles = 36;

	    //Internal use. The cache key for the vertex positions.
	    this._positionsCacheKey = 'skyboxPositions';

	    //Internal use. The skybox mvp matrix.
	    this._mvpMatrix = Matrix.fromIdentity();

	    //Internal use. A minimum scale so that the skybox is not to small.
	    this._minScale = 10000000;

	};

	SkyboxLayer.prototype = Object.create(Layer.prototype);

	Object.defineProperties(SkyboxLayer.prototype, {

	    wwd: {
	        set: function (value) {
	            this._wwd = value;
	        }
	    },


	    imageUrls: {
	        get: function () {
	            return this._imageUrls;
	        },
	        set: function (value) {
	            this._imageUrls = value;
	        }
	    }
	});

	SkyboxLayer.prototype.doRender = function (dc) {
	    if (dc.globe.is2D() || !this._wwd || !this._imageUrls) {
	        return;
	    }

	    var gl = dc.currentGlContext,
	        program = dc.findAndBindProgram(SkyboxProgram),
	        viewport = this._wwd.viewport,
	        range = this._wwd.navigator.range,
	        vboId;

	    var texture = dc.gpuResourceCache.resourceForKey(this._imageUrls.posX);
	    if (!texture) {
	        dc.gpuResourceCache.retrieveCubeMapTextures(gl, this._imageUrls);
	        return;
	    }

	    texture.bind(dc);
	    program.loadTextureUnit(gl, gl.TEXTURE0);

	    //In portrait mode the skybox does not fill the whole height.
	    //Makes the skybox bigger in portrait mode.
	    var aspect = 1;
	    if (viewport.width < viewport.height) {
	        aspect = viewport.width / viewport.height
	    }

	    //Make sure the box is bigger then the globe.
	    var scale = Math.max(range, this._minScale) / aspect;

	    this._mvpMatrix.copy(dc.navigatorState.modelviewProjection);

	    //remove the translations so that the box does not move and remains at the center of the scene.
	    this._mvpMatrix[3] = 0;
	    this._mvpMatrix[7] = 0;
	    this._mvpMatrix[11] = 0;

	    this._mvpMatrix.multiplyByScale(scale, scale, scale);
	    program.loadModelviewProjection(gl, this._mvpMatrix);

	    vboId = dc.gpuResourceCache.resourceForKey(this._positionsCacheKey);
	    if (!vboId) {
	        var positions = this.getVertexPositions();
	        this._numTriangles = Math.floor(positions.length / 3);
	        vboId = gl.createBuffer();
	        gl.bindBuffer(gl.ARRAY_BUFFER, vboId);
	        gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
	        dc.gpuResourceCache.putResource(this._positionsCacheKey, vboId, positions.length * 4);
	        dc.frameStatistics.incrementVboLoadCount(1);
	    }
	    else {
	        gl.bindBuffer(gl.ARRAY_BUFFER, vboId);
	        dc.frameStatistics.incrementVboLoadCount(1);
	    }

	    gl.vertexAttribPointer(program.vertexPointLocation, 3, gl.FLOAT, false, 0, 0);
	    gl.enableVertexAttribArray(0);

	    //Disable depth writes so that the skybox does not occlude the globe.
	    gl.depthMask(false);

	    gl.drawArrays(gl.TRIANGLES, 0, this._numTriangles);

	    gl.depthMask(true);
	};

	SkyboxLayer.prototype.getImageUrls = function (path) {
	    return {
	        posX: path + 'posx.png',
	        negX: path + 'negx.png',
	        posY: path + 'posy.png',
	        negY: path + 'negy.png',
	        posZ: path + 'posz.png',
	        negZ: path + 'negz.png'
	    };
	};

	//Returns non-indexed vertex positions of a cube.
	SkyboxLayer.prototype.getVertexPositions = function () {

	    var SIZE = 1;

	    return new Float32Array([
	        -SIZE, SIZE, -SIZE,
	        -SIZE, -SIZE, -SIZE,
	        SIZE, -SIZE, -SIZE,
	        SIZE, -SIZE, -SIZE,
	        SIZE, SIZE, -SIZE,
	        -SIZE, SIZE, -SIZE,

	        -SIZE, -SIZE, SIZE,
	        -SIZE, -SIZE, -SIZE,
	        -SIZE, SIZE, -SIZE,
	        -SIZE, SIZE, -SIZE,
	        -SIZE, SIZE, SIZE,
	        -SIZE, -SIZE, SIZE,

	        SIZE, -SIZE, -SIZE,
	        SIZE, -SIZE, SIZE,
	        SIZE, SIZE, SIZE,
	        SIZE, SIZE, SIZE,
	        SIZE, SIZE, -SIZE,
	        SIZE, -SIZE, -SIZE,

	        -SIZE, -SIZE, SIZE,
	        -SIZE, SIZE, SIZE,
	        SIZE, SIZE, SIZE,
	        SIZE, SIZE, SIZE,
	        SIZE, -SIZE, SIZE,
	        -SIZE, -SIZE, SIZE,

	        -SIZE, SIZE, -SIZE,
	        SIZE, SIZE, -SIZE,
	        SIZE, SIZE, SIZE,
	        SIZE, SIZE, SIZE,
	        -SIZE, SIZE, SIZE,
	        -SIZE, SIZE, -SIZE,

	        -SIZE, -SIZE, -SIZE,
	        -SIZE, -SIZE, SIZE,
	        SIZE, -SIZE, -SIZE,
	        SIZE, -SIZE, -SIZE,
	        -SIZE, -SIZE, SIZE,
	        SIZE, -SIZE, SIZE
	    ]);

	};

	module.exports = SkyboxLayer;


/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

	var ArgumentError = __webpack_require__(30);
	var GpuProgram = __webpack_require__(81);
	var Logger = __webpack_require__(32);

	var SkyBoxProgram = function (gl) {

	    var vertexShaderSource =
	        'attribute vec3 vertexPoint;\n' +
	        'uniform  mat4 mvpMatrix;\n' +
	        'varying vec3 texCoord;\n' +

	        'void main(){\n' +
	        '   gl_Position = mvpMatrix * vec4(vertexPoint, 1.0);\n' +
	            //prevent the skybox from being clipped by the far plane
	        '   gl_Position.z = gl_Position.w - 0.00001;\n' +
	        '   texCoord = vertexPoint;\n' +
	        '}\n';

	    var fragmentShaderSource =
	        'precision mediump float;\n' +
	        'varying vec3 texCoord;\n' +
	        'uniform samplerCube skybox;\n' +

	        'void main(){\n' +
	        '   gl_FragColor = textureCube(skybox, texCoord);\n' +
	        '}';

	    GpuProgram.call(this, gl, vertexShaderSource, fragmentShaderSource, ['vertexPoint']);

	    this.vertexPointLocation = this.attributeLocation(gl, "vertexPoint");
	    this.mvpMatrixLocation = this.uniformLocation(gl, "mvpMatrix");
	    this.textureUnitLocation = this.uniformLocation(gl, "skybox");
	    this.localState = {
	        textureUnit: null
	    }
	};

	SkyBoxProgram.key = "WorldWindGpuSkyBoxProgram";

	SkyBoxProgram.prototype = Object.create(GpuProgram.prototype);

	/**
	 * Loads the specified matrix as the value of this program's 'mvpMatrix' uniform variable.
	 *
	 * @param {WebGLRenderingContext} gl The current WebGL context.
	 * @param {Matrix} matrix The matrix to load.
	 * @throws {ArgumentError} If the specified matrix is null or undefined.
	 */
	SkyBoxProgram.prototype.loadModelviewProjection = function (gl, matrix) {
	    if (!matrix) {
	        throw new ArgumentError(
	            Logger.logMessage(Logger.LEVEL_SEVERE, "SkyBoxProgram", "loadModelviewProjection", "missingMatrix"));
	    }

	    this.loadUniformMatrix(gl, matrix, this.mvpMatrixLocation);
	};

	/**
	 * Loads the specified number as the value of this program's 'textureSampler' uniform variable.
	 * @param {WebGLRenderingContext} gl The current WebGL context.
	 * @param {Number} unit The texture unit.
	 */
	SkyBoxProgram.prototype.loadTextureUnit = function (gl, unit) {
	    if (this.localState.textureUnit !== unit) {
	        gl.uniform1i(this.textureUnitLocation, unit - gl.TEXTURE0);
	        this.localState.textureUnit = unit;
	    }
	};

	module.exports = SkyBoxProgram;



/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

	var Events = __webpack_require__(5);
	var AtmosphereLayer = __webpack_require__(243);
	var WWMath = __webpack_require__(36);
	var Position = __webpack_require__(47);
	var SunPosition = __webpack_require__(239);

	module.exports = function (time, engine) {

	    var showAtmosphere = true;
	    var drawGround = true;
	    var night = true;
	    var nightSideIsHidden = false;

	    var animationInterval;
	    var pos = SunPosition.getAsGeographicLocation(time);
	    
	    var atmosphere = new AtmosphereLayer();

	    atmosphere.doRender = function (dc) {
	        if (dc.globe.is2D() || !showAtmosphere) {
	            return;
	        }

	        atmosphere.determineLightDirection(dc);
	        atmosphere.drawSky(dc);

	        if (drawGround) {
	            atmosphere.drawGround(dc);
	        }
	    };

	    atmosphere.nightImageSource = 'images/ground/night.png';
	    atmosphere.lightLocation = new Position(pos.latitude, pos.longitude, 100);

	    Events.listen(Events.NAVIGATOR_STATE_CHANGED, function (state) {
	        if (state.range) showNightSide(state.range > 1e7);
	    });

	    Events.listen(Events.SWITCH_ATMOSPHERE_NIGHT, function (state) {
	        night = typeof state === "boolean" ? state : !night;
	        atmosphere.lightLocation = night ? new Position(pos.latitude, pos.longitude, 1) : null;
	        Events.post(Events.REDRAW);
	    });

	    Events.listen(Events.SWITCH_ATMOSPHERE, function (state) {
	        showAtmosphere = typeof state === "boolean" ? state :!showAtmosphere;
	        Events.post(Events.REDRAW);
	    });

	    Events.listen(Events.SWITCH_ATMOSPHERE_GROUND, function (state) {
	        drawGround = typeof state === "boolean" ? state :!drawGround;
	        Events.post(Events.REDRAW);
	    });

	    return atmosphere;
	    
	    function showNightSide(show) {
	        if (!night ||
	            !nightSideIsHidden && show ||
	            nightSideIsHidden && !show) {
	            return;
	        }

	        var from = pos;
	        var to = engine.navigator.lookAtLocation;

	        nightSideIsHidden = !show;
	        clearInterval(animationInterval);
	        var animationTime = 0;
	        animationInterval = setInterval(animate, 15);

	        function animate() {
	            atmosphere.lightLocation = lerpLocation(show ? to : from, show ? from : to);
	            animationTime += 0.1;
	            if (animationTime >= 1) {
	                clearInterval(animationInterval);
	                if (!show) {
	                    atmosphere.lightLocation = null; // hide night image
	                }
	            }
	            Events.post(Events.REDRAW);
	        }

	        function lerpLocation(from, to) {
	            return new Position(
	                lerp(from.latitude, to.latitude),
	                lerp(from.longitude, to.longitude),
	                1000
	            );
	        }

	        function lerp(from, to) {
	            return WWMath.interpolate(animationTime, from, to);
	        }
	    }
	};

/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports AtmosphereLayer
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(30),
	        __webpack_require__(245),
	        __webpack_require__(126),
	        __webpack_require__(32),
	        __webpack_require__(63),
	        __webpack_require__(244),
	        __webpack_require__(75),
	        __webpack_require__(247),
	        __webpack_require__(35),
	        __webpack_require__(83)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
	              GroundProgram,
	              Layer,
	              Logger,
	              Matrix,
	              Matrix3,
	              Sector,
	              SkyProgram,
	              Vec3,
	              WWUtil) {
	        "use strict";

	        /**
	         * Constructs a layer showing the Earth's atmosphere.
	         * @alias AtmosphereLayer
	         * @constructor
	         * @classdesc Provides a layer showing the Earth's atmosphere.
	         * @param {URL} nightImageSource optional url for the night texture.
	         * @augments Layer
	         */
	        var AtmosphereLayer = function (nightImageSource) {
	            Layer.call(this, "Atmosphere");

	            // The atmosphere layer is not pickable.
	            this.pickEnabled = false;

	            //Documented in defineProperties below.
	            this._nightImageSource = nightImageSource ||
	                WorldWind.configuration.baseUrl + 'images/dnb_land_ocean_ice_2012.png';

	            //Documented in defineProperties below.
	            this._lightLocation = null;

	            //Internal use only.
	            //The light direction in cartesian space, computed form the lightLocation or defaults to the eyePoint.
	            this._activeLightDirection = new Vec3(0, 0, 0);

	            this._fullSphereSector = Sector.FULL_SPHERE;

	            //Internal use only. Intentionally not documented.
	            this._skyData = {};

	            //Internal use only. The number of longitudinal points in the grid for the sky geometry.
	            this._skyWidth = 128;

	            //Internal use only. The number of latitudinal points in the grid for the sky geometry.
	            this._skyHeight = 128;

	            //Internal use only. Number of indices for the sky geometry.
	            this._numIndices = 0;

	            //Internal use only. Texture coordinate matrix used for the night texture.
	            this._texMatrix = Matrix3.fromIdentity();

	            //Internal use only. The night texture.
	            this._activeTexture = null;
	        };

	        AtmosphereLayer.prototype = Object.create(Layer.prototype);

	        Object.defineProperties(AtmosphereLayer.prototype, {

	            /**
	             * The geographic location of the light (sun).
	             * @memberof AtmosphereLayer.prototype
	             * @type {Position}
	             */
	            lightLocation: {
	                get: function () {
	                    return this._lightLocation;
	                },
	                set: function (value) {
	                    this._lightLocation = value;
	                }
	            },

	            /**
	             * Url for the night texture.
	             * @memberof AtmosphereLayer.prototype
	             * @type {URL}
	             */
	            nightImageSource: {
	                get: function () {
	                    return this._nightImageSource;
	                },
	                set: function (value) {
	                    this._nightImageSource = value;
	                }
	            }

	        });

	        // Documented in superclass.
	        AtmosphereLayer.prototype.doRender = function (dc) {
	            if (dc.globe.is2D()) {
	                return;
	            }

	            this.determineLightDirection(dc);
	            this.drawSky(dc);
	            this.drawGround(dc);
	        };

	        // Internal. Intentionally not documented.
	        AtmosphereLayer.prototype.applySkyVertices = function (dc) {
	            var gl = dc.currentGlContext,
	                program = dc.currentProgram,
	                skyData = this._skyData,
	                skyPoints, vboId;

	            if (!skyData.verticesVboCacheKey) {
	                skyData.verticesVboCacheKey = dc.gpuResourceCache.generateCacheKey();
	            }

	            vboId = dc.gpuResourceCache.resourceForKey(skyData.verticesVboCacheKey);
	            
	            if (!vboId) {
	                skyPoints = this.assembleVertexPoints(dc, this._skyHeight, this._skyWidth, program.getAltitude());
	                
	                vboId = gl.createBuffer();
	                gl.bindBuffer(gl.ARRAY_BUFFER, vboId);
	                gl.bufferData(gl.ARRAY_BUFFER, skyPoints, gl.STATIC_DRAW);
	                gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);
	                
	                dc.gpuResourceCache.putResource(skyData.verticesVboCacheKey, vboId,
	                    skyPoints.length * 4);
	                dc.frameStatistics.incrementVboLoadCount(1);
	            }
	            else {
	                gl.bindBuffer(gl.ARRAY_BUFFER, vboId);
	                gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);
	            }

	        };

	        // Internal. Intentionally not documented.
	        AtmosphereLayer.prototype.applySkyIndices = function (dc) {
	            var gl = dc.currentGlContext,
	                skyData = this._skyData,
	                skyIndices, vboId;

	            if (!skyData.indicesVboCacheKey) {
	                skyData.indicesVboCacheKey = dc.gpuResourceCache.generateCacheKey();
	            }

	            vboId = dc.gpuResourceCache.resourceForKey(skyData.indicesVboCacheKey);
	            
	            if (!vboId) {
	                skyIndices = this.assembleTriStripIndices(this._skyWidth, this._skyHeight);
	                
	                vboId = gl.createBuffer();
	                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vboId);
	                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, skyIndices, gl.STATIC_DRAW);
	                
	                dc.frameStatistics.incrementVboLoadCount(1);
	                dc.gpuResourceCache.putResource(skyData.indicesVboCacheKey, vboId, skyIndices.length * 2);
	            }
	            else {
	                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vboId);
	            }

	        };

	        // Internal. Intentionally not documented.
	        AtmosphereLayer.prototype.drawSky = function (dc) {
	            var gl = dc.currentGlContext,
	                program = dc.findAndBindProgram(SkyProgram);

	            program.loadGlobeRadius(gl, dc.globe.equatorialRadius);

	            program.loadEyePoint(gl, dc.navigatorState.eyePoint);

	            program.loadVertexOrigin(gl, Vec3.ZERO);

	            program.loadModelviewProjection(gl, dc.navigatorState.modelviewProjection);

	            program.loadLightDirection(gl, this._activeLightDirection);

	            program.setScale(gl);

	            this.applySkyVertices(dc);
	            this.applySkyIndices(dc);

	            gl.depthMask(false);
	            gl.frontFace(gl.CW);
	            gl.enableVertexAttribArray(0);
	            gl.drawElements(gl.TRIANGLE_STRIP, this._numIndices, gl.UNSIGNED_SHORT, 0);

	            gl.depthMask(true);
	            gl.frontFace(gl.CCW);
	            gl.disableVertexAttribArray(0);
	        };

	        // Internal. Intentionally not documented.
	        AtmosphereLayer.prototype.drawGround = function (dc) {
	            var gl = dc.currentGlContext,
	                program = dc.findAndBindProgram(GroundProgram),
	                terrain = dc.terrain,
	                textureBound;

	            program.loadGlobeRadius(gl, dc.globe.equatorialRadius);

	            program.loadEyePoint(gl, dc.navigatorState.eyePoint);

	            program.loadLightDirection(gl, this._activeLightDirection);

	            program.setScale(gl);

	            // Use this layer's night image when the light location is different than the eye location.
	            if (this.nightImageSource && this.lightLocation) {
	                
	                this._activeTexture = dc.gpuResourceCache.resourceForKey(this.nightImageSource);
	                
	                if (!this._activeTexture) {
	                    this._activeTexture = dc.gpuResourceCache.retrieveTexture(gl, this.nightImageSource);
	                }
	                
	                textureBound = this._activeTexture && this._activeTexture.bind(dc);
	            }

	            terrain.beginRendering(dc);

	            for (var idx = 0, len = terrain.surfaceGeometry.length; idx < len; idx++) {
	                var currentTile = terrain.surfaceGeometry[idx];
	                
	                // Use the vertex origin for the terrain tile.
	                var terrainOrigin = currentTile.referencePoint;
	                program.loadVertexOrigin(gl, terrainOrigin);

	                // Use a tex coord matrix that registers the night texture correctly on each terrain.
	                if (textureBound) {
	                    this._texMatrix.setToUnitYFlip();
	                    this._texMatrix.multiplyByTileTransform(currentTile.sector, this._fullSphereSector);
	                    program.loadTexMatrix(gl, this._texMatrix);
	                }

	                terrain.beginRenderingTile(dc, currentTile);

	                // Draw the tile, multiplying the current fragment color by the program's secondary color.
	                program.loadFragMode(gl, program.FRAGMODE_GROUND_SECONDARY);
	                gl.blendFunc(gl.DST_COLOR, gl.ZERO);
	                terrain.renderTile(dc, currentTile);

	                // Draw the terrain as triangles, adding the current fragment color to the program's primary color.
	                var fragMode = textureBound ?
	                    program.FRAGMODE_GROUND_PRIMARY_TEX_BLEND : program.FRAGMODE_GROUND_PRIMARY;
	                program.loadFragMode(gl, fragMode);
	                gl.blendFunc(gl.ONE, gl.ONE);
	                terrain.renderTile(dc, currentTile);

	                terrain.endRenderingTile(dc, currentTile);
	            }

	            // Restore the default World Wind OpenGL state.
	            terrain.endRendering(dc);
	            gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);

	            // Clear references to Gpu resources.
	            this._activeTexture = null;
	        };

	        // Internal. Intentionally not documented.
	        AtmosphereLayer.prototype.assembleVertexPoints = function (dc, numLat, numLon, altitude) {
	            var count = numLat * numLon;
	            var altitudes = new Array(count);
	            WWUtil.fillArray(altitudes, altitude);
	            var result = new Float32Array(count * 3);

	            return dc.globe.computePointsForGrid(this._fullSphereSector, numLat, numLon, altitudes, Vec3.ZERO, result);
	        };

	        // Internal. Intentionally not documented.
	        AtmosphereLayer.prototype.assembleTriStripIndices = function (numLat, numLon) {
	            var result = [];
	            var vertex = 0;

	            for (var latIndex = 0; latIndex < numLat - 1; latIndex++) {
	                // Create a triangle strip joining each adjacent column of vertices, starting in the bottom left corner and
	                // proceeding to the right. The first vertex starts with the left row of vertices and moves right to create
	                // a counterclockwise winding order.
	                for (var lonIndex = 0; lonIndex < numLon; lonIndex++) {
	                    vertex = lonIndex + latIndex * numLon;
	                    result.push(vertex + numLon);
	                    result.push(vertex);
	                }

	                // Insert indices to create 2 degenerate triangles:
	                // - one for the end of the current row, and
	                // - one for the beginning of the next row
	                if (latIndex < numLat - 2) {
	                    result.push(vertex);
	                    result.push((latIndex + 2) * numLon);
	                }
	            }

	            this._numIndices = result.length;
	            
	            return new Uint16Array(result);
	        };

	        // Internal. Intentionally not documented.
	        AtmosphereLayer.prototype.determineLightDirection = function (dc) {
	            if (this.lightLocation != null) {
	                dc.globe.computePointFromLocation(this.lightLocation.latitude, this.lightLocation.longitude,
	                    this._activeLightDirection);
	            }
	            else {
	                this._activeLightDirection.copy(dc.navigatorState.eyePoint);
	            }
	            this._activeLightDirection.normalize();
	        };

	        return AtmosphereLayer;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports Matrix3
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(30),
	        __webpack_require__(32)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
	              Logger) {
	        "use strict";

	        /**
	         * Constructs a 3 x 3  matrix.
	         * @alias Matrix3
	         * @constructor
	         * @classdesc Represents a 3 x 3 double precision matrix stored in a Float64Array in row-major order.
	         * @param {Number} m11 matrix element at row 1, column 1.
	         * @param {Number} m12 matrix element at row 1, column 2.
	         * @param {Number} m13 matrix element at row 1, column 3.
	         * @param {Number} m21 matrix element at row 2, column 1.
	         * @param {Number} m22 matrix element at row 2, column 2.
	         * @param {Number} m23 matrix element at row 2, column 3.
	         * @param {Number} m31 matrix element at row 3, column 1.
	         * @param {Number} m32 matrix element at row 3, column 2.
	         * @param {Number} m33 matrix element at row 3, column 3.
	         */
	        var Matrix3 = function (m11, m12, m13,
	                                m21, m22, m23,
	                                m31, m32, m33) {
	            this[0] = m11;
	            this[1] = m12;
	            this[2] = m13;
	            this[3] = m21;
	            this[4] = m22;
	            this[5] = m23;
	            this[6] = m31;
	            this[7] = m32;
	            this[8] = m33;
	        };

	        // Derives from Float64Array.
	        Matrix3.prototype = new Float64Array(9);

	        /**
	         * Creates an identity matrix.
	         * @returns {Matrix3} A new identity matrix.
	         */
	        Matrix3.fromIdentity = function () {
	            return new Matrix3(
	                1, 0, 0,
	                0, 1, 0,
	                0, 0, 1
	            );
	        };

	        /**
	         * Sets this matrix to one that flips and shifts the y-axis.
	         * <p>
	         * The resultant matrix maps Y=0 to Y=1 and Y=1 to Y=0. All existing values are overwritten. This matrix is
	         * usually used to change the coordinate origin from an upper left coordinate origin to a lower left coordinate
	         * origin. This is typically necessary to align the coordinate system of images (top-left origin) with that of
	         * OpenGL (bottom-left origin).
	         * @returns {Matrix3} This matrix set to values described above.
	         */
	        Matrix3.prototype.setToUnitYFlip = function () {
	            this[0] = 1;
	            this[1] = 0;
	            this[2] = 0;
	            this[3] = 0;
	            this[4] = -1;
	            this[5] = 1;
	            this[6] = 0;
	            this[7] = 0;
	            this[8] = 1;
	            return this;
	        };

	        /**
	         * Multiplies this matrix by a specified matrix.
	         *
	         * @param {Matrix3} matrix The matrix to multiply with this matrix.
	         * @returns {Matrix3} This matrix after multiplying it by the specified matrix.
	         * @throws {ArgumentError} if the specified matrix is null or undefined.
	         */
	        Matrix3.prototype.multiplyMatrix = function (matrix) {
	            if (!matrix) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Matrix3", "multiplyMatrix", "missingMatrix"));
	            }

	            var ma = this,
	                mb = matrix,
	                ma0, ma1, ma2;

	            // Row 1
	            ma0 = ma[0];
	            ma1 = ma[1];
	            ma2 = ma[2];
	            ma[0] = (ma0 * mb[0]) + (ma1 * mb[3]) + (ma2 * mb[6]);
	            ma[1] = (ma0 * mb[1]) + (ma1 * mb[4]) + (ma2 * mb[7]);
	            ma[2] = (ma0 * mb[2]) + (ma1 * mb[5]) + (ma2 * mb[8]);

	            // Row 2
	            ma0 = ma[3];
	            ma1 = ma[4];
	            ma2 = ma[5];
	            ma[3] = (ma0 * mb[0]) + (ma1 * mb[3]) + (ma2 * mb[6]);
	            ma[4] = (ma0 * mb[1]) + (ma1 * mb[4]) + (ma2 * mb[7]);
	            ma[5] = (ma0 * mb[2]) + (ma1 * mb[5]) + (ma2 * mb[8]);

	            // Row 3
	            ma0 = ma[6];
	            ma1 = ma[7];
	            ma2 = ma[8];
	            ma[6] = (ma0 * mb[0]) + (ma1 * mb[3]) + (ma2 * mb[6]);
	            ma[7] = (ma0 * mb[1]) + (ma1 * mb[4]) + (ma2 * mb[7]);
	            ma[8] = (ma0 * mb[2]) + (ma1 * mb[5]) + (ma2 * mb[8]);

	            return this;

	        };

	        /**
	         * Multiplies this matrix by a matrix that transforms normalized coordinates from a source sector to a destination
	         * sector. Normalized coordinates within a sector range from 0 to 1, with (0, 0) indicating the lower left corner
	         * and (1, 1) indicating the upper right. The resultant matrix maps a normalized source coordinate (X, Y) to its
	         * corresponding normalized destination coordinate (X', Y').
	         * <p/>
	         * This matrix typically necessary to transform texture coordinates from one geographic region to another. For
	         * example, the texture coordinates for a terrain tile spanning one region must be transformed to coordinates
	         * appropriate for an image tile spanning a potentially different region.
	         *
	         * @param {Sector} src the source sector
	         * @param {Sector} dst the destination sector
	         *
	         * @returns {Matrix3} this matrix multiplied by the transform matrix implied by values described above
	         */
	        Matrix3.prototype.multiplyByTileTransform = function (src, dst) {

	            var srcDeltaLat = src.deltaLatitude();
	            var srcDeltaLon = src.deltaLongitude();
	            var dstDeltaLat = dst.deltaLatitude();
	            var dstDeltaLon = dst.deltaLongitude();

	            var xs = srcDeltaLon / dstDeltaLon;
	            var ys = srcDeltaLat / dstDeltaLat;
	            var xt = (src.minLongitude - dst.minLongitude) / dstDeltaLon;
	            var yt = (src.minLatitude - dst.minLatitude) / dstDeltaLat;

	            // This is equivalent to the following operation, but is potentially much faster:
	            /*var m = new Matrix3(
	                xs, 0, xt,
	                0, ys, yt,
	                0, 0, 1);
	            this.multiplyMatrix(m);*/

	            // This inline version eliminates unnecessary multiplication by 1 and 0 in the matrix's components, reducing
	            // the total number of primitive operations from 63 to 18.

	            var m = this;

	             // Must be done before modifying m0, m1, etc. below.
	             m[2] += (m[0] * xt) + (m[1] * yt);
	             m[5] += (m[3] * xt) + (m[4] * yt);
	             m[8] += (m[6] * xt) + (m[6] * yt);

	             m[0] *= xs;
	             m[1] *= ys;

	             m[3] *= xs;
	             m[4] *= ys;

	             m[6] *= xs;
	             m[7] *= ys;

	            return this;
	        };

	        /**
	         * Stores this matrix's components in column-major order in a specified array.
	         * <p>
	         * The array must have space for at least 9 elements. This matrix's components are stored in the array
	         * starting with row 0 column 0 in index 0, row 1 column 0 in index 1, row 2 column 0 in index 2, and so on.
	         *
	         * @param {Float32Array | Float64Array | Number[]} result An array of at least 9 elements. Upon return,
	         * contains this matrix's components in column-major.
	         * @returns {Float32Array} The specified result array.
	         * @throws {ArgumentError} If the specified result array in null or undefined.
	         */
	        Matrix3.prototype.columnMajorComponents = function (result) {
	            if (!result) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "Matrix3", "columnMajorComponents", "missingResult"));
	            }

	            // Column 1
	            result[0] = this[0];
	            result[1] = this[3];
	            result[2] = this[6];

	            // Column 2
	            result[3] = this[1];
	            result[4] = this[4];
	            result[5] = this[7];

	            // Column 3
	            result[6] = this[2];
	            result[7] = this[5];
	            result[8] = this[8];

	            return result;
	        };

	        return Matrix3;

	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports GroundProgram
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(246)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (AtmosphereProgram) {
	        "use strict";

	        /**
	         * Constructs a new program.
	         * Initializes, compiles and links this GLSL program with the source code for its vertex and fragment shaders.
	         * <p>
	         * This method creates WebGL shaders for the program's shader sources and attaches them to a new GLSL program.
	         * This method then compiles the shaders and then links the program if compilation is successful. Use the bind
	         * method to make the program current during rendering.
	         *
	         * @alias GroundProgram
	         * @constructor
	         * @augments AtmosphereProgram
	         * @classdesc GroundProgram is a GLSL program that draws the ground component of the atmosphere.
	         * @param {WebGLRenderingContext} gl The current WebGL context.
	         * @throws {ArgumentError} If the shaders cannot be compiled, or linking of
	         * the compiled shaders into a program fails.
	         */
	        var GroundProgram = function (gl) {
	            var vertexShaderSource =
	                    'precision mediump int;\n' +

	                    'const int FRAGMODE_GROUND_PRIMARY_TEX_BLEND = 4;\n' +
	                    'const int SAMPLE_COUNT = 2;\n' +
	                    'const float SAMPLES = 2.0;\n' +

	                    'const float PI = 3.141592653589;\n' +
	                    'const float Kr = 0.0025;\n' +
	                    'const float Kr4PI = Kr * 4.0 * PI;\n' +
	                    'const float Km = 0.0015;\n' +
	                    'const float Km4PI = Km * 4.0 * PI;\n' +
	                    'const float ESun = 15.0;\n' +
	                    'const float KmESun = Km * ESun;\n' +
	                    'const float KrESun = Kr * ESun;\n' +
	                    'const vec3 invWavelength = vec3(5.60204474633241, 9.473284437923038, 19.643802610477206);\n' +
	                    'const float rayleighScaleDepth = 0.25;\n' +

	                    'uniform int fragMode;\n' +
	                    'uniform mat4 mvpMatrix;\n' +
	                    'uniform mat3 texCoordMatrix;\n' +
	                    'uniform vec3 vertexOrigin;\n' +
	                    'uniform vec3 eyePoint;\n' +
	                    'uniform float eyeMagnitude;\n' + /* The eye point's magnitude */
	                    'uniform float eyeMagnitude2;\n' + /* eyeMagnitude^2 */
	                    'uniform vec3 lightDirection;\n' + /* The direction vector to the light source */
	                    'uniform float atmosphereRadius;\n' + /* The outer (atmosphere) radius */
	                    'uniform float atmosphereRadius2;\n' + /* atmosphereRadius^2 */
	                    'uniform float globeRadius;\n' + /* The inner (planetary) radius */
	                    'uniform float scale;\n' + /* 1 / (atmosphereRadius - globeRadius) */
	                    'uniform float scaleDepth;\n' + /* The scale depth (i.e. the altitude at which
	                     the atmosphere's average density is found) */
	                    'uniform float scaleOverScaleDepth;\n' + /* fScale / fScaleDepth */

	                    'attribute vec4 vertexPoint;\n' +
	                    'attribute vec2 vertexTexCoord;\n' +

	                    'varying vec3 primaryColor;\n' +
	                    'varying vec3 secondaryColor;\n' +
	                    'varying vec2 texCoord;\n' +

	                    'float scaleFunc(float cos) {\n' +
	                    '    float x = 1.0 - cos;\n' +
	                    '    return scaleDepth * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\n' +
	                    '}\n' +

	                    'void sampleGround() {\n' +
	                    /* Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the
	                     atmosphere) */
	                    '    vec3 point = vertexPoint.xyz + vertexOrigin;\n' +
	                    '    vec3 ray = point - eyePoint;\n' +
	                    '    float far = length(ray);\n' +
	                    '    ray /= far;\n' +

	                    '    vec3 start;\n' +
	                    '    if (eyeMagnitude < atmosphereRadius) {\n' +
	                    '        start = eyePoint;\n' +
	                    '    } else {\n' +
	                    /* Calculate the closest intersection of the ray with the outer atmosphere (which is the near point of the ray
	                     passing through the atmosphere) */
	                    '        float B = 2.0 * dot(eyePoint, ray);\n' +
	                    '        float C = eyeMagnitude2 - atmosphereRadius2;\n' +
	                    '        float det = max(0.0, B*B - 4.0 * C);\n' +
	                    '        float near = 0.5 * (-B - sqrt(det));\n' +

	                    /* Calculate the ray's starting point, then calculate its scattering offset */
	                    '        start = eyePoint + ray * near;\n' +
	                    '        far -= near;\n' +
	                    '}\n' +

	                    '    float depth = exp((globeRadius - atmosphereRadius) / scaleDepth);\n' +
	                    '    float eyeAngle = dot(-ray, point) / length(point);\n' +
	                    '    float lightAngle = dot(lightDirection, point) / length(point);\n' +
	                    '    float eyeScale = scaleFunc(eyeAngle);\n' +
	                    '    float lightScale = scaleFunc(lightAngle);\n' +
	                    '    float eyeOffset = depth*eyeScale;\n' +
	                    '    float temp = (lightScale + eyeScale);\n' +

	                    /* Initialize the scattering loop variables */
	                    '    float sampleLength = far / SAMPLES;\n' +
	                    '    float scaledLength = sampleLength * scale;\n' +
	                    '    vec3 sampleRay = ray * sampleLength;\n' +
	                    '    vec3 samplePoint = start + sampleRay * 0.5;\n' +

	                    /* Now loop through the sample rays */
	                    '    vec3 frontColor = vec3(0.0, 0.0, 0.0);\n' +
	                    '    vec3 attenuate = vec3(0.0, 0.0, 0.0);\n' +
	                    '    for(int i=0; i<SAMPLE_COUNT; i++)\n' +
	                    '    {\n' +
	                    '        float height = length(samplePoint);\n' +
	                    '        float depth = exp(scaleOverScaleDepth * (globeRadius - height));\n' +
	                    '        float scatter = depth*temp - eyeOffset;\n' +
	                    '        attenuate = exp(-scatter * (invWavelength * Kr4PI + Km4PI));\n' +
	                    '        frontColor += attenuate * (depth * scaledLength);\n' +
	                    '        samplePoint += sampleRay;\n' +
	                    '    }\n' +

	                    '    primaryColor = frontColor * (invWavelength * KrESun + KmESun);\n' +
	                    '    secondaryColor = attenuate;\n' + /* Calculate the attenuation factor for the ground */
	                    '}\n' +

	                    'void main()\n ' +
	                    '{\n' +
	                    '    sampleGround();\n' +
	                    /* Transform the vertex point by the modelview-projection matrix */
	                    '    gl_Position = mvpMatrix * vertexPoint;\n' +
	                    '    if (fragMode == FRAGMODE_GROUND_PRIMARY_TEX_BLEND) {\n' +
	                    /* Transform the vertex texture coordinate by the tex coord matrix */
	                    '        texCoord = (texCoordMatrix * vec3(vertexTexCoord, 1.0)).st;\n' +
	                    '    }\n' +
	                    '}',
	                fragmentShaderSource =
	                    'precision mediump float;\n' +
	                    'precision mediump int;\n' +

	                    'const int FRAGMODE_GROUND_PRIMARY = 2;\n' +
	                    'const int FRAGMODE_GROUND_SECONDARY = 3;\n' +
	                    'const int FRAGMODE_GROUND_PRIMARY_TEX_BLEND = 4;\n' +

	                    'uniform int fragMode;\n' +
	                    'uniform sampler2D texSampler;\n' +

	                    'varying vec3 primaryColor;\n' +
	                    'varying vec3 secondaryColor;\n' +
	                    'varying vec2 texCoord;\n' +

	                    'void main (void)\n' +
	                    '{\n' +
	                    '    if (fragMode == FRAGMODE_GROUND_PRIMARY) {\n' +
	                    '        gl_FragColor = vec4(primaryColor, 1.0);\n' +
	                    '    } else if (fragMode == FRAGMODE_GROUND_SECONDARY) {\n' +
	                    '        gl_FragColor = vec4(secondaryColor, 1.0);\n' +
	                    '    } else if (fragMode == FRAGMODE_GROUND_PRIMARY_TEX_BLEND) {\n' +
	                    '        vec4 texColor = texture2D(texSampler, texCoord);\n' +
	                    '        gl_FragColor = vec4(primaryColor + texColor.rgb * (1.0 - secondaryColor), 1.0);\n' +
	                    '    }\n' +
	                    '}';

	            // Call to the superclass, which performs shader program compiling and linking.
	            AtmosphereProgram.call(this, gl, vertexShaderSource, fragmentShaderSource, ["vertexPoint", "vertexTexCoord"]);
	        };

	        /**
	         * A string that uniquely identifies this program.
	         * @type {string}
	         * @readonly
	         */
	        GroundProgram.key = "WorldWindGroundProgram";

	        // Inherit from AtmosphereProgram.
	        GroundProgram.prototype = Object.create(AtmosphereProgram.prototype);

	        return GroundProgram;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));




/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports AtmosphereProgram
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(30),
	        __webpack_require__(81),
	        __webpack_require__(32)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
	              GpuProgram,
	              Logger) {
	        "use strict";

	        /**
	         * Constructs a new program.
	         * Initializes, compiles and links this GLSL program with the source code for its vertex and fragment shaders.
	         * <p>
	         * This method creates WebGL shaders for the program's shader sources and attaches them to a new GLSL program.
	         * This method then compiles the shaders and then links the program if compilation is successful.
	         *
	         * @alias AtmosphereProgram
	         * @constructor
	         * @augments GpuProgram
	         * @classdesc AtmosphereProgram is a GLSL program that draws the atmosphere.
	         * @param {WebGLRenderingContext} gl The current WebGL context.
	         * @throws {ArgumentError} If the shaders cannot be compiled, or linking of
	         * the compiled shaders into a program fails.
	         */
	        var AtmosphereProgram = function (gl, vertexShaderSource, fragmentShaderSource, attribute) {

	            // Call to the superclass, which performs shader program compiling and linking.
	            GpuProgram.call(this, gl, vertexShaderSource, fragmentShaderSource, attribute);


	            // Frag color mode indicates the atmospheric scattering color components written to the fragment color.
	            this.FRAGMODE_SKY = 1;
	            this.FRAGMODE_GROUND_PRIMARY = 2;
	            this.FRAGMODE_GROUND_SECONDARY = 3;
	            this.FRAGMODE_GROUND_PRIMARY_TEX_BLEND = 4;

	            /**
	             * The globe's atmosphere altitude.
	             * @type {Number}
	             * @default 160000.0 meters
	             */
	            this.altitude = 160000;

	            /**
	             * This atmosphere's Rayleigh scale depth.
	             * @type {Number}
	             * @default 0.25
	             */
	            this.rayleighScaleDepth = 0.25;

	            /**
	             * The WebGL location for this program's 'fragMode' uniform.
	             * @type {WebGLUniformLocation}
	             * @readonly
	             */
	            this.fragModeLocation = this.uniformLocation(gl, "fragMode");

	            /**
	             * The WebGL location for this program's 'mvpMatrix' uniform.
	             * @type {WebGLUniformLocation}
	             * @readonly
	             */
	            this.mvpMatrixLocation = this.uniformLocation(gl, "mvpMatrix");

	            /**
	             * The WebGL location for this program's 'texCoordMatrix' uniform.
	             * @type {WebGLUniformLocation}
	             * @readonly
	             */
	            this.texCoordMatrixLocation = this.uniformLocation(gl, "texCoordMatrix");

	            /**
	             * The WebGL location for this program's 'vertexOrigin' uniform.
	             * @type {WebGLUniformLocation}
	             * @readonly
	             */
	            this.vertexOriginLocation = this.uniformLocation(gl, "vertexOrigin");

	            /**
	             * The WebGL location for this program's 'eyePoint' uniform.
	             * @type {WebGLUniformLocation}
	             * @readonly
	             */
	            this.eyePointLocation = this.uniformLocation(gl, "eyePoint");

	            /**
	             * The WebGL location for this program's 'eyeMagnitude' uniform.
	             * @type {WebGLUniformLocation}
	             * @readonly
	             */
	            this.eyeMagnitudeLocation = this.uniformLocation(gl, "eyeMagnitude");

	            /**
	             * The WebGL location for this program's 'eyeMagnitude2' uniform.
	             * @type {WebGLUniformLocation}
	             * @readonly
	             */
	            this.eyeMagnitude2Location = this.uniformLocation(gl, "eyeMagnitude2");

	            /**
	             * The WebGL location for this program's 'lightDirection' uniform.
	             * @type {WebGLUniformLocation}
	             * @readonly
	             */
	            this.lightDirectionLocation = this.uniformLocation(gl, "lightDirection");

	            /**
	             * The WebGL location for this program's 'atmosphereRadius' uniform.
	             * @type {WebGLUniformLocation}
	             * @readonly
	             */
	            this.atmosphereRadiusLocation = this.uniformLocation(gl, "atmosphereRadius");

	            /**
	             * The WebGL location for this program's 'atmosphereRadius2' uniform.
	             * @type {WebGLUniformLocation}
	             * @readonly
	             */
	            this.atmosphereRadius2Location = this.uniformLocation(gl, "atmosphereRadius2");

	            /**
	             * The WebGL location for this program's 'globeRadius' uniform.
	             * @type {WebGLUniformLocation}
	             * @readonly
	             */
	            this.globeRadiusLocation = this.uniformLocation(gl, "globeRadius");

	            /**
	             * The WebGL location for this program's 'scale' uniform.
	             * @type {WebGLUniformLocation}
	             * @readonly
	             */
	            this.scaleLocation = this.uniformLocation(gl, "scale");

	            /**
	             * The WebGL location for this program's 'scaleDepth' uniform.
	             * @type {WebGLUniformLocation}
	             * @readonly
	             */
	            this.scaleDepthLocation = this.uniformLocation(gl, "scaleDepth");

	            /**
	             * The WebGL location for this program's 'scaleOverScaleDepth' uniform.
	             * @type {WebGLUniformLocation}
	             * @readonly
	             */
	            this.scaleOverScaleDepthLocation = this.uniformLocation(gl, "scaleOverScaleDepth");
	            
	            this.scratchArray9 = new Float32Array(9);
	        };

	        /**
	         * A string that uniquely identifies this program.
	         * @type {string}
	         * @readonly
	         */
	        AtmosphereProgram.key = "WorldWindGpuAtmosphereProgram";

	        // Inherit from GpuProgram.
	        AtmosphereProgram.prototype = Object.create(GpuProgram.prototype);

	        /**
	         * Returns the atmosphere's altitude.
	         * @returns {Number} The atmosphere's altitude in meters.
	         */
	        AtmosphereProgram.prototype.getAltitude = function () {
	            return this.altitude;
	        };

	        /**
	         * Loads the specified number as the value of this program's 'fragMode' uniform variable.
	         *
	         * @param {WebGLRenderingContext} gl The current WebGL context.
	         * @param {Number} fragMode The frag mode value.
	         * @throws {ArgumentError} If the specified number is null or undefined.
	         */
	        AtmosphereProgram.prototype.loadFragMode = function (gl, fragMode) {
	            if (!fragMode) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "AtmosphereProgram", "loadFragMode", "missingFragMode"));
	            }

	            gl.uniform1i(this.fragModeLocation, fragMode);
	        };

	        /**
	         * Loads the specified matrix as the value of this program's 'mvpMatrix' uniform variable.
	         *
	         * @param {WebGLRenderingContext} gl The current WebGL context.
	         * @param {Matrix} matrix The matrix to load.
	         * @throws {ArgumentError} If the specified matrix is null or undefined.
	         */
	        AtmosphereProgram.prototype.loadModelviewProjection = function (gl, matrix) {
	            if (!matrix) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "AtmosphereProgram", "loadModelviewProjection",
	                        "missingMatrix"));
	            }

	            this.loadUniformMatrix(gl, matrix, this.mvpMatrixLocation);
	        };

	        /**
	         * Loads the specified vector as the value of this program's 'vertexOrigin' uniform variable.
	         *
	         * @param {WebGLRenderingContext} gl The current WebGL context.
	         * @param {Vec3} vector The vector to load.
	         * @throws {ArgumentError} If the specified vector is null or undefined.
	         */
	        AtmosphereProgram.prototype.loadVertexOrigin = function (gl, vector) {
	            if (!vector) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "AtmosphereProgram", "loadVertexOrigin", "missingVector"));
	            }

	            gl.uniform3f(this.vertexOriginLocation, vector[0], vector[1], vector[2]);
	        };

	        /**
	         * Loads the specified vector as the value of this program's 'lightDirection' uniform variable.
	         *
	         * @param {WebGLRenderingContext} gl The current WebGL context.
	         * @param {Vec3} vector The vector to load.
	         * @throws {ArgumentError} If the specified vector is null or undefined.
	         */
	        AtmosphereProgram.prototype.loadLightDirection = function (gl, vector) {
	            if (!vector) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "AtmosphereProgram", "loadLightDirection", "missingVector"));
	            }

	            gl.uniform3f(this.lightDirectionLocation, vector[0], vector[1], vector[2]);
	        };

	        /**
	         * Loads the specified vector as the value of this program's 'lightDirection' uniform variable,
	         * the magnitude's specified vector as the value of this program's 'eyeMagnitude' uniform variable and
	         * the squared magnitude's specified vector as the value of this program's 'eyeMagnitude2' uniform variable.
	         *
	         * @param {WebGLRenderingContext} gl The current WebGL context.
	         * @param {Vec3} vector The vector to load.
	         * @throws {ArgumentError} If the specified vector is null or undefined.
	         */
	        AtmosphereProgram.prototype.loadEyePoint = function (gl, vector) {
	            if (!vector) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "AtmosphereProgram", "loadEyePoint", "missingVector"));
	            }

	            gl.uniform3f(this.eyePointLocation, vector[0], vector[1], vector[2]);
	            gl.uniform1f(this.eyeMagnitudeLocation, vector.magnitude());
	            gl.uniform1f(this.eyeMagnitude2Location, vector.magnitudeSquared());
	        };

	        /**
	         * Loads the specified number as the value of this program's 'globeRadius' uniform variable and the specified
	         * number which add the altitude value as the value of this program's 'atmosphereRadius' uniform variable.
	         *
	         * @param {WebGLRenderingContext} gl The current WebGL context.
	         * @param {Number} globeRadius The globe radius value.
	         * @throws {ArgumentError} If the specified number is null or undefined.
	         */
	        AtmosphereProgram.prototype.loadGlobeRadius = function (gl, globeRadius) {
	            if (!globeRadius) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "AtmosphereProgram", "loadGlobeRadius",
	                        "missingGlobeRadius"));
	            }

	            var gr = globeRadius;
	            var ar = gr + this.altitude;

	            gl.uniform1f(this.globeRadiusLocation, gr);
	            gl.uniform1f(this.atmosphereRadiusLocation, ar);
	            gl.uniform1f(this.atmosphereRadius2Location, ar * ar);
	        };

	        /**
	         * Sets the program's 'scale', 'scaleDepth' and 'scaleOverScaleDepth' uniform variables.
	         *
	         * @param {WebGLRenderingContext} gl The current WebGL context.
	         */
	        AtmosphereProgram.prototype.setScale = function (gl) {
	            gl.uniform1f(this.scaleLocation, 1 / this.getAltitude());
	            gl.uniform1f(this.scaleDepthLocation, this.rayleighScaleDepth);
	            gl.uniform1f(this.scaleOverScaleDepthLocation, (1 / this.getAltitude()) / this.rayleighScaleDepth);
	        };

	        /**
	         * Loads the specified matrix as the value of this program's 'texCoordMatrix' uniform variable.
	         * @param {WebGLRenderingContext} gl The current WebGL context.
	         * @param {Matrix3} matrix The texture coordinate matrix.
	         */
	        AtmosphereProgram.prototype.loadTexMatrix = function(gl, matrix){
	            if (!matrix) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "AtmosphereProgram", "loadTexMatrix",
	                        "missingMatrix"));
	            }

	            matrix.columnMajorComponents(this.scratchArray9);
	            gl.uniformMatrix3fv(this.texCoordMatrixLocation, false, this.scratchArray9);
	        };

	        return AtmosphereProgram;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports SkyProgram
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(246)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (AtmosphereProgram) {
	        "use strict";

	        /**
	         * Constructs a new program.
	         * Initializes, compiles and links this GLSL program with the source code for its vertex and fragment shaders.
	         * <p>
	         * This method creates WebGL shaders for the program's shader sources and attaches them to a new GLSL program.
	         * This method then compiles the shaders and then links the program if compilation is successful. Use the bind
	         * method to make the program current during rendering.
	         *
	         * @alias SkyProgram
	         * @constructor
	         * @augments AtmosphereProgram
	         * @classdesc SkyProgram is a GLSL program that draws the sky component of the atmosphere.
	         * @param {WebGLRenderingContext} gl The current WebGL context.
	         * @throws {ArgumentError} If the shaders cannot be compiled, or linking of
	         * the compiled shaders into a program fails.
	         */
	        var  SkyProgram = function (gl) {
	            var vertexShaderSource =
	                    'precision mediump int;\n' +

	                    'const int SAMPLE_COUNT = 2;\n' +
	                    'const float SAMPLES = 2.0;\n' +

	                    'const float PI = 3.141592653589;\n' +
	                    'const float Kr = 0.0025;\n' +
	                    'const float Kr4PI = Kr * 4.0 * PI;\n' +
	                    'const float Km = 0.0015;\n' +
	                    'const float Km4PI = Km * 4.0 * PI;\n' +
	                    'const float ESun = 15.0;\n' +
	                    'const float KmESun = Km * ESun;\n' +
	                    'const float KrESun = Kr * ESun;\n' +
	                    'const vec3 invWavelength = vec3(5.60204474633241, 9.473284437923038, 19.643802610477206);\n' +
	                    'const float rayleighScaleDepth = 0.25;\n' +

	                    'uniform mat4 mvpMatrix;\n' +
	                    'uniform vec3 vertexOrigin;\n' +
	                    'uniform vec3 eyePoint;\n' +
	                    'uniform float eyeMagnitude;\n' +        /* The eye point's magnitude */
	                    'uniform float eyeMagnitude2;\n' +       /* eyeMagnitude^2 */
	                    'uniform mediump vec3 lightDirection;\n' +       /* The direction vector to the light source */
	                    'uniform float atmosphereRadius;\n' +    /* The outer (atmosphere) radius */
	                    'uniform float atmosphereRadius2;\n' +   /* atmosphereRadius^2 */
	                    'uniform float globeRadius;\n' +         /* The inner (planetary) radius */
	                    'uniform float scale;\n' +               /* 1 / (atmosphereRadius - globeRadius) */
	                    'uniform float scaleDepth;\n' +          /* The scale depth (i.e. the altitude at which the
	                     atmosphere's average density is found) */
	                    'uniform float scaleOverScaleDepth;\n' + /* fScale / fScaleDepth */

	                    'attribute vec4 vertexPoint;\n' +

	                    'varying vec3 primaryColor;\n' +
	                    'varying vec3 secondaryColor;\n' +
	                    'varying vec3 direction;\n' +

	                    'float scaleFunc(float cos)\n' +
	                    '{\n' +
	                    '    float x = 1.0 - cos;\n' +
	                    '    return scaleDepth * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\n' +
	                    '}\n' +

	                    'void sampleSky() {\n' +
	                        /* Get the ray from the camera to the vertex and its length (which is the far point of
	                         the ray passing through the atmosphere) */
	                    '    vec3 point = vertexPoint.xyz + vertexOrigin;\n' +
	                    '    vec3 ray = point - eyePoint;\n' +
	                    '    float far = length(ray);\n' +
	                    '    ray /= far;\n' +

	                    '    vec3 start;\n' +
	                    '    float startOffset;\n' +

	                    '    if (eyeMagnitude < atmosphereRadius) {\n' +
	                        /* Calculate the ray's starting point, then calculate its scattering offset */
	                    '        start = eyePoint;\n' +
	                    '        float height = length(start);\n' +
	                    '        float depth = exp(scaleOverScaleDepth * (globeRadius - eyeMagnitude));\n' +
	                    '        float startAngle = dot(ray, start) / height;\n' +
	                    '        startOffset = depth*scaleFunc(startAngle);\n' +
	                    '    } else {\n' +
	                        /* Calculate the closest intersection of the ray with the outer atmosphere (which is the near
	                         point of the ray passing through the atmosphere) */
	                    '        float B = 2.0 * dot(eyePoint, ray);\n' +
	                    '        float C = eyeMagnitude2 - atmosphereRadius2;\n' +
	                    '        float det = max(0.0, B*B - 4.0 * C);\n' +
	                    '        float near = 0.5 * (-B - sqrt(det));\n' +

	                        /* Calculate the ray's starting point, then calculate its scattering offset */
	                    '        start = eyePoint + ray * near;\n' +
	                    '        far -= near;\n' +
	                    '        float startAngle = dot(ray, start) / atmosphereRadius;\n' +
	                    '        float startDepth = exp(-1.0 / scaleDepth);\n' +
	                    '        startOffset = startDepth*scaleFunc(startAngle);\n' +
	                    '    }\n' +

	                        /* Initialize the scattering loop variables */
	                    '    float sampleLength = far / SAMPLES;\n' +
	                    '    float scaledLength = sampleLength * scale;\n' +
	                    '    vec3 sampleRay = ray * sampleLength;\n' +
	                    '    vec3 samplePoint = start + sampleRay * 0.5;\n' +

	                        /* Now loop through the sample rays */
	                    '    vec3 frontColor = vec3(0.0, 0.0, 0.0);\n' +
	                    '    for(int i=0; i<SAMPLE_COUNT; i++)\n' +
	                    '    {\n' +
	                    '       float height = length(samplePoint);\n' +
	                    '       float depth = exp(scaleOverScaleDepth * (globeRadius - height));\n' +
	                    '       float lightAngle = dot(lightDirection, samplePoint) / height;\n' +
	                    '       float cameraAngle = dot(ray, samplePoint) / height;\n' +
	                    '       float scatter = (startOffset + depth*(scaleFunc(lightAngle) - scaleFunc(cameraAngle)));\n'+
	                    '       vec3 attenuate = exp(-scatter * (invWavelength * Kr4PI + Km4PI));\n' +
	                    '       frontColor += attenuate * (depth * scaledLength);\n' +
	                    '       samplePoint += sampleRay;\n' +
	                    '    }\n' +

	                        /* Finally, scale the Mie and Rayleigh colors and set up the varying variables for the fragment
	                         shader */
	                    '    primaryColor = frontColor * (invWavelength * KrESun);\n' +
	                    '    secondaryColor = frontColor * KmESun;\n' +
	                    '    direction = eyePoint - point;\n' +
	                    '}\n' +

	                    'void main()\n' +
	                    '{\n' +
	                    '    sampleSky();\n' +

	                        /* Transform the vertex point by the modelview-projection matrix */
	                    '    gl_Position = mvpMatrix * vertexPoint;\n' +

	                        /* fix horizon clipping */
	                    '    gl_Position.z = gl_Position.w - 0.00001;\n' +
	                    '}',
	                fragmentShaderSource =
	                    '#ifdef GL_FRAGMENT_PRECISION_HIGH\n'+
	                    'precision highp float;\n'+
	                    '#else\n'+
	                    'precision mediump float;\n'+
	                    '#endif\n'+

	                    'const float g = -0.95;\n' +
	                    'const float g2 = g * g;\n' +
	                        
	                    'uniform mediump vec3 lightDirection;\n' +

	                    'varying vec3 primaryColor;\n' +
	                    'varying vec3 secondaryColor;\n' +
	                    'varying vec3 direction;\n' +

	                    'void main (void)\n' +
	                    '{\n' +
	                    '    float cos = dot(lightDirection, direction) / length(direction);\n' +
	                    '    float rayleighPhase = 0.75 * (1.0 + cos * cos);\n' +
	                    '    float miePhase = 1.5 * ((1.0 - g2) / (2.0 + g2)) * (1.0 + cos*cos) / ' +
	                    '        pow(1.0 + g2 - 2.0*g*cos, 1.5);\n' +
	                    '    const float exposure = 2.0;\n' +
	                    '    vec3 color = primaryColor * rayleighPhase + secondaryColor * miePhase;\n' +
	                    '    color = vec3(1.0) - exp(-exposure * color);\n' +
	                    '    gl_FragColor = vec4(color, color.b);\n' +
	                    '}';

	            // Call to the superclass, which performs shader program compiling and linking.
	            AtmosphereProgram.call(this, gl, vertexShaderSource, fragmentShaderSource, ["vertexPoint"]);
	        };

	        /**
	         * A string that uniquely identifies this program.
	         * @type {string}
	         * @readonly
	         */
	        SkyProgram.key = "WorldWindSkyProgram";

	        // Inherit from AtmosphereProgram.
	        SkyProgram.prototype = Object.create(AtmosphereProgram.prototype);

	        return SkyProgram;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));





/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

	var RenderableLayer = __webpack_require__(140);
	var Compass = __webpack_require__(249);
	var Offset = __webpack_require__(45);
	var ScreenImage = __webpack_require__(250);
	var Events = __webpack_require__(5);

	module.exports = function (img1, img2) {

	    Events.listen(Events.SWITCH_COMPASS, switchCompass);

	    var compassLayer = new RenderableLayer();
	    compassLayer.enabled = false;
	    compassLayer.pickEnabled = false;

	    if (img1 != null)
	    addCompass(img1, false);
	    if (img2 != null)
	    addCompass(img2, true);

	    return compassLayer;

	    function switchCompass(value) {
	        compassLayer.enabled = typeof value === 'undefined' ? !compassLayer.enabled : value;
	        Events.post(Events.REDRAW);
	    }

	    function addCompass(img, arrow) {

	        var offset = new Offset(
	            WorldWind.OFFSET_FRACTION, 0.95,
	            WorldWind.OFFSET_FRACTION, 0.90
	        ); // upper-right placement

	        var compass = new ScreenImage(offset, img);
	        var size = 0.1;

	        compass.beginDrawing = function (dc) {
	            ScreenImage.prototype.beginDrawing.call(compass, dc);
	            dc.currentGlContext.disable(dc.currentGlContext.DEPTH_TEST);
	        };

	        compass.render = function (dc) {

	            if (arrow) {
	                compass.imageRotation = dc.navigatorState.heading;
	            }

	            if (dc.navigatorState.tilt < 85) {
	                compass.imageTilt = dc.navigatorState.tilt;
	            }

	            var t = compass.getActiveTexture(dc);
	            if (t) {
	                compass.imageScale = size * dc.currentGlContext.drawingBufferWidth / t.imageWidth;
	            }
	            ScreenImage.prototype.render.call(compass, dc);
	        };


	        compassLayer.addRenderable(compass);
	    }
	};

/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports Compass
	 * @version $Id: Compass.js 3114 2015-05-27 01:08:58Z tgaskins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(30),
	        __webpack_require__(32),
	        __webpack_require__(45),
	        __webpack_require__(250)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
	              Logger,
	              Offset,
	              ScreenImage) {
	        "use strict";

	        /**
	         * Constructs a compass.
	         * @alias Compass
	         * @constructor
	         * @augments ScreenImage
	         * @classdesc Displays a compass image at a specified location in the World Window. The compass image rotates
	         * and tilts to reflect the current navigator's heading and tilt.
	         * @param {Offset} screenOffset The offset indicating the image's placement on the screen. If null or undefined
	         * the compass is placed at the upper-right corner of the World Window.
	         * Use [the image offset property]{@link ScreenImage#imageOffset} to position the image relative to the
	         * screen point.
	         * @param {String} imagePath The URL of the image to display. If null or undefined, a default compass image is used.
	         */
	        var Compass = function (screenOffset, imagePath) {

	            var sOffset = screenOffset ? screenOffset
	                : new Offset(WorldWind.OFFSET_FRACTION, 1, WorldWind.OFFSET_FRACTION, 1), // upper-right placement
	                iPath = imagePath ? imagePath : WorldWind.configuration.baseUrl + "images/notched-compass.png";

	            ScreenImage.call(this, sOffset, iPath);

	            // Must set the default image offset after calling the constructor above.

	            if (!screenOffset) {
	                // Align the upper right corner of the image with the screen point, and give the image some padding.
	                this.imageOffset = new Offset(WorldWind.OFFSET_FRACTION, 1.1, WorldWind.OFFSET_FRACTION, 1.1);
	            }

	            /**
	             * Specifies the size of the compass as a fraction of the World Window width.
	             * @type {number}
	             * @default 0.15
	             */
	            this.size = 0.15;
	        };

	        Compass.prototype = Object.create(ScreenImage.prototype);

	        /**
	         * Capture the navigator's heading and tilt and apply it to the compass' screen image.
	         * @param {DrawContext} dc The current draw context.
	         */
	        Compass.prototype.render = function (dc) {
	            // Capture the navigator's heading and tilt and apply it to the compass' screen image.
	            this.imageRotation = dc.navigatorState.heading;
	            this.imageTilt = dc.navigatorState.tilt;

	            var t = this.getActiveTexture(dc);
	            if (t) {
	                this.imageScale = this.size * dc.currentGlContext.drawingBufferWidth / t.imageWidth;
	            }

	            ScreenImage.prototype.render.call(this, dc);
	        };

	        return Compass;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
	;

/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (C) 2014 United States Government as represented by the Administrator of the
	 * National Aeronautics and Space Administration. All Rights Reserved.
	 */
	/**
	 * @exports ScreenImage
	 * @version $Id: ScreenImage.js 3345 2015-07-28 20:28:35Z dcollins $
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(30),
	        __webpack_require__(129),
	        __webpack_require__(52),
	        __webpack_require__(51),
	        __webpack_require__(32),
	        __webpack_require__(63),
	        __webpack_require__(45),
	        __webpack_require__(87),
	        __webpack_require__(130),
	        __webpack_require__(35),
	        __webpack_require__(36)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,
	              BasicTextureProgram,
	              Color,
	              ImageSource,
	              Logger,
	              Matrix,
	              Offset,
	              PickedObject,
	              Renderable,
	              Vec3,
	              WWMath) {
	        "use strict";

	        /**
	         * Constructs a screen image.
	         * @alias ScreenImage
	         * @constructor
	         * @augments Renderable
	         * @classdesc Displays an image at a specified screen location in the World Window.
	         * The image location is specified by an offset, which causes the image to maintain its relative position
	         * when the window size changes.
	         * @param {Offset} screenOffset The offset indicating the image's placement on the screen.
	         * Use [the image offset property]{@link ScreenImage#imageOffset} to position the image relative to the
	         * specified screen offset.
	         * @param {String|ImageSource} imageSource The source of the image to display.
	         * May be either a string identifying the URL of the image, or an {@link ImageSource} object identifying a
	         * dynamically created image.
	         * @throws {ArgumentError} If the specified screen offset or image source is null or undefined.
	         */
	        var ScreenImage = function (screenOffset, imageSource) {
	            if (!screenOffset) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "ScreenImage", "constructor", "missingOffset"));
	            }

	            if (!imageSource) {
	                throw new ArgumentError(
	                    Logger.logMessage(Logger.LEVEL_SEVERE, "ScreenImage", "constructor", "missingImage"));
	            }

	            Renderable.call(this);

	            /**
	             * The offset indicating this screen image's placement on the screen.
	             * @type {Offset}
	             */
	            this.screenOffset = screenOffset;

	            // Documented with its property accessor below.
	            this._imageSource = imageSource;

	            /**
	             * The image color. When displayed, this shape's image is multiplied by this image color to achieve the
	             * final image color. The color white, the default, causes the image to be drawn in its native colors.
	             * @type {Color}
	             * @default White (1, 1, 1, 1)
	             */
	            this.imageColor = Color.WHITE;

	            /**
	             * Indicates the location within the image at which to align with the specified screen location.
	             * May be null, in which case the image's bottom-left corner is placed at the screen location.
	             * @type {Offset}
	             * @default 0.5, 0.5, both fractional (Centers the image on the screen location.)
	             */
	            this.imageOffset = new Offset(WorldWind.OFFSET_FRACTION, 0.5, WorldWind.OFFSET_FRACTION, 0.5);

	            /**
	             * Indicates the amount to scale the image.
	             * @type {Number}
	             * @default 1
	             */
	            this.imageScale = 1;

	            /**
	             * The amount of rotation to apply to the image, measured in degrees clockwise from the top of the window.
	             * @type {Number}
	             * @default 0
	             */
	            this.imageRotation = 0;

	            /**
	             * The amount of tilt to apply to the image, measured in degrees.
	             * @type {Number}
	             * @default 0
	             */
	            this.imageTilt = 0;

	            /**
	             * Indicates whether to draw this screen image.
	             * @type {Boolean}
	             * @default true
	             */
	            this.enabled = true;

	            /**
	             * This image's opacity. When this screen image is drawn, the actual opacity is the product of
	             * this opacity and the opacity of the layer containing this screen image.
	             * @type {Number}
	             */
	            this.opacity = 1;

	            /**
	             * Indicates the object to return as the userObject of this shape when picked. If null,
	             * then this shape is returned as the userObject.
	             * @type {Object}
	             * @default null
	             * @see  [PickedObject.userObject]{@link PickedObject#userObject}
	             */
	            this.pickDelegate = null;

	            // Internal use only. Intentionally not documented.
	            this.activeTexture = null;

	            // Internal use only. Intentionally not documented.
	            this.imageTransform = Matrix.fromIdentity();

	            // Internal use only. Intentionally not documented.
	            this.texCoordMatrix = Matrix.fromIdentity();

	            // Internal use only. Intentionally not documented.
	            this.imageBounds = null;

	            // Internal use only. Intentionally not documented.
	            this.layer = null;
	        };

	        // Internal use only. Intentionally not documented.
	        ScreenImage.matrix = Matrix.fromIdentity(); // scratch variable

	        ScreenImage.prototype = Object.create(Renderable.prototype);

	        Object.defineProperties(ScreenImage.prototype, {
	            /**
	             * The source of the image to display.
	             * May be either a string identifying the URL of the image, or an {@link ImageSource} object identifying a
	             * dynamically created image.
	             * @type {String|ImageSource}
	             * @default null
	             * @memberof ScreenImage.prototype
	             */
	            imageSource: {
	                get: function () {
	                    return this._imageSource;
	                },
	                set: function (imageSource) {
	                    if (!imageSource) {
	                        throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "ScreenImage", "imageSource",
	                            "missingImage"));
	                    }

	                    this._imageSource = imageSource;
	                    this.imageSourceWasUpdated = true;
	                }
	            }
	        });

	        /**
	         * Renders this screen image. This method is typically not called by applications but is called by
	         * {@link RenderableLayer} during rendering. For this shape this method creates and
	         * enques an ordered renderable with the draw context and does not actually draw the image.
	         * @param {DrawContext} dc The current draw context.
	         */
	        ScreenImage.prototype.render = function (dc) {
	            if (!this.enabled) {
	                return;
	            }

	            if (!dc.accumulateOrderedRenderables) {
	                return;
	            }

	            // Create an ordered renderable, but don't create more than one per frame.
	            var orderedScreenImage = null;
	            if (this.lastFrameTime !== dc.timestamp) {
	                orderedScreenImage = this.makeOrderedRenderable(dc);
	            }

	            if (!orderedScreenImage) {
	                return;
	            }

	            if (!orderedScreenImage.isVisible(dc)) {
	                return;
	            }

	            orderedScreenImage.layer = dc.currentLayer;

	            this.lastFrameTime = dc.timestamp;
	            dc.addOrderedRenderable(orderedScreenImage);
	        };

	        /**
	         * Draws this shape as an ordered renderable. Applications do not call this function. It is called by
	         * [WorldWindow]{@link WorldWindow} during rendering.
	         * @param {DrawContext} dc The current draw context.
	         */
	        ScreenImage.prototype.renderOrdered = function (dc) {
	            this.drawOrderedScreenImage(dc);

	            if (dc.pickingMode) {
	                var po = new PickedObject(this.pickColor.clone(), this.pickDelegate ? this.pickDelegate : this,
	                    null, this.layer, false);
	                dc.resolvePick(po);
	            }
	        };

	        // Internal. Intentionally not documented.
	        ScreenImage.prototype.makeOrderedRenderable = function (dc) {
	            var w, h, s, ws, hs,
	                iOffset, sOffset;

	            this.activeTexture = this.getActiveTexture(dc);
	            if (!this.activeTexture || this.imageSourceWasUpdated) {
	                this.activeTexture = dc.gpuResourceCache.retrieveTexture(dc.currentGlContext, this._imageSource);
	                if (!this.activeTexture) {
	                    return null;
	                }
	            }

	            this.eyeDistance = 0;

	            // Compute the image's transform matrix and texture coordinate matrix according to its screen point, image size,
	            // image offset and image scale. The image offset is defined with its origin at the image's bottom-left corner and
	            // axes that extend up and to the right from the origin point.
	            w = this.activeTexture.imageWidth;
	            h = this.activeTexture.imageHeight;
	            s = this.imageScale;
	            iOffset = this.imageOffset.offsetForSize(w, h);
	            ws = dc.navigatorState.viewport.width;
	            hs = dc.navigatorState.viewport.height;
	            sOffset = this.screenOffset.offsetForSize(ws, hs);

	            this.imageTransform.setTranslation(
	                sOffset[0] - iOffset[0] * s,
	                sOffset[1] - iOffset[1] * s,
	                0);

	            this.imageTransform.setScale(w * s, h * s, 1);

	            this.imageBounds = WWMath.boundingRectForUnitQuad(this.imageTransform);

	            return this;
	        };

	        ScreenImage.prototype.getActiveTexture = function (dc) {
	            return dc.gpuResourceCache.resourceForKey(this._imageSource);
	        };

	        // Internal. Intentionally not documented.
	        ScreenImage.prototype.isVisible = function (dc) {
	            if (dc.pickingMode) {
	                return dc.pickRectangle && (this.imageBounds.intersects(dc.pickRectangle));
	            } else {
	                return this.imageBounds.intersects(dc.navigatorState.viewport);
	            }
	        };

	        // Internal. Intentionally not documented.
	        ScreenImage.prototype.drawOrderedScreenImage = function (dc) {
	            this.beginDrawing(dc);
	            try {
	                this.doDrawOrderedScreenImage(dc);
	            } finally {
	                this.endDrawing(dc);
	            }
	        };

	        // Internal. Intentionally not documented.
	        ScreenImage.prototype.beginDrawing = function (dc) {
	            var gl = dc.currentGlContext,
	                program;

	            dc.findAndBindProgram(BasicTextureProgram);

	            // Configure GL to use the draw context's unit quad VBOs for both model coordinates and texture coordinates.
	            // Most browsers can share the same buffer for vertex and texture coordinates, but Internet Explorer requires
	            // that they be in separate buffers, so the code below uses the 3D buffer for vertex coords and the 2D
	            // buffer for texture coords.
	            program = dc.currentProgram;
	            gl.bindBuffer(gl.ARRAY_BUFFER, dc.unitQuadBuffer());
	            gl.vertexAttribPointer(program.vertexTexCoordLocation, 2, gl.FLOAT, false, 0, 0);
	            gl.enableVertexAttribArray(program.vertexPointLocation);
	            gl.enableVertexAttribArray(program.vertexTexCoordLocation);

	            // Tell the program which texture unit to use.
	            program.loadTextureUnit(gl, gl.TEXTURE0);
	            program.loadModulateColor(gl, dc.pickingMode);

	            // Turn off depth testing.
	            // tag, 6/17/15: It's not clear why this call was here. It was carried over from WWJ.
	            //gl.disable(WebGLRenderingContext.DEPTH_TEST);
	        };

	        // Internal. Intentionally not documented.
	        ScreenImage.prototype.endDrawing = function (dc) {
	            var gl = dc.currentGlContext,
	                program = dc.currentProgram;

	            // Clear the vertex attribute state.
	            gl.disableVertexAttribArray(program.vertexPointLocation);
	            gl.disableVertexAttribArray(program.vertexTexCoordLocation);

	            // Clear GL bindings.
	            gl.bindBuffer(gl.ARRAY_BUFFER, null);
	            gl.bindTexture(gl.TEXTURE_2D, null);

	            // Re-enable depth testing.
	            gl.enable(gl.DEPTH_TEST);
	        };

	        // Internal. Intentionally not documented.
	        ScreenImage.prototype.doDrawOrderedScreenImage = function (dc) {
	            var gl = dc.currentGlContext,
	                program = dc.currentProgram;

	            gl.bindBuffer(gl.ARRAY_BUFFER, dc.unitQuadBuffer3());
	            gl.vertexAttribPointer(program.vertexPointLocation, 3, gl.FLOAT, false, 0, 0);

	            // Compute and specify the MVP matrix.
	            ScreenImage.matrix.copy(dc.screenProjection);
	            ScreenImage.matrix.multiplyMatrix(this.imageTransform);

	            ScreenImage.matrix.multiplyByTranslation(0.5, 0.5, 0.5); // shift Z to prevent image clipping
	            ScreenImage.matrix.multiplyByRotation(1, 0, 0, this.imageTilt);
	            ScreenImage.matrix.multiplyByRotation(0, 0, 1, this.imageRotation);
	            ScreenImage.matrix.multiplyByTranslation(-0.5, -0.5, 0);

	            program.loadModelviewProjection(gl, ScreenImage.matrix);

	            // Enable texture for both normal display and for picking. If picking is enabled in the shader (set in
	            // beginDrawing() above) then the texture's alpha component is still needed in order to modulate the
	            // pick color to mask off transparent pixels.
	            program.loadTextureEnabled(gl, true);

	            // Set the pick color for picking or the color and opacity if not picking.
	            if (dc.pickingMode) {
	                this.pickColor = dc.uniquePickColor();
	                program.loadColor(gl, this.pickColor);
	            } else {
	                program.loadColor(gl, this.imageColor);
	                program.loadOpacity(gl, this.opacity * this.layer.opacity);
	            }

	            this.texCoordMatrix.setToIdentity();
	            this.texCoordMatrix.multiplyByTextureTransform(this.activeTexture);
	            program.loadTextureMatrix(gl, this.texCoordMatrix);

	            if (this.activeTexture.bind(dc)) { // returns false if active texture cannot be bound
	                // Draw the placemark's image quad.
	                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
	            }
	        };

	        return ScreenImage;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
	;

/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

	var Events = __webpack_require__(5);

	module.exports = function (earth) {

	    Events.listen(Events._REQUEST_PICK, processPick);

	    function processPick(mouseEvent) {
	        var pickPoint = earth.canvasCoordinates(mouseEvent.x, mouseEvent.y);
	        var picked = earth.pick(pickPoint);
	        for (var i = 0; i < picked.objects.length; i++) {
	            if (picked.objects[i].parentLayer) { // filter terrain and tiles
	                return picked.objects[i].userObject;
	            }
	        }
	    }
	};



/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

	var Events = __webpack_require__(5);
	var RenderableLayer = __webpack_require__(140);
	var Placemark = __webpack_require__(187);
	var PlacemarkAttributes = __webpack_require__(183);
	var ShapeAttributes = __webpack_require__(132);
	var Color = __webpack_require__(52);
	var SurfacePolygon = __webpack_require__(166);
	var ScreenSpacePath = __webpack_require__(150);
	//var SurfacePolyline = require("../../../../node_modules/web-world-wind/src/shapes/SurfacePolyline");
	var Position = __webpack_require__(47);
	var Location = __webpack_require__(28);
	var CoCoMath = __webpack_require__(153);
	var Dom = __webpack_require__(4);

	var editorColorString = 'ffa500';
	var helperColorString = 'dd7a00';
	var EDITOR_SHAPE_ATTRIBUTES = newShapeAttributes(editorColorString); // orange
	var ARC_RADIUS_MULTIPLIER = 30;

	var newPrimitiveLayer = new RenderableLayer('Editor New Primitive Layer');
	var helperLayer = new RenderableLayer('Editor Helper Layer');
	var editorElement = Dom.select('.editor');
	var editorBorder = Dom.select('#editor-border');
	var scratchPosition = [0, 0, 0];
	var anchorPoints = [];
	var deleteMode = false;

	var editorMode, // тип нанесения (точка, линия, полигон)
	    draggedPoint, // перетаскиваемая сейчас точка
	    dragStartLocation, // исходное географическое положение перетаскиваемой точки
	    source, // geojson, переданный как аргумент редактору
	    centerPoint, // центральная точка
	    currentObjectGeometries, // все составляющие(renderables) редактируемого сейчас объекта,
	    rotateMode, // режим поворота
	    anchorPointMode, // режим нанесения включенных или исключенных точек (undefined, 'include', 'exclude')
	    engine, // link to core
	    x, y, // screen space last mouse down coordinates
	    animationInterval,
	    navigationBlocked,
	    isLeftButton;

	Events.listen(Events.OBJECT_MOUSE_CLICK, showObjectContextMenu);
	Events.listen(Events.NAVIGATOR_STATE_CHANGED, updatePrimitive);
	Events.listen(Events.START_DRAWING, startDrawing);
	Events.listen(Events.EDIT_OBJECT, startEdit);
	Events.listen(Events._FORCE_END_DRAWING, endDrawing);
	Events.listen(Events.DELETE_MODE, function(isOn) {
	    deleteMode = isOn;
	});

	var setCoordForm = Events.post(Events.CREATE_FORM, {
	    id: 'set-coordinates',
	    title: 'Координаты',
	    width:207, height:140,
	    top: 50, left: 50
	});

	Events.listen(Events.BLOCK_NAVIGATION, function(state){
	    navigationBlocked = state;
	});

	Events.listen(Events.SET_DRAW_MODE, function (mode) {
	    if (mode === 'draw') {
	        Events.post(Events.BLOCK_NAVIGATION, !navigationBlocked);
	        return;
	    }
	    switchRotateMode(mode === 'rotate');
	});

	module.exports = function (earth) {
	    engine = earth;
	    engine.addLayer(newPrimitiveLayer);
	    engine.addLayer(helperLayer);
	    engine.redrawCallbacks.push(updatePointsAfterRedraw);
	};

	function showObjectContextMenu(object) {

	    deleteMode && object.id && object.button === 2 &&
	    showContextMenu(object, 'Удалить', function() {
	        Events.post(Events.DESTROY_OBJECT, object.id);
	        Events.post(Events.SHOW_CONTEXT_MENU, false);
	    });

	    //
	    //if (object.object.source.id === '_editor') {
	    //    object.event.handled = true;
	    //    return showContextMenu(object.event, 'Добавить точку', addPoint.bind(nu   ll, object));
	    //}
	    //if (!object.object.source.geometry || object.object.source.geometry.type === 'text') return;
	    //showContextMenu(object.event, 'Редактировать', startEdit.bind(null, object));
	    //
	}

	function createAnchorPoints(coordinates) {
	    if(!coordinates) return;
	    isLineMode() && coordinates.forEach(createAP);
	    isPointMode() && createAP(coordinates);

	    function createAP(coord) {
	        var anchorPoint = createAnchorPoint();
	        var alt = engine.globe.elevationAtLocation(coord[0], coord[1]);
	        anchorPoint.position = new Position(coord[0], coord[1], alt);
	        anchorPoints.push(anchorPoint);
	    }
	}

	function setCurrentObjectGeometriesColor(color) {
	    currentObjectGeometries && currentObjectGeometries.forEach(function (shape) {
	        var c = Color.colorFromHex(color);
	        shape.attributes.outlineColor = c;
	        shape.highlightAttributes.outlineColor = c;
	    });
	}

	function startEdit(object) {
	    hideContextMenu();
	    startDrawing(object.object.source);
	    createAnchorPoints(source.geometry.coordinates);
	    currentObjectGeometries = object.object.allShapesInSign;
	    animationInterval = setInterval(function() {
	        if (draggedPoint)
	            return;
	        var time = new Date().getMilliseconds();
	        time = time < 500 ? 1000 - time : time;
	        var alpha = (time * 255/1000).toString(16);
	        setCurrentObjectGeometriesColor('ff00ff' + alpha);
	        engine.redraw();
	    }, 25);
	    updateEditorState();
	}

	function startDrawing(newPrimitive) {
	    editorMode && endDrawing(true);
	    source = newPrimitive;
	    editorMode = source.geometry.type.toLowerCase();

	    window.addEventListener('mousemove', onMouseMove);
	    window.addEventListener('mousedown', mouseDown);
	    window.addEventListener('mouseup', mouseUp);

	    window.addEventListener('touchmove', onMouseMove);
	    window.addEventListener('touchstart', mouseDown);
	    window.addEventListener('touchend', mouseUp);
	    // window.addEventListener('keydown', keyDown);
	    // window.addEventListener('keyup', keyUp);

	    Events.post(Events.BLOCK_NAVIGATION, true);
	    engine.canvas.classList.add('edit-mode');
	}

	// function keyDown(e) {
	//     switchRotateMode(e.ctrlKey);
	// }
	//
	// function keyUp() {
	//     switchRotateMode(false);
	// }

	function updateSourceGeoJson() {
	    var points = anchorPoints.map(function (point) {
	        return [point.position.latitude, point.position.longitude];
	    });
	    if (isPointMode()) {
	        points = points[0];
	    } else if (isPolygonMode()) {
	        points = [points];
	        points[0].push(points[0][0]);
	    }
	    source.geometry.coordinates = points;
	}

	function removeAllAnchorPoints() {
	    anchorPoints = [];
	    editorElement.innerHTML = '';
	}

	function updatePointsAfterRedraw() {
	    anchorPoints.forEach(updateScreenSpacePointPosition);
	    updateScreenSpacePointPosition(centerPoint);
	    editorBorder.setClass('hidden', !editorMode || !navigationBlocked);
	}

	function updateScreenSpacePointPosition(pt) {
	    if (!pt) return;
	    var result = [];
	    var lat = pt.position.latitude;
	    var lon = pt.position.longitude;
	    var alt = engine.globe.elevationAtLocation(lat, lon);
	    engine.globe.computePointFromPosition(lat, lon, alt, scratchPosition);
	    var visible = engine.navigator.currentState().project(scratchPosition, result);
	    visible &= !CoCoMath.isHorizonOccluded(engine.drawContext, scratchPosition);
	    if (pt.isVisible != null && visible !== pt.isVisible) {
	        pt.style.display = visible ? 'block' : 'none';
	    }
	    pt.style.top = engine.canvas.height - result[1] + 'px';
	    pt.style.left = result[0] + 'px';
	    pt.isVisible = visible;
	}

	function endDrawing(start) {
	    anchorPoints.length && updateSourceGeoJson();
	    animationInterval && clearInterval(animationInterval);
	    currentObjectGeometries && currentObjectGeometries.forEach(function(shape) {
	        shape.layer.removeRenderable(shape);
	    });
	    !start && source && Events.post(Events.END_DRAWING, source);
	    Events.post(Events.BLOCK_NAVIGATION, false);
	    hideContextMenu();
	    removeAllAnchorPoints();
	    newPrimitiveLayer.removeAllRenderables();
	    window.removeEventListener('mousemove', onMouseMove);
	    window.removeEventListener('mousedown', mouseDown);
	    window.removeEventListener('mouseup', mouseUp);
	    window.removeEventListener('touchmove', onMouseMove);
	    window.removeEventListener('touchstart', mouseDown);
	    window.removeEventListener('touchend', mouseUp);
	    engine.canvas.classList.remove('edit-mode');
	    switchRotateMode(false);
	    source = editorMode = draggedPoint = centerPoint = dragStartLocation = null;
	}

	function fixEvent(e) {
	    e.x = e.x || e.touches[0].clientX;
	    e.y = e.y || e.touches[0].clientY;
	    e.isLeft = e.button === 0 || e.touches && e.touches[0];
	}

	function mouseDown(e) {
	    isLeftButton = e.button === 0;
	    if (e.handled || !navigationBlocked)
	        return;
	    fixEvent(e);
	    x = e.x;
	    y = e.y;
	    if (e.target.parentNode === editorElement) {
	        draggedPoint = e.target;
	        actualizeDragStartLocation();
	        draggedPoint.classList.add('drag');
	        return;
	    }
	    if (e.target !== engine.canvas)
	        return;
	    hideContextMenu();
	}

	function mouseUp(e) {
	    if (draggedPoint) {
	        draggedPoint.classList.remove('drag');
	        draggedPoint = null;
	        dragStartLocation = null;
	        helperLayer.removeAllRenderables();
	        engine.redraw();
	    } else if (x === e.x && y === e.y) {
	        if (e.button === 0 && e.target === engine.canvas)
	            processDraw(e);
	        if (e.button === 2)
	            showEndEditContextMenu(e);
	    }
	}

	function updateRotationHelper() {
	    helperLayer.removeAllRenderables();
	    helperPolyline([draggedPoint.position, centerPoint.position, dragStartLocation]);
	    var arcRadius = computeArcRadiusDistance(centerPoint.position);
	    helperPolyline(computeArc(arcRadius, centerPoint.position, dragStartLocation, draggedPoint.position, 'minimum'));
	    helperPolyline(computeArc(arcRadius * 1.3, centerPoint.position, dragStartLocation, draggedPoint.position, 'minimum'));
	}

	function helperPolyline(points) {
	    helperLayer.addRenderable(new ScreenSpacePath(points, helperColorString, 2));
	}

	function computeArc(offset, center, from, to, mode) {
	    var distance = Location.greatCircleDistance(center, from);
	    var angleTo = Location.greatCircleAzimuth(center, to);
	    var angleFrom = Location.greatCircleAzimuth(center, from);
	    var delta = normalizeAngle(angleTo - angleFrom);
	    if (mode === 'minimum' && delta > 180 || mode === 'exclude') delta -= 360;
	    var positions = [computeArcPoint(offset, center, from)];
	    var step = 12;
	    for (var i = 0; i < Math.abs(delta) / step; i++) {
	        var alpha = normalizeAngle(angleFrom + i * step * Math.sign(delta));
	        var p = Location.greatCircleLocation(center, alpha, distance, new Position(0, 0, 0));
	        positions.push(computeArcPoint(offset, center, p));
	    }
	    positions.push(computeArcPoint(offset, center, to));
	    return positions;
	}

	function normalizeAngle(a) {
	    return a < 0 ? a + 360 : a;
	}

	function computeArcPoint(offset, center, position){
	    var r = engine.globe.radiusAt(center.latitude, center.longitude);
	    var distanceInRadians = offset / r;
	    var azimuth = Location.greatCircleAzimuth(center, position);
	    return Location.greatCircleLocation(center, azimuth, distanceInRadians, new Position(0, 0, 0));
	}

	function onMouseMove(e) {
	    if (!draggedPoint)
	        return;
	    if (e.button !== 0 && !e.touches[0])
	        return;
	    fixEvent(e);
	    var cursorPosition = pickPosition(e);
	    if (!cursorPosition)
	        return;
	    var isRotate = !rotateMode && !isLeftButton || rotateMode && isLeftButton;
	    if (draggedPoint.classList.contains('center-point')) {
	        !isRotate && translate(draggedPoint.position, cursorPosition);
	        draggedPoint.position = cursorPosition;
	    } else if (isRotate) {
	        rotate(draggedPoint.position, cursorPosition);
	        updateRotationHelper();
	    } else {
	        draggedPoint.position = cursorPosition;
	        createOrRecalculateCenterPoint();
	    }
	    updatePrimitive();
	}

	function rotate(point, to) {
	    var center = centerPoint.position;
	    var angle = Location.greatCircleAzimuth(center, to) - Location.greatCircleAzimuth(center, point);
	    anchorPoints.forEach(function(anchorPoint) {
	        var azimuth = Location.greatCircleAzimuth(center, anchorPoint.position) + angle;
	        var distance = Location.greatCircleDistance(center, anchorPoint.position);
	        Location.greatCircleLocation(center, azimuth, distance, anchorPoint.position);
	    });
	}

	function translate(from, to) {
	    var deltaLat = to.latitude - from.latitude;
	    var deltaLon = to.longitude - from.longitude;
	    anchorPoints.forEach(function(anchorPoint) {
	        anchorPoint.position.latitude += deltaLat;
	        anchorPoint.position.longitude += deltaLon;
	        normalizeLongitude(anchorPoint.position);
	    });
	}

	function normalizeLongitude(position) {
	    if (position.longitude > 180) position.longitude -= 360;
	    if (position.longitude < -180) position.longitude += 360;
	}

	function pickPosition(e) {
	    var pickPoint = engine.canvasCoordinates(e.x, e.y);
	    var picked = engine.pick(pickPoint).objects;
	    for (var i = 0; i < picked.length; i++) {
	        if (picked[i].isTerrain) return picked[i].position;
	    }
	}

	function updateEditorState() {
	    updatePrimitive();
	    createOrRecalculateCenterPoint();
	    Events.post(Events._ANCHOR_POINTS_COUNT, anchorPoints.length);
	}

	function processDraw(e) {
	    isPointMode() && removeAllAnchorPoints();
	    newEditorPoint(e);
	    updateEditorState();
	}

	function createOrRecalculateCenterPoint() {
	    if (anchorPoints.length < 2) return;
	    var clat = 0;
	    var clon = 0;
	    anchorPoints.forEach(function (anchorPoint) {
	        clat += anchorPoint.position.latitude;
	        clon += anchorPoint.position.longitude;
	    });
	    clat /= anchorPoints.length;
	    clon /= anchorPoints.length;
	    var calt = engine.globe.elevationAtLocation(clat, clon);
	    if (!centerPoint) {
	        centerPoint = createAnchorPoint('center-point');
	    }
	    centerPoint.position = new Position(clat, clon, calt);
	}

	function updateEditorLine(p) {
	    var previousPosition = p[0];
	    for (var i = 1; i < p.length - 1; i++) {
	        var pointMode = anchorPoints[i].mode;
	        if (pointMode) { // точка включена или исключена
	            var arcRadius = computeArcRadiusDistance(p[i]);
	            var arcPositions = computeArc(arcRadius, p[i], p[i - 1], p[i + 1], pointMode);
	            addEditorPolyline(arcPositions);
	        }
	        addEditorPolyline([pointMode ? arcPositions[0] : p[i], previousPosition], i);
	        previousPosition = pointMode ? arcPositions[arcPositions.length - 1] : p[i];
	    }
	    addEditorPolyline([previousPosition, p[p.length - 1]], p.length - 1);
	}

	function updateEditorLine2(p) {
	    var positions = [p[0]];
	    for (var i = 1; i < p.length - 1; i++) {
	        var pointMode = anchorPoints[i].mode;
	        if (pointMode) { // точка включена или исключена
	            var arcRadius = computeArcRadiusDistance(p[i]);
	            var arcPositions = computeArc(arcRadius, p[i], p[i - 1], p[i + 1], pointMode);
	            positions = positions.concat(arcPositions);
	        } else {
	            positions.push(p[i]);
	        }
	    }
	    positions.push(p[p.length - 1]);

	    addEditorPolyline(positions);


	}

	function addEditorPolyline(positions, i) {
	   // var editorLine = new SurfacePolyline(positions, EDITOR_COLOR);
	    var editorLine = new ScreenSpacePath(positions, editorColorString, 2, null);
	    editorLine.source = {id: '_editor', index: i};
	    newPrimitiveLayer.addRenderable(editorLine);
	}

	function updatePrimitive() {
	    engine.redraw();
	    if (isPointMode()) return;
	    newPrimitiveLayer.removeAllRenderables();
	    var positions = anchorPoints.map(function (point, i) {
	        point.innerHTML = i + 1;
	        return point.position;
	    });
	    if (isLineMode() && positions.length > 1) {
	        updateEditorLine2(positions);
	    }
	    if (isPolygonMode() && positions.length > 2) {
	        var surfacePolygon = new SurfacePolygon([positions], EDITOR_SHAPE_ATTRIBUTES);
	        surfacePolygon._attributes.drawOutline = false;
	        newPrimitiveLayer.addRenderable(surfacePolygon);
	        positions.push(positions[0]);
	        addEditorPolyline(positions);
	    }
	}

	function computeArcRadiusDistance(p) {
	    var cartesian = engine.drawContext.surfacePointForMode(
	        p.latitude, p.longitude, p.altitude,
	        WorldWind.CLAMP_TO_GROUND, new Position(0, 0, 0));
	    var ns = engine.drawContext.navigatorState;
	    var d = ns.eyePoint.distanceTo(cartesian);
	    return ns.pixelSizeAtDistance(d) * ARC_RADIUS_MULTIPLIER;
	}

	function switchRotateMode(state) {
	    rotateMode = undefined === state ? !rotateMode : state;
	    if (rotateMode) editorElement.classList.add('rotate-mode');
	    else editorElement.classList.remove('rotate-mode');
	    hideContextMenu();
	}

	function showCenterPointMenu(e) {
	    var funcs = [switchRotateMode.bind(null, undefined)];
	    var items = [rotateMode ? 'Режим перемещения' : 'Режим поворота'];
	    //anchorPointMode === undefined && menuItem2('Включать опорные точки', 'include');
	    //anchorPointMode === 'include' && menuItem2('Исключать опорные точки', 'exclude');
	    //anchorPointMode === 'exclude' && menuItem2('Отключить включение/выключение', undefined);
	    //anchorPoints[1].mode === undefined && menuItem3('Включить все опорные точки', 'include');
	    //anchorPoints[1].mode === 'include' && menuItem3('Исключить все опорные точки', 'exclude');
	    //anchorPoints[1].mode === 'exclude' && menuItem3('Отключить все опорные точки', undefined);
	    showContextMenu(e, items, funcs);

	    function menuItem2(name, pointMode) {
	        items.push(name);
	        funcs.push(function () {
	            anchorPointMode = pointMode;
	            anchorPoints[anchorPoints.length - 1].mode = pointMode;
	            hideContextMenu();
	        });
	    }

	    function menuItem3(name, pointMode) {
	        items.push(name);
	        funcs.push(function () {
	            anchorPoints.forEach(function (pt) {
	                pt.mode = pointMode;
	            });
	            hideContextMenu();
	            updatePrimitive();
	        });
	    }
	}

	function showEndEditContextMenu(e) {
	    showContextMenu(e, 'Завершить', endDrawing.bind(null, null));
	    engine.redraw();
	}

	function addPoint(segment) {
	    var point = createAnchorPoint();
	    point.position = pickPosition(segment.event);
	    var index = segment.object.source.index + 1;
	    anchorPoints.splice(index, 0, point);
	    hideContextMenu();
	    updateEditorState();
	}

	function newShapeAttributes(color) {
	    var attributes = new ShapeAttributes(null);
	    attributes.outlineColor = Color.colorFromHex(color + 'fe');
	    attributes.interiorColor = Color.colorFromHex(color + '3f');
	    return attributes;
	}

	function actualizeDragStartLocation() {
	    dragStartLocation = new Location(draggedPoint.position.latitude, draggedPoint.position.longitude);
	}

	function newEditorPoint(e) {
	    var position = pickPosition(e);
	    if (position) {
	        draggedPoint = createAnchorPoint('anchor-point-active', x = e.x, y = e.y);
	        draggedPoint.addEventListener('mousemove', function (e) {
	            e.target.classList.remove('anchor-point-active');
	        }, false);
	        draggedPoint.position = position;
	        actualizeDragStartLocation();
	        anchorPoints.push(draggedPoint);
	        Events.post(Events._ANCHOR_POINTS_COUNT, anchorPoints.length);
	    }
	    draggedPoint = null;
	}

	function removePoint(pt) {
	    anchorPoints.splice(anchorPoints.indexOf(pt), 1); // remove from collection

	    editorElement.removeChild(pt);
	    hideContextMenu();
	    updateEditorState();
	}

	function showAnchorPointMenu(pt, e) {
	    var items = [
	        'Координаты',
	        'Удалить'
	    ];
	    var funcs = [
	        setCoord.bind(null, pt),
	        removePoint.bind(null, pt)
	    ];
	    var index = anchorPoints.indexOf(pt);
	    //if (index > 0 && index < anchorPoints.length - 1) {
	    //    pt.mode === undefined && menuItem('Включить', 'include');
	    //    pt.mode === 'include' && menuItem('Исключить', 'exclude');
	    //    pt.mode === 'exclude' && menuItem('Отключить', undefined);
	    //}
	    showContextMenu(e, items, funcs);

	    function menuItem(name, pointMode) {
	        items.push(name);
	        funcs.push(setAnchorPointMode.bind(null, pt, pointMode));
	    }
	}

	function setCoord(pt) {
	    hideContextMenu();
	    setCoordForm.clear();
	    var lat = setCoordForm.addInput({title: 'Широта', value: pt.position.latitude.toFixed(6)});
	    var lon = setCoordForm.addInput({title: 'Долгота', value: pt.position.longitude.toFixed(6)});
	    setCoordForm.addButton({title: 'Отмена', width: 85, action: setCoordForm.hide});
	    setCoordForm.addButton({title: 'Сохранить', width: 85, action: function () {
	        pt.position.latitude = +lat.getValue();
	        pt.position.longitude = +lon.getValue();
	        updateScreenSpacePointPosition(pt);
	        setCoordForm.hide();
	        engine.redraw();
	    }});
	    setCoordForm.show(pt.offsetLeft + 30, pt.offsetTop);
	}

	function setAnchorPointMode(point, mode) {
	    point.mode = mode;
	    hideContextMenu();
	    updateEditorState();
	}

	function pointRightClick(pt, e) {
	    if (x !== e.x || y !== e.y)
	        return;
	    if (pt === centerPoint)
	        showCenterPointMenu(e);
	    showAnchorPointMenu(pt, e);
	}

	function createAnchorPoint(className, x, y) {
	    var circle = Dom.div('circle');
	    var pt = Dom.div(className)
	        .append(circle)
	        .appendTo(editorElement);
	    pt.classList.add('anchor-point');
	    pt.oncontextmenu = function(e) {
	        if (!navigationBlocked)
	            return false;
	        pointRightClick(pt, e);
	        return false;
	    };
	    pt.xy = function (x, y) {
	        pt.style.left = x + 'px';
	        pt.style.top = y + 'px';
	        setCoordForm.hide();
	    };
	    pt.mode = anchorPointMode;
	    pt.xy(x || 0, y || 0);
	    return pt;
	}

	function isPointMode() {
	    return editorMode === 'point';
	}

	function isPolygonMode() {
	    return editorMode === 'polygon';
	}

	function isLineMode() {
	    return editorMode === 'linestring';
	}

	function hideContextMenu() {
	    Events.post(Events.SHOW_CONTEXT_MENU, false);
	}

	function showContextMenu(e, names, functions) {
	    if (!Array.isArray(names)) {
	        names = [names];
	        functions = [functions];
	    }
	    Events.post(Events.SHOW_CONTEXT_MENU, {
	        x: e.x, y: e.y, items: names.map(function (name) {
	            return {text: name, func: functions[names.indexOf(name)]}
	        })
	    });
	}


/***/ }),
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

	var Events = __webpack_require__(5);

	var lastAcquiredMoveEvent;
	var activateTimeout;
	var previousPickedObject;

	window.addEventListener('mousedown', function (e) {

	    !e.target.classList.contains('context-menu-item')
	        && Events.post(Events.SHOW_CONTEXT_MENU, false);

	    previousPickedObject && previousPickedObject.source &&
	        Events.post(Events.OBJECT_MOUSE_CLICK, {
	            id: previousPickedObject.source.id,
	            button: e.button,
	            ctrl: e.ctrlKey,
	            alt: e.altKey,
	            shift: e.shiftKey,
	            x: e.x, y: e.y
	        });
	});

	window.addEventListener('mousemove', function (event) {

	    lastAcquiredMoveEvent = event;

	    if (previousPickedObject) {
	        doPick();
	        return;
	    }

	    clearTimeout(activateTimeout);
	    activateTimeout = setTimeout(doPick, 50);

	}, false);

	function doPick() {

	    var currentPickedObject = Events.post(Events._REQUEST_PICK, lastAcquiredMoveEvent);

	    if (previousPickedObject && currentPickedObject !== previousPickedObject){
	        previousPickedObject.highlighted = false;
	        Events.post(Events.TOOLTIP);
	        Events.post(Events.OBJECT_MOUSE_OVER, []);
	        previousPickedObject.hover && previousPickedObject.hover(false);
	    }

	    if (currentPickedObject) {
	        currentPickedObject.highlighted = true;
	        var src = currentPickedObject.source;
	        if (src && src.properties && src.properties.tooltip) {
	            Events.post(Events.TOOLTIP, src.properties.tooltip);
	        }
	        if (src && src.id && currentPickedObject !== previousPickedObject){
	            //Events.post(Events.OBJECT_MOUSE_OVER, [currentPickedObject]);
	             Events.post(Events.OBJECT_MOUSE_OVER, [src.id]);
	        }
	        currentPickedObject.hover && currentPickedObject.hover(true);
	    }
	    previousPickedObject = currentPickedObject;

	    Events.post(Events.REDRAW);
	}

	module.exports = function() {

	};

/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

	/*

	 Copyright 2000, Silicon Graphics, Inc. All Rights Reserved.
	 Copyright 2015, Google Inc. All Rights Reserved.

	 Permission is hereby granted, free of charge, to any person obtaining a copy
	 of this software and associated documentation files (the "Software"), to
	 deal in the Software without restriction, including without limitation the
	 rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
	 sell copies of the Software, and to permit persons to whom the Software is
	 furnished to do so, subject to the following conditions:

	 The above copyright notice including the dates of first publication and
	 either this permission notice or a reference to http://oss.sgi.com/projects/FreeB/
	 shall be included in all copies or substantial portions of the Software.

	 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
	 SILICON GRAPHICS, INC. BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	 WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
	 IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

	 Original Code. The Original Code is: OpenGL Sample Implementation,
	 Version 1.2.1, released January 26, 2000, developed by Silicon Graphics,
	 Inc. The Original Code is Copyright (c) 1991-2000 Silicon Graphics, Inc.
	 Copyright in any portions created by third parties is as indicated
	 elsewhere herein. All Rights Reserved.
	*/
	'use strict';var n;function t(a,b){return a.b===b.b&&a.a===b.a}function u(a,b){return a.b<b.b||a.b===b.b&&a.a<=b.a}function v(a,b,c){var d=b.b-a.b,e=c.b-b.b;return 0<d+e?d<e?b.a-a.a+d/(d+e)*(a.a-c.a):b.a-c.a+e/(d+e)*(c.a-a.a):0}function x(a,b,c){var d=b.b-a.b,e=c.b-b.b;return 0<d+e?(b.a-c.a)*d+(b.a-a.a)*e:0}function z(a,b){return a.a<b.a||a.a===b.a&&a.b<=b.b}function aa(a,b,c){var d=b.a-a.a,e=c.a-b.a;return 0<d+e?d<e?b.b-a.b+d/(d+e)*(a.b-c.b):b.b-c.b+e/(d+e)*(c.b-a.b):0}
	function ba(a,b,c){var d=b.a-a.a,e=c.a-b.a;return 0<d+e?(b.b-c.b)*d+(b.b-a.b)*e:0}function ca(a){return u(a.b.a,a.a)}function da(a){return u(a.a,a.b.a)}function A(a,b,c,d){a=0>a?0:a;c=0>c?0:c;return a<=c?0===c?(b+d)/2:b+a/(a+c)*(d-b):d+c/(a+c)*(b-d)};function ea(a){var b=B(a.b);C(b,a.c);C(b.b,a.c);D(b,a.a);return b}function E(a,b){var c=!1,d=!1;a!==b&&(b.a!==a.a&&(d=!0,F(b.a,a.a)),b.d!==a.d&&(c=!0,G(b.d,a.d)),H(b,a),d||(C(b,a.a),a.a.c=a),c||(D(b,a.d),a.d.a=a))}function I(a){var b=a.b,c=!1;a.d!==a.b.d&&(c=!0,G(a.d,a.b.d));a.c===a?F(a.a,null):(a.b.d.a=J(a),a.a.c=a.c,H(a,J(a)),c||D(a,a.d));b.c===b?(F(b.a,null),G(b.d,null)):(a.d.a=J(b),b.a.c=b.c,H(b,J(b)));fa(a)}
	function K(a){var b=B(a),c=b.b;H(b,a.e);b.a=a.b.a;C(c,b.a);b.d=c.d=a.d;b=b.b;H(a.b,J(a.b));H(a.b,b);a.b.a=b.a;b.b.a.c=b.b;b.b.d=a.b.d;b.f=a.f;b.b.f=a.b.f;return b}function L(a,b){var c=!1,d=B(a),e=d.b;b.d!==a.d&&(c=!0,G(b.d,a.d));H(d,a.e);H(e,b);d.a=a.b.a;e.a=b.a;d.d=e.d=a.d;a.d.a=e;c||D(d,a.d);return d}function B(a){var b=new M,c=new M,d=a.b.h;c.h=d;d.b.h=b;b.h=a;a.b.h=c;b.b=c;b.c=b;b.e=c;c.b=b;c.c=c;return c.e=b}function H(a,b){var c=a.c,d=b.c;c.b.e=b;d.b.e=a;a.c=d;b.c=c}
	function C(a,b){var c=b.f,d=new N(b,c);c.e=d;b.f=d;c=d.c=a;do c.a=d,c=c.c;while(c!==a)}function D(a,b){var c=b.d,d=new ga(b,c);c.b=d;b.d=d;d.a=a;d.c=b.c;c=a;do c.d=d,c=c.e;while(c!==a)}function fa(a){var b=a.h;a=a.b.h;b.b.h=a;a.b.h=b}function F(a,b){var c=a.c,d=c;do d.a=b,d=d.c;while(d!==c);c=a.f;d=a.e;d.f=c;c.e=d}function G(a,b){var c=a.a,d=c;do d.d=b,d=d.e;while(d!==c);c=a.d;d=a.b;d.d=c;c.b=d};function ha(a){var b=0;Math.abs(a[1])>Math.abs(a[0])&&(b=1);Math.abs(a[2])>Math.abs(a[b])&&(b=2);return b};var O=4*1E150;function P(a,b){a.f+=b.f;a.b.f+=b.b.f}function ia(a,b,c){a=a.a;b=b.a;c=c.a;if(b.b.a===a)return c.b.a===a?u(b.a,c.a)?0>=x(c.b.a,b.a,c.a):0<=x(b.b.a,c.a,b.a):0>=x(c.b.a,a,c.a);if(c.b.a===a)return 0<=x(b.b.a,a,b.a);b=v(b.b.a,a,b.a);a=v(c.b.a,a,c.a);return b>=a}function Q(a){a.a.i=null;var b=a.e;b.a.c=b.c;b.c.a=b.a;a.e=null}function ja(a,b){I(a.a);a.c=!1;a.a=b;b.i=a}function ka(a){var b=a.a.a;do a=R(a);while(a.a.a===b);a.c&&(b=L(S(a).a.b,a.a.e),ja(a,b),a=R(a));return a}
	function la(a,b,c){var d=new ma;d.a=c;d.e=na(a.f,b.e,d);return c.i=d}function oa(a,b){switch(a.s){case 100130:return 0!==(b&1);case 100131:return 0!==b;case 100132:return 0<b;case 100133:return 0>b;case 100134:return 2<=b||-2>=b}return!1}function pa(a){var b=a.a,c=b.d;c.c=a.d;c.a=b;Q(a)}function T(a,b,c){a=b;for(b=b.a;a!==c;){a.c=!1;var d=S(a),e=d.a;if(e.a!==b.a){if(!d.c){pa(a);break}e=L(b.c.b,e.b);ja(d,e)}b.c!==e&&(E(J(e),e),E(b,e));pa(a);b=d.a;a=d}return b}
	function U(a,b,c,d,e,f){var g=!0;do la(a,b,c.b),c=c.c;while(c!==d);for(null===e&&(e=S(b).a.b.c);;){d=S(b);c=d.a.b;if(c.a!==e.a)break;c.c!==e&&(E(J(c),c),E(J(e),c));d.f=b.f-c.f;d.d=oa(a,d.f);b.b=!0;!g&&qa(a,b)&&(P(c,e),Q(b),I(e));g=!1;b=d;e=c}b.b=!0;f&&ra(a,b)}function sa(a,b,c,d,e){var f=[b.g[0],b.g[1],b.g[2]];b.d=null;b.d=a.o?a.o(f,c,d,a.c)||null:null;null===b.d&&(e?a.n||(V(a,100156),a.n=!0):b.d=c[0])}
	function ta(a,b,c){var d=[null,null,null,null];d[0]=b.a.d;d[1]=c.a.d;sa(a,b.a,d,[.5,.5,0,0],!1);E(b,c)}function ua(a,b,c,d,e){var f=Math.abs(b.b-a.b)+Math.abs(b.a-a.a),g=Math.abs(c.b-a.b)+Math.abs(c.a-a.a),h=e+1;d[e]=.5*g/(f+g);d[h]=.5*f/(f+g);a.g[0]+=d[e]*b.g[0]+d[h]*c.g[0];a.g[1]+=d[e]*b.g[1]+d[h]*c.g[1];a.g[2]+=d[e]*b.g[2]+d[h]*c.g[2]}
	function qa(a,b){var c=S(b),d=b.a,e=c.a;if(u(d.a,e.a)){if(0<x(e.b.a,d.a,e.a))return!1;if(!t(d.a,e.a))K(e.b),E(d,J(e)),b.b=c.b=!0;else if(d.a!==e.a){var c=a.e,f=d.a.h;if(0<=f){var c=c.b,g=c.d,h=c.e,k=c.c,l=k[f];g[l]=g[c.a];k[g[l]]=l;l<=--c.a&&(1>=l?W(c,l):u(h[g[l>>1]],h[g[l]])?W(c,l):va(c,l));h[f]=null;k[f]=c.b;c.b=f}else for(c.c[-(f+1)]=null;0<c.a&&null===c.c[c.d[c.a-1]];)--c.a;ta(a,J(e),d)}}else{if(0>x(d.b.a,e.a,d.a))return!1;R(b).b=b.b=!0;K(d.b);E(J(e),d)}return!0}
	function wa(a,b){var c=S(b),d=b.a,e=c.a,f=d.a,g=e.a,h=d.b.a,k=e.b.a,l=new N;x(h,a.a,f);x(k,a.a,g);if(f===g||Math.min(f.a,h.a)>Math.max(g.a,k.a))return!1;if(u(f,g)){if(0<x(k,f,g))return!1}else if(0>x(h,g,f))return!1;var r=h,p=f,q=k,y=g,m,w;u(r,p)||(m=r,r=p,p=m);u(q,y)||(m=q,q=y,y=m);u(r,q)||(m=r,r=q,q=m,m=p,p=y,y=m);u(q,p)?u(p,y)?(m=v(r,q,p),w=v(q,p,y),0>m+w&&(m=-m,w=-w),l.b=A(m,q.b,w,p.b)):(m=x(r,q,p),w=-x(r,y,p),0>m+w&&(m=-m,w=-w),l.b=A(m,q.b,w,y.b)):l.b=(q.b+p.b)/2;z(r,p)||(m=r,r=p,p=m);z(q,y)||
	(m=q,q=y,y=m);z(r,q)||(m=r,r=q,q=m,m=p,p=y,y=m);z(q,p)?z(p,y)?(m=aa(r,q,p),w=aa(q,p,y),0>m+w&&(m=-m,w=-w),l.a=A(m,q.a,w,p.a)):(m=ba(r,q,p),w=-ba(r,y,p),0>m+w&&(m=-m,w=-w),l.a=A(m,q.a,w,y.a)):l.a=(q.a+p.a)/2;u(l,a.a)&&(l.b=a.a.b,l.a=a.a.a);r=u(f,g)?f:g;u(r,l)&&(l.b=r.b,l.a=r.a);if(t(l,f)||t(l,g))return qa(a,b),!1;if(!t(h,a.a)&&0<=x(h,a.a,l)||!t(k,a.a)&&0>=x(k,a.a,l)){if(k===a.a)return K(d.b),E(e.b,d),b=ka(b),d=S(b).a,T(a,S(b),c),U(a,b,J(d),d,d,!0),!0;if(h===a.a){K(e.b);E(d.e,J(e));f=c=b;g=f.a.b.a;
	do f=R(f);while(f.a.b.a===g);b=f;f=S(b).a.b.c;c.a=J(e);e=T(a,c,null);U(a,b,e.c,d.b.c,f,!0);return!0}0<=x(h,a.a,l)&&(R(b).b=b.b=!0,K(d.b),d.a.b=a.a.b,d.a.a=a.a.a);0>=x(k,a.a,l)&&(b.b=c.b=!0,K(e.b),e.a.b=a.a.b,e.a.a=a.a.a);return!1}K(d.b);K(e.b);E(J(e),d);d.a.b=l.b;d.a.a=l.a;d.a.h=xa(a.e,d.a);d=d.a;e=[0,0,0,0];l=[f.d,h.d,g.d,k.d];d.g[0]=d.g[1]=d.g[2]=0;ua(d,f,h,e,0);ua(d,g,k,e,2);sa(a,d,l,e,!0);R(b).b=b.b=c.b=!0;return!1}
	function ra(a,b){for(var c=S(b);;){for(;c.b;)b=c,c=S(c);if(!b.b&&(c=b,b=R(b),null===b||!b.b))break;b.b=!1;var d=b.a,e=c.a,f;if(f=d.b.a!==e.b.a)a:{f=b;var g=S(f),h=f.a,k=g.a,l=void 0;if(u(h.b.a,k.b.a)){if(0>x(h.b.a,k.b.a,h.a)){f=!1;break a}R(f).b=f.b=!0;l=K(h);E(k.b,l);l.d.c=f.d}else{if(0<x(k.b.a,h.b.a,k.a)){f=!1;break a}f.b=g.b=!0;l=K(k);E(h.e,k.b);l.b.d.c=f.d}f=!0}f&&(c.c?(Q(c),I(e),c=S(b),e=c.a):b.c&&(Q(b),I(d),b=R(c),d=b.a));if(d.a!==e.a)if(d.b.a===e.b.a||b.c||c.c||d.b.a!==a.a&&e.b.a!==a.a)qa(a,
	b);else if(wa(a,b))break;d.a===e.a&&d.b.a===e.b.a&&(P(e,d),Q(b),I(d),b=R(c))}}
	function ya(a,b){a.a=b;for(var c=b.c;null===c.i;)if(c=c.c,c===b.c){var c=a,d=b,e=new ma;e.a=d.c.b;var f=c.f,g=f.a;do g=g.a;while(null!==g.b&&!f.c(f.b,e,g.b));var f=g.b,h=S(f),e=f.a,g=h.a;if(0===x(e.b.a,d,e.a))e=f.a,t(e.a,d)||t(e.b.a,d)||(K(e.b),f.c&&(I(e.c),f.c=!1),E(d.c,e),ya(c,d));else{var k=u(g.b.a,e.b.a)?f:h,h=void 0;f.d||k.c?(k===f?h=L(d.c.b,e.e):h=L(g.b.c.b,d.c).b,k.c?ja(k,h):(e=c,f=la(c,f,h),f.f=R(f).f+f.a.f,f.d=oa(e,f.f)),ya(c,d)):U(c,f,d.c,d.c,null,!0)}return}c=ka(c.i);e=S(c);f=e.a;e=T(a,
	e,null);if(e.c===f){var f=e,e=f.c,g=S(c),h=c.a,k=g.a,l=!1;h.b.a!==k.b.a&&wa(a,c);t(h.a,a.a)&&(E(J(e),h),c=ka(c),e=S(c).a,T(a,S(c),g),l=!0);t(k.a,a.a)&&(E(f,J(k)),f=T(a,g,null),l=!0);l?U(a,c,f.c,e,e,!0):(u(k.a,h.a)?d=J(k):d=h,d=L(f.c.b,d),U(a,c,d,d.c,d.c,!1),d.b.i.c=!0,ra(a,c))}else U(a,c,e.c,f,f,!0)}function za(a,b){var c=new ma,d=ea(a.b);d.a.b=O;d.a.a=b;d.b.a.b=-O;d.b.a.a=b;a.a=d.b.a;c.a=d;c.f=0;c.d=!1;c.c=!1;c.h=!0;c.b=!1;d=a.f;d=na(d,d.a,c);c.e=d};function Aa(a){this.a=new Ba;this.b=a;this.c=ia}function na(a,b,c){do b=b.c;while(null!==b.b&&!a.c(a.b,b.b,c));a=new Ba(c,b.a,b);b.a.c=a;return b.a=a};function Ba(a,b,c){this.b=a||null;this.a=b||this;this.c=c||this};function X(){this.d=Y;this.p=this.b=this.q=null;this.j=[0,0,0];this.s=100130;this.n=!1;this.o=this.a=this.e=this.f=null;this.m=!1;this.c=this.r=this.i=this.k=this.l=this.h=null}var Y=0;n=X.prototype;n.x=function(){Z(this,Y)};n.B=function(a,b){switch(a){case 100142:return;case 100140:switch(b){case 100130:case 100131:case 100132:case 100133:case 100134:this.s=b;return}break;case 100141:this.m=!!b;return;default:V(this,100900);return}V(this,100901)};
	n.y=function(a){switch(a){case 100142:return 0;case 100140:return this.s;case 100141:return this.m;default:V(this,100900)}return!1};n.A=function(a,b,c){this.j[0]=a;this.j[1]=b;this.j[2]=c};
	n.z=function(a,b){var c=b?b:null;switch(a){case 100100:case 100106:this.h=c;break;case 100104:case 100110:this.l=c;break;case 100101:case 100107:this.k=c;break;case 100102:case 100108:this.i=c;break;case 100103:case 100109:this.p=c;break;case 100105:case 100111:this.o=c;break;case 100112:this.r=c;break;default:V(this,100900)}};
	n.C=function(a,b){var c=!1,d=[0,0,0];Z(this,2);for(var e=0;3>e;++e){var f=a[e];-1E150>f&&(f=-1E150,c=!0);1E150<f&&(f=1E150,c=!0);d[e]=f}c&&V(this,100155);c=this.q;null===c?(c=ea(this.b),E(c,c.b)):(K(c),c=c.e);c.a.d=b;c.a.g[0]=d[0];c.a.g[1]=d[1];c.a.g[2]=d[2];c.f=1;c.b.f=-1;this.q=c};n.u=function(a){Z(this,Y);this.d=1;this.b=new Ca;this.c=a};n.t=function(){Z(this,1);this.d=2;this.q=null};n.v=function(){Z(this,2);this.d=1};
	n.w=function(){Z(this,1);this.d=Y;var a=this.j[0],b=this.j[1],c=this.j[2],d=!1,e=[a,b,c];if(0===a&&0===b&&0===c){for(var b=[-2*1E150,-2*1E150,-2*1E150],f=[2*1E150,2*1E150,2*1E150],c=[],g=[],d=this.b.c,a=d.e;a!==d;a=a.e)for(var h=0;3>h;++h){var k=a.g[h];k<f[h]&&(f[h]=k,g[h]=a);k>b[h]&&(b[h]=k,c[h]=a)}a=0;b[1]-f[1]>b[0]-f[0]&&(a=1);b[2]-f[2]>b[a]-f[a]&&(a=2);if(f[a]>=b[a])e[0]=0,e[1]=0,e[2]=1;else{b=0;f=g[a];c=c[a];g=[0,0,0];f=[f.g[0]-c.g[0],f.g[1]-c.g[1],f.g[2]-c.g[2]];h=[0,0,0];for(a=d.e;a!==d;a=
	a.e)h[0]=a.g[0]-c.g[0],h[1]=a.g[1]-c.g[1],h[2]=a.g[2]-c.g[2],g[0]=f[1]*h[2]-f[2]*h[1],g[1]=f[2]*h[0]-f[0]*h[2],g[2]=f[0]*h[1]-f[1]*h[0],k=g[0]*g[0]+g[1]*g[1]+g[2]*g[2],k>b&&(b=k,e[0]=g[0],e[1]=g[1],e[2]=g[2]);0>=b&&(e[0]=e[1]=e[2]=0,e[ha(f)]=1)}d=!0}g=ha(e);a=this.b.c;b=(g+1)%3;c=(g+2)%3;g=0<e[g]?1:-1;for(e=a.e;e!==a;e=e.e)e.b=e.g[b],e.a=g*e.g[c];if(d){e=0;d=this.b.a;for(a=d.b;a!==d;a=a.b)if(b=a.a,!(0>=b.f)){do e+=(b.a.b-b.b.a.b)*(b.a.a+b.b.a.a),b=b.e;while(b!==a.a)}if(0>e)for(e=this.b.c,d=e.e;d!==
	e;d=d.e)d.a=-d.a}this.n=!1;e=this.b.b;for(a=e.h;a!==e;a=d)if(d=a.h,b=a.e,t(a.a,a.b.a)&&a.e.e!==a&&(ta(this,b,a),I(a),a=b,b=a.e),b.e===a){if(b!==a){if(b===d||b===d.b)d=d.h;I(b)}if(a===d||a===d.b)d=d.h;I(a)}this.e=e=new Da;d=this.b.c;for(a=d.e;a!==d;a=a.e)a.h=xa(e,a);Ea(e);this.f=new Aa(this);za(this,-O);for(za(this,O);null!==(e=Fa(this.e));){for(;;){a:if(a=this.e,0===a.a)d=Ga(a.b);else if(d=a.c[a.d[a.a-1]],0!==a.b.a&&(a=Ga(a.b),u(a,d))){d=a;break a}if(null===d||!t(d,e))break;d=Fa(this.e);ta(this,e.c,
	d.c)}ya(this,e)}this.a=this.f.a.a.b.a.a;for(e=0;null!==(d=this.f.a.a.b);)d.h||++e,Q(d);this.f=null;e=this.e;e.b=null;e.d=null;this.e=e.c=null;e=this.b;for(a=e.a.b;a!==e.a;a=d)d=a.b,a=a.a,a.e.e===a&&(P(a.c,a),I(a));if(!this.n){e=this.b;if(this.m)for(a=e.b.h;a!==e.b;a=d)d=a.h,a.b.d.c!==a.d.c?a.f=a.d.c?1:-1:I(a);else for(a=e.a.b;a!==e.a;a=d)if(d=a.b,a.c){for(a=a.a;u(a.b.a,a.a);a=a.c.b);for(;u(a.a,a.b.a);a=a.e);b=a.c.b;for(c=void 0;a.e!==b;)if(u(a.b.a,b.a)){for(;b.e!==a&&(ca(b.e)||0>=x(b.a,b.b.a,b.e.b.a));)c=
	L(b.e,b),b=c.b;b=b.c.b}else{for(;b.e!==a&&(da(a.c.b)||0<=x(a.b.a,a.a,a.c.b.a));)c=L(a,a.c.b),a=c.b;a=a.e}for(;b.e.e!==a;)c=L(b.e,b),b=c.b}if(this.h||this.i||this.k||this.l)if(this.m)for(e=this.b,d=e.a.b;d!==e.a;d=d.b){if(d.c){this.h&&this.h(2,this.c);a=d.a;do this.k&&this.k(a.a.d,this.c),a=a.e;while(a!==d.a);this.i&&this.i(this.c)}}else{e=this.b;d=!!this.l;a=!1;b=-1;for(c=e.a.d;c!==e.a;c=c.d)if(c.c){a||(this.h&&this.h(4,this.c),a=!0);g=c.a;do d&&(f=g.b.d.c?0:1,b!==f&&(b=f,this.l&&this.l(!!b,this.c))),
	this.k&&this.k(g.a.d,this.c),g=g.e;while(g!==c.a)}a&&this.i&&this.i(this.c)}if(this.r){e=this.b;for(a=e.a.b;a!==e.a;a=d)if(d=a.b,!a.c){b=a.a;c=b.e;g=void 0;do g=c,c=g.e,g.d=null,null===g.b.d&&(g.c===g?F(g.a,null):(g.a.c=g.c,H(g,J(g))),f=g.b,f.c===f?F(f.a,null):(f.a.c=f.c,H(f,J(f))),fa(g));while(g!==b);b=a.d;a=a.b;a.d=b;b.b=a}this.r(this.b);this.c=this.b=null;return}}this.b=this.c=null};
	function Z(a,b){if(a.d!==b)for(;a.d!==b;)if(a.d<b)switch(a.d){case Y:V(a,100151);a.u(null);break;case 1:V(a,100152),a.t()}else switch(a.d){case 2:V(a,100154);a.v();break;case 1:V(a,100153),a.w()}}function V(a,b){a.p&&a.p(b,a.c)};function ga(a,b){this.b=a||this;this.d=b||this;this.a=null;this.c=!1};function M(){this.h=this;this.i=this.d=this.a=this.e=this.c=this.b=null;this.f=0}function J(a){return a.b.e};function Ca(){this.c=new N;this.a=new ga;this.b=new M;this.d=new M;this.b.b=this.d;this.d.b=this.b};function N(a,b){this.e=a||this;this.f=b||this;this.d=this.c=null;this.g=[0,0,0];this.h=this.a=this.b=0};function Da(){this.c=[];this.d=null;this.a=0;this.e=!1;this.b=new Ha}function Ea(a){a.d=[];for(var b=0;b<a.a;b++)a.d[b]=b;a.d.sort(function(a){return function(b,e){return u(a[b],a[e])?1:-1}}(a.c));a.e=!0;Ia(a.b)}function xa(a,b){if(a.e){var c=a.b,d=++c.a;2*d>c.f&&(c.f*=2,c.c=Ja(c.c,c.f+1));var e;0===c.b?e=d:(e=c.b,c.b=c.c[c.b]);c.e[e]=b;c.c[e]=d;c.d[d]=e;c.h&&va(c,d);return e}c=a.a++;a.c[c]=b;return-(c+1)}
	function Fa(a){if(0===a.a)return Ka(a.b);var b=a.c[a.d[a.a-1]];if(0!==a.b.a&&u(Ga(a.b),b))return Ka(a.b);do--a.a;while(0<a.a&&null===a.c[a.d[a.a-1]]);return b};function Ha(){this.d=Ja([0],33);this.e=[null,null];this.c=[0,0];this.a=0;this.f=32;this.b=0;this.h=!1;this.d[1]=1}function Ja(a,b){for(var c=Array(b),d=0;d<a.length;d++)c[d]=a[d];for(;d<b;d++)c[d]=0;return c}function Ia(a){for(var b=a.a;1<=b;--b)W(a,b);a.h=!0}function Ga(a){return a.e[a.d[1]]}function Ka(a){var b=a.d,c=a.e,d=a.c,e=b[1],f=c[e];0<a.a&&(b[1]=b[a.a],d[b[1]]=1,c[e]=null,d[e]=a.b,a.b=e,0<--a.a&&W(a,1));return f}
	function W(a,b){for(var c=a.d,d=a.e,e=a.c,f=b,g=c[f];;){var h=f<<1;h<a.a&&u(d[c[h+1]],d[c[h]])&&(h+=1);var k=c[h];if(h>a.a||u(d[g],d[k])){c[f]=g;e[g]=f;break}c[f]=k;e[k]=f;f=h}}function va(a,b){for(var c=a.d,d=a.e,e=a.c,f=b,g=c[f];;){var h=f>>1,k=c[h];if(0===h||u(d[k],d[g])){c[f]=g;e[g]=f;break}c[f]=k;e[k]=f;f=h}};function ma(){this.e=this.a=null;this.f=0;this.c=this.b=this.h=this.d=!1}function S(a){return a.e.c.b}function R(a){return a.e.a.b};this.libtess={GluTesselator:X,windingRule:{GLU_TESS_WINDING_ODD:100130,GLU_TESS_WINDING_NONZERO:100131,GLU_TESS_WINDING_POSITIVE:100132,GLU_TESS_WINDING_NEGATIVE:100133,GLU_TESS_WINDING_ABS_GEQ_TWO:100134},primitiveType:{GL_LINE_LOOP:2,GL_TRIANGLES:4,GL_TRIANGLE_STRIP:5,GL_TRIANGLE_FAN:6},errorType:{GLU_TESS_MISSING_BEGIN_POLYGON:100151,GLU_TESS_MISSING_END_POLYGON:100153,GLU_TESS_MISSING_BEGIN_CONTOUR:100152,GLU_TESS_MISSING_END_CONTOUR:100154,GLU_TESS_COORD_TOO_LARGE:100155,GLU_TESS_NEED_COMBINE_CALLBACK:100156},
	gluEnum:{GLU_TESS_MESH:100112,GLU_TESS_TOLERANCE:100142,GLU_TESS_WINDING_RULE:100140,GLU_TESS_BOUNDARY_ONLY:100141,GLU_INVALID_ENUM:100900,GLU_INVALID_VALUE:100901,GLU_TESS_BEGIN:100100,GLU_TESS_VERTEX:100101,GLU_TESS_END:100102,GLU_TESS_ERROR:100103,GLU_TESS_EDGE_FLAG:100104,GLU_TESS_COMBINE:100105,GLU_TESS_BEGIN_DATA:100106,GLU_TESS_VERTEX_DATA:100107,GLU_TESS_END_DATA:100108,GLU_TESS_ERROR_DATA:100109,GLU_TESS_EDGE_FLAG_DATA:100110,GLU_TESS_COMBINE_DATA:100111}};X.prototype.gluDeleteTess=X.prototype.x;
	X.prototype.gluTessProperty=X.prototype.B;X.prototype.gluGetTessProperty=X.prototype.y;X.prototype.gluTessNormal=X.prototype.A;X.prototype.gluTessCallback=X.prototype.z;X.prototype.gluTessVertex=X.prototype.C;X.prototype.gluTessBeginPolygon=X.prototype.u;X.prototype.gluTessBeginContour=X.prototype.t;X.prototype.gluTessEndContour=X.prototype.v;X.prototype.gluTessEndPolygon=X.prototype.w; if (true) { module.exports = this.libtess; }


/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

	/****************************************************************************
	 **
	 ** Copyright (C) 2016 The Qt Company Ltd.
	 ** Copyright (C) 2014 Klarälvdalens Datakonsult AB, a KDAB Group company, info@kdab.com, author Milian Wolff <milian.wolff@kdab.com>
	 ** Contact: https://www.qt.io/licensing/
	 **
	 ** This file is part of the QtWebChannel module of the Qt Toolkit.
	 **
	 ** $QT_BEGIN_LICENSE:BSD$
	 ** Commercial License Usage
	 ** Licensees holding valid commercial Qt licenses may use this file in
	 ** accordance with the commercial license agreement provided with the
	 ** Software or, alternatively, in accordance with the terms contained in
	 ** a written agreement between you and The Qt Company. For licensing terms
	 ** and conditions see https://www.qt.io/terms-conditions. For further
	 ** information use the contact form at https://www.qt.io/contact-us.
	 **
	 ** BSD License Usage
	 ** Alternatively, you may use this file under the terms of the BSD license
	 ** as follows:
	 **
	 ** "Redistribution and use in source and binary forms, with or without
	 ** modification, are permitted provided that the following conditions are
	 ** met:
	 **   * Redistributions of source code must retain the above copyright
	 **     notice, this list of conditions and the following disclaimer.
	 **   * Redistributions in binary form must reproduce the above copyright
	 **     notice, this list of conditions and the following disclaimer in
	 **     the documentation and/or other materials provided with the
	 **     distribution.
	 **   * Neither the name of The Qt Company Ltd nor the names of its
	 **     contributors may be used to endorse or promote products derived
	 **     from this software without specific prior written permission.
	 **
	 **
	 ** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 ** "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 ** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 ** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 ** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 ** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 ** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 ** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 ** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 ** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 ** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
	 **
	 ** $QT_END_LICENSE$
	 **
	 ****************************************************************************/

	"use strict";

	var QWebChannelMessageTypes = {
	    signal: 1,
	    propertyUpdate: 2,
	    init: 3,
	    idle: 4,
	    debug: 5,
	    invokeMethod: 6,
	    connectToSignal: 7,
	    disconnectFromSignal: 8,
	    setProperty: 9,
	    response: 10,
	};

	var QWebChannel = function (transport, initCallback) {
	    if (typeof transport !== "object" || typeof transport.send !== "function") {
	        console.error("The QWebChannel expects a transport object with a send function and onmessage callback property." +
	            " Given is: transport: " + typeof(transport) + ", transport.send: " + typeof(transport.send));
	        return;
	    }

	    var channel = this;
	    this.transport = transport;

	    this.send = function (data) {
	        if (typeof(data) !== "string") {
	            data = JSON.stringify(data);
	        }
	        channel.transport.send(data);
	    }

	    this.transport.onmessage = function (message) {
	        var data = message.data;
	        if (typeof data === "string") {
	            data = JSON.parse(data);
	        }
	        switch (data.type) {
	            case QWebChannelMessageTypes.signal:
	                channel.handleSignal(data);
	                break;
	            case QWebChannelMessageTypes.response:
	                channel.handleResponse(data);
	                break;
	            case QWebChannelMessageTypes.propertyUpdate:
	                channel.handlePropertyUpdate(data);
	                break;
	            default:
	                console.error("invalid message received:", message.data);
	                break;
	        }
	    }

	    this.execCallbacks = {};
	    this.execId = 0;
	    this.exec = function (data, callback) {
	        if (!callback) {
	            // if no callback is given, send directly
	            channel.send(data);
	            return;
	        }
	        if (channel.execId === Number.MAX_VALUE) {
	            // wrap
	            channel.execId = Number.MIN_VALUE;
	        }
	        if (data.hasOwnProperty("id")) {
	            console.error("Cannot exec message with property id: " + JSON.stringify(data));
	            return;
	        }
	        data.id = channel.execId++;
	        channel.execCallbacks[data.id] = callback;
	        channel.send(data);
	    };

	    this.objects = {};

	    this.handleSignal = function (message) {
	        var object = channel.objects[message.object];
	        if (object) {
	            object.signalEmitted(message.signal, message.args);
	        } else {
	            console.warn("Unhandled signal: " + message.object + "::" + message.signal);
	        }
	    }

	    this.handleResponse = function (message) {
	        if (!message.hasOwnProperty("id")) {
	            console.error("Invalid response message received: ", JSON.stringify(message));
	            return;
	        }
	        channel.execCallbacks[message.id](message.data);
	        delete channel.execCallbacks[message.id];
	    }

	    this.handlePropertyUpdate = function (message) {
	        for (var i in message.data) {
	            var data = message.data[i];
	            var object = channel.objects[data.object];
	            if (object) {
	                object.propertyUpdate(data.signals, data.properties);
	            } else {
	                console.warn("Unhandled property update: " + data.object + "::" + data.signal);
	            }
	        }
	        channel.exec({type: QWebChannelMessageTypes.idle});
	    }

	    this.debug = function (message) {
	        channel.send({type: QWebChannelMessageTypes.debug, data: message});
	    };

	    channel.exec({type: QWebChannelMessageTypes.init}, function (data) {
	        for (var objectName in data) {
	            var object = new QObject(objectName, data[objectName], channel);
	        }
	        // now unwrap properties, which might reference other registered objects
	        for (var objectName in channel.objects) {
	            channel.objects[objectName].unwrapProperties();
	        }
	        if (initCallback) {
	            initCallback(channel);
	        }
	        channel.exec({type: QWebChannelMessageTypes.idle});
	    });
	};

	function QObject(name, data, webChannel) {
	    this.__id__ = name;
	    webChannel.objects[name] = this;

	    // List of callbacks that get invoked upon signal emission
	    this.__objectSignals__ = {};

	    // Cache of all properties, updated when a notify signal is emitted
	    this.__propertyCache__ = {};

	    var object = this;

	    // ----------------------------------------------------------------------

	    this.unwrapQObject = function (response) {
	        if (response instanceof Array) {
	            // support list of objects
	            var ret = new Array(response.length);
	            for (var i = 0; i < response.length; ++i) {
	                ret[i] = object.unwrapQObject(response[i]);
	            }
	            return ret;
	        }
	        if (!response
	            || !response["__QObject*__"]
	            || response.id === undefined) {
	            return response;
	        }

	        var objectId = response.id;
	        if (webChannel.objects[objectId])
	            return webChannel.objects[objectId];

	        if (!response.data) {
	            console.error("Cannot unwrap unknown QObject " + objectId + " without data.");
	            return;
	        }

	        var qObject = new QObject(objectId, response.data, webChannel);
	        qObject.destroyed.connect(function () {
	            if (webChannel.objects[objectId] === qObject) {
	                delete webChannel.objects[objectId];
	                // reset the now deleted QObject to an empty {} object
	                // just assigning {} though would not have the desired effect, but the
	                // below also ensures all external references will see the empty map
	                // NOTE: this detour is necessary to workaround QTBUG-40021
	                var propertyNames = [];
	                for (var propertyName in qObject) {
	                    propertyNames.push(propertyName);
	                }
	                for (var idx in propertyNames) {
	                    delete qObject[propertyNames[idx]];
	                }
	            }
	        });
	        // here we are already initialized, and thus must directly unwrap the properties
	        qObject.unwrapProperties();
	        return qObject;
	    }

	    this.unwrapProperties = function () {
	        for (var propertyIdx in object.__propertyCache__) {
	            object.__propertyCache__[propertyIdx] = object.unwrapQObject(object.__propertyCache__[propertyIdx]);
	        }
	    }

	    function addSignal(signalData, isPropertyNotifySignal) {
	        var signalName = signalData[0];
	        var signalIndex = signalData[1];
	        object[signalName] = {
	            connect: function (callback) {
	                if (typeof(callback) !== "function") {
	                    console.error("Bad callback given to connect to signal " + signalName);
	                    return;
	                }

	                object.__objectSignals__[signalIndex] = object.__objectSignals__[signalIndex] || [];
	                object.__objectSignals__[signalIndex].push(callback);

	                if (!isPropertyNotifySignal && signalName !== "destroyed") {
	                    // only required for "pure" signals, handled separately for properties in propertyUpdate
	                    // also note that we always get notified about the destroyed signal
	                    webChannel.exec({
	                        type: QWebChannelMessageTypes.connectToSignal,
	                        object: object.__id__,
	                        signal: signalIndex
	                    });
	                }
	            },
	            disconnect: function (callback) {
	                if (typeof(callback) !== "function") {
	                    console.error("Bad callback given to disconnect from signal " + signalName);
	                    return;
	                }
	                object.__objectSignals__[signalIndex] = object.__objectSignals__[signalIndex] || [];
	                var idx = object.__objectSignals__[signalIndex].indexOf(callback);
	                if (idx === -1) {
	                    console.error("Cannot find connection of signal " + signalName + " to " + callback.name);
	                    return;
	                }
	                object.__objectSignals__[signalIndex].splice(idx, 1);
	                if (!isPropertyNotifySignal && object.__objectSignals__[signalIndex].length === 0) {
	                    // only required for "pure" signals, handled separately for properties in propertyUpdate
	                    webChannel.exec({
	                        type: QWebChannelMessageTypes.disconnectFromSignal,
	                        object: object.__id__,
	                        signal: signalIndex
	                    });
	                }
	            }
	        };
	    }

	    /**
	     * Invokes all callbacks for the given signalname. Also works for property notify callbacks.
	     */
	    function invokeSignalCallbacks(signalName, signalArgs) {
	        var connections = object.__objectSignals__[signalName];
	        if (connections) {
	            connections.forEach(function (callback) {
	                callback.apply(callback, signalArgs);
	            });
	        }
	    }

	    this.propertyUpdate = function (signals, propertyMap) {
	        // update property cache
	        for (var propertyIndex in propertyMap) {
	            var propertyValue = propertyMap[propertyIndex];
	            object.__propertyCache__[propertyIndex] = propertyValue;
	        }

	        for (var signalName in signals) {
	            // Invoke all callbacks, as signalEmitted() does not. This ensures the
	            // property cache is updated before the callbacks are invoked.
	            invokeSignalCallbacks(signalName, signals[signalName]);
	        }
	    }

	    this.signalEmitted = function (signalName, signalArgs) {
	        invokeSignalCallbacks(signalName, signalArgs);
	    }

	    function addMethod(methodData) {
	        var methodName = methodData[0];
	        var methodIdx = methodData[1];
	        object[methodName] = function () {
	            var args = [];
	            var callback;
	            for (var i = 0; i < arguments.length; ++i) {
	                if (typeof arguments[i] === "function")
	                    callback = arguments[i];
	                else
	                    args.push(arguments[i]);
	            }

	            webChannel.exec({
	                "type": QWebChannelMessageTypes.invokeMethod,
	                "object": object.__id__,
	                "method": methodIdx,
	                "args": args
	            }, function (response) {
	                if (response !== undefined) {
	                    var result = object.unwrapQObject(response);
	                    if (callback) {
	                        (callback)(result);
	                    }
	                }
	            });
	        };
	    }

	    function bindGetterSetter(propertyInfo) {
	        var propertyIndex = propertyInfo[0];
	        var propertyName = propertyInfo[1];
	        var notifySignalData = propertyInfo[2];
	        // initialize property cache with current value
	        // NOTE: if this is an object, it is not directly unwrapped as it might
	        // reference other QObject that we do not know yet
	        object.__propertyCache__[propertyIndex] = propertyInfo[3];

	        if (notifySignalData) {
	            if (notifySignalData[0] === 1) {
	                // signal name is optimized away, reconstruct the actual name
	                notifySignalData[0] = propertyName + "Changed";
	            }
	            addSignal(notifySignalData, true);
	        }

	        Object.defineProperty(object, propertyName, {
	            configurable: true,
	            get: function () {
	                var propertyValue = object.__propertyCache__[propertyIndex];
	                if (propertyValue === undefined) {
	                    // This shouldn't happen
	                    console.warn("Undefined value in property cache for property \"" + propertyName + "\" in object " + object.__id__);
	                }

	                return propertyValue;
	            },
	            set: function (value) {
	                if (value === undefined) {
	                    console.warn("Property setter for " + propertyName + " called with undefined value!");
	                    return;
	                }
	                object.__propertyCache__[propertyIndex] = value;
	                webChannel.exec({
	                    "type": QWebChannelMessageTypes.setProperty,
	                    "object": object.__id__,
	                    "property": propertyIndex,
	                    "value": value
	                });
	            }
	        });

	    }

	    // ----------------------------------------------------------------------

	    data.methods.forEach(addMethod);

	    data.properties.forEach(bindGetterSetter);

	    data.signals.forEach(function (signal) {
	        addSignal(signal, false);
	    });

	    for (var name in data.enums) {
	        object[name] = data.enums[name];
	    }
	}

	//required for use with nodejs
	if (true) {
	    module.exports = {
	        QWebChannel: QWebChannel
	    };
	}


/***/ })
/******/ ]);